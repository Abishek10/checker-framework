--- a/com/sun/java/swing/plaf/gtk/GTKLookAndFeel.java	2016-06-22 19:54:41.374701171 -0700
+++ b/com/sun/java/swing/plaf/gtk/GTKLookAndFeel.java	2016-06-29 16:22:17.454942297 -0700
@@ -148,58 +148,58 @@
     /**
      * Returns true if running on system containing at least 2.2.
      */
-    static boolean is2_2() {
-        // NOTE: We're currently hard coding to use 2.2.
-        // If we want to support both GTK 2.0 and 2.2, we'll
-        // need to get the major/minor/micro version from the .so.
-        // Refer to bug 4912613 for details.
-        return IS_22;
-    }
+    static boolean is2_2() {throw new RuntimeException("cf-bug");} //{
+//        // NOTE: We're currently hard coding to use 2.2.
+//        // If we want to support both GTK 2.0 and 2.2, we'll
+//        // need to get the major/minor/micro version from the .so.
+//        // Refer to bug 4912613 for details.
+//        return IS_22;
+//    }
 
     /**
      * Maps a swing constant to a GTK constant.
      */
-    static PositionType SwingOrientationConstantToGTK(int side) {
-        switch (side) {
-        case SwingConstants.LEFT:
-            return PositionType.LEFT;
-        case SwingConstants.RIGHT:
-            return PositionType.RIGHT;
-        case SwingConstants.TOP:
-            return PositionType.TOP;
-        case SwingConstants.BOTTOM:
-            return PositionType.BOTTOM;
-        }
-        assert false : "Unknown orientation: " + side;
-        return PositionType.TOP;
-    }
+    static PositionType SwingOrientationConstantToGTK(int side) {throw new RuntimeException("cf-bug");} //{
+//        switch (side) {
+//        case SwingConstants.LEFT:
+//            return PositionType.LEFT;
+//        case SwingConstants.RIGHT:
+//            return PositionType.RIGHT;
+//        case SwingConstants.TOP:
+//            return PositionType.TOP;
+//        case SwingConstants.BOTTOM:
+//            return PositionType.BOTTOM;
+//        }
+//        assert false : "Unknown orientation: " + side;
+//        return PositionType.TOP;
+//    }
 
     /**
      * Maps from Synth state to native GTK state using typesafe enumeration
      * StateType.  This is only used by GTKEngine.
      */
-    static StateType synthStateToGTKStateType(int state) {
-        StateType result;
-        switch (state) {
-            case SynthConstants.PRESSED:
-                result = StateType.ACTIVE;
-                break;
-            case SynthConstants.MOUSE_OVER:
-                result = StateType.PRELIGHT;
-                break;
-            case SynthConstants.SELECTED:
-                result = StateType.SELECTED;
-                break;
-            case SynthConstants.DISABLED:
-                result = StateType.INSENSITIVE;
-                break;
-            case SynthConstants.ENABLED:
-            default:
-                result = StateType.NORMAL;
-                break;
-        }
-        return result;
-    }
+    static StateType synthStateToGTKStateType(int state) {throw new RuntimeException("cf-bug");} //{
+//        StateType result;
+//        switch (state) {
+//            case SynthConstants.PRESSED:
+//                result = StateType.ACTIVE;
+//                break;
+//            case SynthConstants.MOUSE_OVER:
+//                result = StateType.PRELIGHT;
+//                break;
+//            case SynthConstants.SELECTED:
+//                result = StateType.SELECTED;
+//                break;
+//            case SynthConstants.DISABLED:
+//                result = StateType.INSENSITIVE;
+//                break;
+//            case SynthConstants.ENABLED:
+//            default:
+//                result = StateType.NORMAL;
+//                break;
+//        }
+//        return result;
+//    }
 
     /**
      * Maps from a Synth state to the corresponding GTK state.
@@ -214,1271 +214,1271 @@
      * </table>
      * Additionally some widgets are special cased.
      */
-    static int synthStateToGTKState(Region region, int state) {
-        if ((state & SynthConstants.PRESSED) != 0) {
-            if (region == Region.RADIO_BUTTON
-                    || region == Region.CHECK_BOX
-                    || region == Region.MENU
-                    || region == Region.MENU_ITEM
-                    || region == Region.RADIO_BUTTON_MENU_ITEM
-                    || region == Region.CHECK_BOX_MENU_ITEM
-                    || region == Region.SPLIT_PANE) {
-                state = SynthConstants.MOUSE_OVER;
-            } else {
-                state = SynthConstants.PRESSED;
-            }
-
-        } else if (region == Region.TABBED_PANE_TAB) {
-            if ((state & SynthConstants.DISABLED) != 0) {
-                state = SynthConstants.DISABLED;
-            }
-            else if ((state & SynthConstants.SELECTED) != 0) {
-                state = SynthConstants.ENABLED;
-            } else {
-                state = SynthConstants.PRESSED;
-            }
-
-        } else if ((state & SynthConstants.SELECTED) != 0) {
-            if (region == Region.MENU) {
-                state = SynthConstants.MOUSE_OVER;
-            } else if (region == Region.RADIO_BUTTON ||
-                          region == Region.TOGGLE_BUTTON ||
-                          region == Region.RADIO_BUTTON_MENU_ITEM ||
-                          region == Region.CHECK_BOX_MENU_ITEM ||
-                          region == Region.CHECK_BOX ||
-                          region == Region.BUTTON) {
-                if ((state & SynthConstants.DISABLED) != 0) {
-                    state = SynthConstants.DISABLED;
-                }
-                // If the button is SELECTED and is PRELIGHT we need to
-                // make the state MOUSE_OVER otherwise we don't paint the
-                // PRELIGHT.
-                else if ((state & SynthConstants.MOUSE_OVER) != 0) {
-                    state = SynthConstants.MOUSE_OVER;
-                } else {
-                    state = SynthConstants.PRESSED;
-                }
-            } else {
-                state = SynthConstants.SELECTED;
-            }
-        }
-
-        else if ((state & SynthConstants.MOUSE_OVER) != 0) {
-            state = SynthConstants.MOUSE_OVER;
-        }
-        else if ((state & SynthConstants.DISABLED) != 0) {
-            state = SynthConstants.DISABLED;
-        }
-        else {
-            if (region == Region.SLIDER_TRACK) {
-                state = SynthConstants.PRESSED;
-            } else {
-                state = SynthConstants.ENABLED;
-            }
-        }
-        return state;
-    }
-
-    static boolean isText(Region region) {
-        // These Regions treat FOREGROUND as TEXT.
-        return (region == Region.TEXT_FIELD ||
-                region == Region.FORMATTED_TEXT_FIELD ||
-                region == Region.LIST ||
-                region == Region.PASSWORD_FIELD ||
-                region == Region.SPINNER ||
-                region == Region.TABLE ||
-                region == Region.TEXT_AREA ||
-                region == Region.TEXT_FIELD ||
-                region == Region.TEXT_PANE ||
-                region == Region.TREE);
-    }
-
-    public UIDefaults getDefaults() {
-        // We need to call super for basic's properties file.
-        UIDefaults table = super.getDefaults();
-
-        // SynthTabbedPaneUI supports rollover on tabs, GTK does not
-        table.put("TabbedPane.isTabRollover", Boolean.FALSE);
-
-        // Prevents Synth from setting text AA by itself
-        table.put("Synth.doNotSetTextAA", true);
-
-        initResourceBundle(table);
-        // For compatibility with apps expecting certain defaults we'll
-        // populate the table with the values from basic.
-        initSystemColorDefaults(table);
-        initComponentDefaults(table);
-        installPropertyChangeListeners();
-        return table;
-    }
-
-    private void installPropertyChangeListeners() {
-        if(!pclInstalled) {
-            Toolkit kit = Toolkit.getDefaultToolkit();
-            WeakPCL pcl = new WeakPCL(this, kit, "gnome.Net/ThemeName");
-            kit.addPropertyChangeListener(pcl.getKey(), pcl);
-            pcl = new WeakPCL(this, kit, "gnome.Gtk/FontName");
-            kit.addPropertyChangeListener(pcl.getKey(), pcl);
-            pcl = new WeakPCL(this, kit, "gnome.Xft/DPI");
-            kit.addPropertyChangeListener(pcl.getKey(), pcl);
-
-            flushUnreferenced();
-            pclInstalled = true;
-        }
-    }
-
-    private void initResourceBundle(UIDefaults table) {
-        table.addResourceBundle("com.sun.java.swing.plaf.gtk.resources.gtk");
-    }
-
-    protected void initComponentDefaults(UIDefaults table) {
-        // For compatibility with apps expecting certain defaults we'll
-        // populate the table with the values from basic.
-        super.initComponentDefaults(table);
-
-        Integer zero =  Integer.valueOf(0);
-        Object zeroBorder = new sun.swing.SwingLazyValue(
-            "javax.swing.plaf.BorderUIResource$EmptyBorderUIResource",
-            new Object[] {zero, zero, zero, zero});
-        Object focusBorder = new GTKStyle.GTKLazyValue(
-            "com.sun.java.swing.plaf.gtk.GTKPainter$ListTableFocusBorder",
-            "getUnselectedCellBorder");
-        Object focusSelectedBorder = new GTKStyle.GTKLazyValue(
-            "com.sun.java.swing.plaf.gtk.GTKPainter$ListTableFocusBorder",
-            "getSelectedCellBorder");
-        Object noFocusBorder = new GTKStyle.GTKLazyValue(
-            "com.sun.java.swing.plaf.gtk.GTKPainter$ListTableFocusBorder",
-            "getNoFocusCellBorder");
-
-        GTKStyleFactory factory = (GTKStyleFactory)getStyleFactory();
-        GTKStyle tableStyle = (GTKStyle)factory.getStyle(null, Region.TREE);
-        Color tableBg = tableStyle.getGTKColor(SynthConstants.ENABLED,
-                GTKColorType.TEXT_BACKGROUND);
-        Color tableFocusCellBg = tableStyle.getGTKColor(SynthConstants.ENABLED,
-                GTKColorType.BACKGROUND);
-        Color tableFocusCellFg = tableStyle.getGTKColor(SynthConstants.ENABLED,
-                GTKColorType.FOREGROUND);
-
-        // The following progress bar size calculations come from
-        // gtkprogressbar.c (version 2.8.20), see MIN_* constants and
-        // the gtk_progress_bar_size_request() method.
-        GTKStyle progStyle = (GTKStyle)
-            factory.getStyle(null, Region.PROGRESS_BAR);
-        int progXThickness = progStyle.getXThickness();
-        int progYThickness = progStyle.getYThickness();
-        int hProgWidth  = 150 - (progXThickness * 2);
-        int hProgHeight =  20 - (progYThickness * 2);
-        int vProgWidth  =  22 - (progXThickness * 2);
-        int vProgHeight =  80 - (progYThickness * 2);
-
-        Integer caretBlinkRate = Integer.valueOf(500);
-        Insets zeroInsets = new InsetsUIResource(0, 0, 0, 0);
-
-        Double defaultCaretAspectRatio = new Double(0.025);
-        Color caretColor = table.getColor("caretColor");
-        Color controlText = table.getColor("controlText");
-
-        Object fieldInputMap = new UIDefaults.LazyInputMap(new Object[] {
-                       "ctrl C", DefaultEditorKit.copyAction,
-                       "ctrl V", DefaultEditorKit.pasteAction,
-                       "ctrl X", DefaultEditorKit.cutAction,
-                         "COPY", DefaultEditorKit.copyAction,
-                        "PASTE", DefaultEditorKit.pasteAction,
-                          "CUT", DefaultEditorKit.cutAction,
-               "control INSERT", DefaultEditorKit.copyAction,
-                 "shift INSERT", DefaultEditorKit.pasteAction,
-                 "shift DELETE", DefaultEditorKit.cutAction,
-                   "shift LEFT", DefaultEditorKit.selectionBackwardAction,
-                "shift KP_LEFT", DefaultEditorKit.selectionBackwardAction,
-                  "shift RIGHT", DefaultEditorKit.selectionForwardAction,
-               "shift KP_RIGHT", DefaultEditorKit.selectionForwardAction,
-                    "ctrl LEFT", DefaultEditorKit.previousWordAction,
-                 "ctrl KP_LEFT", DefaultEditorKit.previousWordAction,
-                   "ctrl RIGHT", DefaultEditorKit.nextWordAction,
-                "ctrl KP_RIGHT", DefaultEditorKit.nextWordAction,
-              "ctrl shift LEFT", DefaultEditorKit.selectionPreviousWordAction,
-           "ctrl shift KP_LEFT", DefaultEditorKit.selectionPreviousWordAction,
-             "ctrl shift RIGHT", DefaultEditorKit.selectionNextWordAction,
-          "ctrl shift KP_RIGHT", DefaultEditorKit.selectionNextWordAction,
-                       "ctrl A", DefaultEditorKit.selectAllAction,
-                         "HOME", DefaultEditorKit.beginLineAction,
-                          "END", DefaultEditorKit.endLineAction,
-                   "shift HOME", DefaultEditorKit.selectionBeginLineAction,
-                    "shift END", DefaultEditorKit.selectionEndLineAction,
-                   "BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
-             "shift BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
-                       "ctrl H", DefaultEditorKit.deletePrevCharAction,
-                       "DELETE", DefaultEditorKit.deleteNextCharAction,
-                  "ctrl DELETE", DefaultEditorKit.deleteNextWordAction,
-              "ctrl BACK_SPACE", DefaultEditorKit.deletePrevWordAction,
-                        "RIGHT", DefaultEditorKit.forwardAction,
-                         "LEFT", DefaultEditorKit.backwardAction,
-                     "KP_RIGHT", DefaultEditorKit.forwardAction,
-                      "KP_LEFT", DefaultEditorKit.backwardAction,
-                        "ENTER", JTextField.notifyAction,
-              "ctrl BACK_SLASH", "unselect"/*DefaultEditorKit.unselectAction*/,
-               "control shift O", "toggle-componentOrientation"/*DefaultEditorKit.toggleComponentOrientation*/
-            });
-
-        Object passwordInputMap = new UIDefaults.LazyInputMap(new Object[] {
-                       "ctrl C", DefaultEditorKit.copyAction,
-                       "ctrl V", DefaultEditorKit.pasteAction,
-                       "ctrl X", DefaultEditorKit.cutAction,
-                         "COPY", DefaultEditorKit.copyAction,
-                        "PASTE", DefaultEditorKit.pasteAction,
-                          "CUT", DefaultEditorKit.cutAction,
-               "control INSERT", DefaultEditorKit.copyAction,
-                 "shift INSERT", DefaultEditorKit.pasteAction,
-                 "shift DELETE", DefaultEditorKit.cutAction,
-                   "shift LEFT", DefaultEditorKit.selectionBackwardAction,
-                "shift KP_LEFT", DefaultEditorKit.selectionBackwardAction,
-                  "shift RIGHT", DefaultEditorKit.selectionForwardAction,
-               "shift KP_RIGHT", DefaultEditorKit.selectionForwardAction,
-                    "ctrl LEFT", DefaultEditorKit.beginLineAction,
-                 "ctrl KP_LEFT", DefaultEditorKit.beginLineAction,
-                   "ctrl RIGHT", DefaultEditorKit.endLineAction,
-                "ctrl KP_RIGHT", DefaultEditorKit.endLineAction,
-              "ctrl shift LEFT", DefaultEditorKit.selectionBeginLineAction,
-           "ctrl shift KP_LEFT", DefaultEditorKit.selectionBeginLineAction,
-             "ctrl shift RIGHT", DefaultEditorKit.selectionEndLineAction,
-          "ctrl shift KP_RIGHT", DefaultEditorKit.selectionEndLineAction,
-                       "ctrl A", DefaultEditorKit.selectAllAction,
-                         "HOME", DefaultEditorKit.beginLineAction,
-                          "END", DefaultEditorKit.endLineAction,
-                   "shift HOME", DefaultEditorKit.selectionBeginLineAction,
-                    "shift END", DefaultEditorKit.selectionEndLineAction,
-                   "BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
-             "shift BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
-                       "ctrl H", DefaultEditorKit.deletePrevCharAction,
-                       "DELETE", DefaultEditorKit.deleteNextCharAction,
-                        "RIGHT", DefaultEditorKit.forwardAction,
-                         "LEFT", DefaultEditorKit.backwardAction,
-                     "KP_RIGHT", DefaultEditorKit.forwardAction,
-                      "KP_LEFT", DefaultEditorKit.backwardAction,
-                        "ENTER", JTextField.notifyAction,
-              "ctrl BACK_SLASH", "unselect"/*DefaultEditorKit.unselectAction*/,
-               "control shift O", "toggle-componentOrientation"/*DefaultEditorKit.toggleComponentOrientation*/
-            });
-
-        Object editorMargin = new InsetsUIResource(3,3,3,3);
-
-        Object multilineInputMap = new UIDefaults.LazyInputMap(new Object[] {
-                           "ctrl C", DefaultEditorKit.copyAction,
-                           "ctrl V", DefaultEditorKit.pasteAction,
-                           "ctrl X", DefaultEditorKit.cutAction,
-                             "COPY", DefaultEditorKit.copyAction,
-                            "PASTE", DefaultEditorKit.pasteAction,
-                              "CUT", DefaultEditorKit.cutAction,
-                   "control INSERT", DefaultEditorKit.copyAction,
-                     "shift INSERT", DefaultEditorKit.pasteAction,
-                     "shift DELETE", DefaultEditorKit.cutAction,
-                       "shift LEFT", DefaultEditorKit.selectionBackwardAction,
-                    "shift KP_LEFT", DefaultEditorKit.selectionBackwardAction,
-                      "shift RIGHT", DefaultEditorKit.selectionForwardAction,
-                   "shift KP_RIGHT", DefaultEditorKit.selectionForwardAction,
-                        "ctrl LEFT", DefaultEditorKit.previousWordAction,
-                     "ctrl KP_LEFT", DefaultEditorKit.previousWordAction,
-                       "ctrl RIGHT", DefaultEditorKit.nextWordAction,
-                    "ctrl KP_RIGHT", DefaultEditorKit.nextWordAction,
-                  "ctrl shift LEFT", DefaultEditorKit.selectionPreviousWordAction,
-               "ctrl shift KP_LEFT", DefaultEditorKit.selectionPreviousWordAction,
-                 "ctrl shift RIGHT", DefaultEditorKit.selectionNextWordAction,
-              "ctrl shift KP_RIGHT", DefaultEditorKit.selectionNextWordAction,
-                           "ctrl A", DefaultEditorKit.selectAllAction,
-                             "HOME", DefaultEditorKit.beginLineAction,
-                              "END", DefaultEditorKit.endLineAction,
-                       "shift HOME", DefaultEditorKit.selectionBeginLineAction,
-                        "shift END", DefaultEditorKit.selectionEndLineAction,
-
-                               "UP", DefaultEditorKit.upAction,
-                            "KP_UP", DefaultEditorKit.upAction,
-                             "DOWN", DefaultEditorKit.downAction,
-                          "KP_DOWN", DefaultEditorKit.downAction,
-                          "PAGE_UP", DefaultEditorKit.pageUpAction,
-                        "PAGE_DOWN", DefaultEditorKit.pageDownAction,
-                    "shift PAGE_UP", "selection-page-up",
-                  "shift PAGE_DOWN", "selection-page-down",
-               "ctrl shift PAGE_UP", "selection-page-left",
-             "ctrl shift PAGE_DOWN", "selection-page-right",
-                         "shift UP", DefaultEditorKit.selectionUpAction,
-                      "shift KP_UP", DefaultEditorKit.selectionUpAction,
-                       "shift DOWN", DefaultEditorKit.selectionDownAction,
-                    "shift KP_DOWN", DefaultEditorKit.selectionDownAction,
-                            "ENTER", DefaultEditorKit.insertBreakAction,
-                       "BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
-                 "shift BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
-                           "ctrl H", DefaultEditorKit.deletePrevCharAction,
-                           "DELETE", DefaultEditorKit.deleteNextCharAction,
-                      "ctrl DELETE", DefaultEditorKit.deleteNextWordAction,
-                  "ctrl BACK_SPACE", DefaultEditorKit.deletePrevWordAction,
-                            "RIGHT", DefaultEditorKit.forwardAction,
-                             "LEFT", DefaultEditorKit.backwardAction,
-                         "KP_RIGHT", DefaultEditorKit.forwardAction,
-                          "KP_LEFT", DefaultEditorKit.backwardAction,
-                              "TAB", DefaultEditorKit.insertTabAction,
-                  "ctrl BACK_SLASH", "unselect"/*DefaultEditorKit.unselectAction*/,
-                        "ctrl HOME", DefaultEditorKit.beginAction,
-                         "ctrl END", DefaultEditorKit.endAction,
-                  "ctrl shift HOME", DefaultEditorKit.selectionBeginAction,
-                   "ctrl shift END", DefaultEditorKit.selectionEndAction,
-                           "ctrl T", "next-link-action",
-                     "ctrl shift T", "previous-link-action",
-                       "ctrl SPACE", "activate-link-action",
-                   "control shift O", "toggle-componentOrientation"/*DefaultEditorKit.toggleComponentOrientation*/
-            });
-
-        class FontLazyValue implements UIDefaults.LazyValue {
-            private Region region;
-            FontLazyValue(Region region) {
-                this.region = region;
-            }
-            public Object createValue(UIDefaults table) {
-                GTKStyleFactory factory = (GTKStyleFactory)getStyleFactory();
-                GTKStyle style = (GTKStyle)factory.getStyle(null, region);
-                return style.getFontForState(null);
-            }
-        }
-
-        Object[] defaults = new Object[] {
-            "ArrowButton.size", Integer.valueOf(13),
-
-
-            "Button.defaultButtonFollowsFocus", Boolean.FALSE,
-            "Button.focusInputMap", new UIDefaults.LazyInputMap(new Object[] {
-                         "SPACE", "pressed",
-                "released SPACE", "released",
-                         "ENTER", "pressed",
-                "released ENTER", "released"
-              }),
-            "Button.font", new FontLazyValue(Region.BUTTON),
-            "Button.margin", zeroInsets,
-
-
-            "CheckBox.focusInputMap", new UIDefaults.LazyInputMap(new Object[]{
-                         "SPACE", "pressed",
-                "released SPACE", "released"
-              }),
-            "CheckBox.icon", new GTKStyle.GTKLazyValue(
-                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
-                              "getCheckBoxIcon"),
-            "CheckBox.font", new FontLazyValue(Region.CHECK_BOX),
-            "CheckBox.margin", zeroInsets,
-
-
-            "CheckBoxMenuItem.arrowIcon", null,
-            "CheckBoxMenuItem.checkIcon", new GTKStyle.GTKLazyValue(
-                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
-                              "getCheckBoxMenuItemCheckIcon"),
-            "CheckBoxMenuItem.font",
-                new FontLazyValue(Region.CHECK_BOX_MENU_ITEM),
-            "CheckBoxMenuItem.margin", zeroInsets,
-            "CheckBoxMenuItem.alignAcceleratorText", Boolean.FALSE,
-
-
-            "ColorChooser.showPreviewPanelText", Boolean.FALSE,
-            "ColorChooser.panels", new UIDefaults.ActiveValue() {
-                public Object createValue(UIDefaults table) {
-                    return new AbstractColorChooserPanel[] {
-                                       new GTKColorChooserPanel() };
-                }
-            },
-            "ColorChooser.font", new FontLazyValue(Region.COLOR_CHOOSER),
-
-
-            "ComboBox.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                     "ESCAPE", "hidePopup",
-                    "PAGE_UP", "pageUpPassThrough",
-                  "PAGE_DOWN", "pageDownPassThrough",
-                       "HOME", "homePassThrough",
-                        "END", "endPassThrough",
-                       "DOWN", "selectNext",
-                    "KP_DOWN", "selectNext",
-                   "alt DOWN", "togglePopup",
-                "alt KP_DOWN", "togglePopup",
-                     "alt UP", "togglePopup",
-                  "alt KP_UP", "togglePopup",
-                      "SPACE", "spacePopup",
-                      "ENTER", "enterPressed",
-                         "UP", "selectPrevious",
-                      "KP_UP", "selectPrevious"
-
-                 }),
-            "ComboBox.font", new FontLazyValue(Region.COMBO_BOX),
-            "ComboBox.isEnterSelectablePopup", Boolean.TRUE,
-
-
-            "EditorPane.caretForeground", caretColor,
-            "EditorPane.caretAspectRatio", defaultCaretAspectRatio,
-            "EditorPane.caretBlinkRate", caretBlinkRate,
-            "EditorPane.margin", editorMargin,
-            "EditorPane.focusInputMap", multilineInputMap,
-            "EditorPane.font", new FontLazyValue(Region.EDITOR_PANE),
-
-
-            "FileChooser.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                     "ESCAPE", "cancelSelection",
-                 "ctrl ENTER", "approveSelection"
-                 }),
-            "FileChooserUI", "com.sun.java.swing.plaf.gtk.GTKLookAndFeel",
-
-
-            "FormattedTextField.caretForeground", caretColor,
-            "FormattedTextField.caretAspectRatio", defaultCaretAspectRatio,
-            "FormattedTextField.caretBlinkRate", caretBlinkRate,
-            "FormattedTextField.focusInputMap",
-              new UIDefaults.LazyInputMap(new Object[] {
-                           "ctrl C", DefaultEditorKit.copyAction,
-                           "ctrl V", DefaultEditorKit.pasteAction,
-                           "ctrl X", DefaultEditorKit.cutAction,
-                             "COPY", DefaultEditorKit.copyAction,
-                            "PASTE", DefaultEditorKit.pasteAction,
-                              "CUT", DefaultEditorKit.cutAction,
-                   "control INSERT", DefaultEditorKit.copyAction,
-                     "shift INSERT", DefaultEditorKit.pasteAction,
-                     "shift DELETE", DefaultEditorKit.cutAction,
-                       "shift LEFT", DefaultEditorKit.selectionBackwardAction,
-                    "shift KP_LEFT", DefaultEditorKit.selectionBackwardAction,
-                      "shift RIGHT", DefaultEditorKit.selectionForwardAction,
-                   "shift KP_RIGHT", DefaultEditorKit.selectionForwardAction,
-                        "ctrl LEFT", DefaultEditorKit.previousWordAction,
-                     "ctrl KP_LEFT", DefaultEditorKit.previousWordAction,
-                       "ctrl RIGHT", DefaultEditorKit.nextWordAction,
-                    "ctrl KP_RIGHT", DefaultEditorKit.nextWordAction,
-                  "ctrl shift LEFT", DefaultEditorKit.selectionPreviousWordAction,
-               "ctrl shift KP_LEFT", DefaultEditorKit.selectionPreviousWordAction,
-                 "ctrl shift RIGHT", DefaultEditorKit.selectionNextWordAction,
-              "ctrl shift KP_RIGHT", DefaultEditorKit.selectionNextWordAction,
-                           "ctrl A", DefaultEditorKit.selectAllAction,
-                             "HOME", DefaultEditorKit.beginLineAction,
-                              "END", DefaultEditorKit.endLineAction,
-                       "shift HOME", DefaultEditorKit.selectionBeginLineAction,
-                        "shift END", DefaultEditorKit.selectionEndLineAction,
-                       "BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
-                 "shift BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
-                           "ctrl H", DefaultEditorKit.deletePrevCharAction,
-                           "DELETE", DefaultEditorKit.deleteNextCharAction,
-                      "ctrl DELETE", DefaultEditorKit.deleteNextWordAction,
-                  "ctrl BACK_SPACE", DefaultEditorKit.deletePrevWordAction,
-                            "RIGHT", DefaultEditorKit.forwardAction,
-                             "LEFT", DefaultEditorKit.backwardAction,
-                         "KP_RIGHT", DefaultEditorKit.forwardAction,
-                          "KP_LEFT", DefaultEditorKit.backwardAction,
-                            "ENTER", JTextField.notifyAction,
-                  "ctrl BACK_SLASH", "unselect",
-                  "control shift O", "toggle-componentOrientation",
-                           "ESCAPE", "reset-field-edit",
-                               "UP", "increment",
-                            "KP_UP", "increment",
-                             "DOWN", "decrement",
-                          "KP_DOWN", "decrement",
-              }),
-            "FormattedTextField.font",
-                new FontLazyValue(Region.FORMATTED_TEXT_FIELD),
-
-
-            "InternalFrameTitlePane.titlePaneLayout",
-                                new GTKStyle.GTKLazyValue("com.sun.java.swing.plaf.gtk.Metacity",
-                                                 "getTitlePaneLayout"),
-            "InternalFrame.windowBindings", new Object[] {
-                  "shift ESCAPE", "showSystemMenu",
-                    "ctrl SPACE", "showSystemMenu",
-                        "ESCAPE", "hideSystemMenu" },
-            "InternalFrame.layoutTitlePaneAtOrigin", Boolean.TRUE,
-            "InternalFrame.useTaskBar", Boolean.TRUE,
-
-            "InternalFrameTitlePane.iconifyButtonOpacity", null,
-            "InternalFrameTitlePane.maximizeButtonOpacity", null,
-            "InternalFrameTitlePane.closeButtonOpacity", null,
-
-            "Label.font", new FontLazyValue(Region.LABEL),
-
-            "List.background", tableBg,
-            "List.focusCellHighlightBorder", focusBorder,
-            "List.focusSelectedCellHighlightBorder", focusSelectedBorder,
-            "List.noFocusBorder", noFocusBorder,
-            "List.focusInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                           "ctrl C", "copy",
-                           "ctrl V", "paste",
-                           "ctrl X", "cut",
-                             "COPY", "copy",
-                            "PASTE", "paste",
-                              "CUT", "cut",
-                   "control INSERT", "copy",
-                     "shift INSERT", "paste",
-                     "shift DELETE", "cut",
-                               "UP", "selectPreviousRow",
-                            "KP_UP", "selectPreviousRow",
-                         "shift UP", "selectPreviousRowExtendSelection",
-                      "shift KP_UP", "selectPreviousRowExtendSelection",
-                    "ctrl shift UP", "selectPreviousRowExtendSelection",
-                 "ctrl shift KP_UP", "selectPreviousRowExtendSelection",
-                          "ctrl UP", "selectPreviousRowChangeLead",
-                       "ctrl KP_UP", "selectPreviousRowChangeLead",
-                             "DOWN", "selectNextRow",
-                          "KP_DOWN", "selectNextRow",
-                       "shift DOWN", "selectNextRowExtendSelection",
-                    "shift KP_DOWN", "selectNextRowExtendSelection",
-                  "ctrl shift DOWN", "selectNextRowExtendSelection",
-               "ctrl shift KP_DOWN", "selectNextRowExtendSelection",
-                        "ctrl DOWN", "selectNextRowChangeLead",
-                     "ctrl KP_DOWN", "selectNextRowChangeLead",
-                             "LEFT", "selectPreviousColumn",
-                          "KP_LEFT", "selectPreviousColumn",
-                       "shift LEFT", "selectPreviousColumnExtendSelection",
-                    "shift KP_LEFT", "selectPreviousColumnExtendSelection",
-                  "ctrl shift LEFT", "selectPreviousColumnExtendSelection",
-               "ctrl shift KP_LEFT", "selectPreviousColumnExtendSelection",
-                        "ctrl LEFT", "selectPreviousColumnChangeLead",
-                     "ctrl KP_LEFT", "selectPreviousColumnChangeLead",
-                            "RIGHT", "selectNextColumn",
-                         "KP_RIGHT", "selectNextColumn",
-                      "shift RIGHT", "selectNextColumnExtendSelection",
-                   "shift KP_RIGHT", "selectNextColumnExtendSelection",
-                 "ctrl shift RIGHT", "selectNextColumnExtendSelection",
-              "ctrl shift KP_RIGHT", "selectNextColumnExtendSelection",
-                       "ctrl RIGHT", "selectNextColumnChangeLead",
-                    "ctrl KP_RIGHT", "selectNextColumnChangeLead",
-                             "HOME", "selectFirstRow",
-                       "shift HOME", "selectFirstRowExtendSelection",
-                  "ctrl shift HOME", "selectFirstRowExtendSelection",
-                        "ctrl HOME", "selectFirstRowChangeLead",
-                              "END", "selectLastRow",
-                        "shift END", "selectLastRowExtendSelection",
-                   "ctrl shift END", "selectLastRowExtendSelection",
-                         "ctrl END", "selectLastRowChangeLead",
-                          "PAGE_UP", "scrollUp",
-                    "shift PAGE_UP", "scrollUpExtendSelection",
-               "ctrl shift PAGE_UP", "scrollUpExtendSelection",
-                     "ctrl PAGE_UP", "scrollUpChangeLead",
-                        "PAGE_DOWN", "scrollDown",
-                  "shift PAGE_DOWN", "scrollDownExtendSelection",
-             "ctrl shift PAGE_DOWN", "scrollDownExtendSelection",
-                   "ctrl PAGE_DOWN", "scrollDownChangeLead",
-                           "ctrl A", "selectAll",
-                       "ctrl SLASH", "selectAll",
-                  "ctrl BACK_SLASH", "clearSelection",
-                            "SPACE", "addToSelection",
-                       "ctrl SPACE", "toggleAndAnchor",
-                      "shift SPACE", "extendTo",
-                 "ctrl shift SPACE", "moveSelectionTo"
-                 }),
-            "List.focusInputMap.RightToLeft",
-               new UIDefaults.LazyInputMap(new Object[] {
-                             "LEFT", "selectNextColumn",
-                          "KP_LEFT", "selectNextColumn",
-                       "shift LEFT", "selectNextColumnExtendSelection",
-                    "shift KP_LEFT", "selectNextColumnExtendSelection",
-                  "ctrl shift LEFT", "selectNextColumnExtendSelection",
-               "ctrl shift KP_LEFT", "selectNextColumnExtendSelection",
-                        "ctrl LEFT", "selectNextColumnChangeLead",
-                     "ctrl KP_LEFT", "selectNextColumnChangeLead",
-                            "RIGHT", "selectPreviousColumn",
-                         "KP_RIGHT", "selectPreviousColumn",
-                      "shift RIGHT", "selectPreviousColumnExtendSelection",
-                   "shift KP_RIGHT", "selectPreviousColumnExtendSelection",
-                 "ctrl shift RIGHT", "selectPreviousColumnExtendSelection",
-              "ctrl shift KP_RIGHT", "selectPreviousColumnExtendSelection",
-                       "ctrl RIGHT", "selectPreviousColumnChangeLead",
-                    "ctrl KP_RIGHT", "selectPreviousColumnChangeLead",
-                 }),
-            "List.font", new FontLazyValue(Region.LIST),
-            "List.rendererUseUIBorder", Boolean.FALSE,
-
-            "Menu.arrowIcon", new GTKStyle.GTKLazyValue(
-                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
-                              "getMenuArrowIcon"),
-            "Menu.checkIcon", null,
-            "Menu.font", new FontLazyValue(Region.MENU),
-            "Menu.margin", zeroInsets,
-            "Menu.cancelMode", "hideMenuTree",
-            "Menu.alignAcceleratorText", Boolean.FALSE,
-            "Menu.useMenuBarForTopLevelMenus", Boolean.TRUE,
-
-
-                "MenuBar.windowBindings", new Object[] {
-                "F10", "takeFocus" },
-            "MenuBar.font", new FontLazyValue(Region.MENU_BAR),
-
-
-            "MenuItem.arrowIcon", null,
-            "MenuItem.checkIcon", null,
-            "MenuItem.font", new FontLazyValue(Region.MENU_ITEM),
-            "MenuItem.margin", zeroInsets,
-            "MenuItem.alignAcceleratorText", Boolean.FALSE,
-
-
-            "OptionPane.setButtonMargin", Boolean.FALSE,
-            "OptionPane.sameSizeButtons", Boolean.TRUE,
-            "OptionPane.buttonOrientation", new Integer(SwingConstants.RIGHT),
-            "OptionPane.minimumSize", new DimensionUIResource(262, 90),
-            "OptionPane.buttonPadding", new Integer(10),
-            "OptionPane.windowBindings", new Object[] {
-                "ESCAPE", "close" },
-            "OptionPane.buttonClickThreshhold", new Integer(500),
-            "OptionPane.isYesLast", Boolean.TRUE,
-            "OptionPane.font", new FontLazyValue(Region.OPTION_PANE),
-
-            "Panel.font", new FontLazyValue(Region.PANEL),
-
-            "PasswordField.caretForeground", caretColor,
-            "PasswordField.caretAspectRatio", defaultCaretAspectRatio,
-            "PasswordField.caretBlinkRate", caretBlinkRate,
-            "PasswordField.margin", zeroInsets,
-            "PasswordField.focusInputMap", passwordInputMap,
-            "PasswordField.font", new FontLazyValue(Region.PASSWORD_FIELD),
-
-
-            "PopupMenu.consumeEventOnClose", Boolean.TRUE,
-            "PopupMenu.selectedWindowInputMapBindings", new Object[] {
-                  "ESCAPE", "cancel",
-                    "DOWN", "selectNext",
-                 "KP_DOWN", "selectNext",
-                      "UP", "selectPrevious",
-                   "KP_UP", "selectPrevious",
-                    "LEFT", "selectParent",
-                 "KP_LEFT", "selectParent",
-                   "RIGHT", "selectChild",
-                "KP_RIGHT", "selectChild",
-                   "ENTER", "return",
-                   "SPACE", "return"
-            },
-            "PopupMenu.selectedWindowInputMapBindings.RightToLeft",
-                  new Object[] {
-                    "LEFT", "selectChild",
-                 "KP_LEFT", "selectChild",
-                   "RIGHT", "selectParent",
-                "KP_RIGHT", "selectParent",
-            },
-            "PopupMenu.font", new FontLazyValue(Region.POPUP_MENU),
-
-            "ProgressBar.horizontalSize",
-                new DimensionUIResource(hProgWidth, hProgHeight),
-            "ProgressBar.verticalSize",
-                new DimensionUIResource(vProgWidth, vProgHeight),
-            "ProgressBar.font", new FontLazyValue(Region.PROGRESS_BAR),
-
-            "RadioButton.focusInputMap",
-                   new UIDefaults.LazyInputMap(new Object[] {
-                            "SPACE", "pressed",
-                   "released SPACE", "released",
-                           "RETURN", "pressed"
-                   }),
-            "RadioButton.icon", new GTKStyle.GTKLazyValue(
-                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
-                              "getRadioButtonIcon"),
-            "RadioButton.font", new FontLazyValue(Region.RADIO_BUTTON),
-            "RadioButton.margin", zeroInsets,
-
-
-            "RadioButtonMenuItem.arrowIcon", null,
-            "RadioButtonMenuItem.checkIcon", new GTKStyle.GTKLazyValue(
-                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
-                              "getRadioButtonMenuItemCheckIcon"),
-            "RadioButtonMenuItem.font", new FontLazyValue(Region.RADIO_BUTTON_MENU_ITEM),
-            "RadioButtonMenuItem.margin", zeroInsets,
-            "RadioButtonMenuItem.alignAcceleratorText", Boolean.FALSE,
-
-
-            // These bindings are only enabled when there is a default
-            // button set on the rootpane.
-            "RootPane.defaultButtonWindowKeyBindings", new Object[] {
-                               "ENTER", "press",
-                      "released ENTER", "release",
-                          "ctrl ENTER", "press",
-                 "ctrl released ENTER", "release"
-            },
-
-
-            "ScrollBar.squareButtons", Boolean.FALSE,
-            "ScrollBar.thumbHeight", Integer.valueOf(14),
-            "ScrollBar.width", Integer.valueOf(16),
-            "ScrollBar.minimumThumbSize", new Dimension(8, 8),
-            "ScrollBar.maximumThumbSize", new Dimension(4096, 4096),
-            "ScrollBar.allowsAbsolutePositioning", Boolean.TRUE,
-            "ScrollBar.alwaysShowThumb", Boolean.TRUE,
-            "ScrollBar.ancestorInputMap",
-                   new UIDefaults.LazyInputMap(new Object[] {
-                       "RIGHT", "positiveUnitIncrement",
-                    "KP_RIGHT", "positiveUnitIncrement",
-                        "DOWN", "positiveUnitIncrement",
-                     "KP_DOWN", "positiveUnitIncrement",
-                   "PAGE_DOWN", "positiveBlockIncrement",
-                        "LEFT", "negativeUnitIncrement",
-                     "KP_LEFT", "negativeUnitIncrement",
-                          "UP", "negativeUnitIncrement",
-                       "KP_UP", "negativeUnitIncrement",
-                     "PAGE_UP", "negativeBlockIncrement",
-                        "HOME", "minScroll",
-                         "END", "maxScroll"
-                   }),
-            "ScrollBar.ancestorInputMap.RightToLeft",
-                    new UIDefaults.LazyInputMap(new Object[] {
-                       "RIGHT", "negativeUnitIncrement",
-                    "KP_RIGHT", "negativeUnitIncrement",
-                        "LEFT", "positiveUnitIncrement",
-                     "KP_LEFT", "positiveUnitIncrement",
-                    }),
-
-
-            "Spinner.disableOnBoundaryValues", Boolean.TRUE,
-
-
-            "ScrollPane.fillUpperCorner", Boolean.TRUE,
-            "ScrollPane.fillLowerCorner", Boolean.TRUE,
-            "ScrollPane.ancestorInputMap",
-                    new UIDefaults.LazyInputMap(new Object[] {
-                           "RIGHT", "unitScrollRight",
-                        "KP_RIGHT", "unitScrollRight",
-                            "DOWN", "unitScrollDown",
-                         "KP_DOWN", "unitScrollDown",
-                            "LEFT", "unitScrollLeft",
-                         "KP_LEFT", "unitScrollLeft",
-                              "UP", "unitScrollUp",
-                           "KP_UP", "unitScrollUp",
-                         "PAGE_UP", "scrollUp",
-                       "PAGE_DOWN", "scrollDown",
-                    "ctrl PAGE_UP", "scrollLeft",
-                  "ctrl PAGE_DOWN", "scrollRight",
-                       "ctrl HOME", "scrollHome",
-                        "ctrl END", "scrollEnd"
-                    }),
-            "ScrollPane.ancestorInputMap.RightToLeft",
-                    new UIDefaults.LazyInputMap(new Object[] {
-                    "ctrl PAGE_UP", "scrollRight",
-                  "ctrl PAGE_DOWN", "scrollLeft",
-                    }),
-            "ScrollPane.font", new FontLazyValue(Region.SCROLL_PANE),
-
-
-            "Separator.insets", zeroInsets,
-            "Separator.thickness", Integer.valueOf(2),
-
-
-            "Slider.paintValue", Boolean.TRUE,
-            "Slider.thumbWidth", Integer.valueOf(30),
-            "Slider.thumbHeight", Integer.valueOf(14),
-            "Slider.focusInputMap",
-                    new UIDefaults.LazyInputMap(new Object[] {
-                            "RIGHT", "positiveUnitIncrement",
-                         "KP_RIGHT", "positiveUnitIncrement",
-                             "DOWN", "negativeUnitIncrement",
-                          "KP_DOWN", "negativeUnitIncrement",
-                        "PAGE_DOWN", "negativeBlockIncrement",
-                             "LEFT", "negativeUnitIncrement",
-                          "KP_LEFT", "negativeUnitIncrement",
-                               "UP", "positiveUnitIncrement",
-                            "KP_UP", "positiveUnitIncrement",
-                          "PAGE_UP", "positiveBlockIncrement",
-                             "HOME", "minScroll",
-                              "END", "maxScroll"
-                        }),
-            "Slider.focusInputMap.RightToLeft",
-                    new UIDefaults.LazyInputMap(new Object[] {
-                            "RIGHT", "negativeUnitIncrement",
-                         "KP_RIGHT", "negativeUnitIncrement",
-                             "LEFT", "positiveUnitIncrement",
-                          "KP_LEFT", "positiveUnitIncrement",
-                         }),
-            "Slider.onlyLeftMouseButtonDrag", Boolean.FALSE,
-
-            "Spinner.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                               "UP", "increment",
-                            "KP_UP", "increment",
-                             "DOWN", "decrement",
-                          "KP_DOWN", "decrement",
-               }),
-            "Spinner.font", new FontLazyValue(Region.SPINNER),
-            "Spinner.editorAlignment", JTextField.LEADING,
-
-            "SplitPane.ancestorInputMap",
-                    new UIDefaults.LazyInputMap(new Object[] {
-                        "UP", "negativeIncrement",
-                      "DOWN", "positiveIncrement",
-                      "LEFT", "negativeIncrement",
-                     "RIGHT", "positiveIncrement",
-                     "KP_UP", "negativeIncrement",
-                   "KP_DOWN", "positiveIncrement",
-                   "KP_LEFT", "negativeIncrement",
-                  "KP_RIGHT", "positiveIncrement",
-                      "HOME", "selectMin",
-                       "END", "selectMax",
-                        "F8", "startResize",
-                        "F6", "toggleFocus",
-                  "ctrl TAB", "focusOutForward",
-            "ctrl shift TAB", "focusOutBackward"
-                    }),
-
-
-            "SplitPane.size", Integer.valueOf(7),
-            "SplitPane.oneTouchOffset", Integer.valueOf(2),
-            "SplitPane.oneTouchButtonSize", Integer.valueOf(5),
-            "SplitPane.supportsOneTouchButtons", Boolean.FALSE,
-
-
-            "TabbedPane.focusInputMap",
-              new UIDefaults.LazyInputMap(new Object[] {
-                         "RIGHT", "navigateRight",
-                      "KP_RIGHT", "navigateRight",
-                          "LEFT", "navigateLeft",
-                       "KP_LEFT", "navigateLeft",
-                            "UP", "navigateUp",
-                         "KP_UP", "navigateUp",
-                          "DOWN", "navigateDown",
-                       "KP_DOWN", "navigateDown",
-                     "ctrl DOWN", "requestFocusForVisibleComponent",
-                  "ctrl KP_DOWN", "requestFocusForVisibleComponent",
-                         "SPACE", "selectTabWithFocus"
-                }),
-            "TabbedPane.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                         "ctrl TAB", "navigateNext",
-                   "ctrl shift TAB", "navigatePrevious",
-                   "ctrl PAGE_DOWN", "navigatePageDown",
-                     "ctrl PAGE_UP", "navigatePageUp",
-                          "ctrl UP", "requestFocus",
-                       "ctrl KP_UP", "requestFocus",
-                 }),
-
-            "TabbedPane.labelShift", 3,
-            "TabbedPane.selectedLabelShift", 3,
-            "TabbedPane.font", new FontLazyValue(Region.TABBED_PANE),
-            "TabbedPane.selectedTabPadInsets", new InsetsUIResource(2, 2, 0, 1),
-
-            "Table.scrollPaneBorder", zeroBorder,
-            "Table.background", tableBg,
-            "Table.focusCellBackground", tableFocusCellBg,
-            "Table.focusCellForeground", tableFocusCellFg,
-            "Table.focusCellHighlightBorder", focusBorder,
-            "Table.focusSelectedCellHighlightBorder", focusSelectedBorder,
-            "Table.ancestorInputMap",
-                    new UIDefaults.LazyInputMap(new Object[] {
-                               "ctrl C", "copy",
-                               "ctrl V", "paste",
-                               "ctrl X", "cut",
-                                 "COPY", "copy",
-                                "PASTE", "paste",
-                                  "CUT", "cut",
-                       "control INSERT", "copy",
-                         "shift INSERT", "paste",
-                         "shift DELETE", "cut",
-                                "RIGHT", "selectNextColumn",
-                             "KP_RIGHT", "selectNextColumn",
-                          "shift RIGHT", "selectNextColumnExtendSelection",
-                       "shift KP_RIGHT", "selectNextColumnExtendSelection",
-                     "ctrl shift RIGHT", "selectNextColumnExtendSelection",
-                  "ctrl shift KP_RIGHT", "selectNextColumnExtendSelection",
-                           "ctrl RIGHT", "selectNextColumnChangeLead",
-                        "ctrl KP_RIGHT", "selectNextColumnChangeLead",
-                                 "LEFT", "selectPreviousColumn",
-                              "KP_LEFT", "selectPreviousColumn",
-                           "shift LEFT", "selectPreviousColumnExtendSelection",
-                        "shift KP_LEFT", "selectPreviousColumnExtendSelection",
-                      "ctrl shift LEFT", "selectPreviousColumnExtendSelection",
-                   "ctrl shift KP_LEFT", "selectPreviousColumnExtendSelection",
-                            "ctrl LEFT", "selectPreviousColumnChangeLead",
-                         "ctrl KP_LEFT", "selectPreviousColumnChangeLead",
-                                 "DOWN", "selectNextRow",
-                              "KP_DOWN", "selectNextRow",
-                           "shift DOWN", "selectNextRowExtendSelection",
-                        "shift KP_DOWN", "selectNextRowExtendSelection",
-                      "ctrl shift DOWN", "selectNextRowExtendSelection",
-                   "ctrl shift KP_DOWN", "selectNextRowExtendSelection",
-                            "ctrl DOWN", "selectNextRowChangeLead",
-                         "ctrl KP_DOWN", "selectNextRowChangeLead",
-                                   "UP", "selectPreviousRow",
-                                "KP_UP", "selectPreviousRow",
-                             "shift UP", "selectPreviousRowExtendSelection",
-                          "shift KP_UP", "selectPreviousRowExtendSelection",
-                        "ctrl shift UP", "selectPreviousRowExtendSelection",
-                     "ctrl shift KP_UP", "selectPreviousRowExtendSelection",
-                              "ctrl UP", "selectPreviousRowChangeLead",
-                           "ctrl KP_UP", "selectPreviousRowChangeLead",
-                                 "HOME", "selectFirstColumn",
-                           "shift HOME", "selectFirstColumnExtendSelection",
-                      "ctrl shift HOME", "selectFirstRowExtendSelection",
-                            "ctrl HOME", "selectFirstRow",
-                                  "END", "selectLastColumn",
-                            "shift END", "selectLastColumnExtendSelection",
-                       "ctrl shift END", "selectLastRowExtendSelection",
-                             "ctrl END", "selectLastRow",
-                              "PAGE_UP", "scrollUpChangeSelection",
-                        "shift PAGE_UP", "scrollUpExtendSelection",
-                   "ctrl shift PAGE_UP", "scrollLeftExtendSelection",
-                         "ctrl PAGE_UP", "scrollLeftChangeSelection",
-                            "PAGE_DOWN", "scrollDownChangeSelection",
-                      "shift PAGE_DOWN", "scrollDownExtendSelection",
-                 "ctrl shift PAGE_DOWN", "scrollRightExtendSelection",
-                       "ctrl PAGE_DOWN", "scrollRightChangeSelection",
-                                  "TAB", "selectNextColumnCell",
-                            "shift TAB", "selectPreviousColumnCell",
-                                "ENTER", "selectNextRowCell",
-                          "shift ENTER", "selectPreviousRowCell",
-                               "ctrl A", "selectAll",
-                           "ctrl SLASH", "selectAll",
-                      "ctrl BACK_SLASH", "clearSelection",
-                               "ESCAPE", "cancel",
-                                   "F2", "startEditing",
-                                "SPACE", "addToSelection",
-                           "ctrl SPACE", "toggleAndAnchor",
-                          "shift SPACE", "extendTo",
-                     "ctrl shift SPACE", "moveSelectionTo",
-                                   "F8", "focusHeader"
-                    }),
-            "Table.ancestorInputMap.RightToLeft",
-                    new UIDefaults.LazyInputMap(new Object[] {
-                                "RIGHT", "selectPreviousColumn",
-                             "KP_RIGHT", "selectPreviousColumn",
-                          "shift RIGHT", "selectPreviousColumnExtendSelection",
-                       "shift KP_RIGHT", "selectPreviousColumnExtendSelection",
-                     "ctrl shift RIGHT", "selectPreviousColumnExtendSelection",
-                  "ctrl shift KP_RIGHT", "selectPreviousColumnExtendSelection",
-                          "shift RIGHT", "selectPreviousColumnChangeLead",
-                       "shift KP_RIGHT", "selectPreviousColumnChangeLead",
-                                 "LEFT", "selectNextColumn",
-                              "KP_LEFT", "selectNextColumn",
-                           "shift LEFT", "selectNextColumnExtendSelection",
-                        "shift KP_LEFT", "selectNextColumnExtendSelection",
-                      "ctrl shift LEFT", "selectNextColumnExtendSelection",
-                   "ctrl shift KP_LEFT", "selectNextColumnExtendSelection",
-                            "ctrl LEFT", "selectNextColumnChangeLead",
-                         "ctrl KP_LEFT", "selectNextColumnChangeLead",
-                         "ctrl PAGE_UP", "scrollRightChangeSelection",
-                       "ctrl PAGE_DOWN", "scrollLeftChangeSelection",
-                   "ctrl shift PAGE_UP", "scrollRightExtendSelection",
-                 "ctrl shift PAGE_DOWN", "scrollLeftExtendSelection",
-                    }),
-            "Table.font", new FontLazyValue(Region.TABLE),
-            "Table.ascendingSortIcon",  new GTKStyle.GTKLazyValue(
-                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
-                              "getAscendingSortIcon"),
-            "Table.descendingSortIcon",  new GTKStyle.GTKLazyValue(
-                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
-                              "getDescendingSortIcon"),
-
-            "TableHeader.font", new FontLazyValue(Region.TABLE_HEADER),
-            "TableHeader.alignSorterArrow", Boolean.TRUE,
-
-            "TextArea.caretForeground", caretColor,
-            "TextArea.caretAspectRatio", defaultCaretAspectRatio,
-            "TextArea.caretBlinkRate", caretBlinkRate,
-            "TextArea.margin", zeroInsets,
-            "TextArea.focusInputMap", multilineInputMap,
-            "TextArea.font", new FontLazyValue(Region.TEXT_AREA),
-
-
-            "TextField.caretForeground", caretColor,
-            "TextField.caretAspectRatio", defaultCaretAspectRatio,
-            "TextField.caretBlinkRate", caretBlinkRate,
-            "TextField.margin", zeroInsets,
-            "TextField.focusInputMap", fieldInputMap,
-            "TextField.font", new FontLazyValue(Region.TEXT_FIELD),
-
-
-            "TextPane.caretForeground", caretColor,
-            "TextPane.caretAspectRatio", defaultCaretAspectRatio,
-            "TextPane.caretBlinkRate", caretBlinkRate,
-            "TextPane.margin", editorMargin,
-            "TextPane.focusInputMap", multilineInputMap,
-            "TextPane.font", new FontLazyValue(Region.TEXT_PANE),
-
-
-            "TitledBorder.titleColor", controlText,
-            "TitledBorder.border", new UIDefaults.LazyValue() {
-                public Object createValue(UIDefaults table) {
-                    return new GTKPainter.TitledBorder();
-                }
-            },
-
-            "ToggleButton.focusInputMap",
-                   new UIDefaults.LazyInputMap(new Object[] {
-                            "SPACE", "pressed",
-                   "released SPACE", "released"
-                   }),
-            "ToggleButton.font", new FontLazyValue(Region.TOGGLE_BUTTON),
-            "ToggleButton.margin", zeroInsets,
-
-
-            "ToolBar.separatorSize", new DimensionUIResource(10, 10),
-            "ToolBar.handleIcon", new UIDefaults.ActiveValue() {
-                public Object createValue(UIDefaults table) {
-                    return GTKIconFactory.getToolBarHandleIcon();
-                }
-            },
-            "ToolBar.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                        "UP", "navigateUp",
-                     "KP_UP", "navigateUp",
-                      "DOWN", "navigateDown",
-                   "KP_DOWN", "navigateDown",
-                      "LEFT", "navigateLeft",
-                   "KP_LEFT", "navigateLeft",
-                     "RIGHT", "navigateRight",
-                  "KP_RIGHT", "navigateRight"
-                 }),
-            "ToolBar.font", new FontLazyValue(Region.TOOL_BAR),
-
-            "ToolTip.font", new FontLazyValue(Region.TOOL_TIP),
-
-            "Tree.padding", Integer.valueOf(4),
-            "Tree.background", tableBg,
-            "Tree.drawHorizontalLines", Boolean.FALSE,
-            "Tree.drawVerticalLines", Boolean.FALSE,
-            "Tree.rowHeight", Integer.valueOf(-1),
-            "Tree.scrollsOnExpand", Boolean.FALSE,
-            "Tree.expanderSize", Integer.valueOf(10),
-            "Tree.repaintWholeRow", Boolean.TRUE,
-            "Tree.closedIcon", null,
-            "Tree.leafIcon", null,
-            "Tree.openIcon", null,
-            "Tree.expandedIcon", new GTKStyle.GTKLazyValue(
-                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
-                              "getTreeExpandedIcon"),
-            "Tree.collapsedIcon", new GTKStyle.GTKLazyValue(
-                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
-                              "getTreeCollapsedIcon"),
-            "Tree.leftChildIndent", Integer.valueOf(2),
-            "Tree.rightChildIndent", Integer.valueOf(12),
-            "Tree.scrollsHorizontallyAndVertically", Boolean.FALSE,
-            "Tree.drawsFocusBorder", Boolean.TRUE,
-            "Tree.focusInputMap",
-                    new UIDefaults.LazyInputMap(new Object[] {
-                                 "ctrl C", "copy",
-                                 "ctrl V", "paste",
-                                 "ctrl X", "cut",
-                                   "COPY", "copy",
-                                  "PASTE", "paste",
-                                    "CUT", "cut",
-                         "control INSERT", "copy",
-                           "shift INSERT", "paste",
-                           "shift DELETE", "cut",
-                                     "UP", "selectPrevious",
-                                  "KP_UP", "selectPrevious",
-                               "shift UP", "selectPreviousExtendSelection",
-                            "shift KP_UP", "selectPreviousExtendSelection",
-                          "ctrl shift UP", "selectPreviousExtendSelection",
-                       "ctrl shift KP_UP", "selectPreviousExtendSelection",
-                                "ctrl UP", "selectPreviousChangeLead",
-                             "ctrl KP_UP", "selectPreviousChangeLead",
-                                   "DOWN", "selectNext",
-                                "KP_DOWN", "selectNext",
-                             "shift DOWN", "selectNextExtendSelection",
-                          "shift KP_DOWN", "selectNextExtendSelection",
-                        "ctrl shift DOWN", "selectNextExtendSelection",
-                     "ctrl shift KP_DOWN", "selectNextExtendSelection",
-                              "ctrl DOWN", "selectNextChangeLead",
-                           "ctrl KP_DOWN", "selectNextChangeLead",
-                                  "RIGHT", "selectChild",
-                               "KP_RIGHT", "selectChild",
-                                   "LEFT", "selectParent",
-                                "KP_LEFT", "selectParent",
-                                "typed +", "expand",
-                                "typed -", "collapse",
-                             "BACK_SPACE", "moveSelectionToParent",
-                                "PAGE_UP", "scrollUpChangeSelection",
-                          "shift PAGE_UP", "scrollUpExtendSelection",
-                     "ctrl shift PAGE_UP", "scrollUpExtendSelection",
-                           "ctrl PAGE_UP", "scrollUpChangeLead",
-                              "PAGE_DOWN", "scrollDownChangeSelection",
-                        "shift PAGE_DOWN", "scrollDownExtendSelection",
-                   "ctrl shift PAGE_DOWN", "scrollDownExtendSelection",
-                         "ctrl PAGE_DOWN", "scrollDownChangeLead",
-                                   "HOME", "selectFirst",
-                             "shift HOME", "selectFirstExtendSelection",
-                        "ctrl shift HOME", "selectFirstExtendSelection",
-                              "ctrl HOME", "selectFirstChangeLead",
-                                    "END", "selectLast",
-                              "shift END", "selectLastExtendSelection",
-                         "ctrl shift END", "selectLastExtendSelection",
-                               "ctrl END", "selectLastChangeLead",
-                                     "F2", "startEditing",
-                                 "ctrl A", "selectAll",
-                             "ctrl SLASH", "selectAll",
-                        "ctrl BACK_SLASH", "clearSelection",
-                              "ctrl LEFT", "scrollLeft",
-                           "ctrl KP_LEFT", "scrollLeft",
-                             "ctrl RIGHT", "scrollRight",
-                          "ctrl KP_RIGHT", "scrollRight",
-                                  "SPACE", "addToSelection",
-                             "ctrl SPACE", "toggleAndAnchor",
-                            "shift SPACE", "extendTo",
-                       "ctrl shift SPACE", "moveSelectionTo"
-                    }),
-            "Tree.focusInputMap.RightToLeft",
-                    new UIDefaults.LazyInputMap(new Object[] {
-                                  "RIGHT", "selectParent",
-                               "KP_RIGHT", "selectParent",
-                                   "LEFT", "selectChild",
-                                "KP_LEFT", "selectChild",
-                 }),
-            "Tree.ancestorInputMap",
-                      new UIDefaults.LazyInputMap(new Object[] {
-                         "ESCAPE", "cancel"
-                      }),
-            "Tree.font", new FontLazyValue(Region.TREE),
-
-            "Viewport.font", new FontLazyValue(Region.VIEWPORT)
-        };
-        table.putDefaults(defaults);
-
-        if (fallbackFont != null) {
-            table.put("TitledBorder.font", fallbackFont);
-        }
-        table.put(SwingUtilities2.AA_TEXT_PROPERTY_KEY, aaTextInfo);
-    }
-
-    protected void initSystemColorDefaults(UIDefaults table) {
-        GTKStyleFactory factory = (GTKStyleFactory)getStyleFactory();
-        GTKStyle windowStyle =
-                (GTKStyle)factory.getStyle(null, Region.INTERNAL_FRAME);
-        table.put("window", windowStyle.getGTKColor(SynthConstants.ENABLED,
-                GTKColorType.BACKGROUND));
-        table.put("windowText", windowStyle.getGTKColor(SynthConstants.ENABLED,
-                GTKColorType.TEXT_FOREGROUND));
-
-        GTKStyle entryStyle = (GTKStyle)factory.getStyle(null, Region.TEXT_FIELD);
-        table.put("text", entryStyle.getGTKColor(SynthConstants.ENABLED,
-                                           GTKColorType.TEXT_BACKGROUND));
-        table.put("textText", entryStyle.getGTKColor(SynthConstants.ENABLED,
-                                           GTKColorType.TEXT_FOREGROUND));
-        table.put("textHighlight",
-                entryStyle.getGTKColor(SynthConstants.SELECTED,
-                                         GTKColorType.TEXT_BACKGROUND));
-        table.put("textHighlightText",
-                  entryStyle.getGTKColor(SynthConstants.SELECTED,
-                                         GTKColorType.TEXT_FOREGROUND));
-        table.put("textInactiveText",
-                  entryStyle.getGTKColor(SynthConstants.DISABLED,
-                                         GTKColorType.TEXT_FOREGROUND));
-        Object caretColor =
-            entryStyle.getClassSpecificValue("cursor-color");
-        if (caretColor == null) {
-            caretColor = GTKStyle.BLACK_COLOR;
-        }
-        table.put("caretColor", caretColor);
-
-        GTKStyle menuStyle = (GTKStyle)factory.getStyle(null, Region.MENU_ITEM);
-        table.put("menu", menuStyle.getGTKColor(SynthConstants.ENABLED,
-                                           GTKColorType.BACKGROUND));
-        table.put("menuText", menuStyle.getGTKColor(SynthConstants.ENABLED,
-                                           GTKColorType.TEXT_FOREGROUND));
-
-        GTKStyle scrollbarStyle = (GTKStyle)factory.getStyle(null, Region.SCROLL_BAR);
-        table.put("scrollbar", scrollbarStyle.getGTKColor(SynthConstants.ENABLED,
-                                           GTKColorType.BACKGROUND));
-
-        GTKStyle infoStyle = (GTKStyle)factory.getStyle(null, Region.OPTION_PANE);
-        table.put("info", infoStyle.getGTKColor(SynthConstants.ENABLED,
-                                           GTKColorType.BACKGROUND));
-        table.put("infoText", infoStyle.getGTKColor(SynthConstants.ENABLED,
-                                           GTKColorType.TEXT_FOREGROUND));
-
-        GTKStyle desktopStyle = (GTKStyle)factory.getStyle(null, Region.DESKTOP_PANE);
-        table.put("desktop", desktopStyle.getGTKColor(SynthConstants.ENABLED,
-                                           GTKColorType.BACKGROUND));
-
-        // colors specific only for GTK
-        // It is impossible to create a simple GtkWidget without specifying the
-        // type. So for GtkWidget we can use any appropriate concrete type of
-        // wigdet. LABEL in this case.
-        GTKStyle widgetStyle = (GTKStyle)factory.getStyle(null, Region.LABEL);
-        Color bg = widgetStyle.getGTKColor(SynthConstants.ENABLED,
-                                           GTKColorType.BACKGROUND);
-        table.put("control", bg);
-        table.put("controlHighlight", bg);
-        table.put("controlText", widgetStyle.getGTKColor(SynthConstants.ENABLED,
-                                               GTKColorType.TEXT_FOREGROUND));
-        table.put("controlLtHighlight", widgetStyle.getGTKColor(
-                SynthConstants.ENABLED, GTKColorType.LIGHT));
-        table.put("controlShadow", widgetStyle.getGTKColor(
-                SynthConstants.ENABLED, GTKColorType.DARK));
-        table.put("controlDkShadow", widgetStyle.getGTKColor(
-                SynthConstants.ENABLED, GTKColorType.BLACK));
-        table.put("light", widgetStyle.getGTKColor(
-                SynthConstants.ENABLED, GTKColorType.LIGHT));
-        table.put("mid", widgetStyle.getGTKColor(
-                SynthConstants.ENABLED, GTKColorType.MID));
-        table.put("dark", widgetStyle.getGTKColor(
-                SynthConstants.ENABLED, GTKColorType.DARK));
-        table.put("black", widgetStyle.getGTKColor(
-                SynthConstants.ENABLED, GTKColorType.BLACK));
-        table.put("white", widgetStyle.getGTKColor(
-                SynthConstants.ENABLED, GTKColorType.WHITE));
-    }
+    static int synthStateToGTKState(Region region, int state) {throw new RuntimeException("cf-bug");} //{
+//        if ((state & SynthConstants.PRESSED) != 0) {
+//            if (region == Region.RADIO_BUTTON
+//                    || region == Region.CHECK_BOX
+//                    || region == Region.MENU
+//                    || region == Region.MENU_ITEM
+//                    || region == Region.RADIO_BUTTON_MENU_ITEM
+//                    || region == Region.CHECK_BOX_MENU_ITEM
+//                    || region == Region.SPLIT_PANE) {
+//                state = SynthConstants.MOUSE_OVER;
+//            } else {
+//                state = SynthConstants.PRESSED;
+//            }
+//
+//        } else if (region == Region.TABBED_PANE_TAB) {
+//            if ((state & SynthConstants.DISABLED) != 0) {
+//                state = SynthConstants.DISABLED;
+//            }
+//            else if ((state & SynthConstants.SELECTED) != 0) {
+//                state = SynthConstants.ENABLED;
+//            } else {
+//                state = SynthConstants.PRESSED;
+//            }
+//
+//        } else if ((state & SynthConstants.SELECTED) != 0) {
+//            if (region == Region.MENU) {
+//                state = SynthConstants.MOUSE_OVER;
+//            } else if (region == Region.RADIO_BUTTON ||
+//                          region == Region.TOGGLE_BUTTON ||
+//                          region == Region.RADIO_BUTTON_MENU_ITEM ||
+//                          region == Region.CHECK_BOX_MENU_ITEM ||
+//                          region == Region.CHECK_BOX ||
+//                          region == Region.BUTTON) {
+//                if ((state & SynthConstants.DISABLED) != 0) {
+//                    state = SynthConstants.DISABLED;
+//                }
+//                // If the button is SELECTED and is PRELIGHT we need to
+//                // make the state MOUSE_OVER otherwise we don't paint the
+//                // PRELIGHT.
+//                else if ((state & SynthConstants.MOUSE_OVER) != 0) {
+//                    state = SynthConstants.MOUSE_OVER;
+//                } else {
+//                    state = SynthConstants.PRESSED;
+//                }
+//            } else {
+//                state = SynthConstants.SELECTED;
+//            }
+//        }
+//
+//        else if ((state & SynthConstants.MOUSE_OVER) != 0) {
+//            state = SynthConstants.MOUSE_OVER;
+//        }
+//        else if ((state & SynthConstants.DISABLED) != 0) {
+//            state = SynthConstants.DISABLED;
+//        }
+//        else {
+//            if (region == Region.SLIDER_TRACK) {
+//                state = SynthConstants.PRESSED;
+//            } else {
+//                state = SynthConstants.ENABLED;
+//            }
+//        }
+//        return state;
+//    }
+
+    static boolean isText(Region region) {throw new RuntimeException("cf-bug");} //{
+//        // These Regions treat FOREGROUND as TEXT.
+//        return (region == Region.TEXT_FIELD ||
+//                region == Region.FORMATTED_TEXT_FIELD ||
+//                region == Region.LIST ||
+//                region == Region.PASSWORD_FIELD ||
+//                region == Region.SPINNER ||
+//                region == Region.TABLE ||
+//                region == Region.TEXT_AREA ||
+//                region == Region.TEXT_FIELD ||
+//                region == Region.TEXT_PANE ||
+//                region == Region.TREE);
+//    }
+
+    public UIDefaults getDefaults() {throw new RuntimeException("cf-bug");} //{
+//        // We need to call super for basic's properties file.
+//        UIDefaults table = super.getDefaults();
+//
+//        // SynthTabbedPaneUI supports rollover on tabs, GTK does not
+//        table.put("TabbedPane.isTabRollover", Boolean.FALSE);
+//
+//        // Prevents Synth from setting text AA by itself
+//        table.put("Synth.doNotSetTextAA", true);
+//
+//        initResourceBundle(table);
+//        // For compatibility with apps expecting certain defaults we'll
+//        // populate the table with the values from basic.
+//        initSystemColorDefaults(table);
+//        initComponentDefaults(table);
+//        installPropertyChangeListeners();
+//        return table;
+//    }
+
+    private void installPropertyChangeListeners() {throw new RuntimeException("cf-bug");} //{
+//        if(!pclInstalled) {
+//            Toolkit kit = Toolkit.getDefaultToolkit();
+//            WeakPCL pcl = new WeakPCL(this, kit, "gnome.Net/ThemeName");
+//            kit.addPropertyChangeListener(pcl.getKey(), pcl);
+//            pcl = new WeakPCL(this, kit, "gnome.Gtk/FontName");
+//            kit.addPropertyChangeListener(pcl.getKey(), pcl);
+//            pcl = new WeakPCL(this, kit, "gnome.Xft/DPI");
+//            kit.addPropertyChangeListener(pcl.getKey(), pcl);
+//
+//            flushUnreferenced();
+//            pclInstalled = true;
+//        }
+//    }
+
+    private void initResourceBundle(UIDefaults table) {throw new RuntimeException("cf-bug");} //{
+//        table.addResourceBundle("com.sun.java.swing.plaf.gtk.resources.gtk");
+//    }
+
+    protected void initComponentDefaults(UIDefaults table) {throw new RuntimeException("cf-bug");} //{
+//        // For compatibility with apps expecting certain defaults we'll
+//        // populate the table with the values from basic.
+//        super.initComponentDefaults(table);
+//
+//        Integer zero =  Integer.valueOf(0);
+//        Object zeroBorder = new sun.swing.SwingLazyValue(
+//            "javax.swing.plaf.BorderUIResource$EmptyBorderUIResource",
+//            new Object[] {zero, zero, zero, zero});
+//        Object focusBorder = new GTKStyle.GTKLazyValue(
+//            "com.sun.java.swing.plaf.gtk.GTKPainter$ListTableFocusBorder",
+//            "getUnselectedCellBorder");
+//        Object focusSelectedBorder = new GTKStyle.GTKLazyValue(
+//            "com.sun.java.swing.plaf.gtk.GTKPainter$ListTableFocusBorder",
+//            "getSelectedCellBorder");
+//        Object noFocusBorder = new GTKStyle.GTKLazyValue(
+//            "com.sun.java.swing.plaf.gtk.GTKPainter$ListTableFocusBorder",
+//            "getNoFocusCellBorder");
+//
+//        GTKStyleFactory factory = (GTKStyleFactory)getStyleFactory();
+//        GTKStyle tableStyle = (GTKStyle)factory.getStyle(null, Region.TREE);
+//        Color tableBg = tableStyle.getGTKColor(SynthConstants.ENABLED,
+//                GTKColorType.TEXT_BACKGROUND);
+//        Color tableFocusCellBg = tableStyle.getGTKColor(SynthConstants.ENABLED,
+//                GTKColorType.BACKGROUND);
+//        Color tableFocusCellFg = tableStyle.getGTKColor(SynthConstants.ENABLED,
+//                GTKColorType.FOREGROUND);
+//
+//        // The following progress bar size calculations come from
+//        // gtkprogressbar.c (version 2.8.20), see MIN_* constants and
+//        // the gtk_progress_bar_size_request() method.
+//        GTKStyle progStyle = (GTKStyle)
+//            factory.getStyle(null, Region.PROGRESS_BAR);
+//        int progXThickness = progStyle.getXThickness();
+//        int progYThickness = progStyle.getYThickness();
+//        int hProgWidth  = 150 - (progXThickness * 2);
+//        int hProgHeight =  20 - (progYThickness * 2);
+//        int vProgWidth  =  22 - (progXThickness * 2);
+//        int vProgHeight =  80 - (progYThickness * 2);
+//
+//        Integer caretBlinkRate = Integer.valueOf(500);
+//        Insets zeroInsets = new InsetsUIResource(0, 0, 0, 0);
+//
+//        Double defaultCaretAspectRatio = new Double(0.025);
+//        Color caretColor = table.getColor("caretColor");
+//        Color controlText = table.getColor("controlText");
+//
+//        Object fieldInputMap = new UIDefaults.LazyInputMap(new Object[] {
+//                       "ctrl C", DefaultEditorKit.copyAction,
+//                       "ctrl V", DefaultEditorKit.pasteAction,
+//                       "ctrl X", DefaultEditorKit.cutAction,
+//                         "COPY", DefaultEditorKit.copyAction,
+//                        "PASTE", DefaultEditorKit.pasteAction,
+//                          "CUT", DefaultEditorKit.cutAction,
+//               "control INSERT", DefaultEditorKit.copyAction,
+//                 "shift INSERT", DefaultEditorKit.pasteAction,
+//                 "shift DELETE", DefaultEditorKit.cutAction,
+//                   "shift LEFT", DefaultEditorKit.selectionBackwardAction,
+//                "shift KP_LEFT", DefaultEditorKit.selectionBackwardAction,
+//                  "shift RIGHT", DefaultEditorKit.selectionForwardAction,
+//               "shift KP_RIGHT", DefaultEditorKit.selectionForwardAction,
+//                    "ctrl LEFT", DefaultEditorKit.previousWordAction,
+//                 "ctrl KP_LEFT", DefaultEditorKit.previousWordAction,
+//                   "ctrl RIGHT", DefaultEditorKit.nextWordAction,
+//                "ctrl KP_RIGHT", DefaultEditorKit.nextWordAction,
+//              "ctrl shift LEFT", DefaultEditorKit.selectionPreviousWordAction,
+//           "ctrl shift KP_LEFT", DefaultEditorKit.selectionPreviousWordAction,
+//             "ctrl shift RIGHT", DefaultEditorKit.selectionNextWordAction,
+//          "ctrl shift KP_RIGHT", DefaultEditorKit.selectionNextWordAction,
+//                       "ctrl A", DefaultEditorKit.selectAllAction,
+//                         "HOME", DefaultEditorKit.beginLineAction,
+//                          "END", DefaultEditorKit.endLineAction,
+//                   "shift HOME", DefaultEditorKit.selectionBeginLineAction,
+//                    "shift END", DefaultEditorKit.selectionEndLineAction,
+//                   "BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
+//             "shift BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
+//                       "ctrl H", DefaultEditorKit.deletePrevCharAction,
+//                       "DELETE", DefaultEditorKit.deleteNextCharAction,
+//                  "ctrl DELETE", DefaultEditorKit.deleteNextWordAction,
+//              "ctrl BACK_SPACE", DefaultEditorKit.deletePrevWordAction,
+//                        "RIGHT", DefaultEditorKit.forwardAction,
+//                         "LEFT", DefaultEditorKit.backwardAction,
+//                     "KP_RIGHT", DefaultEditorKit.forwardAction,
+//                      "KP_LEFT", DefaultEditorKit.backwardAction,
+//                        "ENTER", JTextField.notifyAction,
+//              "ctrl BACK_SLASH", "unselect"/*DefaultEditorKit.unselectAction*/,
+//               "control shift O", "toggle-componentOrientation"/*DefaultEditorKit.toggleComponentOrientation*/
+//            });
+//
+//        Object passwordInputMap = new UIDefaults.LazyInputMap(new Object[] {
+//                       "ctrl C", DefaultEditorKit.copyAction,
+//                       "ctrl V", DefaultEditorKit.pasteAction,
+//                       "ctrl X", DefaultEditorKit.cutAction,
+//                         "COPY", DefaultEditorKit.copyAction,
+//                        "PASTE", DefaultEditorKit.pasteAction,
+//                          "CUT", DefaultEditorKit.cutAction,
+//               "control INSERT", DefaultEditorKit.copyAction,
+//                 "shift INSERT", DefaultEditorKit.pasteAction,
+//                 "shift DELETE", DefaultEditorKit.cutAction,
+//                   "shift LEFT", DefaultEditorKit.selectionBackwardAction,
+//                "shift KP_LEFT", DefaultEditorKit.selectionBackwardAction,
+//                  "shift RIGHT", DefaultEditorKit.selectionForwardAction,
+//               "shift KP_RIGHT", DefaultEditorKit.selectionForwardAction,
+//                    "ctrl LEFT", DefaultEditorKit.beginLineAction,
+//                 "ctrl KP_LEFT", DefaultEditorKit.beginLineAction,
+//                   "ctrl RIGHT", DefaultEditorKit.endLineAction,
+//                "ctrl KP_RIGHT", DefaultEditorKit.endLineAction,
+//              "ctrl shift LEFT", DefaultEditorKit.selectionBeginLineAction,
+//           "ctrl shift KP_LEFT", DefaultEditorKit.selectionBeginLineAction,
+//             "ctrl shift RIGHT", DefaultEditorKit.selectionEndLineAction,
+//          "ctrl shift KP_RIGHT", DefaultEditorKit.selectionEndLineAction,
+//                       "ctrl A", DefaultEditorKit.selectAllAction,
+//                         "HOME", DefaultEditorKit.beginLineAction,
+//                          "END", DefaultEditorKit.endLineAction,
+//                   "shift HOME", DefaultEditorKit.selectionBeginLineAction,
+//                    "shift END", DefaultEditorKit.selectionEndLineAction,
+//                   "BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
+//             "shift BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
+//                       "ctrl H", DefaultEditorKit.deletePrevCharAction,
+//                       "DELETE", DefaultEditorKit.deleteNextCharAction,
+//                        "RIGHT", DefaultEditorKit.forwardAction,
+//                         "LEFT", DefaultEditorKit.backwardAction,
+//                     "KP_RIGHT", DefaultEditorKit.forwardAction,
+//                      "KP_LEFT", DefaultEditorKit.backwardAction,
+//                        "ENTER", JTextField.notifyAction,
+//              "ctrl BACK_SLASH", "unselect"/*DefaultEditorKit.unselectAction*/,
+//               "control shift O", "toggle-componentOrientation"/*DefaultEditorKit.toggleComponentOrientation*/
+//            });
+//
+//        Object editorMargin = new InsetsUIResource(3,3,3,3);
+//
+//        Object multilineInputMap = new UIDefaults.LazyInputMap(new Object[] {
+//                           "ctrl C", DefaultEditorKit.copyAction,
+//                           "ctrl V", DefaultEditorKit.pasteAction,
+//                           "ctrl X", DefaultEditorKit.cutAction,
+//                             "COPY", DefaultEditorKit.copyAction,
+//                            "PASTE", DefaultEditorKit.pasteAction,
+//                              "CUT", DefaultEditorKit.cutAction,
+//                   "control INSERT", DefaultEditorKit.copyAction,
+//                     "shift INSERT", DefaultEditorKit.pasteAction,
+//                     "shift DELETE", DefaultEditorKit.cutAction,
+//                       "shift LEFT", DefaultEditorKit.selectionBackwardAction,
+//                    "shift KP_LEFT", DefaultEditorKit.selectionBackwardAction,
+//                      "shift RIGHT", DefaultEditorKit.selectionForwardAction,
+//                   "shift KP_RIGHT", DefaultEditorKit.selectionForwardAction,
+//                        "ctrl LEFT", DefaultEditorKit.previousWordAction,
+//                     "ctrl KP_LEFT", DefaultEditorKit.previousWordAction,
+//                       "ctrl RIGHT", DefaultEditorKit.nextWordAction,
+//                    "ctrl KP_RIGHT", DefaultEditorKit.nextWordAction,
+//                  "ctrl shift LEFT", DefaultEditorKit.selectionPreviousWordAction,
+//               "ctrl shift KP_LEFT", DefaultEditorKit.selectionPreviousWordAction,
+//                 "ctrl shift RIGHT", DefaultEditorKit.selectionNextWordAction,
+//              "ctrl shift KP_RIGHT", DefaultEditorKit.selectionNextWordAction,
+//                           "ctrl A", DefaultEditorKit.selectAllAction,
+//                             "HOME", DefaultEditorKit.beginLineAction,
+//                              "END", DefaultEditorKit.endLineAction,
+//                       "shift HOME", DefaultEditorKit.selectionBeginLineAction,
+//                        "shift END", DefaultEditorKit.selectionEndLineAction,
+//
+//                               "UP", DefaultEditorKit.upAction,
+//                            "KP_UP", DefaultEditorKit.upAction,
+//                             "DOWN", DefaultEditorKit.downAction,
+//                          "KP_DOWN", DefaultEditorKit.downAction,
+//                          "PAGE_UP", DefaultEditorKit.pageUpAction,
+//                        "PAGE_DOWN", DefaultEditorKit.pageDownAction,
+//                    "shift PAGE_UP", "selection-page-up",
+//                  "shift PAGE_DOWN", "selection-page-down",
+//               "ctrl shift PAGE_UP", "selection-page-left",
+//             "ctrl shift PAGE_DOWN", "selection-page-right",
+//                         "shift UP", DefaultEditorKit.selectionUpAction,
+//                      "shift KP_UP", DefaultEditorKit.selectionUpAction,
+//                       "shift DOWN", DefaultEditorKit.selectionDownAction,
+//                    "shift KP_DOWN", DefaultEditorKit.selectionDownAction,
+//                            "ENTER", DefaultEditorKit.insertBreakAction,
+//                       "BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
+//                 "shift BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
+//                           "ctrl H", DefaultEditorKit.deletePrevCharAction,
+//                           "DELETE", DefaultEditorKit.deleteNextCharAction,
+//                      "ctrl DELETE", DefaultEditorKit.deleteNextWordAction,
+//                  "ctrl BACK_SPACE", DefaultEditorKit.deletePrevWordAction,
+//                            "RIGHT", DefaultEditorKit.forwardAction,
+//                             "LEFT", DefaultEditorKit.backwardAction,
+//                         "KP_RIGHT", DefaultEditorKit.forwardAction,
+//                          "KP_LEFT", DefaultEditorKit.backwardAction,
+//                              "TAB", DefaultEditorKit.insertTabAction,
+//                  "ctrl BACK_SLASH", "unselect"/*DefaultEditorKit.unselectAction*/,
+//                        "ctrl HOME", DefaultEditorKit.beginAction,
+//                         "ctrl END", DefaultEditorKit.endAction,
+//                  "ctrl shift HOME", DefaultEditorKit.selectionBeginAction,
+//                   "ctrl shift END", DefaultEditorKit.selectionEndAction,
+//                           "ctrl T", "next-link-action",
+//                     "ctrl shift T", "previous-link-action",
+//                       "ctrl SPACE", "activate-link-action",
+//                   "control shift O", "toggle-componentOrientation"/*DefaultEditorKit.toggleComponentOrientation*/
+//            });
+//
+//        class FontLazyValue implements UIDefaults.LazyValue {
+//            private Region region;
+//            FontLazyValue(Region region) {
+//                this.region = region;
+//            }
+//            public Object createValue(UIDefaults table) {
+//                GTKStyleFactory factory = (GTKStyleFactory)getStyleFactory();
+//                GTKStyle style = (GTKStyle)factory.getStyle(null, region);
+//                return style.getFontForState(null);
+//            }
+//        }
+//
+//        Object[] defaults = new Object[] {
+//            "ArrowButton.size", Integer.valueOf(13),
+//
+//
+//            "Button.defaultButtonFollowsFocus", Boolean.FALSE,
+//            "Button.focusInputMap", new UIDefaults.LazyInputMap(new Object[] {
+//                         "SPACE", "pressed",
+//                "released SPACE", "released",
+//                         "ENTER", "pressed",
+//                "released ENTER", "released"
+//              }),
+//            "Button.font", new FontLazyValue(Region.BUTTON),
+//            "Button.margin", zeroInsets,
+//
+//
+//            "CheckBox.focusInputMap", new UIDefaults.LazyInputMap(new Object[]{
+//                         "SPACE", "pressed",
+//                "released SPACE", "released"
+//              }),
+//            "CheckBox.icon", new GTKStyle.GTKLazyValue(
+//                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
+//                              "getCheckBoxIcon"),
+//            "CheckBox.font", new FontLazyValue(Region.CHECK_BOX),
+//            "CheckBox.margin", zeroInsets,
+//
+//
+//            "CheckBoxMenuItem.arrowIcon", null,
+//            "CheckBoxMenuItem.checkIcon", new GTKStyle.GTKLazyValue(
+//                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
+//                              "getCheckBoxMenuItemCheckIcon"),
+//            "CheckBoxMenuItem.font",
+//                new FontLazyValue(Region.CHECK_BOX_MENU_ITEM),
+//            "CheckBoxMenuItem.margin", zeroInsets,
+//            "CheckBoxMenuItem.alignAcceleratorText", Boolean.FALSE,
+//
+//
+//            "ColorChooser.showPreviewPanelText", Boolean.FALSE,
+//            "ColorChooser.panels", new UIDefaults.ActiveValue() {
+//                public Object createValue(UIDefaults table) {
+//                    return new AbstractColorChooserPanel[] {
+//                                       new GTKColorChooserPanel() };
+//                }
+//            },
+//            "ColorChooser.font", new FontLazyValue(Region.COLOR_CHOOSER),
+//
+//
+//            "ComboBox.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                     "ESCAPE", "hidePopup",
+//                    "PAGE_UP", "pageUpPassThrough",
+//                  "PAGE_DOWN", "pageDownPassThrough",
+//                       "HOME", "homePassThrough",
+//                        "END", "endPassThrough",
+//                       "DOWN", "selectNext",
+//                    "KP_DOWN", "selectNext",
+//                   "alt DOWN", "togglePopup",
+//                "alt KP_DOWN", "togglePopup",
+//                     "alt UP", "togglePopup",
+//                  "alt KP_UP", "togglePopup",
+//                      "SPACE", "spacePopup",
+//                      "ENTER", "enterPressed",
+//                         "UP", "selectPrevious",
+//                      "KP_UP", "selectPrevious"
+//
+//                 }),
+//            "ComboBox.font", new FontLazyValue(Region.COMBO_BOX),
+//            "ComboBox.isEnterSelectablePopup", Boolean.TRUE,
+//
+//
+//            "EditorPane.caretForeground", caretColor,
+//            "EditorPane.caretAspectRatio", defaultCaretAspectRatio,
+//            "EditorPane.caretBlinkRate", caretBlinkRate,
+//            "EditorPane.margin", editorMargin,
+//            "EditorPane.focusInputMap", multilineInputMap,
+//            "EditorPane.font", new FontLazyValue(Region.EDITOR_PANE),
+//
+//
+//            "FileChooser.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                     "ESCAPE", "cancelSelection",
+//                 "ctrl ENTER", "approveSelection"
+//                 }),
+//            "FileChooserUI", "com.sun.java.swing.plaf.gtk.GTKLookAndFeel",
+//
+//
+//            "FormattedTextField.caretForeground", caretColor,
+//            "FormattedTextField.caretAspectRatio", defaultCaretAspectRatio,
+//            "FormattedTextField.caretBlinkRate", caretBlinkRate,
+//            "FormattedTextField.focusInputMap",
+//              new UIDefaults.LazyInputMap(new Object[] {
+//                           "ctrl C", DefaultEditorKit.copyAction,
+//                           "ctrl V", DefaultEditorKit.pasteAction,
+//                           "ctrl X", DefaultEditorKit.cutAction,
+//                             "COPY", DefaultEditorKit.copyAction,
+//                            "PASTE", DefaultEditorKit.pasteAction,
+//                              "CUT", DefaultEditorKit.cutAction,
+//                   "control INSERT", DefaultEditorKit.copyAction,
+//                     "shift INSERT", DefaultEditorKit.pasteAction,
+//                     "shift DELETE", DefaultEditorKit.cutAction,
+//                       "shift LEFT", DefaultEditorKit.selectionBackwardAction,
+//                    "shift KP_LEFT", DefaultEditorKit.selectionBackwardAction,
+//                      "shift RIGHT", DefaultEditorKit.selectionForwardAction,
+//                   "shift KP_RIGHT", DefaultEditorKit.selectionForwardAction,
+//                        "ctrl LEFT", DefaultEditorKit.previousWordAction,
+//                     "ctrl KP_LEFT", DefaultEditorKit.previousWordAction,
+//                       "ctrl RIGHT", DefaultEditorKit.nextWordAction,
+//                    "ctrl KP_RIGHT", DefaultEditorKit.nextWordAction,
+//                  "ctrl shift LEFT", DefaultEditorKit.selectionPreviousWordAction,
+//               "ctrl shift KP_LEFT", DefaultEditorKit.selectionPreviousWordAction,
+//                 "ctrl shift RIGHT", DefaultEditorKit.selectionNextWordAction,
+//              "ctrl shift KP_RIGHT", DefaultEditorKit.selectionNextWordAction,
+//                           "ctrl A", DefaultEditorKit.selectAllAction,
+//                             "HOME", DefaultEditorKit.beginLineAction,
+//                              "END", DefaultEditorKit.endLineAction,
+//                       "shift HOME", DefaultEditorKit.selectionBeginLineAction,
+//                        "shift END", DefaultEditorKit.selectionEndLineAction,
+//                       "BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
+//                 "shift BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
+//                           "ctrl H", DefaultEditorKit.deletePrevCharAction,
+//                           "DELETE", DefaultEditorKit.deleteNextCharAction,
+//                      "ctrl DELETE", DefaultEditorKit.deleteNextWordAction,
+//                  "ctrl BACK_SPACE", DefaultEditorKit.deletePrevWordAction,
+//                            "RIGHT", DefaultEditorKit.forwardAction,
+//                             "LEFT", DefaultEditorKit.backwardAction,
+//                         "KP_RIGHT", DefaultEditorKit.forwardAction,
+//                          "KP_LEFT", DefaultEditorKit.backwardAction,
+//                            "ENTER", JTextField.notifyAction,
+//                  "ctrl BACK_SLASH", "unselect",
+//                  "control shift O", "toggle-componentOrientation",
+//                           "ESCAPE", "reset-field-edit",
+//                               "UP", "increment",
+//                            "KP_UP", "increment",
+//                             "DOWN", "decrement",
+//                          "KP_DOWN", "decrement",
+//              }),
+//            "FormattedTextField.font",
+//                new FontLazyValue(Region.FORMATTED_TEXT_FIELD),
+//
+//
+//            "InternalFrameTitlePane.titlePaneLayout",
+//                                new GTKStyle.GTKLazyValue("com.sun.java.swing.plaf.gtk.Metacity",
+//                                                 "getTitlePaneLayout"),
+//            "InternalFrame.windowBindings", new Object[] {
+//                  "shift ESCAPE", "showSystemMenu",
+//                    "ctrl SPACE", "showSystemMenu",
+//                        "ESCAPE", "hideSystemMenu" },
+//            "InternalFrame.layoutTitlePaneAtOrigin", Boolean.TRUE,
+//            "InternalFrame.useTaskBar", Boolean.TRUE,
+//
+//            "InternalFrameTitlePane.iconifyButtonOpacity", null,
+//            "InternalFrameTitlePane.maximizeButtonOpacity", null,
+//            "InternalFrameTitlePane.closeButtonOpacity", null,
+//
+//            "Label.font", new FontLazyValue(Region.LABEL),
+//
+//            "List.background", tableBg,
+//            "List.focusCellHighlightBorder", focusBorder,
+//            "List.focusSelectedCellHighlightBorder", focusSelectedBorder,
+//            "List.noFocusBorder", noFocusBorder,
+//            "List.focusInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                           "ctrl C", "copy",
+//                           "ctrl V", "paste",
+//                           "ctrl X", "cut",
+//                             "COPY", "copy",
+//                            "PASTE", "paste",
+//                              "CUT", "cut",
+//                   "control INSERT", "copy",
+//                     "shift INSERT", "paste",
+//                     "shift DELETE", "cut",
+//                               "UP", "selectPreviousRow",
+//                            "KP_UP", "selectPreviousRow",
+//                         "shift UP", "selectPreviousRowExtendSelection",
+//                      "shift KP_UP", "selectPreviousRowExtendSelection",
+//                    "ctrl shift UP", "selectPreviousRowExtendSelection",
+//                 "ctrl shift KP_UP", "selectPreviousRowExtendSelection",
+//                          "ctrl UP", "selectPreviousRowChangeLead",
+//                       "ctrl KP_UP", "selectPreviousRowChangeLead",
+//                             "DOWN", "selectNextRow",
+//                          "KP_DOWN", "selectNextRow",
+//                       "shift DOWN", "selectNextRowExtendSelection",
+//                    "shift KP_DOWN", "selectNextRowExtendSelection",
+//                  "ctrl shift DOWN", "selectNextRowExtendSelection",
+//               "ctrl shift KP_DOWN", "selectNextRowExtendSelection",
+//                        "ctrl DOWN", "selectNextRowChangeLead",
+//                     "ctrl KP_DOWN", "selectNextRowChangeLead",
+//                             "LEFT", "selectPreviousColumn",
+//                          "KP_LEFT", "selectPreviousColumn",
+//                       "shift LEFT", "selectPreviousColumnExtendSelection",
+//                    "shift KP_LEFT", "selectPreviousColumnExtendSelection",
+//                  "ctrl shift LEFT", "selectPreviousColumnExtendSelection",
+//               "ctrl shift KP_LEFT", "selectPreviousColumnExtendSelection",
+//                        "ctrl LEFT", "selectPreviousColumnChangeLead",
+//                     "ctrl KP_LEFT", "selectPreviousColumnChangeLead",
+//                            "RIGHT", "selectNextColumn",
+//                         "KP_RIGHT", "selectNextColumn",
+//                      "shift RIGHT", "selectNextColumnExtendSelection",
+//                   "shift KP_RIGHT", "selectNextColumnExtendSelection",
+//                 "ctrl shift RIGHT", "selectNextColumnExtendSelection",
+//              "ctrl shift KP_RIGHT", "selectNextColumnExtendSelection",
+//                       "ctrl RIGHT", "selectNextColumnChangeLead",
+//                    "ctrl KP_RIGHT", "selectNextColumnChangeLead",
+//                             "HOME", "selectFirstRow",
+//                       "shift HOME", "selectFirstRowExtendSelection",
+//                  "ctrl shift HOME", "selectFirstRowExtendSelection",
+//                        "ctrl HOME", "selectFirstRowChangeLead",
+//                              "END", "selectLastRow",
+//                        "shift END", "selectLastRowExtendSelection",
+//                   "ctrl shift END", "selectLastRowExtendSelection",
+//                         "ctrl END", "selectLastRowChangeLead",
+//                          "PAGE_UP", "scrollUp",
+//                    "shift PAGE_UP", "scrollUpExtendSelection",
+//               "ctrl shift PAGE_UP", "scrollUpExtendSelection",
+//                     "ctrl PAGE_UP", "scrollUpChangeLead",
+//                        "PAGE_DOWN", "scrollDown",
+//                  "shift PAGE_DOWN", "scrollDownExtendSelection",
+//             "ctrl shift PAGE_DOWN", "scrollDownExtendSelection",
+//                   "ctrl PAGE_DOWN", "scrollDownChangeLead",
+//                           "ctrl A", "selectAll",
+//                       "ctrl SLASH", "selectAll",
+//                  "ctrl BACK_SLASH", "clearSelection",
+//                            "SPACE", "addToSelection",
+//                       "ctrl SPACE", "toggleAndAnchor",
+//                      "shift SPACE", "extendTo",
+//                 "ctrl shift SPACE", "moveSelectionTo"
+//                 }),
+//            "List.focusInputMap.RightToLeft",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                             "LEFT", "selectNextColumn",
+//                          "KP_LEFT", "selectNextColumn",
+//                       "shift LEFT", "selectNextColumnExtendSelection",
+//                    "shift KP_LEFT", "selectNextColumnExtendSelection",
+//                  "ctrl shift LEFT", "selectNextColumnExtendSelection",
+//               "ctrl shift KP_LEFT", "selectNextColumnExtendSelection",
+//                        "ctrl LEFT", "selectNextColumnChangeLead",
+//                     "ctrl KP_LEFT", "selectNextColumnChangeLead",
+//                            "RIGHT", "selectPreviousColumn",
+//                         "KP_RIGHT", "selectPreviousColumn",
+//                      "shift RIGHT", "selectPreviousColumnExtendSelection",
+//                   "shift KP_RIGHT", "selectPreviousColumnExtendSelection",
+//                 "ctrl shift RIGHT", "selectPreviousColumnExtendSelection",
+//              "ctrl shift KP_RIGHT", "selectPreviousColumnExtendSelection",
+//                       "ctrl RIGHT", "selectPreviousColumnChangeLead",
+//                    "ctrl KP_RIGHT", "selectPreviousColumnChangeLead",
+//                 }),
+//            "List.font", new FontLazyValue(Region.LIST),
+//            "List.rendererUseUIBorder", Boolean.FALSE,
+//
+//            "Menu.arrowIcon", new GTKStyle.GTKLazyValue(
+//                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
+//                              "getMenuArrowIcon"),
+//            "Menu.checkIcon", null,
+//            "Menu.font", new FontLazyValue(Region.MENU),
+//            "Menu.margin", zeroInsets,
+//            "Menu.cancelMode", "hideMenuTree",
+//            "Menu.alignAcceleratorText", Boolean.FALSE,
+//            "Menu.useMenuBarForTopLevelMenus", Boolean.TRUE,
+//
+//
+//                "MenuBar.windowBindings", new Object[] {
+//                "F10", "takeFocus" },
+//            "MenuBar.font", new FontLazyValue(Region.MENU_BAR),
+//
+//
+//            "MenuItem.arrowIcon", null,
+//            "MenuItem.checkIcon", null,
+//            "MenuItem.font", new FontLazyValue(Region.MENU_ITEM),
+//            "MenuItem.margin", zeroInsets,
+//            "MenuItem.alignAcceleratorText", Boolean.FALSE,
+//
+//
+//            "OptionPane.setButtonMargin", Boolean.FALSE,
+//            "OptionPane.sameSizeButtons", Boolean.TRUE,
+//            "OptionPane.buttonOrientation", new Integer(SwingConstants.RIGHT),
+//            "OptionPane.minimumSize", new DimensionUIResource(262, 90),
+//            "OptionPane.buttonPadding", new Integer(10),
+//            "OptionPane.windowBindings", new Object[] {
+//                "ESCAPE", "close" },
+//            "OptionPane.buttonClickThreshhold", new Integer(500),
+//            "OptionPane.isYesLast", Boolean.TRUE,
+//            "OptionPane.font", new FontLazyValue(Region.OPTION_PANE),
+//
+//            "Panel.font", new FontLazyValue(Region.PANEL),
+//
+//            "PasswordField.caretForeground", caretColor,
+//            "PasswordField.caretAspectRatio", defaultCaretAspectRatio,
+//            "PasswordField.caretBlinkRate", caretBlinkRate,
+//            "PasswordField.margin", zeroInsets,
+//            "PasswordField.focusInputMap", passwordInputMap,
+//            "PasswordField.font", new FontLazyValue(Region.PASSWORD_FIELD),
+//
+//
+//            "PopupMenu.consumeEventOnClose", Boolean.TRUE,
+//            "PopupMenu.selectedWindowInputMapBindings", new Object[] {
+//                  "ESCAPE", "cancel",
+//                    "DOWN", "selectNext",
+//                 "KP_DOWN", "selectNext",
+//                      "UP", "selectPrevious",
+//                   "KP_UP", "selectPrevious",
+//                    "LEFT", "selectParent",
+//                 "KP_LEFT", "selectParent",
+//                   "RIGHT", "selectChild",
+//                "KP_RIGHT", "selectChild",
+//                   "ENTER", "return",
+//                   "SPACE", "return"
+//            },
+//            "PopupMenu.selectedWindowInputMapBindings.RightToLeft",
+//                  new Object[] {
+//                    "LEFT", "selectChild",
+//                 "KP_LEFT", "selectChild",
+//                   "RIGHT", "selectParent",
+//                "KP_RIGHT", "selectParent",
+//            },
+//            "PopupMenu.font", new FontLazyValue(Region.POPUP_MENU),
+//
+//            "ProgressBar.horizontalSize",
+//                new DimensionUIResource(hProgWidth, hProgHeight),
+//            "ProgressBar.verticalSize",
+//                new DimensionUIResource(vProgWidth, vProgHeight),
+//            "ProgressBar.font", new FontLazyValue(Region.PROGRESS_BAR),
+//
+//            "RadioButton.focusInputMap",
+//                   new UIDefaults.LazyInputMap(new Object[] {
+//                            "SPACE", "pressed",
+//                   "released SPACE", "released",
+//                           "RETURN", "pressed"
+//                   }),
+//            "RadioButton.icon", new GTKStyle.GTKLazyValue(
+//                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
+//                              "getRadioButtonIcon"),
+//            "RadioButton.font", new FontLazyValue(Region.RADIO_BUTTON),
+//            "RadioButton.margin", zeroInsets,
+//
+//
+//            "RadioButtonMenuItem.arrowIcon", null,
+//            "RadioButtonMenuItem.checkIcon", new GTKStyle.GTKLazyValue(
+//                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
+//                              "getRadioButtonMenuItemCheckIcon"),
+//            "RadioButtonMenuItem.font", new FontLazyValue(Region.RADIO_BUTTON_MENU_ITEM),
+//            "RadioButtonMenuItem.margin", zeroInsets,
+//            "RadioButtonMenuItem.alignAcceleratorText", Boolean.FALSE,
+//
+//
+//            // These bindings are only enabled when there is a default
+//            // button set on the rootpane.
+//            "RootPane.defaultButtonWindowKeyBindings", new Object[] {
+//                               "ENTER", "press",
+//                      "released ENTER", "release",
+//                          "ctrl ENTER", "press",
+//                 "ctrl released ENTER", "release"
+//            },
+//
+//
+//            "ScrollBar.squareButtons", Boolean.FALSE,
+//            "ScrollBar.thumbHeight", Integer.valueOf(14),
+//            "ScrollBar.width", Integer.valueOf(16),
+//            "ScrollBar.minimumThumbSize", new Dimension(8, 8),
+//            "ScrollBar.maximumThumbSize", new Dimension(4096, 4096),
+//            "ScrollBar.allowsAbsolutePositioning", Boolean.TRUE,
+//            "ScrollBar.alwaysShowThumb", Boolean.TRUE,
+//            "ScrollBar.ancestorInputMap",
+//                   new UIDefaults.LazyInputMap(new Object[] {
+//                       "RIGHT", "positiveUnitIncrement",
+//                    "KP_RIGHT", "positiveUnitIncrement",
+//                        "DOWN", "positiveUnitIncrement",
+//                     "KP_DOWN", "positiveUnitIncrement",
+//                   "PAGE_DOWN", "positiveBlockIncrement",
+//                        "LEFT", "negativeUnitIncrement",
+//                     "KP_LEFT", "negativeUnitIncrement",
+//                          "UP", "negativeUnitIncrement",
+//                       "KP_UP", "negativeUnitIncrement",
+//                     "PAGE_UP", "negativeBlockIncrement",
+//                        "HOME", "minScroll",
+//                         "END", "maxScroll"
+//                   }),
+//            "ScrollBar.ancestorInputMap.RightToLeft",
+//                    new UIDefaults.LazyInputMap(new Object[] {
+//                       "RIGHT", "negativeUnitIncrement",
+//                    "KP_RIGHT", "negativeUnitIncrement",
+//                        "LEFT", "positiveUnitIncrement",
+//                     "KP_LEFT", "positiveUnitIncrement",
+//                    }),
+//
+//
+//            "Spinner.disableOnBoundaryValues", Boolean.TRUE,
+//
+//
+//            "ScrollPane.fillUpperCorner", Boolean.TRUE,
+//            "ScrollPane.fillLowerCorner", Boolean.TRUE,
+//            "ScrollPane.ancestorInputMap",
+//                    new UIDefaults.LazyInputMap(new Object[] {
+//                           "RIGHT", "unitScrollRight",
+//                        "KP_RIGHT", "unitScrollRight",
+//                            "DOWN", "unitScrollDown",
+//                         "KP_DOWN", "unitScrollDown",
+//                            "LEFT", "unitScrollLeft",
+//                         "KP_LEFT", "unitScrollLeft",
+//                              "UP", "unitScrollUp",
+//                           "KP_UP", "unitScrollUp",
+//                         "PAGE_UP", "scrollUp",
+//                       "PAGE_DOWN", "scrollDown",
+//                    "ctrl PAGE_UP", "scrollLeft",
+//                  "ctrl PAGE_DOWN", "scrollRight",
+//                       "ctrl HOME", "scrollHome",
+//                        "ctrl END", "scrollEnd"
+//                    }),
+//            "ScrollPane.ancestorInputMap.RightToLeft",
+//                    new UIDefaults.LazyInputMap(new Object[] {
+//                    "ctrl PAGE_UP", "scrollRight",
+//                  "ctrl PAGE_DOWN", "scrollLeft",
+//                    }),
+//            "ScrollPane.font", new FontLazyValue(Region.SCROLL_PANE),
+//
+//
+//            "Separator.insets", zeroInsets,
+//            "Separator.thickness", Integer.valueOf(2),
+//
+//
+//            "Slider.paintValue", Boolean.TRUE,
+//            "Slider.thumbWidth", Integer.valueOf(30),
+//            "Slider.thumbHeight", Integer.valueOf(14),
+//            "Slider.focusInputMap",
+//                    new UIDefaults.LazyInputMap(new Object[] {
+//                            "RIGHT", "positiveUnitIncrement",
+//                         "KP_RIGHT", "positiveUnitIncrement",
+//                             "DOWN", "negativeUnitIncrement",
+//                          "KP_DOWN", "negativeUnitIncrement",
+//                        "PAGE_DOWN", "negativeBlockIncrement",
+//                             "LEFT", "negativeUnitIncrement",
+//                          "KP_LEFT", "negativeUnitIncrement",
+//                               "UP", "positiveUnitIncrement",
+//                            "KP_UP", "positiveUnitIncrement",
+//                          "PAGE_UP", "positiveBlockIncrement",
+//                             "HOME", "minScroll",
+//                              "END", "maxScroll"
+//                        }),
+//            "Slider.focusInputMap.RightToLeft",
+//                    new UIDefaults.LazyInputMap(new Object[] {
+//                            "RIGHT", "negativeUnitIncrement",
+//                         "KP_RIGHT", "negativeUnitIncrement",
+//                             "LEFT", "positiveUnitIncrement",
+//                          "KP_LEFT", "positiveUnitIncrement",
+//                         }),
+//            "Slider.onlyLeftMouseButtonDrag", Boolean.FALSE,
+//
+//            "Spinner.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                               "UP", "increment",
+//                            "KP_UP", "increment",
+//                             "DOWN", "decrement",
+//                          "KP_DOWN", "decrement",
+//               }),
+//            "Spinner.font", new FontLazyValue(Region.SPINNER),
+//            "Spinner.editorAlignment", JTextField.LEADING,
+//
+//            "SplitPane.ancestorInputMap",
+//                    new UIDefaults.LazyInputMap(new Object[] {
+//                        "UP", "negativeIncrement",
+//                      "DOWN", "positiveIncrement",
+//                      "LEFT", "negativeIncrement",
+//                     "RIGHT", "positiveIncrement",
+//                     "KP_UP", "negativeIncrement",
+//                   "KP_DOWN", "positiveIncrement",
+//                   "KP_LEFT", "negativeIncrement",
+//                  "KP_RIGHT", "positiveIncrement",
+//                      "HOME", "selectMin",
+//                       "END", "selectMax",
+//                        "F8", "startResize",
+//                        "F6", "toggleFocus",
+//                  "ctrl TAB", "focusOutForward",
+//            "ctrl shift TAB", "focusOutBackward"
+//                    }),
+//
+//
+//            "SplitPane.size", Integer.valueOf(7),
+//            "SplitPane.oneTouchOffset", Integer.valueOf(2),
+//            "SplitPane.oneTouchButtonSize", Integer.valueOf(5),
+//            "SplitPane.supportsOneTouchButtons", Boolean.FALSE,
+//
+//
+//            "TabbedPane.focusInputMap",
+//              new UIDefaults.LazyInputMap(new Object[] {
+//                         "RIGHT", "navigateRight",
+//                      "KP_RIGHT", "navigateRight",
+//                          "LEFT", "navigateLeft",
+//                       "KP_LEFT", "navigateLeft",
+//                            "UP", "navigateUp",
+//                         "KP_UP", "navigateUp",
+//                          "DOWN", "navigateDown",
+//                       "KP_DOWN", "navigateDown",
+//                     "ctrl DOWN", "requestFocusForVisibleComponent",
+//                  "ctrl KP_DOWN", "requestFocusForVisibleComponent",
+//                         "SPACE", "selectTabWithFocus"
+//                }),
+//            "TabbedPane.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                         "ctrl TAB", "navigateNext",
+//                   "ctrl shift TAB", "navigatePrevious",
+//                   "ctrl PAGE_DOWN", "navigatePageDown",
+//                     "ctrl PAGE_UP", "navigatePageUp",
+//                          "ctrl UP", "requestFocus",
+//                       "ctrl KP_UP", "requestFocus",
+//                 }),
+//
+//            "TabbedPane.labelShift", 3,
+//            "TabbedPane.selectedLabelShift", 3,
+//            "TabbedPane.font", new FontLazyValue(Region.TABBED_PANE),
+//            "TabbedPane.selectedTabPadInsets", new InsetsUIResource(2, 2, 0, 1),
+//
+//            "Table.scrollPaneBorder", zeroBorder,
+//            "Table.background", tableBg,
+//            "Table.focusCellBackground", tableFocusCellBg,
+//            "Table.focusCellForeground", tableFocusCellFg,
+//            "Table.focusCellHighlightBorder", focusBorder,
+//            "Table.focusSelectedCellHighlightBorder", focusSelectedBorder,
+//            "Table.ancestorInputMap",
+//                    new UIDefaults.LazyInputMap(new Object[] {
+//                               "ctrl C", "copy",
+//                               "ctrl V", "paste",
+//                               "ctrl X", "cut",
+//                                 "COPY", "copy",
+//                                "PASTE", "paste",
+//                                  "CUT", "cut",
+//                       "control INSERT", "copy",
+//                         "shift INSERT", "paste",
+//                         "shift DELETE", "cut",
+//                                "RIGHT", "selectNextColumn",
+//                             "KP_RIGHT", "selectNextColumn",
+//                          "shift RIGHT", "selectNextColumnExtendSelection",
+//                       "shift KP_RIGHT", "selectNextColumnExtendSelection",
+//                     "ctrl shift RIGHT", "selectNextColumnExtendSelection",
+//                  "ctrl shift KP_RIGHT", "selectNextColumnExtendSelection",
+//                           "ctrl RIGHT", "selectNextColumnChangeLead",
+//                        "ctrl KP_RIGHT", "selectNextColumnChangeLead",
+//                                 "LEFT", "selectPreviousColumn",
+//                              "KP_LEFT", "selectPreviousColumn",
+//                           "shift LEFT", "selectPreviousColumnExtendSelection",
+//                        "shift KP_LEFT", "selectPreviousColumnExtendSelection",
+//                      "ctrl shift LEFT", "selectPreviousColumnExtendSelection",
+//                   "ctrl shift KP_LEFT", "selectPreviousColumnExtendSelection",
+//                            "ctrl LEFT", "selectPreviousColumnChangeLead",
+//                         "ctrl KP_LEFT", "selectPreviousColumnChangeLead",
+//                                 "DOWN", "selectNextRow",
+//                              "KP_DOWN", "selectNextRow",
+//                           "shift DOWN", "selectNextRowExtendSelection",
+//                        "shift KP_DOWN", "selectNextRowExtendSelection",
+//                      "ctrl shift DOWN", "selectNextRowExtendSelection",
+//                   "ctrl shift KP_DOWN", "selectNextRowExtendSelection",
+//                            "ctrl DOWN", "selectNextRowChangeLead",
+//                         "ctrl KP_DOWN", "selectNextRowChangeLead",
+//                                   "UP", "selectPreviousRow",
+//                                "KP_UP", "selectPreviousRow",
+//                             "shift UP", "selectPreviousRowExtendSelection",
+//                          "shift KP_UP", "selectPreviousRowExtendSelection",
+//                        "ctrl shift UP", "selectPreviousRowExtendSelection",
+//                     "ctrl shift KP_UP", "selectPreviousRowExtendSelection",
+//                              "ctrl UP", "selectPreviousRowChangeLead",
+//                           "ctrl KP_UP", "selectPreviousRowChangeLead",
+//                                 "HOME", "selectFirstColumn",
+//                           "shift HOME", "selectFirstColumnExtendSelection",
+//                      "ctrl shift HOME", "selectFirstRowExtendSelection",
+//                            "ctrl HOME", "selectFirstRow",
+//                                  "END", "selectLastColumn",
+//                            "shift END", "selectLastColumnExtendSelection",
+//                       "ctrl shift END", "selectLastRowExtendSelection",
+//                             "ctrl END", "selectLastRow",
+//                              "PAGE_UP", "scrollUpChangeSelection",
+//                        "shift PAGE_UP", "scrollUpExtendSelection",
+//                   "ctrl shift PAGE_UP", "scrollLeftExtendSelection",
+//                         "ctrl PAGE_UP", "scrollLeftChangeSelection",
+//                            "PAGE_DOWN", "scrollDownChangeSelection",
+//                      "shift PAGE_DOWN", "scrollDownExtendSelection",
+//                 "ctrl shift PAGE_DOWN", "scrollRightExtendSelection",
+//                       "ctrl PAGE_DOWN", "scrollRightChangeSelection",
+//                                  "TAB", "selectNextColumnCell",
+//                            "shift TAB", "selectPreviousColumnCell",
+//                                "ENTER", "selectNextRowCell",
+//                          "shift ENTER", "selectPreviousRowCell",
+//                               "ctrl A", "selectAll",
+//                           "ctrl SLASH", "selectAll",
+//                      "ctrl BACK_SLASH", "clearSelection",
+//                               "ESCAPE", "cancel",
+//                                   "F2", "startEditing",
+//                                "SPACE", "addToSelection",
+//                           "ctrl SPACE", "toggleAndAnchor",
+//                          "shift SPACE", "extendTo",
+//                     "ctrl shift SPACE", "moveSelectionTo",
+//                                   "F8", "focusHeader"
+//                    }),
+//            "Table.ancestorInputMap.RightToLeft",
+//                    new UIDefaults.LazyInputMap(new Object[] {
+//                                "RIGHT", "selectPreviousColumn",
+//                             "KP_RIGHT", "selectPreviousColumn",
+//                          "shift RIGHT", "selectPreviousColumnExtendSelection",
+//                       "shift KP_RIGHT", "selectPreviousColumnExtendSelection",
+//                     "ctrl shift RIGHT", "selectPreviousColumnExtendSelection",
+//                  "ctrl shift KP_RIGHT", "selectPreviousColumnExtendSelection",
+//                          "shift RIGHT", "selectPreviousColumnChangeLead",
+//                       "shift KP_RIGHT", "selectPreviousColumnChangeLead",
+//                                 "LEFT", "selectNextColumn",
+//                              "KP_LEFT", "selectNextColumn",
+//                           "shift LEFT", "selectNextColumnExtendSelection",
+//                        "shift KP_LEFT", "selectNextColumnExtendSelection",
+//                      "ctrl shift LEFT", "selectNextColumnExtendSelection",
+//                   "ctrl shift KP_LEFT", "selectNextColumnExtendSelection",
+//                            "ctrl LEFT", "selectNextColumnChangeLead",
+//                         "ctrl KP_LEFT", "selectNextColumnChangeLead",
+//                         "ctrl PAGE_UP", "scrollRightChangeSelection",
+//                       "ctrl PAGE_DOWN", "scrollLeftChangeSelection",
+//                   "ctrl shift PAGE_UP", "scrollRightExtendSelection",
+//                 "ctrl shift PAGE_DOWN", "scrollLeftExtendSelection",
+//                    }),
+//            "Table.font", new FontLazyValue(Region.TABLE),
+//            "Table.ascendingSortIcon",  new GTKStyle.GTKLazyValue(
+//                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
+//                              "getAscendingSortIcon"),
+//            "Table.descendingSortIcon",  new GTKStyle.GTKLazyValue(
+//                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
+//                              "getDescendingSortIcon"),
+//
+//            "TableHeader.font", new FontLazyValue(Region.TABLE_HEADER),
+//            "TableHeader.alignSorterArrow", Boolean.TRUE,
+//
+//            "TextArea.caretForeground", caretColor,
+//            "TextArea.caretAspectRatio", defaultCaretAspectRatio,
+//            "TextArea.caretBlinkRate", caretBlinkRate,
+//            "TextArea.margin", zeroInsets,
+//            "TextArea.focusInputMap", multilineInputMap,
+//            "TextArea.font", new FontLazyValue(Region.TEXT_AREA),
+//
+//
+//            "TextField.caretForeground", caretColor,
+//            "TextField.caretAspectRatio", defaultCaretAspectRatio,
+//            "TextField.caretBlinkRate", caretBlinkRate,
+//            "TextField.margin", zeroInsets,
+//            "TextField.focusInputMap", fieldInputMap,
+//            "TextField.font", new FontLazyValue(Region.TEXT_FIELD),
+//
+//
+//            "TextPane.caretForeground", caretColor,
+//            "TextPane.caretAspectRatio", defaultCaretAspectRatio,
+//            "TextPane.caretBlinkRate", caretBlinkRate,
+//            "TextPane.margin", editorMargin,
+//            "TextPane.focusInputMap", multilineInputMap,
+//            "TextPane.font", new FontLazyValue(Region.TEXT_PANE),
+//
+//
+//            "TitledBorder.titleColor", controlText,
+//            "TitledBorder.border", new UIDefaults.LazyValue() {
+//                public Object createValue(UIDefaults table) {
+//                    return new GTKPainter.TitledBorder();
+//                }
+//            },
+//
+//            "ToggleButton.focusInputMap",
+//                   new UIDefaults.LazyInputMap(new Object[] {
+//                            "SPACE", "pressed",
+//                   "released SPACE", "released"
+//                   }),
+//            "ToggleButton.font", new FontLazyValue(Region.TOGGLE_BUTTON),
+//            "ToggleButton.margin", zeroInsets,
+//
+//
+//            "ToolBar.separatorSize", new DimensionUIResource(10, 10),
+//            "ToolBar.handleIcon", new UIDefaults.ActiveValue() {
+//                public Object createValue(UIDefaults table) {
+//                    return GTKIconFactory.getToolBarHandleIcon();
+//                }
+//            },
+//            "ToolBar.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                        "UP", "navigateUp",
+//                     "KP_UP", "navigateUp",
+//                      "DOWN", "navigateDown",
+//                   "KP_DOWN", "navigateDown",
+//                      "LEFT", "navigateLeft",
+//                   "KP_LEFT", "navigateLeft",
+//                     "RIGHT", "navigateRight",
+//                  "KP_RIGHT", "navigateRight"
+//                 }),
+//            "ToolBar.font", new FontLazyValue(Region.TOOL_BAR),
+//
+//            "ToolTip.font", new FontLazyValue(Region.TOOL_TIP),
+//
+//            "Tree.padding", Integer.valueOf(4),
+//            "Tree.background", tableBg,
+//            "Tree.drawHorizontalLines", Boolean.FALSE,
+//            "Tree.drawVerticalLines", Boolean.FALSE,
+//            "Tree.rowHeight", Integer.valueOf(-1),
+//            "Tree.scrollsOnExpand", Boolean.FALSE,
+//            "Tree.expanderSize", Integer.valueOf(10),
+//            "Tree.repaintWholeRow", Boolean.TRUE,
+//            "Tree.closedIcon", null,
+//            "Tree.leafIcon", null,
+//            "Tree.openIcon", null,
+//            "Tree.expandedIcon", new GTKStyle.GTKLazyValue(
+//                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
+//                              "getTreeExpandedIcon"),
+//            "Tree.collapsedIcon", new GTKStyle.GTKLazyValue(
+//                              "com.sun.java.swing.plaf.gtk.GTKIconFactory",
+//                              "getTreeCollapsedIcon"),
+//            "Tree.leftChildIndent", Integer.valueOf(2),
+//            "Tree.rightChildIndent", Integer.valueOf(12),
+//            "Tree.scrollsHorizontallyAndVertically", Boolean.FALSE,
+//            "Tree.drawsFocusBorder", Boolean.TRUE,
+//            "Tree.focusInputMap",
+//                    new UIDefaults.LazyInputMap(new Object[] {
+//                                 "ctrl C", "copy",
+//                                 "ctrl V", "paste",
+//                                 "ctrl X", "cut",
+//                                   "COPY", "copy",
+//                                  "PASTE", "paste",
+//                                    "CUT", "cut",
+//                         "control INSERT", "copy",
+//                           "shift INSERT", "paste",
+//                           "shift DELETE", "cut",
+//                                     "UP", "selectPrevious",
+//                                  "KP_UP", "selectPrevious",
+//                               "shift UP", "selectPreviousExtendSelection",
+//                            "shift KP_UP", "selectPreviousExtendSelection",
+//                          "ctrl shift UP", "selectPreviousExtendSelection",
+//                       "ctrl shift KP_UP", "selectPreviousExtendSelection",
+//                                "ctrl UP", "selectPreviousChangeLead",
+//                             "ctrl KP_UP", "selectPreviousChangeLead",
+//                                   "DOWN", "selectNext",
+//                                "KP_DOWN", "selectNext",
+//                             "shift DOWN", "selectNextExtendSelection",
+//                          "shift KP_DOWN", "selectNextExtendSelection",
+//                        "ctrl shift DOWN", "selectNextExtendSelection",
+//                     "ctrl shift KP_DOWN", "selectNextExtendSelection",
+//                              "ctrl DOWN", "selectNextChangeLead",
+//                           "ctrl KP_DOWN", "selectNextChangeLead",
+//                                  "RIGHT", "selectChild",
+//                               "KP_RIGHT", "selectChild",
+//                                   "LEFT", "selectParent",
+//                                "KP_LEFT", "selectParent",
+//                                "typed +", "expand",
+//                                "typed -", "collapse",
+//                             "BACK_SPACE", "moveSelectionToParent",
+//                                "PAGE_UP", "scrollUpChangeSelection",
+//                          "shift PAGE_UP", "scrollUpExtendSelection",
+//                     "ctrl shift PAGE_UP", "scrollUpExtendSelection",
+//                           "ctrl PAGE_UP", "scrollUpChangeLead",
+//                              "PAGE_DOWN", "scrollDownChangeSelection",
+//                        "shift PAGE_DOWN", "scrollDownExtendSelection",
+//                   "ctrl shift PAGE_DOWN", "scrollDownExtendSelection",
+//                         "ctrl PAGE_DOWN", "scrollDownChangeLead",
+//                                   "HOME", "selectFirst",
+//                             "shift HOME", "selectFirstExtendSelection",
+//                        "ctrl shift HOME", "selectFirstExtendSelection",
+//                              "ctrl HOME", "selectFirstChangeLead",
+//                                    "END", "selectLast",
+//                              "shift END", "selectLastExtendSelection",
+//                         "ctrl shift END", "selectLastExtendSelection",
+//                               "ctrl END", "selectLastChangeLead",
+//                                     "F2", "startEditing",
+//                                 "ctrl A", "selectAll",
+//                             "ctrl SLASH", "selectAll",
+//                        "ctrl BACK_SLASH", "clearSelection",
+//                              "ctrl LEFT", "scrollLeft",
+//                           "ctrl KP_LEFT", "scrollLeft",
+//                             "ctrl RIGHT", "scrollRight",
+//                          "ctrl KP_RIGHT", "scrollRight",
+//                                  "SPACE", "addToSelection",
+//                             "ctrl SPACE", "toggleAndAnchor",
+//                            "shift SPACE", "extendTo",
+//                       "ctrl shift SPACE", "moveSelectionTo"
+//                    }),
+//            "Tree.focusInputMap.RightToLeft",
+//                    new UIDefaults.LazyInputMap(new Object[] {
+//                                  "RIGHT", "selectParent",
+//                               "KP_RIGHT", "selectParent",
+//                                   "LEFT", "selectChild",
+//                                "KP_LEFT", "selectChild",
+//                 }),
+//            "Tree.ancestorInputMap",
+//                      new UIDefaults.LazyInputMap(new Object[] {
+//                         "ESCAPE", "cancel"
+//                      }),
+//            "Tree.font", new FontLazyValue(Region.TREE),
+//
+//            "Viewport.font", new FontLazyValue(Region.VIEWPORT)
+//        };
+//        table.putDefaults(defaults);
+//
+//        if (fallbackFont != null) {
+//            table.put("TitledBorder.font", fallbackFont);
+//        }
+//        table.put(SwingUtilities2.AA_TEXT_PROPERTY_KEY, aaTextInfo);
+//    }
+
+    protected void initSystemColorDefaults(UIDefaults table) {throw new RuntimeException("cf-bug");} //{
+//        GTKStyleFactory factory = (GTKStyleFactory)getStyleFactory();
+//        GTKStyle windowStyle =
+//                (GTKStyle)factory.getStyle(null, Region.INTERNAL_FRAME);
+//        table.put("window", windowStyle.getGTKColor(SynthConstants.ENABLED,
+//                GTKColorType.BACKGROUND));
+//        table.put("windowText", windowStyle.getGTKColor(SynthConstants.ENABLED,
+//                GTKColorType.TEXT_FOREGROUND));
+//
+//        GTKStyle entryStyle = (GTKStyle)factory.getStyle(null, Region.TEXT_FIELD);
+//        table.put("text", entryStyle.getGTKColor(SynthConstants.ENABLED,
+//                                           GTKColorType.TEXT_BACKGROUND));
+//        table.put("textText", entryStyle.getGTKColor(SynthConstants.ENABLED,
+//                                           GTKColorType.TEXT_FOREGROUND));
+//        table.put("textHighlight",
+//                entryStyle.getGTKColor(SynthConstants.SELECTED,
+//                                         GTKColorType.TEXT_BACKGROUND));
+//        table.put("textHighlightText",
+//                  entryStyle.getGTKColor(SynthConstants.SELECTED,
+//                                         GTKColorType.TEXT_FOREGROUND));
+//        table.put("textInactiveText",
+//                  entryStyle.getGTKColor(SynthConstants.DISABLED,
+//                                         GTKColorType.TEXT_FOREGROUND));
+//        Object caretColor =
+//            entryStyle.getClassSpecificValue("cursor-color");
+//        if (caretColor == null) {
+//            caretColor = GTKStyle.BLACK_COLOR;
+//        }
+//        table.put("caretColor", caretColor);
+//
+//        GTKStyle menuStyle = (GTKStyle)factory.getStyle(null, Region.MENU_ITEM);
+//        table.put("menu", menuStyle.getGTKColor(SynthConstants.ENABLED,
+//                                           GTKColorType.BACKGROUND));
+//        table.put("menuText", menuStyle.getGTKColor(SynthConstants.ENABLED,
+//                                           GTKColorType.TEXT_FOREGROUND));
+//
+//        GTKStyle scrollbarStyle = (GTKStyle)factory.getStyle(null, Region.SCROLL_BAR);
+//        table.put("scrollbar", scrollbarStyle.getGTKColor(SynthConstants.ENABLED,
+//                                           GTKColorType.BACKGROUND));
+//
+//        GTKStyle infoStyle = (GTKStyle)factory.getStyle(null, Region.OPTION_PANE);
+//        table.put("info", infoStyle.getGTKColor(SynthConstants.ENABLED,
+//                                           GTKColorType.BACKGROUND));
+//        table.put("infoText", infoStyle.getGTKColor(SynthConstants.ENABLED,
+//                                           GTKColorType.TEXT_FOREGROUND));
+//
+//        GTKStyle desktopStyle = (GTKStyle)factory.getStyle(null, Region.DESKTOP_PANE);
+//        table.put("desktop", desktopStyle.getGTKColor(SynthConstants.ENABLED,
+//                                           GTKColorType.BACKGROUND));
+//
+//        // colors specific only for GTK
+//        // It is impossible to create a simple GtkWidget without specifying the
+//        // type. So for GtkWidget we can use any appropriate concrete type of
+//        // wigdet. LABEL in this case.
+//        GTKStyle widgetStyle = (GTKStyle)factory.getStyle(null, Region.LABEL);
+//        Color bg = widgetStyle.getGTKColor(SynthConstants.ENABLED,
+//                                           GTKColorType.BACKGROUND);
+//        table.put("control", bg);
+//        table.put("controlHighlight", bg);
+//        table.put("controlText", widgetStyle.getGTKColor(SynthConstants.ENABLED,
+//                                               GTKColorType.TEXT_FOREGROUND));
+//        table.put("controlLtHighlight", widgetStyle.getGTKColor(
+//                SynthConstants.ENABLED, GTKColorType.LIGHT));
+//        table.put("controlShadow", widgetStyle.getGTKColor(
+//                SynthConstants.ENABLED, GTKColorType.DARK));
+//        table.put("controlDkShadow", widgetStyle.getGTKColor(
+//                SynthConstants.ENABLED, GTKColorType.BLACK));
+//        table.put("light", widgetStyle.getGTKColor(
+//                SynthConstants.ENABLED, GTKColorType.LIGHT));
+//        table.put("mid", widgetStyle.getGTKColor(
+//                SynthConstants.ENABLED, GTKColorType.MID));
+//        table.put("dark", widgetStyle.getGTKColor(
+//                SynthConstants.ENABLED, GTKColorType.DARK));
+//        table.put("black", widgetStyle.getGTKColor(
+//                SynthConstants.ENABLED, GTKColorType.BLACK));
+//        table.put("white", widgetStyle.getGTKColor(
+//                SynthConstants.ENABLED, GTKColorType.WHITE));
+//    }
 
     /**
      * Creates the GTK look and feel class for the passed in Component.
      */
-    public static ComponentUI createUI(JComponent c) {
-        String key = c.getUIClassID().intern();
-
-        if (key == "FileChooserUI") {
-            return GTKFileChooserUI.createUI(c);
-        }
-        return SynthLookAndFeel.createUI(c);
-    }
+    public static ComponentUI createUI(JComponent c) {throw new RuntimeException("cf-bug");} //{
+//        String key = c.getUIClassID().intern();
+//
+//        if (key == "FileChooserUI") {
+//            return GTKFileChooserUI.createUI(c);
+//        }
+//        return SynthLookAndFeel.createUI(c);
+//    }
 
     /**
      * Returns the cached gtkThemeName
      */
-    static String getGtkThemeName() {
-        return gtkThemeName;
-    }
-
-    static boolean isLeftToRight(Component c) {
-        return c.getComponentOrientation().isLeftToRight();
-    }
-
-    public void initialize() {
-        /*
-         * We need to call loadGTK() to ensure that the native GTK
-         * libraries are loaded.  It is very unlikely that this call will
-         * fail (since we've already verified native GTK support in
-         * isSupportedLookAndFeel()), but we can throw an error in the
-         * failure situation just in case.
-         */
-        Toolkit toolkit = Toolkit.getDefaultToolkit();
-        if (toolkit instanceof UNIXToolkit &&
-            !((UNIXToolkit)toolkit).loadGTK())
-        {
-            throw new InternalError("Unable to load native GTK libraries");
-        }
-
-        super.initialize();
-        inInitialize = true;
-        loadStyles();
-        inInitialize = false;
-
-        /*
-         * Check if system AA font settings should be used.
-         * Sun's JDS (for Linux and Solaris) ships with high quality CJK
-         * fonts and specifies via fontconfig that these be rendered in
-         * B&W to take advantage of the embedded bitmaps.
-         * If is a Sun CJK locale or remote display, indicate by the condition
-         * variable that in this case the L&F recommends ignoring desktop
-         * settings. On other Unixes (eg Linux) this doesn't apply.
-         * REMIND 1: The isSunCJK test is really just a place holder
-         * until we can properly query fontconfig and use the properties
-         * set for specific fonts.
-         * REMIND 2: See comment on isLocalDisplay() definition regarding
-         * XRender.
-         */
-        gtkAAFontSettingsCond = !isSunCJK && SwingUtilities2.isLocalDisplay();
-        aaTextInfo = SwingUtilities2.AATextInfo.getAATextInfo(gtkAAFontSettingsCond);
-    }
+    static String getGtkThemeName() {throw new RuntimeException("cf-bug");} //{
+//        return gtkThemeName;
+//    }
+
+    static boolean isLeftToRight(Component c) {throw new RuntimeException("cf-bug");} //{
+//        return c.getComponentOrientation().isLeftToRight();
+//    }
+
+    public void initialize() {throw new RuntimeException("cf-bug");} //{
+//        /*
+//         * We need to call loadGTK() to ensure that the native GTK
+//         * libraries are loaded.  It is very unlikely that this call will
+//         * fail (since we've already verified native GTK support in
+//         * isSupportedLookAndFeel()), but we can throw an error in the
+//         * failure situation just in case.
+//         */
+//        Toolkit toolkit = Toolkit.getDefaultToolkit();
+//        if (toolkit instanceof UNIXToolkit &&
+//            !((UNIXToolkit)toolkit).loadGTK())
+//        {
+//            throw new InternalError("Unable to load native GTK libraries");
+//        }
+//
+//        super.initialize();
+//        inInitialize = true;
+//        loadStyles();
+//        inInitialize = false;
+//
+//        /*
+//         * Check if system AA font settings should be used.
+//         * Sun's JDS (for Linux and Solaris) ships with high quality CJK
+//         * fonts and specifies via fontconfig that these be rendered in
+//         * B&W to take advantage of the embedded bitmaps.
+//         * If is a Sun CJK locale or remote display, indicate by the condition
+//         * variable that in this case the L&F recommends ignoring desktop
+//         * settings. On other Unixes (eg Linux) this doesn't apply.
+//         * REMIND 1: The isSunCJK test is really just a place holder
+//         * until we can properly query fontconfig and use the properties
+//         * set for specific fonts.
+//         * REMIND 2: See comment on isLocalDisplay() definition regarding
+//         * XRender.
+//         */
+//        gtkAAFontSettingsCond = !isSunCJK && SwingUtilities2.isLocalDisplay();
+//        aaTextInfo = SwingUtilities2.AATextInfo.getAATextInfo(gtkAAFontSettingsCond);
+//    }
 
     static ReferenceQueue<GTKLookAndFeel> queue = new ReferenceQueue<GTKLookAndFeel>();
 
-    private static void flushUnreferenced() {
-        WeakPCL pcl;
-
-        while ((pcl = (WeakPCL)queue.poll()) != null) {
-            pcl.dispose();
-        }
-    }
+    private static void flushUnreferenced() {throw new RuntimeException("cf-bug");} //{
+//        WeakPCL pcl;
+//
+//        while ((pcl = (WeakPCL)queue.poll()) != null) {
+//            pcl.dispose();
+//        }
+//    }
 
     static class WeakPCL extends WeakReference<GTKLookAndFeel> implements
             PropertyChangeListener {
@@ -1491,169 +1491,169 @@
             this.key = key;
         }
 
-        public String getKey() { return key; }
-
-        public void propertyChange(final PropertyChangeEvent pce) {
-            final GTKLookAndFeel lnf = get();
+        public String getKey() {throw new RuntimeException("cf-bug");} //{ return key; }
 
-            if (lnf == null || UIManager.getLookAndFeel() != lnf) {
-                // The property was GC'ed, we're no longer interested in
-                // PropertyChanges, remove the listener.
-                dispose();
-            }
-            else {
-                // We are using invokeLater here because we are getting called
-                // on the AWT-Motif thread which can cause a deadlock.
-                SwingUtilities.invokeLater(new Runnable() {
-                    public void run() {
-                        String name = pce.getPropertyName();
-                        /* We are listening for GTK desktop text AA settings:
-                         * "gnome.Xft/Antialias" and "gnome.Xft/RGBA".
-                         * However we don't need to read these here as
-                         * the UIDefaults reads them and this event causes
-                         * those to be reinitialised.
-                         */
-                        if ("gnome.Net/ThemeName".equals(name)) {
-                            GTKEngine.INSTANCE.themeChanged();
-                            GTKIconFactory.resetIcons();
-                        }
-                        lnf.loadStyles();
-                        Window appWindows[] = Window.getWindows();
-                        for (int i = 0; i < appWindows.length; i++) {
-                            SynthLookAndFeel.updateStyles(appWindows[i]);
-                        }
-                    }
-                });
-            }
-        }
-
-        void dispose() {
-            kit.removePropertyChangeListener(key, this);
-        }
-    }
-
-    public boolean isSupportedLookAndFeel() {
-        Toolkit toolkit = Toolkit.getDefaultToolkit();
-        return (toolkit instanceof SunToolkit &&
-                ((SunToolkit)toolkit).isNativeGTKAvailable());
-    }
-
-    public boolean isNativeLookAndFeel() {
-        return true;
-    }
-
-    public String getDescription() {
-        return "GTK look and feel";
-    }
-
-    public String getName() {
-        return "GTK look and feel";
-    }
-
-    public String getID() {
-        return "GTK";
-    }
+        public void propertyChange(final PropertyChangeEvent pce) {throw new RuntimeException("cf-bug");} //{
+//            final GTKLookAndFeel lnf = get();
+//
+//            if (lnf == null || UIManager.getLookAndFeel() != lnf) {
+//                // The property was GC'ed, we're no longer interested in
+//                // PropertyChanges, remove the listener.
+//                dispose();
+//            }
+//            else {
+//                // We are using invokeLater here because we are getting called
+//                // on the AWT-Motif thread which can cause a deadlock.
+//                SwingUtilities.invokeLater(new Runnable() {
+//                    public void run() {
+//                        String name = pce.getPropertyName();
+//                        /* We are listening for GTK desktop text AA settings:
+//                         * "gnome.Xft/Antialias" and "gnome.Xft/RGBA".
+//                         * However we don't need to read these here as
+//                         * the UIDefaults reads them and this event causes
+//                         * those to be reinitialised.
+//                         */
+//                        if ("gnome.Net/ThemeName".equals(name)) {
+//                            GTKEngine.INSTANCE.themeChanged();
+//                            GTKIconFactory.resetIcons();
+//                        }
+//                        lnf.loadStyles();
+//                        Window appWindows[] = Window.getWindows();
+//                        for (int i = 0; i < appWindows.length; i++) {
+//                            SynthLookAndFeel.updateStyles(appWindows[i]);
+//                        }
+//                    }
+//                });
+//            }
+//        }
+
+        void dispose() {throw new RuntimeException("cf-bug");} //{
+//            kit.removePropertyChangeListener(key, this);
+//        }
+    }
+
+    public boolean isSupportedLookAndFeel() {throw new RuntimeException("cf-bug");} //{
+//        Toolkit toolkit = Toolkit.getDefaultToolkit();
+//        return (toolkit instanceof SunToolkit &&
+//                ((SunToolkit)toolkit).isNativeGTKAvailable());
+//    }
+
+    public boolean isNativeLookAndFeel() {throw new RuntimeException("cf-bug");} //{
+//        return true;
+//    }
+
+    public String getDescription() {throw new RuntimeException("cf-bug");} //{
+//        return "GTK look and feel";
+//    }
+
+    public String getName() {throw new RuntimeException("cf-bug");} //{
+//        return "GTK look and feel";
+//    }
+
+    public String getID() {throw new RuntimeException("cf-bug");} //{
+//        return "GTK";
+//    }
 
     // Subclassed to pass in false to the superclass, we don't want to try
     // and load the system colors.
-    protected void loadSystemColors(UIDefaults table, String[] systemColors, boolean useNative) {
-        super.loadSystemColors(table, systemColors, false);
-    }
-
-    private void loadStyles() {
-        gtkThemeName = (String)Toolkit.getDefaultToolkit().
-                getDesktopProperty("gnome.Net/ThemeName");
-
-        setStyleFactory(getGTKStyleFactory());
-
-        // If we are in initialize initializations will be
-        // called later, don't do it now.
-        if (!inInitialize) {
-            UIDefaults table = UIManager.getLookAndFeelDefaults();
-            initSystemColorDefaults(table);
-            initComponentDefaults(table);
-        }
-    }
-
-    private GTKStyleFactory getGTKStyleFactory() {
-
-        GTKEngine engine = GTKEngine.INSTANCE;
-        Object iconSizes = engine.getSetting(GTKEngine.Settings.GTK_ICON_SIZES);
-        if (iconSizes instanceof String) {
-            if (!configIconSizes((String)iconSizes)) {
-                System.err.println("Error parsing gtk-icon-sizes string: '" + iconSizes + "'");
-            }
-        }
-
-        // Desktop property appears to have preference over rc font.
-        Object fontName = Toolkit.getDefaultToolkit().getDesktopProperty(
-                                  "gnome.Gtk/FontName");
-
-       if (!(fontName instanceof String)) {
-            fontName = engine.getSetting(GTKEngine.Settings.GTK_FONT_NAME);
-            if (!(fontName instanceof String)) {
-               fontName = "sans 10";
-            }
-        }
-
-        if (styleFactory == null) {
-            styleFactory = new GTKStyleFactory();
-        }
-
-        Font defaultFont = PangoFonts.lookupFont((String)fontName);
-        fallbackFont = defaultFont;
-        styleFactory.initStyles(defaultFont);
-
-        return styleFactory;
-    }
-
-    private boolean configIconSizes(String sizeString) {
-        String[] sizes = sizeString.split(":");
-        for (int i = 0; i < sizes.length; i++) {
-            String[] splits = sizes[i].split("=");
-
-            if (splits.length != 2) {
-                return false;
-            }
-
-            String size = splits[0].trim().intern();
-            if (size.length() < 1) {
-                return false;
-            }
-
-            splits = splits[1].split(",");
-
-            if (splits.length != 2) {
-                return false;
-            }
-
-            String width = splits[0].trim();
-            String height = splits[1].trim();
-
-            if (width.length() < 1 || height.length() < 1) {
-                return false;
-            }
-
-            int w;
-            int h;
-
-            try {
-                w = Integer.parseInt(width);
-                h = Integer.parseInt(height);
-            } catch (NumberFormatException nfe) {
-                return false;
-            }
-
-            if (w > 0 && h > 0) {
-                int type = GTKStyle.GTKStockIconInfo.getIconType(size);
-                GTKStyle.GTKStockIconInfo.setIconSize(type, w, h);
-            } else {
-                System.err.println("Invalid size in gtk-icon-sizes: " + w + "," + h);
-            }
-        }
-
-        return true;
-    }
+    protected void loadSystemColors(UIDefaults table, String[] systemColors, boolean useNative) {throw new RuntimeException("cf-bug");} //{
+//        super.loadSystemColors(table, systemColors, false);
+//    }
+
+    private void loadStyles() {throw new RuntimeException("cf-bug");} //{
+//        gtkThemeName = (String)Toolkit.getDefaultToolkit().
+//                getDesktopProperty("gnome.Net/ThemeName");
+//
+//        setStyleFactory(getGTKStyleFactory());
+//
+//        // If we are in initialize initializations will be
+//        // called later, don't do it now.
+//        if (!inInitialize) {
+//            UIDefaults table = UIManager.getLookAndFeelDefaults();
+//            initSystemColorDefaults(table);
+//            initComponentDefaults(table);
+//        }
+//    }
+
+    private GTKStyleFactory getGTKStyleFactory() {throw new RuntimeException("cf-bug");} //{
+//
+//        GTKEngine engine = GTKEngine.INSTANCE;
+//        Object iconSizes = engine.getSetting(GTKEngine.Settings.GTK_ICON_SIZES);
+//        if (iconSizes instanceof String) {
+//            if (!configIconSizes((String)iconSizes)) {
+//                System.err.println("Error parsing gtk-icon-sizes string: '" + iconSizes + "'");
+//            }
+//        }
+//
+//        // Desktop property appears to have preference over rc font.
+//        Object fontName = Toolkit.getDefaultToolkit().getDesktopProperty(
+//                                  "gnome.Gtk/FontName");
+//
+//       if (!(fontName instanceof String)) {
+//            fontName = engine.getSetting(GTKEngine.Settings.GTK_FONT_NAME);
+//            if (!(fontName instanceof String)) {
+//               fontName = "sans 10";
+//            }
+//        }
+//
+//        if (styleFactory == null) {
+//            styleFactory = new GTKStyleFactory();
+//        }
+//
+//        Font defaultFont = PangoFonts.lookupFont((String)fontName);
+//        fallbackFont = defaultFont;
+//        styleFactory.initStyles(defaultFont);
+//
+//        return styleFactory;
+//    }
+
+    private boolean configIconSizes(String sizeString) {throw new RuntimeException("cf-bug");} //{
+//        String[] sizes = sizeString.split(":");
+//        for (int i = 0; i < sizes.length; i++) {
+//            String[] splits = sizes[i].split("=");
+//
+//            if (splits.length != 2) {
+//                return false;
+//            }
+//
+//            String size = splits[0].trim().intern();
+//            if (size.length() < 1) {
+//                return false;
+//            }
+//
+//            splits = splits[1].split(",");
+//
+//            if (splits.length != 2) {
+//                return false;
+//            }
+//
+//            String width = splits[0].trim();
+//            String height = splits[1].trim();
+//
+//            if (width.length() < 1 || height.length() < 1) {
+//                return false;
+//            }
+//
+//            int w;
+//            int h;
+//
+//            try {
+//                w = Integer.parseInt(width);
+//                h = Integer.parseInt(height);
+//            } catch (NumberFormatException nfe) {
+//                return false;
+//            }
+//
+//            if (w > 0 && h > 0) {
+//                int type = GTKStyle.GTKStockIconInfo.getIconType(size);
+//                GTKStyle.GTKStockIconInfo.setIconSize(type, w, h);
+//            } else {
+//                System.err.println("Invalid size in gtk-icon-sizes: " + w + "," + h);
+//            }
+//        }
+//
+//        return true;
+//    }
 
     /**
      * Returns whether or not the UIs should update their
@@ -1664,16 +1664,16 @@
      * <code>SynthStyles</code> from the <code>SynthStyleFactory</code>
      * when the ancestor changed.
      */
-    public boolean shouldUpdateStyleOnAncestorChanged() {
-        return true;
-    }
+    public boolean shouldUpdateStyleOnAncestorChanged() {throw new RuntimeException("cf-bug");} //{
+//        return true;
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public LayoutStyle getLayoutStyle() {
-        return GnomeLayoutStyle.INSTANCE;
-    }
+    public LayoutStyle getLayoutStyle() {throw new RuntimeException("cf-bug");} //{
+//        return GnomeLayoutStyle.INSTANCE;
+//    }
 
 
     /**
@@ -1689,51 +1689,51 @@
         @Override
         public int getPreferredGap(JComponent component1,
                 JComponent component2, ComponentPlacement type, int position,
-                Container parent) {
-            // Checks args
-            super.getPreferredGap(component1, component2, type, position,
-                                  parent);
-
-            switch(type) {
-            case INDENT:
-                if (position == SwingConstants.EAST ||
-                        position == SwingConstants.WEST) {
-                    // Indent group members 12 pixels to denote hierarchy and
-                    // association.
-                    return 12;
-                }
-                // Fall through to related
-            // As a basic rule of thumb, leave space between user
-            // interface components in increments of 6 pixels, going up as
-            // the relationship between related elements becomes more
-            // distant. For example, between icon labels and associated
-            // graphics within an icon, 6 pixels are adequate. Between
-            // labels and associated components, leave 12 horizontal
-            // pixels. For vertical spacing between groups of components,
-            // 18 pixels is adequate.
-            //
-            // The first part of this is handled automatically by Icon (which
-            // won't give you 6 pixels).
-            case RELATED:
-                if (isLabelAndNonlabel(component1, component2, position)) {
-                    return 12;
-                }
-                return 6;
-            case UNRELATED:
-                return 12;
-            }
-            return 0;
-        }
+                Container parent) {throw new RuntimeException("cf-bug");} //{
+//            // Checks args
+//            super.getPreferredGap(component1, component2, type, position,
+//                                  parent);
+//
+//            switch(type) {
+//            case INDENT:
+//                if (position == SwingConstants.EAST ||
+//                        position == SwingConstants.WEST) {
+//                    // Indent group members 12 pixels to denote hierarchy and
+//                    // association.
+//                    return 12;
+//                }
+//                // Fall through to related
+//            // As a basic rule of thumb, leave space between user
+//            // interface components in increments of 6 pixels, going up as
+//            // the relationship between related elements becomes more
+//            // distant. For example, between icon labels and associated
+//            // graphics within an icon, 6 pixels are adequate. Between
+//            // labels and associated components, leave 12 horizontal
+//            // pixels. For vertical spacing between groups of components,
+//            // 18 pixels is adequate.
+//            //
+//            // The first part of this is handled automatically by Icon (which
+//            // won't give you 6 pixels).
+//            case RELATED:
+//                if (isLabelAndNonlabel(component1, component2, position)) {
+//                    return 12;
+//                }
+//                return 6;
+//            case UNRELATED:
+//                return 12;
+//            }
+//            return 0;
+//        }
 
         @Override
         public int getContainerGap(JComponent component, int position,
-                                   Container parent) {
-            // Checks args
-            super.getContainerGap(component, position, parent);
-            // A general padding of 12 pixels is
-            // recommended between the contents of a dialog window and the
-            // window borders.
-            return 12;
-        }
+                                   Container parent) {throw new RuntimeException("cf-bug");} //{
+//            // Checks args
+//            super.getContainerGap(component, position, parent);
+//            // A general padding of 12 pixels is
+//            // recommended between the contents of a dialog window and the
+//            // window borders.
+//            return 12;
+//        }
     }
 }
--- a/com/sun/java/swing/plaf/motif/MotifGraphicsUtils.java	2016-06-22 19:54:41.600702285 -0700
+++ b/com/sun/java/swing/plaf/motif/MotifGraphicsUtils.java	2016-06-29 10:59:54.921740727 -0700
@@ -54,9 +54,9 @@
     /**
      * Draws the point (<b>x</b>, <b>y</b>) in the current color.
      */
-    static void drawPoint(Graphics g, int x, int y) {
-        g.drawLine(x, y, x, y);
-    }
+    static void drawPoint(Graphics g, int x, int y) {throw new RuntimeException("cf-bug");} //{
+//        g.drawLine(x, y, x, y);
+//    }
 
     /*
      * Convenience method for drawing a grooved line
@@ -64,23 +64,23 @@
      */
     public static void drawGroove(Graphics g, int x, int y, int w, int h,
                                   Color shadow, Color highlight)
-    {
-        Color oldColor = g.getColor();  // Make no net change to g
-        g.translate(x, y);
-
-        g.setColor(shadow);
-        g.drawRect(0, 0, w-2, h-2);
-
-        g.setColor(highlight);
-        g.drawLine(1, h-3, 1, 1);
-        g.drawLine(1, 1, w-3, 1);
-
-        g.drawLine(0, h-1, w-1, h-1);
-        g.drawLine(w-1, h-1, w-1, 0);
-
-        g.translate(-x, -y);
-        g.setColor(oldColor);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        Color oldColor = g.getColor();  // Make no net change to g
+//        g.translate(x, y);
+//
+//        g.setColor(shadow);
+//        g.drawRect(0, 0, w-2, h-2);
+//
+//        g.setColor(highlight);
+//        g.drawLine(1, h-3, 1, 1);
+//        g.drawLine(1, 1, w-3, 1);
+//
+//        g.drawLine(0, h-1, w-1, h-1);
+//        g.drawLine(w-1, h-1, w-1, 0);
+//
+//        g.translate(-x, -y);
+//        g.setColor(oldColor);
+//    }
 
     /** Draws <b>aString</b> in the rectangle defined by
       * (<b>x</b>, <b>y</b>, <b>width</b>, <b>height</b>).
@@ -92,51 +92,51 @@
       * @see #drawString
       */
     public static void drawStringInRect(Graphics g, String aString, int x, int y,
-                                 int width, int height, int justification) {
-        drawStringInRect(null, g, aString, x, y, width, height, justification);
-    }
+                                 int width, int height, int justification) {throw new RuntimeException("cf-bug");} //{
+//        drawStringInRect(null, g, aString, x, y, width, height, justification);
+//    }
 
     static void drawStringInRect(JComponent c, Graphics g, String aString,
                                  int x, int y, int width, int height,
-                                 int justification) {
-        FontMetrics  fontMetrics;
-        int          drawWidth, startX, startY, delta;
-
-        if (g.getFont() == null) {
-//            throw new InconsistencyException("No font set");
-            return;
-        }
-        fontMetrics = SwingUtilities2.getFontMetrics(c, g);
-        if (fontMetrics == null) {
-//            throw new InconsistencyException("No metrics for Font " + font());
-            return;
-        }
-
-        if (justification == CENTER) {
-            drawWidth = SwingUtilities2.stringWidth(c, fontMetrics, aString);
-            if (drawWidth > width) {
-                drawWidth = width;
-            }
-            startX = x + (width - drawWidth) / 2;
-        } else if (justification == RIGHT) {
-            drawWidth = SwingUtilities2.stringWidth(c, fontMetrics, aString);
-            if (drawWidth > width) {
-                drawWidth = width;
-            }
-            startX = x + width - drawWidth;
-        } else {
-            startX = x;
-        }
-
-        delta = (height - fontMetrics.getAscent() - fontMetrics.getDescent()) / 2;
-        if (delta < 0) {
-            delta = 0;
-        }
-
-        startY = y + height - delta - fontMetrics.getDescent();
-
-        SwingUtilities2.drawString(c, g, aString, startX, startY);
-    }
+                                 int justification) {throw new RuntimeException("cf-bug");} //{
+//        FontMetrics  fontMetrics;
+//        int          drawWidth, startX, startY, delta;
+//
+//        if (g.getFont() == null) {
+////            throw new InconsistencyException("No font set");
+//            return;
+//        }
+//        fontMetrics = SwingUtilities2.getFontMetrics(c, g);
+//        if (fontMetrics == null) {
+////            throw new InconsistencyException("No metrics for Font " + font());
+//            return;
+//        }
+//
+//        if (justification == CENTER) {
+//            drawWidth = SwingUtilities2.stringWidth(c, fontMetrics, aString);
+//            if (drawWidth > width) {
+//                drawWidth = width;
+//            }
+//            startX = x + (width - drawWidth) / 2;
+//        } else if (justification == RIGHT) {
+//            drawWidth = SwingUtilities2.stringWidth(c, fontMetrics, aString);
+//            if (drawWidth > width) {
+//                drawWidth = width;
+//            }
+//            startX = x + width - drawWidth;
+//        } else {
+//            startX = x;
+//        }
+//
+//        delta = (height - fontMetrics.getAscent() - fontMetrics.getDescent()) / 2;
+//        if (delta < 0) {
+//            delta = 0;
+//        }
+//
+//        startY = y + height - delta - fontMetrics.getDescent();
+//
+//        SwingUtilities2.drawString(c, g, aString, startX, startY);
+//    }
 
   /**
    * This method is not being used to paint menu item since
@@ -147,186 +147,186 @@
                                    Icon checkIcon, Icon arrowIcon,
                                    Color background, Color foreground,
                                    int defaultTextIconGap)
-    {
-
-        JMenuItem b = (JMenuItem) c;
-        ButtonModel model = b.getModel();
-
-        Dimension size = b.getSize();
-        Insets i = c.getInsets();
-
-        Rectangle viewRect = new Rectangle(size);
-
-        viewRect.x += i.left;
-        viewRect.y += i.top;
-        viewRect.width -= (i.right + viewRect.x);
-        viewRect.height -= (i.bottom + viewRect.y);
-
-        Rectangle iconRect = new Rectangle();
-        Rectangle textRect = new Rectangle();
-        Rectangle acceleratorRect = new Rectangle();
-        Rectangle checkRect = new Rectangle();
-        Rectangle arrowRect = new Rectangle();
-
-        Font holdf = g.getFont();
-        Font f = c.getFont();
-        g.setFont(f);
-        FontMetrics fm = SwingUtilities2.getFontMetrics(c, g, f);
-        FontMetrics fmAccel = SwingUtilities2.getFontMetrics(
-            c, g, UIManager.getFont("MenuItem.acceleratorFont"));
-
-        if (c.isOpaque()) {
-            if (model.isArmed()|| (c instanceof JMenu && model.isSelected())) {
-                g.setColor(background);
-            } else {
-                g.setColor(c.getBackground());
-            }
-            g.fillRect(0,0, size.width, size.height);
-        }
-
-        // get Accelerator text
-        KeyStroke accelerator =  b.getAccelerator();
-        String acceleratorText = "";
-        if (accelerator != null) {
-            int modifiers = accelerator.getModifiers();
-            if (modifiers > 0) {
-                acceleratorText = KeyEvent.getKeyModifiersText(modifiers);
-                acceleratorText += "+";
-            }
-            acceleratorText += KeyEvent.getKeyText(accelerator.getKeyCode());
-        }
-
-        // layout the text and icon
-        String text = layoutMenuItem(c, fm, b.getText(), fmAccel,
-                                     acceleratorText, b.getIcon(),
-                                     checkIcon, arrowIcon,
-                                     b.getVerticalAlignment(),
-                                     b.getHorizontalAlignment(),
-                                     b.getVerticalTextPosition(),
-                                     b.getHorizontalTextPosition(),
-                                     viewRect, iconRect,
-                                     textRect, acceleratorRect,
-                                     checkRect, arrowRect,
-                                     b.getText() == null
-                                     ? 0 : defaultTextIconGap,
-                                     defaultTextIconGap
-                                     );
-
-        // Paint the Check
-        Color holdc = g.getColor();
-        if (checkIcon != null) {
-            if(model.isArmed() || (c instanceof JMenu && model.isSelected()))
-                g.setColor(foreground);
-            checkIcon.paintIcon(c, g, checkRect.x, checkRect.y);
-            g.setColor(holdc);
-        }
-
-        // Paint the Icon
-        if(b.getIcon() != null) {
-            Icon icon;
-            if(!model.isEnabled()) {
-                icon = b.getDisabledIcon();
-            } else if(model.isPressed() && model.isArmed()) {
-                icon = b.getPressedIcon();
-                if(icon == null) {
-                    // Use default icon
-                    icon = b.getIcon();
-                }
-            } else {
-                icon = b.getIcon();
-            }
-
-            if (icon!=null) {
-                icon.paintIcon(c, g, iconRect.x, iconRect.y);
-            }
-        }
-
-        // Draw the Text
-        if(text != null && !text.equals("")) {
-            // Once BasicHTML becomes public, use BasicHTML.propertyKey
-            // instead of the hardcoded string below!
-            View v = (View) c.getClientProperty("html");
-            if (v != null) {
-                v.paint(g, textRect);
-            } else {
-                int mnemIndex = b.getDisplayedMnemonicIndex();
-
-                if(!model.isEnabled()) {
-                    // *** paint the text disabled
-                    g.setColor(b.getBackground().brighter());
-                    SwingUtilities2.drawStringUnderlineCharAt(b, g,text,
-                        mnemIndex,
-                        textRect.x, textRect.y + fmAccel.getAscent());
-                    g.setColor(b.getBackground().darker());
-                    SwingUtilities2.drawStringUnderlineCharAt(b, g,text,
-                        mnemIndex,
-                        textRect.x - 1, textRect.y + fmAccel.getAscent() - 1);
-
-                } else {
-                    // *** paint the text normally
-                    if (model.isArmed()|| (c instanceof JMenu && model.isSelected())) {
-                        g.setColor(foreground);
-                    } else {
-                        g.setColor(b.getForeground());
-                    }
-                    SwingUtilities2.drawStringUnderlineCharAt(b, g,text,
-                                                  mnemIndex,
-                                                  textRect.x,
-                                                  textRect.y + fm.getAscent());
-                }
-            }
-        }
-
-        // Draw the Accelerator Text
-        if(acceleratorText != null && !acceleratorText.equals("")) {
-
-            //Get the maxAccWidth from the parent to calculate the offset.
-            int accOffset = 0;
-            Container parent = b.getParent();
-            if (parent != null && parent instanceof JComponent) {
-                JComponent p = (JComponent) parent;
-                Integer maxValueInt = (Integer) p.getClientProperty(MotifGraphicsUtils.MAX_ACC_WIDTH);
-                int maxValue = maxValueInt != null ?
-                    maxValueInt.intValue() : acceleratorRect.width;
-
-                //Calculate the offset, with which the accelerator texts will be drawn with.
-                accOffset = maxValue - acceleratorRect.width;
-            }
-
-            g.setFont( UIManager.getFont("MenuItem.acceleratorFont") );
-            if(!model.isEnabled()) {
-                // *** paint the acceleratorText disabled
-                g.setColor(b.getBackground().brighter());
-                SwingUtilities2.drawString(c, g,acceleratorText,
-                                              acceleratorRect.x - accOffset, acceleratorRect.y + fm.getAscent());
-                g.setColor(b.getBackground().darker());
-                SwingUtilities2.drawString(c, g,acceleratorText,
-                                              acceleratorRect.x - accOffset - 1, acceleratorRect.y + fm.getAscent() - 1);
-            } else {
-                // *** paint the acceleratorText normally
-                if (model.isArmed()|| (c instanceof JMenu && model.isSelected()))
-                    {
-                        g.setColor(foreground);
-                    } else {
-                        g.setColor(b.getForeground());
-                    }
-                SwingUtilities2.drawString(c, g,acceleratorText,
-                                              acceleratorRect.x - accOffset,
-                                              acceleratorRect.y + fmAccel.getAscent());
-            }
-        }
-
-        // Paint the Arrow
-        if (arrowIcon != null) {
-            if(model.isArmed() || (c instanceof JMenu && model.isSelected()))
-                g.setColor(foreground);
-            if( !(b.getParent() instanceof JMenuBar) )
-                arrowIcon.paintIcon(c, g, arrowRect.x, arrowRect.y);
-        }
-
-        g.setColor(holdc);
-        g.setFont(holdf);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//
+//        JMenuItem b = (JMenuItem) c;
+//        ButtonModel model = b.getModel();
+//
+//        Dimension size = b.getSize();
+//        Insets i = c.getInsets();
+//
+//        Rectangle viewRect = new Rectangle(size);
+//
+//        viewRect.x += i.left;
+//        viewRect.y += i.top;
+//        viewRect.width -= (i.right + viewRect.x);
+//        viewRect.height -= (i.bottom + viewRect.y);
+//
+//        Rectangle iconRect = new Rectangle();
+//        Rectangle textRect = new Rectangle();
+//        Rectangle acceleratorRect = new Rectangle();
+//        Rectangle checkRect = new Rectangle();
+//        Rectangle arrowRect = new Rectangle();
+//
+//        Font holdf = g.getFont();
+//        Font f = c.getFont();
+//        g.setFont(f);
+//        FontMetrics fm = SwingUtilities2.getFontMetrics(c, g, f);
+//        FontMetrics fmAccel = SwingUtilities2.getFontMetrics(
+//            c, g, UIManager.getFont("MenuItem.acceleratorFont"));
+//
+//        if (c.isOpaque()) {
+//            if (model.isArmed()|| (c instanceof JMenu && model.isSelected())) {
+//                g.setColor(background);
+//            } else {
+//                g.setColor(c.getBackground());
+//            }
+//            g.fillRect(0,0, size.width, size.height);
+//        }
+//
+//        // get Accelerator text
+//        KeyStroke accelerator =  b.getAccelerator();
+//        String acceleratorText = "";
+//        if (accelerator != null) {
+//            int modifiers = accelerator.getModifiers();
+//            if (modifiers > 0) {
+//                acceleratorText = KeyEvent.getKeyModifiersText(modifiers);
+//                acceleratorText += "+";
+//            }
+//            acceleratorText += KeyEvent.getKeyText(accelerator.getKeyCode());
+//        }
+//
+//        // layout the text and icon
+//        String text = layoutMenuItem(c, fm, b.getText(), fmAccel,
+//                                     acceleratorText, b.getIcon(),
+//                                     checkIcon, arrowIcon,
+//                                     b.getVerticalAlignment(),
+//                                     b.getHorizontalAlignment(),
+//                                     b.getVerticalTextPosition(),
+//                                     b.getHorizontalTextPosition(),
+//                                     viewRect, iconRect,
+//                                     textRect, acceleratorRect,
+//                                     checkRect, arrowRect,
+//                                     b.getText() == null
+//                                     ? 0 : defaultTextIconGap,
+//                                     defaultTextIconGap
+//                                     );
+//
+//        // Paint the Check
+//        Color holdc = g.getColor();
+//        if (checkIcon != null) {
+//            if(model.isArmed() || (c instanceof JMenu && model.isSelected()))
+//                g.setColor(foreground);
+//            checkIcon.paintIcon(c, g, checkRect.x, checkRect.y);
+//            g.setColor(holdc);
+//        }
+//
+//        // Paint the Icon
+//        if(b.getIcon() != null) {
+//            Icon icon;
+//            if(!model.isEnabled()) {
+//                icon = b.getDisabledIcon();
+//            } else if(model.isPressed() && model.isArmed()) {
+//                icon = b.getPressedIcon();
+//                if(icon == null) {
+//                    // Use default icon
+//                    icon = b.getIcon();
+//                }
+//            } else {
+//                icon = b.getIcon();
+//            }
+//
+//            if (icon!=null) {
+//                icon.paintIcon(c, g, iconRect.x, iconRect.y);
+//            }
+//        }
+//
+//        // Draw the Text
+//        if(text != null && !text.equals("")) {
+//            // Once BasicHTML becomes public, use BasicHTML.propertyKey
+//            // instead of the hardcoded string below!
+//            View v = (View) c.getClientProperty("html");
+//            if (v != null) {
+//                v.paint(g, textRect);
+//            } else {
+//                int mnemIndex = b.getDisplayedMnemonicIndex();
+//
+//                if(!model.isEnabled()) {
+//                    // *** paint the text disabled
+//                    g.setColor(b.getBackground().brighter());
+//                    SwingUtilities2.drawStringUnderlineCharAt(b, g,text,
+//                        mnemIndex,
+//                        textRect.x, textRect.y + fmAccel.getAscent());
+//                    g.setColor(b.getBackground().darker());
+//                    SwingUtilities2.drawStringUnderlineCharAt(b, g,text,
+//                        mnemIndex,
+//                        textRect.x - 1, textRect.y + fmAccel.getAscent() - 1);
+//
+//                } else {
+//                    // *** paint the text normally
+//                    if (model.isArmed()|| (c instanceof JMenu && model.isSelected())) {
+//                        g.setColor(foreground);
+//                    } else {
+//                        g.setColor(b.getForeground());
+//                    }
+//                    SwingUtilities2.drawStringUnderlineCharAt(b, g,text,
+//                                                  mnemIndex,
+//                                                  textRect.x,
+//                                                  textRect.y + fm.getAscent());
+//                }
+//            }
+//        }
+//
+//        // Draw the Accelerator Text
+//        if(acceleratorText != null && !acceleratorText.equals("")) {
+//
+//            //Get the maxAccWidth from the parent to calculate the offset.
+//            int accOffset = 0;
+//            Container parent = b.getParent();
+//            if (parent != null && parent instanceof JComponent) {
+//                JComponent p = (JComponent) parent;
+//                Integer maxValueInt = (Integer) p.getClientProperty(MotifGraphicsUtils.MAX_ACC_WIDTH);
+//                int maxValue = maxValueInt != null ?
+//                    maxValueInt.intValue() : acceleratorRect.width;
+//
+//                //Calculate the offset, with which the accelerator texts will be drawn with.
+//                accOffset = maxValue - acceleratorRect.width;
+//            }
+//
+//            g.setFont( UIManager.getFont("MenuItem.acceleratorFont") );
+//            if(!model.isEnabled()) {
+//                // *** paint the acceleratorText disabled
+//                g.setColor(b.getBackground().brighter());
+//                SwingUtilities2.drawString(c, g,acceleratorText,
+//                                              acceleratorRect.x - accOffset, acceleratorRect.y + fm.getAscent());
+//                g.setColor(b.getBackground().darker());
+//                SwingUtilities2.drawString(c, g,acceleratorText,
+//                                              acceleratorRect.x - accOffset - 1, acceleratorRect.y + fm.getAscent() - 1);
+//            } else {
+//                // *** paint the acceleratorText normally
+//                if (model.isArmed()|| (c instanceof JMenu && model.isSelected()))
+//                    {
+//                        g.setColor(foreground);
+//                    } else {
+//                        g.setColor(b.getForeground());
+//                    }
+//                SwingUtilities2.drawString(c, g,acceleratorText,
+//                                              acceleratorRect.x - accOffset,
+//                                              acceleratorRect.y + fmAccel.getAscent());
+//            }
+//        }
+//
+//        // Paint the Arrow
+//        if (arrowIcon != null) {
+//            if(model.isArmed() || (c instanceof JMenu && model.isSelected()))
+//                g.setColor(foreground);
+//            if( !(b.getParent() instanceof JMenuBar) )
+//                arrowIcon.paintIcon(c, g, arrowRect.x, arrowRect.y);
+//        }
+//
+//        g.setColor(holdc);
+//        g.setFont(holdf);
+//    }
 
 
     /**
@@ -358,119 +358,119 @@
         int textIconGap,
         int menuItemGap
         )
-    {
-
-        SwingUtilities.layoutCompoundLabel(c,
-                                           fm,
-                                           text,
-                                           icon,
-                                           verticalAlignment,
-                                           horizontalAlignment,
-                                           verticalTextPosition,
-                                           horizontalTextPosition,
-                                           viewR,
-                                           iconR,
-                                           textR,
-                                           textIconGap);
-
-        /* Initialize the acceelratorText bounds rectangle textR.  If a null
-         * or and empty String was specified we substitute "" here
-         * and use 0,0,0,0 for acceleratorTextR.
-         */
-        if( (acceleratorText == null) || acceleratorText.equals("") ) {
-            acceleratorR.width = acceleratorR.height = 0;
-            acceleratorText = "";
-        }
-        else {
-            acceleratorR.width
-                = SwingUtilities2.stringWidth(c, fmAccel, acceleratorText);
-            acceleratorR.height = fmAccel.getHeight();
-        }
-
-        /* Initialize the checkIcon bounds rectangle checkIconR.
-         */
-
-        if (checkIcon != null) {
-            checkIconR.width = checkIcon.getIconWidth();
-            checkIconR.height = checkIcon.getIconHeight();
-        }
-        else {
-            checkIconR.width = checkIconR.height = 0;
-        }
-
-        /* Initialize the arrowIcon bounds rectangle arrowIconR.
-         */
-
-        if (arrowIcon != null) {
-            arrowIconR.width = arrowIcon.getIconWidth();
-            arrowIconR.height = arrowIcon.getIconHeight();
-        }
-        else {
-            arrowIconR.width = arrowIconR.height = 0;
-        }
-
-
-        Rectangle labelR = iconR.union(textR);
-        if( MotifGraphicsUtils.isLeftToRight(c) ) {
-            textR.x += checkIconR.width + menuItemGap;
-            iconR.x += checkIconR.width + menuItemGap;
-
-            // Position the Accelerator text rect
-            acceleratorR.x = viewR.x + viewR.width - arrowIconR.width
-                             - menuItemGap - acceleratorR.width;
-
-            // Position the Check and Arrow Icons
-            checkIconR.x = viewR.x;
-            arrowIconR.x = viewR.x + viewR.width - menuItemGap
-                           - arrowIconR.width;
-        } else {
-            textR.x -= (checkIconR.width + menuItemGap);
-            iconR.x -= (checkIconR.width + menuItemGap);
-
-            // Position the Accelerator text rect
-            acceleratorR.x = viewR.x + arrowIconR.width + menuItemGap;
-
-            // Position the Check and Arrow Icons
-            checkIconR.x = viewR.x + viewR.width - checkIconR.width;
-            arrowIconR.x = viewR.x + menuItemGap;
-        }
-
-        // Align the accelertor text and the check and arrow icons vertically
-        // with the center of the label rect.
-        acceleratorR.y = labelR.y + (labelR.height/2) - (acceleratorR.height/2);
-        arrowIconR.y = labelR.y + (labelR.height/2) - (arrowIconR.height/2);
-        checkIconR.y = labelR.y + (labelR.height/2) - (checkIconR.height/2);
-
-        /*
-          System.out.println("Layout: v=" +viewR+"  c="+checkIconR+" i="+
-          iconR+" t="+textR+" acc="+acceleratorR+" a="+arrowIconR);
-          */
-        return text;
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//
+//        SwingUtilities.layoutCompoundLabel(c,
+//                                           fm,
+//                                           text,
+//                                           icon,
+//                                           verticalAlignment,
+//                                           horizontalAlignment,
+//                                           verticalTextPosition,
+//                                           horizontalTextPosition,
+//                                           viewR,
+//                                           iconR,
+//                                           textR,
+//                                           textIconGap);
+//
+//        /* Initialize the acceelratorText bounds rectangle textR.  If a null
+//         * or and empty String was specified we substitute "" here
+//         * and use 0,0,0,0 for acceleratorTextR.
+//         */
+//        if( (acceleratorText == null) || acceleratorText.equals("") ) {
+//            acceleratorR.width = acceleratorR.height = 0;
+//            acceleratorText = "";
+//        }
+//        else {
+//            acceleratorR.width
+//                = SwingUtilities2.stringWidth(c, fmAccel, acceleratorText);
+//            acceleratorR.height = fmAccel.getHeight();
+//        }
+//
+//        /* Initialize the checkIcon bounds rectangle checkIconR.
+//         */
+//
+//        if (checkIcon != null) {
+//            checkIconR.width = checkIcon.getIconWidth();
+//            checkIconR.height = checkIcon.getIconHeight();
+//        }
+//        else {
+//            checkIconR.width = checkIconR.height = 0;
+//        }
+//
+//        /* Initialize the arrowIcon bounds rectangle arrowIconR.
+//         */
+//
+//        if (arrowIcon != null) {
+//            arrowIconR.width = arrowIcon.getIconWidth();
+//            arrowIconR.height = arrowIcon.getIconHeight();
+//        }
+//        else {
+//            arrowIconR.width = arrowIconR.height = 0;
+//        }
+//
+//
+//        Rectangle labelR = iconR.union(textR);
+//        if( MotifGraphicsUtils.isLeftToRight(c) ) {
+//            textR.x += checkIconR.width + menuItemGap;
+//            iconR.x += checkIconR.width + menuItemGap;
+//
+//            // Position the Accelerator text rect
+//            acceleratorR.x = viewR.x + viewR.width - arrowIconR.width
+//                             - menuItemGap - acceleratorR.width;
+//
+//            // Position the Check and Arrow Icons
+//            checkIconR.x = viewR.x;
+//            arrowIconR.x = viewR.x + viewR.width - menuItemGap
+//                           - arrowIconR.width;
+//        } else {
+//            textR.x -= (checkIconR.width + menuItemGap);
+//            iconR.x -= (checkIconR.width + menuItemGap);
+//
+//            // Position the Accelerator text rect
+//            acceleratorR.x = viewR.x + arrowIconR.width + menuItemGap;
+//
+//            // Position the Check and Arrow Icons
+//            checkIconR.x = viewR.x + viewR.width - checkIconR.width;
+//            arrowIconR.x = viewR.x + menuItemGap;
+//        }
+//
+//        // Align the accelertor text and the check and arrow icons vertically
+//        // with the center of the label rect.
+//        acceleratorR.y = labelR.y + (labelR.height/2) - (acceleratorR.height/2);
+//        arrowIconR.y = labelR.y + (labelR.height/2) - (arrowIconR.height/2);
+//        checkIconR.y = labelR.y + (labelR.height/2) - (checkIconR.height/2);
+//
+//        /*
+//          System.out.println("Layout: v=" +viewR+"  c="+checkIconR+" i="+
+//          iconR+" t="+textR+" acc="+acceleratorR+" a="+arrowIconR);
+//          */
+//        return text;
+//    }
 
   private static void drawMenuBezel(Graphics g, Color background,
                                     int x, int y,
                                     int width, int height)
-    {
-      // shadowed button region
-      g.setColor(background);
-      g.fillRect(x,y,width,height);
-
-      g.setColor(background.brighter().brighter());
-      g.drawLine(x+1,       y+height-1,  x+width-1, y+height-1);
-      g.drawLine(x+width-1, y+height-2,  x+width-1, y+1);
-
-      g.setColor(background.darker().darker());
-      g.drawLine(x,   y,   x+width-2, y);
-      g.drawLine(x,   y+1, x,         y+height-2);
-
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//      // shadowed button region
+//      g.setColor(background);
+//      g.fillRect(x,y,width,height);
+//
+//      g.setColor(background.brighter().brighter());
+//      g.drawLine(x+1,       y+height-1,  x+width-1, y+height-1);
+//      g.drawLine(x+width-1, y+height-2,  x+width-1, y+1);
+//
+//      g.setColor(background.darker().darker());
+//      g.drawLine(x,   y,   x+width-2, y);
+//      g.drawLine(x,   y+1, x,         y+height-2);
+//
+//    }
 
     /*
      * Convenience function for determining ComponentOrientation.  Helps us
      * avoid having Munge directives throughout the code.
      */
-    static boolean isLeftToRight( Component c ) {
-        return c.getComponentOrientation().isLeftToRight();
-    }
+    static boolean isLeftToRight( Component c ) {throw new RuntimeException("cf-bug");} //{
+//        return c.getComponentOrientation().isLeftToRight();
+//    }
 }
--- a/sun/nio/ch/AsynchronousChannelGroupImpl.java	2016-06-22 19:56:19.668185783 -0700
+++ b/sun/nio/ch/AsynchronousChannelGroupImpl.java	2016-06-29 12:36:01.372499523 -0700
@@ -88,88 +88,88 @@
         this.timeoutExecutor.setRemoveOnCancelPolicy(true);
     }
 
-    final ExecutorService executor() {
-        return pool.executor();
-    }
-
-    final boolean isFixedThreadPool() {
-        return pool.isFixedThreadPool();
-    }
-
-    final int fixedThreadCount() {
-        if (isFixedThreadPool()) {
-            return pool.poolSize();
-        } else {
-            return pool.poolSize() + internalThreadCount;
-        }
-    }
-
-    private Runnable bindToGroup(final Runnable task) {
-        final AsynchronousChannelGroupImpl thisGroup = this;
-        return new Runnable() {
-            public void run() {
-                Invoker.bindToGroup(thisGroup);
-                task.run();
-            }
-        };
-    }
-
-    private void startInternalThread(final Runnable task) {
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
-            @Override
-            public Void run() {
-                // internal threads should not be visible to application so
-                // cannot use user-supplied thread factory
-                ThreadPool.defaultThreadFactory().newThread(task).start();
-                return null;
-            }
-         });
-    }
-
-    protected final void startThreads(Runnable task) {
-        if (!isFixedThreadPool()) {
-            for (int i=0; i<internalThreadCount; i++) {
-                startInternalThread(task);
-                threadCount.incrementAndGet();
-            }
-        }
-        if (pool.poolSize() > 0) {
-            task = bindToGroup(task);
-            try {
-                for (int i=0; i<pool.poolSize(); i++) {
-                    pool.executor().execute(task);
-                    threadCount.incrementAndGet();
-                }
-            } catch (RejectedExecutionException  x) {
-                // nothing we can do
-            }
-        }
-    }
-
-    final int threadCount() {
-        return threadCount.get();
-    }
+    final ExecutorService executor() {throw new RuntimeException("cf-bug");} //{
+//        return pool.executor();
+//    }
+
+    final boolean isFixedThreadPool() {throw new RuntimeException("cf-bug");} //{
+//        return pool.isFixedThreadPool();
+//    }
+
+    final int fixedThreadCount() {throw new RuntimeException("cf-bug");} //{
+//        if (isFixedThreadPool()) {
+//            return pool.poolSize();
+//        } else {
+//            return pool.poolSize() + internalThreadCount;
+//        }
+//    }
+
+    private Runnable bindToGroup(final Runnable task) {throw new RuntimeException("cf-bug");} //{
+//        final AsynchronousChannelGroupImpl thisGroup = this;
+//        return new Runnable() {
+//            public void run() {
+//                Invoker.bindToGroup(thisGroup);
+//                task.run();
+//            }
+//        };
+//    }
+
+    private void startInternalThread(final Runnable task) {throw new RuntimeException("cf-bug");} //{
+//        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+//            @Override
+//            public Void run() {
+//                // internal threads should not be visible to application so
+//                // cannot use user-supplied thread factory
+//                ThreadPool.defaultThreadFactory().newThread(task).start();
+//                return null;
+//            }
+//         });
+//    }
+
+    protected final void startThreads(Runnable task) {throw new RuntimeException("cf-bug");} //{
+//        if (!isFixedThreadPool()) {
+//            for (int i=0; i<internalThreadCount; i++) {
+//                startInternalThread(task);
+//                threadCount.incrementAndGet();
+//            }
+//        }
+//        if (pool.poolSize() > 0) {
+//            task = bindToGroup(task);
+//            try {
+//                for (int i=0; i<pool.poolSize(); i++) {
+//                    pool.executor().execute(task);
+//                    threadCount.incrementAndGet();
+//                }
+//            } catch (RejectedExecutionException  x) {
+//                // nothing we can do
+//            }
+//        }
+//    }
+
+    final int threadCount() {throw new RuntimeException("cf-bug");} //{
+//        return threadCount.get();
+//    }
 
     /**
      * Invoked by tasks as they terminate
      */
-    final int threadExit(Runnable task, boolean replaceMe) {
-        if (replaceMe) {
-            try {
-                if (Invoker.isBoundToAnyGroup()) {
-                    // submit new task to replace this thread
-                    pool.executor().execute(bindToGroup(task));
-                } else {
-                    // replace internal thread
-                    startInternalThread(task);
-                }
-                return threadCount.get();
-            } catch (RejectedExecutionException x) {
-                // unable to replace
-            }
-        }
-        return threadCount.decrementAndGet();
-    }
+    final int threadExit(Runnable task, boolean replaceMe) {throw new RuntimeException("cf-bug");} //{
+//        if (replaceMe) {
+//            try {
+//                if (Invoker.isBoundToAnyGroup()) {
+//                    // submit new task to replace this thread
+//                    pool.executor().execute(bindToGroup(task));
+//                } else {
+//                    // replace internal thread
+//                    startInternalThread(task);
+//                }
+//                return threadCount.get();
+//            } catch (RejectedExecutionException x) {
+//                // unable to replace
+//            }
+//        }
+//        return threadCount.decrementAndGet();
+//    }
 
     /**
      * Wakes up a thread waiting for I/O events to execute the given task.
@@ -181,43 +181,43 @@
      * events. For other thread pools we simply submit the task to the thread
      * pool.
      */
-    final void executeOnPooledThread(Runnable task) {
-        if (isFixedThreadPool()) {
-            executeOnHandlerTask(task);
-        } else {
-            pool.executor().execute(bindToGroup(task));
-        }
-    }
-
-    final void offerTask(Runnable task) {
-        taskQueue.offer(task);
-    }
-
-    final Runnable pollTask() {
-        return (taskQueue == null) ? null : taskQueue.poll();
-    }
-
-    final Future<?> schedule(Runnable task, long timeout, TimeUnit unit) {
-        try {
-            return timeoutExecutor.schedule(task, timeout, unit);
-        } catch (RejectedExecutionException rej) {
-            if (terminateInitiated) {
-                // no timeout scheduled as group is terminating
-                return null;
-            }
-            throw new AssertionError(rej);
-        }
-    }
-
-    @Override
-    public final boolean isShutdown() {
-        return shutdown.get();
-    }
-
-    @Override
-    public final boolean isTerminated()  {
-        return pool.executor().isTerminated();
-    }
+    final void executeOnPooledThread(Runnable task) {throw new RuntimeException("cf-bug");} //{
+//        if (isFixedThreadPool()) {
+//            executeOnHandlerTask(task);
+//        } else {
+//            pool.executor().execute(bindToGroup(task));
+//        }
+//    }
+
+    final void offerTask(Runnable task) {throw new RuntimeException("cf-bug");} //{
+//        taskQueue.offer(task);
+//    }
+
+    final Runnable pollTask() {throw new RuntimeException("cf-bug");} //{
+//        return (taskQueue == null) ? null : taskQueue.poll();
+//    }
+
+    final Future<?> schedule(Runnable task, long timeout, TimeUnit unit) {throw new RuntimeException("cf-bug");} //{
+//        try {
+//            return timeoutExecutor.schedule(task, timeout, unit);
+//        } catch (RejectedExecutionException rej) {
+//            if (terminateInitiated) {
+//                // no timeout scheduled as group is terminating
+//                return null;
+//            }
+//            throw new AssertionError(rej);
+//        }
+//    }
+
+    @Override
+    public final boolean isShutdown() {throw new RuntimeException("cf-bug");} //{
+//        return shutdown.get();
+//    }
+
+    @Override
+    public final boolean isTerminated()  {throw new RuntimeException("cf-bug");} //{
+//        return pool.executor().isTerminated();
+//    }
 
     /**
      * Returns true if there are no channels in the group
@@ -245,94 +245,94 @@
      */
     abstract void shutdownHandlerTasks();
 
-    private void shutdownExecutors() {
-        AccessController.doPrivileged(new PrivilegedAction<Void>() {
-            public Void run() {
-                pool.executor().shutdown();
-                timeoutExecutor.shutdown();
-                return null;
-            }
-        });
-    }
-
-    @Override
-    public final void shutdown() {
-        if (shutdown.getAndSet(true)) {
-            // already shutdown
-            return;
-        }
-        // if there are channels in the group then shutdown will continue
-        // when the last channel is closed
-        if (!isEmpty()) {
-            return;
-        }
-        // initiate termination (acquire shutdownNowLock to ensure that other
-        // threads invoking shutdownNow will block).
-        synchronized (shutdownNowLock) {
-            if (!terminateInitiated) {
-                terminateInitiated = true;
-                shutdownHandlerTasks();
-                shutdownExecutors();
-            }
-        }
-    }
-
-    @Override
-    public final void shutdownNow() throws IOException {
-        shutdown.set(true);
-        synchronized (shutdownNowLock) {
-            if (!terminateInitiated) {
-                terminateInitiated = true;
-                closeAllChannels();
-                shutdownHandlerTasks();
-                shutdownExecutors();
-            }
-        }
-    }
+    private void shutdownExecutors() {throw new RuntimeException("cf-bug");} //{
+//        AccessController.doPrivileged(new PrivilegedAction<Void>() {
+//            public Void run() {
+//                pool.executor().shutdown();
+//                timeoutExecutor.shutdown();
+//                return null;
+//            }
+//        });
+//    }
+
+    @Override
+    public final void shutdown() {throw new RuntimeException("cf-bug");} //{
+//        if (shutdown.getAndSet(true)) {
+//            // already shutdown
+//            return;
+//        }
+//        // if there are channels in the group then shutdown will continue
+//        // when the last channel is closed
+//        if (!isEmpty()) {
+//            return;
+//        }
+//        // initiate termination (acquire shutdownNowLock to ensure that other
+//        // threads invoking shutdownNow will block).
+//        synchronized (shutdownNowLock) {
+//            if (!terminateInitiated) {
+//                terminateInitiated = true;
+//                shutdownHandlerTasks();
+//                shutdownExecutors();
+//            }
+//        }
+//    }
+
+    @Override
+    public final void shutdownNow() throws IOException {throw new RuntimeException("cf-bug");} //{
+//        shutdown.set(true);
+//        synchronized (shutdownNowLock) {
+//            if (!terminateInitiated) {
+//                terminateInitiated = true;
+//                closeAllChannels();
+//                shutdownHandlerTasks();
+//                shutdownExecutors();
+//            }
+//        }
+//    }
 
     /**
      * For use by AsynchronousFileChannel to release resources without shutting
      * down the thread pool.
      */
-    final void detachFromThreadPool() {
-        if (shutdown.getAndSet(true))
-            throw new AssertionError("Already shutdown");
-        if (!isEmpty())
-            throw new AssertionError("Group not empty");
-        shutdownHandlerTasks();
-    }
+    final void detachFromThreadPool() {throw new RuntimeException("cf-bug");} //{
+//        if (shutdown.getAndSet(true))
+//            throw new AssertionError("Already shutdown");
+//        if (!isEmpty())
+//            throw new AssertionError("Group not empty");
+//        shutdownHandlerTasks();
+//    }
 
     @Override
     public final boolean awaitTermination(long timeout, TimeUnit unit)
         throws InterruptedException
-    {
-        return pool.executor().awaitTermination(timeout, unit);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        return pool.executor().awaitTermination(timeout, unit);
+//    }
 
     /**
      * Executes the given command on one of the channel group's pooled threads.
      */
     @Override
-    public final void execute(Runnable task) {
-        SecurityManager sm = System.getSecurityManager();
-        if (sm != null) {
-            // when a security manager is installed then the user's task
-            // must be run with the current calling context
-            final AccessControlContext acc = AccessController.getContext();
-            final Runnable delegate = task;
-            task = new Runnable() {
-                @Override
-                public void run() {
-                    AccessController.doPrivileged(new PrivilegedAction<Void>() {
-                        @Override
-                        public Void run() {
-                            delegate.run();
-                            return null;
-                        }
-                    }, acc);
-                }
-            };
-        }
-        executeOnPooledThread(task);
-    }
+    public final void execute(Runnable task) {throw new RuntimeException("cf-bug");} //{
+//        SecurityManager sm = System.getSecurityManager();
+//        if (sm != null) {
+//            // when a security manager is installed then the user's task
+//            // must be run with the current calling context
+//            final AccessControlContext acc = AccessController.getContext();
+//            final Runnable delegate = task;
+//            task = new Runnable() {
+//                @Override
+//                public void run() {
+//                    AccessController.doPrivileged(new PrivilegedAction<Void>() {
+//                        @Override
+//                        public Void run() {
+//                            delegate.run();
+//                            return null;
+//                        }
+//                    }, acc);
+//                }
+//            };
+//        }
+//        executeOnPooledThread(task);
+//    }
 }
--- a/sun/swing/FilePane.java	2016-06-22 19:55:36.607973490 -0700
+++ b/sun/swing/FilePane.java	2016-06-29 16:23:59.225422082 -0700
@@ -125,142 +125,142 @@
          * as the prefix with appropriate number of the same letters followed
          * by first typed another letter.
          */
-        public void keyTyped(KeyEvent e) {
-            BasicDirectoryModel model = getModel();
-            int rowCount = model.getSize();
-
-            if (detailsTable == null || rowCount == 0 ||
-                    e.isAltDown() || e.isControlDown() || e.isMetaDown()) {
-                return;
-            }
-
-            InputMap inputMap = detailsTable.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
-            KeyStroke key = KeyStroke.getKeyStrokeForEvent(e);
-
-            if (inputMap != null && inputMap.get(key) != null) {
-                return;
-            }
-
-            int startIndex = detailsTable.getSelectionModel().getLeadSelectionIndex();
-
-            if (startIndex < 0) {
-                startIndex = 0;
-            }
-
-            if (startIndex >= rowCount) {
-                startIndex = rowCount - 1;
-            }
-
-            char c = e.getKeyChar();
-
-            long time = e.getWhen();
-
-            if (time - lastTime < timeFactor) {
-                if (typedString.length() == 1 && typedString.charAt(0) == c) {
-                    // Subsequent same key presses move the keyboard focus to the next
-                    // object that starts with the same letter.
-                    startIndex++;
-                } else {
-                    typedString.append(c);
-                }
-            } else {
-                startIndex++;
-
-                typedString.setLength(0);
-                typedString.append(c);
-            }
-
-            lastTime = time;
-
-            if (startIndex >= rowCount) {
-                startIndex = 0;
-            }
-
-            // Find next file
-            int index = getNextMatch(startIndex, rowCount - 1);
-
-            if (index < 0 && startIndex > 0) { // wrap
-                index = getNextMatch(0, startIndex - 1);
-            }
-
-            if (index >= 0) {
-                detailsTable.getSelectionModel().setSelectionInterval(index, index);
-
-                Rectangle cellRect = detailsTable.getCellRect(index,
-                        detailsTable.convertColumnIndexToView(COLUMN_FILENAME), false);
-                detailsTable.scrollRectToVisible(cellRect);
-            }
-        }
-
-        private int getNextMatch(int startIndex, int finishIndex) {
-            BasicDirectoryModel model = getModel();
-            JFileChooser fileChooser = getFileChooser();
-            DetailsTableRowSorter rowSorter = getRowSorter();
-
-            String prefix = typedString.toString().toLowerCase();
-
-            // Search element
-            for (int index = startIndex; index <= finishIndex; index++) {
-                File file = (File) model.getElementAt(rowSorter.convertRowIndexToModel(index));
-
-                String fileName = fileChooser.getName(file).toLowerCase();
-
-                if (fileName.startsWith(prefix)) {
-                    return index;
-                }
-            }
-
-            return -1;
-        }
+        public void keyTyped(KeyEvent e) {throw new RuntimeException("cf-bug");} //{
+//            BasicDirectoryModel model = getModel();
+//            int rowCount = model.getSize();
+//
+//            if (detailsTable == null || rowCount == 0 ||
+//                    e.isAltDown() || e.isControlDown() || e.isMetaDown()) {
+//                return;
+//            }
+//
+//            InputMap inputMap = detailsTable.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
+//            KeyStroke key = KeyStroke.getKeyStrokeForEvent(e);
+//
+//            if (inputMap != null && inputMap.get(key) != null) {
+//                return;
+//            }
+//
+//            int startIndex = detailsTable.getSelectionModel().getLeadSelectionIndex();
+//
+//            if (startIndex < 0) {
+//                startIndex = 0;
+//            }
+//
+//            if (startIndex >= rowCount) {
+//                startIndex = rowCount - 1;
+//            }
+//
+//            char c = e.getKeyChar();
+//
+//            long time = e.getWhen();
+//
+//            if (time - lastTime < timeFactor) {
+//                if (typedString.length() == 1 && typedString.charAt(0) == c) {
+//                    // Subsequent same key presses move the keyboard focus to the next
+//                    // object that starts with the same letter.
+//                    startIndex++;
+//                } else {
+//                    typedString.append(c);
+//                }
+//            } else {
+//                startIndex++;
+//
+//                typedString.setLength(0);
+//                typedString.append(c);
+//            }
+//
+//            lastTime = time;
+//
+//            if (startIndex >= rowCount) {
+//                startIndex = 0;
+//            }
+//
+//            // Find next file
+//            int index = getNextMatch(startIndex, rowCount - 1);
+//
+//            if (index < 0 && startIndex > 0) { // wrap
+//                index = getNextMatch(0, startIndex - 1);
+//            }
+//
+//            if (index >= 0) {
+//                detailsTable.getSelectionModel().setSelectionInterval(index, index);
+//
+//                Rectangle cellRect = detailsTable.getCellRect(index,
+//                        detailsTable.convertColumnIndexToView(COLUMN_FILENAME), false);
+//                detailsTable.scrollRectToVisible(cellRect);
+//            }
+//        }
+
+        private int getNextMatch(int startIndex, int finishIndex) {throw new RuntimeException("cf-bug");} //{
+//            BasicDirectoryModel model = getModel();
+//            JFileChooser fileChooser = getFileChooser();
+//            DetailsTableRowSorter rowSorter = getRowSorter();
+//
+//            String prefix = typedString.toString().toLowerCase();
+//
+//            // Search element
+//            for (int index = startIndex; index <= finishIndex; index++) {
+//                File file = (File) model.getElementAt(rowSorter.convertRowIndexToModel(index));
+//
+//                String fileName = fileChooser.getName(file).toLowerCase();
+//
+//                if (fileName.startsWith(prefix)) {
+//                    return index;
+//                }
+//            }
+//
+//            return -1;
+//        }
     };
 
     private FocusListener editorFocusListener = new FocusAdapter() {
-        public void focusLost(FocusEvent e) {
-            if (! e.isTemporary()) {
-                applyEdit();
-            }
-        }
+        public void focusLost(FocusEvent e) {throw new RuntimeException("cf-bug");} //{
+//            if (! e.isTemporary()) {
+//                applyEdit();
+//            }
+//        }
     };
 
     private static FocusListener repaintListener = new FocusListener() {
-        public void focusGained(FocusEvent fe) {
-            repaintSelection(fe.getSource());
-        }
-
-        public void focusLost(FocusEvent fe) {
-            repaintSelection(fe.getSource());
-        }
-
-        private void repaintSelection(Object source) {
-            if (source instanceof JList) {
-                repaintListSelection((JList)source);
-            } else if (source instanceof JTable) {
-                repaintTableSelection((JTable)source);
-            }
-        }
-
-        private void repaintListSelection(JList list) {
-            int[] indices = list.getSelectedIndices();
-            for (int i : indices) {
-                Rectangle bounds = list.getCellBounds(i, i);
-                list.repaint(bounds);
-            }
-        }
-
-        private void repaintTableSelection(JTable table) {
-            int minRow = table.getSelectionModel().getMinSelectionIndex();
-            int maxRow = table.getSelectionModel().getMaxSelectionIndex();
-            if (minRow == -1 || maxRow == -1) {
-                return;
-            }
-
-            int col0 = table.convertColumnIndexToView(COLUMN_FILENAME);
-
-            Rectangle first = table.getCellRect(minRow, col0, false);
-            Rectangle last = table.getCellRect(maxRow, col0, false);
-            Rectangle dirty = first.union(last);
-            table.repaint(dirty);
-        }
+        public void focusGained(FocusEvent fe) {throw new RuntimeException("cf-bug");} //{
+//            repaintSelection(fe.getSource());
+//        }
+
+        public void focusLost(FocusEvent fe) {throw new RuntimeException("cf-bug");} //{
+//            repaintSelection(fe.getSource());
+//        }
+
+        private void repaintSelection(Object source) {throw new RuntimeException("cf-bug");} //{
+//            if (source instanceof JList) {
+//                repaintListSelection((JList)source);
+//            } else if (source instanceof JTable) {
+//                repaintTableSelection((JTable)source);
+//            }
+//        }
+
+        private void repaintListSelection(JList list) {throw new RuntimeException("cf-bug");} //{
+//            int[] indices = list.getSelectedIndices();
+//            for (int i : indices) {
+//                Rectangle bounds = list.getCellBounds(i, i);
+//                list.repaint(bounds);
+//            }
+//        }
+
+        private void repaintTableSelection(JTable table) {throw new RuntimeException("cf-bug");} //{
+//            int minRow = table.getSelectionModel().getMinSelectionIndex();
+//            int maxRow = table.getSelectionModel().getMaxSelectionIndex();
+//            if (minRow == -1 || maxRow == -1) {
+//                return;
+//            }
+//
+//            int col0 = table.convertColumnIndexToView(COLUMN_FILENAME);
+//
+//            Rectangle first = table.getCellRect(minRow, col0, false);
+//            Rectangle last = table.getCellRect(maxRow, col0, false);
+//            Rectangle dirty = first.union(last);
+//            table.repaint(dirty);
+//        }
     };
 
     private boolean smallIconsView = false;
@@ -294,102 +294,102 @@
         createActionMap();
     }
 
-    public void uninstallUI() {
-        if (getModel() != null) {
-            getModel().removePropertyChangeListener(this);
-        }
-    }
-
-    protected JFileChooser getFileChooser() {
-        return fileChooserUIAccessor.getFileChooser();
-    }
-
-    protected BasicDirectoryModel getModel() {
-        return fileChooserUIAccessor.getModel();
-    }
-
-    public int getViewType() {
-        return viewType;
-    }
-
-    public void setViewType(int viewType) {
-        if (viewType == this.viewType) {
-            return;
-        }
-
-        int oldValue = this.viewType;
-        this.viewType = viewType;
-
-        JPanel createdViewPanel = null;
-        Component newFocusOwner = null;
-
-        switch (viewType) {
-          case VIEWTYPE_LIST:
-            if (viewPanels[viewType] == null) {
-                createdViewPanel = fileChooserUIAccessor.createList();
-                if (createdViewPanel == null) {
-                    createdViewPanel = createList();
-                }
-
-                list = (JList) findChildComponent(createdViewPanel, JList.class);
-                if (listSelectionModel == null) {
-                    listSelectionModel = list.getSelectionModel();
-                    if (detailsTable != null) {
-                        detailsTable.setSelectionModel(listSelectionModel);
-                    }
-                } else {
-                    list.setSelectionModel(listSelectionModel);
-                }
-            }
-            list.setLayoutOrientation(JList.VERTICAL_WRAP);
-            newFocusOwner = list;
-            break;
-
-          case VIEWTYPE_DETAILS:
-            if (viewPanels[viewType] == null) {
-                createdViewPanel = fileChooserUIAccessor.createDetailsView();
-                if (createdViewPanel == null) {
-                    createdViewPanel = createDetailsView();
-                }
-
-                detailsTable = (JTable) findChildComponent(createdViewPanel, JTable.class);
-                detailsTable.setRowHeight(Math.max(detailsTable.getFont().getSize() + 4, 16 + 1));
-                if (listSelectionModel != null) {
-                    detailsTable.setSelectionModel(listSelectionModel);
-                }
-            }
-            newFocusOwner = detailsTable;
-            break;
-        }
-
-        if (createdViewPanel != null) {
-            viewPanels[viewType] = createdViewPanel;
-            recursivelySetInheritsPopupMenu(createdViewPanel, true);
-        }
-
-        boolean isFocusOwner = false;
-
-        if (currentViewPanel != null) {
-            Component owner = DefaultKeyboardFocusManager.
-                    getCurrentKeyboardFocusManager().getPermanentFocusOwner();
-
-            isFocusOwner = owner == detailsTable || owner == list;
-
-            remove(currentViewPanel);
-        }
-
-        currentViewPanel = viewPanels[viewType];
-        add(currentViewPanel, BorderLayout.CENTER);
-
-        if (isFocusOwner && newFocusOwner != null) {
-            newFocusOwner.requestFocusInWindow();
-        }
-
-        revalidate();
-        repaint();
-        updateViewMenu();
-        firePropertyChange("viewType", oldValue, viewType);
-    }
+    public void uninstallUI() {throw new RuntimeException("cf-bug");} //{
+//        if (getModel() != null) {
+//            getModel().removePropertyChangeListener(this);
+//        }
+//    }
+
+    protected JFileChooser getFileChooser() {throw new RuntimeException("cf-bug");} //{
+//        return fileChooserUIAccessor.getFileChooser();
+//    }
+
+    protected BasicDirectoryModel getModel() {throw new RuntimeException("cf-bug");} //{
+//        return fileChooserUIAccessor.getModel();
+//    }
+
+    public int getViewType() {throw new RuntimeException("cf-bug");} //{
+//        return viewType;
+//    }
+
+    public void setViewType(int viewType) {throw new RuntimeException("cf-bug");} //{
+//        if (viewType == this.viewType) {
+//            return;
+//        }
+//
+//        int oldValue = this.viewType;
+//        this.viewType = viewType;
+//
+//        JPanel createdViewPanel = null;
+//        Component newFocusOwner = null;
+//
+//        switch (viewType) {
+//          case VIEWTYPE_LIST:
+//            if (viewPanels[viewType] == null) {
+//                createdViewPanel = fileChooserUIAccessor.createList();
+//                if (createdViewPanel == null) {
+//                    createdViewPanel = createList();
+//                }
+//
+//                list = (JList) findChildComponent(createdViewPanel, JList.class);
+//                if (listSelectionModel == null) {
+//                    listSelectionModel = list.getSelectionModel();
+//                    if (detailsTable != null) {
+//                        detailsTable.setSelectionModel(listSelectionModel);
+//                    }
+//                } else {
+//                    list.setSelectionModel(listSelectionModel);
+//                }
+//            }
+//            list.setLayoutOrientation(JList.VERTICAL_WRAP);
+//            newFocusOwner = list;
+//            break;
+//
+//          case VIEWTYPE_DETAILS:
+//            if (viewPanels[viewType] == null) {
+//                createdViewPanel = fileChooserUIAccessor.createDetailsView();
+//                if (createdViewPanel == null) {
+//                    createdViewPanel = createDetailsView();
+//                }
+//
+//                detailsTable = (JTable) findChildComponent(createdViewPanel, JTable.class);
+//                detailsTable.setRowHeight(Math.max(detailsTable.getFont().getSize() + 4, 16 + 1));
+//                if (listSelectionModel != null) {
+//                    detailsTable.setSelectionModel(listSelectionModel);
+//                }
+//            }
+//            newFocusOwner = detailsTable;
+//            break;
+//        }
+//
+//        if (createdViewPanel != null) {
+//            viewPanels[viewType] = createdViewPanel;
+//            recursivelySetInheritsPopupMenu(createdViewPanel, true);
+//        }
+//
+//        boolean isFocusOwner = false;
+//
+//        if (currentViewPanel != null) {
+//            Component owner = DefaultKeyboardFocusManager.
+//                    getCurrentKeyboardFocusManager().getPermanentFocusOwner();
+//
+//            isFocusOwner = owner == detailsTable || owner == list;
+//
+//            remove(currentViewPanel);
+//        }
+//
+//        currentViewPanel = viewPanels[viewType];
+//        add(currentViewPanel, BorderLayout.CENTER);
+//
+//        if (isFocusOwner && newFocusOwner != null) {
+//            newFocusOwner.requestFocusInWindow();
+//        }
+//
+//        revalidate();
+//        repaint();
+//        updateViewMenu();
+//        firePropertyChange("viewType", oldValue, viewType);
+//    }
 
     class ViewTypeAction extends AbstractAction {
         private int viewType;
@@ -407,60 +407,60 @@
             putValue(Action.ACTION_COMMAND_KEY, cmd);
         }
 
-        public void actionPerformed(ActionEvent e) {
-            setViewType(viewType);
-        }
-    }
-
-    public Action getViewTypeAction(int viewType) {
-        return new ViewTypeAction(viewType);
-    }
-
-    private static void recursivelySetInheritsPopupMenu(Container container, boolean b) {
-        if (container instanceof JComponent) {
-            ((JComponent)container).setInheritsPopupMenu(b);
-        }
-        int n = container.getComponentCount();
-        for (int i = 0; i < n; i++) {
-            recursivelySetInheritsPopupMenu((Container)container.getComponent(i), b);
-        }
-    }
-
-    protected void installDefaults() {
-        Locale l = getFileChooser().getLocale();
-
-        listViewBorder       = UIManager.getBorder("FileChooser.listViewBorder");
-        listViewBackground   = UIManager.getColor("FileChooser.listViewBackground");
-        listViewWindowsStyle = UIManager.getBoolean("FileChooser.listViewWindowsStyle");
-        readOnly             = UIManager.getBoolean("FileChooser.readOnly");
-
-        // TODO: On windows, get the following localized strings from the OS
-
-        viewMenuLabelText =
-                        UIManager.getString("FileChooser.viewMenuLabelText", l);
-        refreshActionLabelText =
-                        UIManager.getString("FileChooser.refreshActionLabelText", l);
-        newFolderActionLabelText =
-                        UIManager.getString("FileChooser.newFolderActionLabelText", l);
-
-        viewTypeActionNames = new String[VIEWTYPE_COUNT];
-        viewTypeActionNames[VIEWTYPE_LIST] =
-                        UIManager.getString("FileChooser.listViewActionLabelText", l);
-        viewTypeActionNames[VIEWTYPE_DETAILS] =
-                        UIManager.getString("FileChooser.detailsViewActionLabelText", l);
-
-        kiloByteString = UIManager.getString("FileChooser.fileSizeKiloBytes", l);
-        megaByteString = UIManager.getString("FileChooser.fileSizeMegaBytes", l);
-        gigaByteString = UIManager.getString("FileChooser.fileSizeGigaBytes", l);
-        fullRowSelection = UIManager.getBoolean("FileView.fullRowSelection");
-
-        filesListAccessibleName = UIManager.getString("FileChooser.filesListAccessibleName", l);
-        filesDetailsAccessibleName = UIManager.getString("FileChooser.filesDetailsAccessibleName", l);
-
-        renameErrorTitleText = UIManager.getString("FileChooser.renameErrorTitleText", l);
-        renameErrorText = UIManager.getString("FileChooser.renameErrorText", l);
-        renameErrorFileExistsText = UIManager.getString("FileChooser.renameErrorFileExistsText", l);
-    }
+        public void actionPerformed(ActionEvent e) {throw new RuntimeException("cf-bug");} //{
+//            setViewType(viewType);
+//        }
+    }
+
+    public Action getViewTypeAction(int viewType) {throw new RuntimeException("cf-bug");} //{
+//        return new ViewTypeAction(viewType);
+//    }
+
+    private static void recursivelySetInheritsPopupMenu(Container container, boolean b) {throw new RuntimeException("cf-bug");} //{
+//        if (container instanceof JComponent) {
+//            ((JComponent)container).setInheritsPopupMenu(b);
+//        }
+//        int n = container.getComponentCount();
+//        for (int i = 0; i < n; i++) {
+//            recursivelySetInheritsPopupMenu((Container)container.getComponent(i), b);
+//        }
+//    }
+
+    protected void installDefaults() {throw new RuntimeException("cf-bug");} //{
+//        Locale l = getFileChooser().getLocale();
+//
+//        listViewBorder       = UIManager.getBorder("FileChooser.listViewBorder");
+//        listViewBackground   = UIManager.getColor("FileChooser.listViewBackground");
+//        listViewWindowsStyle = UIManager.getBoolean("FileChooser.listViewWindowsStyle");
+//        readOnly             = UIManager.getBoolean("FileChooser.readOnly");
+//
+//        // TODO: On windows, get the following localized strings from the OS
+//
+//        viewMenuLabelText =
+//                        UIManager.getString("FileChooser.viewMenuLabelText", l);
+//        refreshActionLabelText =
+//                        UIManager.getString("FileChooser.refreshActionLabelText", l);
+//        newFolderActionLabelText =
+//                        UIManager.getString("FileChooser.newFolderActionLabelText", l);
+//
+//        viewTypeActionNames = new String[VIEWTYPE_COUNT];
+//        viewTypeActionNames[VIEWTYPE_LIST] =
+//                        UIManager.getString("FileChooser.listViewActionLabelText", l);
+//        viewTypeActionNames[VIEWTYPE_DETAILS] =
+//                        UIManager.getString("FileChooser.detailsViewActionLabelText", l);
+//
+//        kiloByteString = UIManager.getString("FileChooser.fileSizeKiloBytes", l);
+//        megaByteString = UIManager.getString("FileChooser.fileSizeMegaBytes", l);
+//        gigaByteString = UIManager.getString("FileChooser.fileSizeGigaBytes", l);
+//        fullRowSelection = UIManager.getBoolean("FileView.fullRowSelection");
+//
+//        filesListAccessibleName = UIManager.getString("FileChooser.filesListAccessibleName", l);
+//        filesDetailsAccessibleName = UIManager.getString("FileChooser.filesDetailsAccessibleName", l);
+//
+//        renameErrorTitleText = UIManager.getString("FileChooser.renameErrorTitleText", l);
+//        renameErrorText = UIManager.getString("FileChooser.renameErrorText", l);
+//        renameErrorFileExistsText = UIManager.getString("FileChooser.renameErrorFileExistsText", l);
+//    }
 
     /**
      * Fetches the command list for the FilePane. These commands
@@ -468,185 +468,185 @@
      *
      * @return the command list
      */
-    public Action[] getActions() {
-        if (actions == null) {
-            class FilePaneAction extends AbstractAction {
-                FilePaneAction(String name) {
-                    this(name, name);
-                }
-
-                FilePaneAction(String name, String cmd) {
-                    super(name);
-                    putValue(Action.ACTION_COMMAND_KEY, cmd);
-                }
-
-                public void actionPerformed(ActionEvent e) {
-                    String cmd = (String)getValue(Action.ACTION_COMMAND_KEY);
-
-                    if (cmd == ACTION_CANCEL) {
-                        if (editFile != null) {
-                           cancelEdit();
-                        } else {
-                           getFileChooser().cancelSelection();
-                        }
-                    } else if (cmd == ACTION_EDIT_FILE_NAME) {
-                        JFileChooser fc = getFileChooser();
-                        int index = listSelectionModel.getMinSelectionIndex();
-                        if (index >= 0 && editFile == null &&
-                            (!fc.isMultiSelectionEnabled() ||
-                             fc.getSelectedFiles().length <= 1)) {
-
-                            editFileName(index);
-                        }
-                    } else if (cmd == ACTION_REFRESH) {
-                        getFileChooser().rescanCurrentDirectory();
-                    }
-                }
-
-                public boolean isEnabled() {
-                    String cmd = (String)getValue(Action.ACTION_COMMAND_KEY);
-                    if (cmd == ACTION_CANCEL) {
-                        return getFileChooser().isEnabled();
-                    } else if (cmd == ACTION_EDIT_FILE_NAME) {
-                        return !readOnly && getFileChooser().isEnabled();
-                    } else {
-                        return true;
-                    }
-                }
-            }
-
-            ArrayList<Action> actionList = new ArrayList<Action>(8);
-            Action action;
-
-            actionList.add(new FilePaneAction(ACTION_CANCEL));
-            actionList.add(new FilePaneAction(ACTION_EDIT_FILE_NAME));
-            actionList.add(new FilePaneAction(refreshActionLabelText, ACTION_REFRESH));
-
-            action = fileChooserUIAccessor.getApproveSelectionAction();
-            if (action != null) {
-                actionList.add(action);
-            }
-            action = fileChooserUIAccessor.getChangeToParentDirectoryAction();
-            if (action != null) {
-                actionList.add(action);
-            }
-            action = getNewFolderAction();
-            if (action != null) {
-                actionList.add(action);
-            }
-            action = getViewTypeAction(VIEWTYPE_LIST);
-            if (action != null) {
-                actionList.add(action);
-            }
-            action = getViewTypeAction(VIEWTYPE_DETAILS);
-            if (action != null) {
-                actionList.add(action);
-            }
-            actions = actionList.toArray(new Action[actionList.size()]);
-        }
-
-        return actions;
-    }
-
-    protected void createActionMap() {
-        addActionsToMap(super.getActionMap(), getActions());
-    }
-
-
-    public static void addActionsToMap(ActionMap map, Action[] actions) {
-        if (map != null && actions != null) {
-            for (Action a : actions) {
-                String cmd = (String)a.getValue(Action.ACTION_COMMAND_KEY);
-                if (cmd == null) {
-                    cmd = (String)a.getValue(Action.NAME);
-                }
-                map.put(cmd, a);
-            }
-        }
-    }
-
-
-    private void updateListRowCount(JList list) {
-        if (smallIconsView) {
-            list.setVisibleRowCount(getModel().getSize() / 3);
-        } else {
-            list.setVisibleRowCount(-1);
-        }
-    }
-
-    public JPanel createList() {
-        JPanel p = new JPanel(new BorderLayout());
-        final JFileChooser fileChooser = getFileChooser();
-        final JList<Object> list = new JList<Object>() {
-            public int getNextMatch(String prefix, int startIndex, Position.Bias bias) {
-                ListModel model = getModel();
-                int max = model.getSize();
-                if (prefix == null || startIndex < 0 || startIndex >= max) {
-                    throw new IllegalArgumentException();
-                }
-                // start search from the next element before/after the selected element
-                boolean backwards = (bias == Position.Bias.Backward);
-                for (int i = startIndex; backwards ? i >= 0 : i < max; i += (backwards ?  -1 : 1)) {
-                    String filename = fileChooser.getName((File)model.getElementAt(i));
-                    if (filename.regionMatches(true, 0, prefix, 0, prefix.length())) {
-                        return i;
-                    }
-                }
-                return -1;
-            }
-        };
-        list.setCellRenderer(new FileRenderer());
-        list.setLayoutOrientation(JList.VERTICAL_WRAP);
-
-        // 4835633 : tell BasicListUI that this is a file list
-        list.putClientProperty("List.isFileList", Boolean.TRUE);
-
-        if (listViewWindowsStyle) {
-            list.addFocusListener(repaintListener);
-        }
-
-        updateListRowCount(list);
-
-        getModel().addListDataListener(new ListDataListener() {
-            public void intervalAdded(ListDataEvent e) {
-                updateListRowCount(list);
-            }
-            public void intervalRemoved(ListDataEvent e) {
-                updateListRowCount(list);
-            }
-            public void contentsChanged(ListDataEvent e) {
-                if (isShowing()) {
-                    clearSelection();
-                }
-                updateListRowCount(list);
-            }
-        });
-
-        getModel().addPropertyChangeListener(this);
-
-        if (fileChooser.isMultiSelectionEnabled()) {
-            list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
-        } else {
-            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
-        }
-        list.setModel(new SortableListModel());
-
-        list.addListSelectionListener(createListSelectionListener());
-        list.addMouseListener(getMouseHandler());
-
-        JScrollPane scrollpane = new JScrollPane(list);
-        if (listViewBackground != null) {
-            list.setBackground(listViewBackground);
-        }
-        if (listViewBorder != null) {
-            scrollpane.setBorder(listViewBorder);
-        }
-
-        list.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY, filesListAccessibleName);
-
-        p.add(scrollpane, BorderLayout.CENTER);
-        return p;
-    }
+    public Action[] getActions() {throw new RuntimeException("cf-bug");} //{
+//        if (actions == null) {
+//            class FilePaneAction extends AbstractAction {
+//                FilePaneAction(String name) {
+//                    this(name, name);
+//                }
+//
+//                FilePaneAction(String name, String cmd) {
+//                    super(name);
+//                    putValue(Action.ACTION_COMMAND_KEY, cmd);
+//                }
+//
+//                public void actionPerformed(ActionEvent e) {
+//                    String cmd = (String)getValue(Action.ACTION_COMMAND_KEY);
+//
+//                    if (cmd == ACTION_CANCEL) {
+//                        if (editFile != null) {
+//                           cancelEdit();
+//                        } else {
+//                           getFileChooser().cancelSelection();
+//                        }
+//                    } else if (cmd == ACTION_EDIT_FILE_NAME) {
+//                        JFileChooser fc = getFileChooser();
+//                        int index = listSelectionModel.getMinSelectionIndex();
+//                        if (index >= 0 && editFile == null &&
+//                            (!fc.isMultiSelectionEnabled() ||
+//                             fc.getSelectedFiles().length <= 1)) {
+//
+//                            editFileName(index);
+//                        }
+//                    } else if (cmd == ACTION_REFRESH) {
+//                        getFileChooser().rescanCurrentDirectory();
+//                    }
+//                }
+//
+//                public boolean isEnabled() {
+//                    String cmd = (String)getValue(Action.ACTION_COMMAND_KEY);
+//                    if (cmd == ACTION_CANCEL) {
+//                        return getFileChooser().isEnabled();
+//                    } else if (cmd == ACTION_EDIT_FILE_NAME) {
+//                        return !readOnly && getFileChooser().isEnabled();
+//                    } else {
+//                        return true;
+//                    }
+//                }
+//            }
+//
+//            ArrayList<Action> actionList = new ArrayList<Action>(8);
+//            Action action;
+//
+//            actionList.add(new FilePaneAction(ACTION_CANCEL));
+//            actionList.add(new FilePaneAction(ACTION_EDIT_FILE_NAME));
+//            actionList.add(new FilePaneAction(refreshActionLabelText, ACTION_REFRESH));
+//
+//            action = fileChooserUIAccessor.getApproveSelectionAction();
+//            if (action != null) {
+//                actionList.add(action);
+//            }
+//            action = fileChooserUIAccessor.getChangeToParentDirectoryAction();
+//            if (action != null) {
+//                actionList.add(action);
+//            }
+//            action = getNewFolderAction();
+//            if (action != null) {
+//                actionList.add(action);
+//            }
+//            action = getViewTypeAction(VIEWTYPE_LIST);
+//            if (action != null) {
+//                actionList.add(action);
+//            }
+//            action = getViewTypeAction(VIEWTYPE_DETAILS);
+//            if (action != null) {
+//                actionList.add(action);
+//            }
+//            actions = actionList.toArray(new Action[actionList.size()]);
+//        }
+//
+//        return actions;
+//    }
+
+    protected void createActionMap() {throw new RuntimeException("cf-bug");} //{
+//        addActionsToMap(super.getActionMap(), getActions());
+//    }
+
+
+    public static void addActionsToMap(ActionMap map, Action[] actions) {throw new RuntimeException("cf-bug");} //{
+//        if (map != null && actions != null) {
+//            for (Action a : actions) {
+//                String cmd = (String)a.getValue(Action.ACTION_COMMAND_KEY);
+//                if (cmd == null) {
+//                    cmd = (String)a.getValue(Action.NAME);
+//                }
+//                map.put(cmd, a);
+//            }
+//        }
+//    }
+
+
+    private void updateListRowCount(JList list) {throw new RuntimeException("cf-bug");} //{
+//        if (smallIconsView) {
+//            list.setVisibleRowCount(getModel().getSize() / 3);
+//        } else {
+//            list.setVisibleRowCount(-1);
+//        }
+//    }
+
+    public JPanel createList() {throw new RuntimeException("cf-bug");} //{
+//        JPanel p = new JPanel(new BorderLayout());
+//        final JFileChooser fileChooser = getFileChooser();
+//        final JList<Object> list = new JList<Object>() {
+//            public int getNextMatch(String prefix, int startIndex, Position.Bias bias) {
+//                ListModel model = getModel();
+//                int max = model.getSize();
+//                if (prefix == null || startIndex < 0 || startIndex >= max) {
+//                    throw new IllegalArgumentException();
+//                }
+//                // start search from the next element before/after the selected element
+//                boolean backwards = (bias == Position.Bias.Backward);
+//                for (int i = startIndex; backwards ? i >= 0 : i < max; i += (backwards ?  -1 : 1)) {
+//                    String filename = fileChooser.getName((File)model.getElementAt(i));
+//                    if (filename.regionMatches(true, 0, prefix, 0, prefix.length())) {
+//                        return i;
+//                    }
+//                }
+//                return -1;
+//            }
+//        };
+//        list.setCellRenderer(new FileRenderer());
+//        list.setLayoutOrientation(JList.VERTICAL_WRAP);
+//
+//        // 4835633 : tell BasicListUI that this is a file list
+//        list.putClientProperty("List.isFileList", Boolean.TRUE);
+//
+//        if (listViewWindowsStyle) {
+//            list.addFocusListener(repaintListener);
+//        }
+//
+//        updateListRowCount(list);
+//
+//        getModel().addListDataListener(new ListDataListener() {
+//            public void intervalAdded(ListDataEvent e) {
+//                updateListRowCount(list);
+//            }
+//            public void intervalRemoved(ListDataEvent e) {
+//                updateListRowCount(list);
+//            }
+//            public void contentsChanged(ListDataEvent e) {
+//                if (isShowing()) {
+//                    clearSelection();
+//                }
+//                updateListRowCount(list);
+//            }
+//        });
+//
+//        getModel().addPropertyChangeListener(this);
+//
+//        if (fileChooser.isMultiSelectionEnabled()) {
+//            list.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
+//        } else {
+//            list.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+//        }
+//        list.setModel(new SortableListModel());
+//
+//        list.addListSelectionListener(createListSelectionListener());
+//        list.addMouseListener(getMouseHandler());
+//
+//        JScrollPane scrollpane = new JScrollPane(list);
+//        if (listViewBackground != null) {
+//            list.setBackground(listViewBackground);
+//        }
+//        if (listViewBorder != null) {
+//            scrollpane.setBorder(listViewBorder);
+//        }
+//
+//        list.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY, filesListAccessibleName);
+//
+//        p.add(scrollpane, BorderLayout.CENTER);
+//        return p;
+//    }
 
     /**
      * This model allows for sorting JList
@@ -659,30 +659,30 @@
             getRowSorter().addRowSorterListener(this);
         }
 
-        public int getSize() {
-            return getModel().getSize();
-        }
-
-        public Object getElementAt(int index) {
-            // JList doesn't support RowSorter so far, so we put it into the list model
-            return getModel().getElementAt(getRowSorter().convertRowIndexToModel(index));
-        }
-
-        public void tableChanged(TableModelEvent e) {
-            fireContentsChanged(this, 0, getSize());
-        }
-
-        public void sorterChanged(RowSorterEvent e) {
-            fireContentsChanged(this, 0, getSize());
-        }
-    }
-
-    private DetailsTableModel getDetailsTableModel() {
-        if(detailsTableModel == null) {
-            detailsTableModel = new DetailsTableModel(getFileChooser());
-        }
-        return detailsTableModel;
-    }
+        public int getSize() {throw new RuntimeException("cf-bug");} //{
+//            return getModel().getSize();
+//        }
+
+        public Object getElementAt(int index) {throw new RuntimeException("cf-bug");} //{
+//            // JList doesn't support RowSorter so far, so we put it into the list model
+//            return getModel().getElementAt(getRowSorter().convertRowIndexToModel(index));
+//        }
+
+        public void tableChanged(TableModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//            fireContentsChanged(this, 0, getSize());
+//        }
+
+        public void sorterChanged(RowSorterEvent e) {throw new RuntimeException("cf-bug");} //{
+//            fireContentsChanged(this, 0, getSize());
+//        }
+    }
+
+    private DetailsTableModel getDetailsTableModel() {throw new RuntimeException("cf-bug");} //{
+//        if(detailsTableModel == null) {
+//            detailsTableModel = new DetailsTableModel(getFileChooser());
+//        }
+//        return detailsTableModel;
+//    }
 
     class DetailsTableModel extends AbstractTableModel implements ListDataListener {
         JFileChooser chooser;
@@ -699,261 +699,261 @@
             updateColumnInfo();
         }
 
-        void updateColumnInfo() {
-            File dir = chooser.getCurrentDirectory();
-            if (dir != null && usesShellFolder(chooser)) {
-                try {
-                    dir = ShellFolder.getShellFolder(dir);
-                } catch (FileNotFoundException e) {
-                    // Leave dir without changing
-                }
-            }
-
-            ShellFolderColumnInfo[] allColumns = ShellFolder.getFolderColumns(dir);
-
-            ArrayList<ShellFolderColumnInfo> visibleColumns =
-                    new ArrayList<ShellFolderColumnInfo>();
-            columnMap = new int[allColumns.length];
-            for (int i = 0; i < allColumns.length; i++) {
-                ShellFolderColumnInfo column = allColumns[i];
-                if (column.isVisible()) {
-                    columnMap[visibleColumns.size()] = i;
-                    visibleColumns.add(column);
-                }
-            }
-
-            columns = new ShellFolderColumnInfo[visibleColumns.size()];
-            visibleColumns.toArray(columns);
-            columnMap = Arrays.copyOf(columnMap, columns.length);
-
-            List<? extends RowSorter.SortKey> sortKeys =
-                    (rowSorter == null) ? null : rowSorter.getSortKeys();
-            fireTableStructureChanged();
-            restoreSortKeys(sortKeys);
-        }
-
-        private void restoreSortKeys(List<? extends RowSorter.SortKey> sortKeys) {
-            if (sortKeys != null) {
-                // check if preserved sortKeys are valid for this folder
-                for (int i = 0; i < sortKeys.size(); i++) {
-                    RowSorter.SortKey sortKey = sortKeys.get(i);
-                    if (sortKey.getColumn() >= columns.length) {
-                        sortKeys = null;
-                        break;
-                    }
-                }
-                if (sortKeys != null) {
-                    rowSorter.setSortKeys(sortKeys);
-                }
-            }
-        }
-
-        public int getRowCount() {
-            return directoryModel.getSize();
-        }
-
-        public int getColumnCount() {
-            return columns.length;
-        }
-
-        public Object getValueAt(int row, int col) {
-            // Note: It is very important to avoid getting info on drives, as
-            // this will trigger "No disk in A:" and similar dialogs.
-            //
-            // Use (f.exists() && !chooser.getFileSystemView().isFileSystemRoot(f)) to
-            // determine if it is safe to call methods directly on f.
-            return getFileColumnValue((File)directoryModel.getElementAt(row), col);
-        }
-
-        private Object getFileColumnValue(File f, int col) {
-            return (col == COLUMN_FILENAME)
-                    ? f // always return the file itself for the 1st column
-                    : ShellFolder.getFolderColumnValue(f, columnMap[col]);
-        }
-
-        public void setValueAt(Object value, int row, int col) {
-            if (col == COLUMN_FILENAME) {
-                final JFileChooser chooser = getFileChooser();
-                File f = (File)getValueAt(row, col);
-                if (f != null) {
-                    String oldDisplayName = chooser.getName(f);
-                    String oldFileName = f.getName();
-                    String newDisplayName = ((String)value).trim();
-                    String newFileName;
-
-                    if (!newDisplayName.equals(oldDisplayName)) {
-                        newFileName = newDisplayName;
-                        //Check if extension is hidden from user
-                        int i1 = oldFileName.length();
-                        int i2 = oldDisplayName.length();
-                        if (i1 > i2 && oldFileName.charAt(i2) == '.') {
-                            newFileName = newDisplayName + oldFileName.substring(i2);
-                        }
-
-                        // rename
-                        FileSystemView fsv = chooser.getFileSystemView();
-                        final File f2 = fsv.createFileObject(f.getParentFile(), newFileName);
-                        if (f2.exists()) {
-                            JOptionPane.showMessageDialog(chooser, MessageFormat.format(renameErrorFileExistsText,
-                                    oldFileName), renameErrorTitleText, JOptionPane.ERROR_MESSAGE);
-                        } else {
-                            if (FilePane.this.getModel().renameFile(f, f2)) {
-                                if (fsv.isParent(chooser.getCurrentDirectory(), f2)) {
-                                    // The setSelectedFile method produces a new setValueAt invocation while the JTable
-                                    // is editing. Postpone file selection to be sure that edit mode of the JTable
-                                    // is completed
-                                    SwingUtilities.invokeLater(new Runnable() {
-                                        public void run() {
-                                            if (chooser.isMultiSelectionEnabled()) {
-                                                chooser.setSelectedFiles(new File[]{f2});
-                                            } else {
-                                                chooser.setSelectedFile(f2);
-                                            }
-                                        }
-                                    });
-                                } else {
-                                    // Could be because of delay in updating Desktop folder
-                                    // chooser.setSelectedFile(null);
-                                }
-                            } else {
-                                JOptionPane.showMessageDialog(chooser, MessageFormat.format(renameErrorText, oldFileName),
-                                        renameErrorTitleText, JOptionPane.ERROR_MESSAGE);
-                            }
-                        }
-                    }
-                }
-            }
-        }
-
-        public boolean isCellEditable(int row, int column) {
-            File currentDirectory = getFileChooser().getCurrentDirectory();
-            return (!readOnly && column == COLUMN_FILENAME && canWrite(currentDirectory));
-        }
-
-        public void contentsChanged(ListDataEvent e) {
-            // Update the selection after the model has been updated
-            new DelayedSelectionUpdater();
-            fireTableDataChanged();
-        }
-
-        public void intervalAdded(ListDataEvent e) {
-            int i0 = e.getIndex0();
-            int i1 = e.getIndex1();
-            if (i0 == i1) {
-                File file = (File)getModel().getElementAt(i0);
-                if (file.equals(newFolderFile)) {
-                    new DelayedSelectionUpdater(file);
-                    newFolderFile = null;
-                }
-            }
-
-            fireTableRowsInserted(e.getIndex0(), e.getIndex1());
-        }
-        public void intervalRemoved(ListDataEvent e) {
-            fireTableRowsDeleted(e.getIndex0(), e.getIndex1());
-        }
-
-        public ShellFolderColumnInfo[] getColumns() {
-            return columns;
-        }
-    }
-
-
-    private void updateDetailsColumnModel(JTable table) {
-        if (table != null) {
-            ShellFolderColumnInfo[] columns = detailsTableModel.getColumns();
-
-            TableColumnModel columnModel = new DefaultTableColumnModel();
-            for (int i = 0; i < columns.length; i++) {
-                ShellFolderColumnInfo dataItem = columns[i];
-                TableColumn column = new TableColumn(i);
-
-                String title = dataItem.getTitle();
-                if (title != null && title.startsWith("FileChooser.") && title.endsWith("HeaderText")) {
-                    // the column must have a string resource that we try to get
-                    String uiTitle = UIManager.getString(title, table.getLocale());
-                    if (uiTitle != null) {
-                        title = uiTitle;
-                    }
-                }
-                column.setHeaderValue(title);
-
-                Integer width = dataItem.getWidth();
-                if (width != null) {
-                    column.setPreferredWidth(width);
-                    // otherwise we let JTable to decide the actual width
-                }
-
-                columnModel.addColumn(column);
-            }
-
-            // Install cell editor for editing file name
-            if (!readOnly && columnModel.getColumnCount() > COLUMN_FILENAME) {
-                columnModel.getColumn(COLUMN_FILENAME).
-                        setCellEditor(getDetailsTableCellEditor());
-            }
-
-            table.setColumnModel(columnModel);
-        }
-    }
-
-    private DetailsTableRowSorter getRowSorter() {
-        if (rowSorter == null) {
-            rowSorter = new DetailsTableRowSorter();
-        }
-        return rowSorter;
-    }
+        void updateColumnInfo() {throw new RuntimeException("cf-bug");} //{
+//            File dir = chooser.getCurrentDirectory();
+//            if (dir != null && usesShellFolder(chooser)) {
+//                try {
+//                    dir = ShellFolder.getShellFolder(dir);
+//                } catch (FileNotFoundException e) {
+//                    // Leave dir without changing
+//                }
+//            }
+//
+//            ShellFolderColumnInfo[] allColumns = ShellFolder.getFolderColumns(dir);
+//
+//            ArrayList<ShellFolderColumnInfo> visibleColumns =
+//                    new ArrayList<ShellFolderColumnInfo>();
+//            columnMap = new int[allColumns.length];
+//            for (int i = 0; i < allColumns.length; i++) {
+//                ShellFolderColumnInfo column = allColumns[i];
+//                if (column.isVisible()) {
+//                    columnMap[visibleColumns.size()] = i;
+//                    visibleColumns.add(column);
+//                }
+//            }
+//
+//            columns = new ShellFolderColumnInfo[visibleColumns.size()];
+//            visibleColumns.toArray(columns);
+//            columnMap = Arrays.copyOf(columnMap, columns.length);
+//
+//            List<? extends RowSorter.SortKey> sortKeys =
+//                    (rowSorter == null) ? null : rowSorter.getSortKeys();
+//            fireTableStructureChanged();
+//            restoreSortKeys(sortKeys);
+//        }
+
+        private void restoreSortKeys(List<? extends RowSorter.SortKey> sortKeys) {throw new RuntimeException("cf-bug");} //{
+//            if (sortKeys != null) {
+//                // check if preserved sortKeys are valid for this folder
+//                for (int i = 0; i < sortKeys.size(); i++) {
+//                    RowSorter.SortKey sortKey = sortKeys.get(i);
+//                    if (sortKey.getColumn() >= columns.length) {
+//                        sortKeys = null;
+//                        break;
+//                    }
+//                }
+//                if (sortKeys != null) {
+//                    rowSorter.setSortKeys(sortKeys);
+//                }
+//            }
+//        }
+
+        public int getRowCount() {throw new RuntimeException("cf-bug");} //{
+//            return directoryModel.getSize();
+//        }
+
+        public int getColumnCount() {throw new RuntimeException("cf-bug");} //{
+//            return columns.length;
+//        }
+
+        public Object getValueAt(int row, int col) {throw new RuntimeException("cf-bug");} //{
+//            // Note: It is very important to avoid getting info on drives, as
+//            // this will trigger "No disk in A:" and similar dialogs.
+//            //
+//            // Use (f.exists() && !chooser.getFileSystemView().isFileSystemRoot(f)) to
+//            // determine if it is safe to call methods directly on f.
+//            return getFileColumnValue((File)directoryModel.getElementAt(row), col);
+//        }
+
+        private Object getFileColumnValue(File f, int col) {throw new RuntimeException("cf-bug");} //{
+//            return (col == COLUMN_FILENAME)
+//                    ? f // always return the file itself for the 1st column
+//                    : ShellFolder.getFolderColumnValue(f, columnMap[col]);
+//        }
+
+        public void setValueAt(Object value, int row, int col) {throw new RuntimeException("cf-bug");} //{
+//            if (col == COLUMN_FILENAME) {
+//                final JFileChooser chooser = getFileChooser();
+//                File f = (File)getValueAt(row, col);
+//                if (f != null) {
+//                    String oldDisplayName = chooser.getName(f);
+//                    String oldFileName = f.getName();
+//                    String newDisplayName = ((String)value).trim();
+//                    String newFileName;
+//
+//                    if (!newDisplayName.equals(oldDisplayName)) {
+//                        newFileName = newDisplayName;
+//                        //Check if extension is hidden from user
+//                        int i1 = oldFileName.length();
+//                        int i2 = oldDisplayName.length();
+//                        if (i1 > i2 && oldFileName.charAt(i2) == '.') {
+//                            newFileName = newDisplayName + oldFileName.substring(i2);
+//                        }
+//
+//                        // rename
+//                        FileSystemView fsv = chooser.getFileSystemView();
+//                        final File f2 = fsv.createFileObject(f.getParentFile(), newFileName);
+//                        if (f2.exists()) {
+//                            JOptionPane.showMessageDialog(chooser, MessageFormat.format(renameErrorFileExistsText,
+//                                    oldFileName), renameErrorTitleText, JOptionPane.ERROR_MESSAGE);
+//                        } else {
+//                            if (FilePane.this.getModel().renameFile(f, f2)) {
+//                                if (fsv.isParent(chooser.getCurrentDirectory(), f2)) {
+//                                    // The setSelectedFile method produces a new setValueAt invocation while the JTable
+//                                    // is editing. Postpone file selection to be sure that edit mode of the JTable
+//                                    // is completed
+//                                    SwingUtilities.invokeLater(new Runnable() {
+//                                        public void run() {
+//                                            if (chooser.isMultiSelectionEnabled()) {
+//                                                chooser.setSelectedFiles(new File[]{f2});
+//                                            } else {
+//                                                chooser.setSelectedFile(f2);
+//                                            }
+//                                        }
+//                                    });
+//                                } else {
+//                                    // Could be because of delay in updating Desktop folder
+//                                    // chooser.setSelectedFile(null);
+//                                }
+//                            } else {
+//                                JOptionPane.showMessageDialog(chooser, MessageFormat.format(renameErrorText, oldFileName),
+//                                        renameErrorTitleText, JOptionPane.ERROR_MESSAGE);
+//                            }
+//                        }
+//                    }
+//                }
+//            }
+//        }
+
+        public boolean isCellEditable(int row, int column) {throw new RuntimeException("cf-bug");} //{
+//            File currentDirectory = getFileChooser().getCurrentDirectory();
+//            return (!readOnly && column == COLUMN_FILENAME && canWrite(currentDirectory));
+//        }
+
+        public void contentsChanged(ListDataEvent e) {throw new RuntimeException("cf-bug");} //{
+//            // Update the selection after the model has been updated
+//            new DelayedSelectionUpdater();
+//            fireTableDataChanged();
+//        }
+
+        public void intervalAdded(ListDataEvent e) {throw new RuntimeException("cf-bug");} //{
+//            int i0 = e.getIndex0();
+//            int i1 = e.getIndex1();
+//            if (i0 == i1) {
+//                File file = (File)getModel().getElementAt(i0);
+//                if (file.equals(newFolderFile)) {
+//                    new DelayedSelectionUpdater(file);
+//                    newFolderFile = null;
+//                }
+//            }
+//
+//            fireTableRowsInserted(e.getIndex0(), e.getIndex1());
+//        }
+        public void intervalRemoved(ListDataEvent e) {throw new RuntimeException("cf-bug");} //{
+//            fireTableRowsDeleted(e.getIndex0(), e.getIndex1());
+//        }
+
+        public ShellFolderColumnInfo[] getColumns() {throw new RuntimeException("cf-bug");} //{
+//            return columns;
+//        }
+    }
+
+
+    private void updateDetailsColumnModel(JTable table) {throw new RuntimeException("cf-bug");} //{
+//        if (table != null) {
+//            ShellFolderColumnInfo[] columns = detailsTableModel.getColumns();
+//
+//            TableColumnModel columnModel = new DefaultTableColumnModel();
+//            for (int i = 0; i < columns.length; i++) {
+//                ShellFolderColumnInfo dataItem = columns[i];
+//                TableColumn column = new TableColumn(i);
+//
+//                String title = dataItem.getTitle();
+//                if (title != null && title.startsWith("FileChooser.") && title.endsWith("HeaderText")) {
+//                    // the column must have a string resource that we try to get
+//                    String uiTitle = UIManager.getString(title, table.getLocale());
+//                    if (uiTitle != null) {
+//                        title = uiTitle;
+//                    }
+//                }
+//                column.setHeaderValue(title);
+//
+//                Integer width = dataItem.getWidth();
+//                if (width != null) {
+//                    column.setPreferredWidth(width);
+//                    // otherwise we let JTable to decide the actual width
+//                }
+//
+//                columnModel.addColumn(column);
+//            }
+//
+//            // Install cell editor for editing file name
+//            if (!readOnly && columnModel.getColumnCount() > COLUMN_FILENAME) {
+//                columnModel.getColumn(COLUMN_FILENAME).
+//                        setCellEditor(getDetailsTableCellEditor());
+//            }
+//
+//            table.setColumnModel(columnModel);
+//        }
+//    }
+
+    private DetailsTableRowSorter getRowSorter() {throw new RuntimeException("cf-bug");} //{
+//        if (rowSorter == null) {
+//            rowSorter = new DetailsTableRowSorter();
+//        }
+//        return rowSorter;
+//    }
 
     private class DetailsTableRowSorter extends TableRowSorter<TableModel> {
         public DetailsTableRowSorter() {
             setModelWrapper(new SorterModelWrapper());
         }
 
-        public void updateComparators(ShellFolderColumnInfo [] columns) {
-            for (int i = 0; i < columns.length; i++) {
-                Comparator c = columns[i].getComparator();
-                if (c != null) {
-                    c = new DirectoriesFirstComparatorWrapper(i, c);
-                }
-                setComparator(i, c);
-            }
-        }
+        public void updateComparators(ShellFolderColumnInfo [] columns) {throw new RuntimeException("cf-bug");} //{
+//            for (int i = 0; i < columns.length; i++) {
+//                Comparator c = columns[i].getComparator();
+//                if (c != null) {
+//                    c = new DirectoriesFirstComparatorWrapper(i, c);
+//                }
+//                setComparator(i, c);
+//            }
+//        }
 
         @Override
-        public void sort() {
-            ShellFolder.invoke(new Callable<Void>() {
-                public Void call() {
-                    DetailsTableRowSorter.super.sort();
-                    return null;
-                }
-            });
-        }
-
-        public void modelStructureChanged() {
-            super.modelStructureChanged();
-            updateComparators(detailsTableModel.getColumns());
-        }
+        public void sort() {throw new RuntimeException("cf-bug");} //{
+//            ShellFolder.invoke(new Callable<Void>() {
+//                public Void call() {
+//                    DetailsTableRowSorter.super.sort();
+//                    return null;
+//                }
+//            });
+//        }
+
+        public void modelStructureChanged() {throw new RuntimeException("cf-bug");} //{
+//            super.modelStructureChanged();
+//            updateComparators(detailsTableModel.getColumns());
+//        }
 
         private class SorterModelWrapper extends ModelWrapper<TableModel, Integer> {
-            public TableModel getModel() {
-                return getDetailsTableModel();
-            }
-
-            public int getColumnCount() {
-                return getDetailsTableModel().getColumnCount();
-            }
-
-            public int getRowCount() {
-                return getDetailsTableModel().getRowCount();
-            }
-
-            public Object getValueAt(int row, int column) {
-                return FilePane.this.getModel().getElementAt(row);
-            }
-
-            public Integer getIdentifier(int row) {
-                return row;
-            }
+            public TableModel getModel() {throw new RuntimeException("cf-bug");} //{
+//                return getDetailsTableModel();
+//            }
+
+            public int getColumnCount() {throw new RuntimeException("cf-bug");} //{
+//                return getDetailsTableModel().getColumnCount();
+//            }
+
+            public int getRowCount() {throw new RuntimeException("cf-bug");} //{
+//                return getDetailsTableModel().getRowCount();
+//            }
+
+            public Object getValueAt(int row, int column) {throw new RuntimeException("cf-bug");} //{
+//                return FilePane.this.getModel().getElementAt(row);
+//            }
+
+            public Integer getIdentifier(int row) {throw new RuntimeException("cf-bug");} //{
+//                return row;
+//            }
         }
     }
 
@@ -970,38 +970,38 @@
             this.comparator = comparator;
         }
 
-        public int compare(File f1, File f2) {
-            if (f1 != null && f2 != null) {
-                boolean traversable1 = getFileChooser().isTraversable(f1);
-                boolean traversable2 = getFileChooser().isTraversable(f2);
-                // directories go first
-                if (traversable1 && !traversable2) {
-                    return -1;
-                }
-                if (!traversable1 && traversable2) {
-                    return 1;
-                }
-            }
-            if (detailsTableModel.getColumns()[column].isCompareByColumn()) {
-                return comparator.compare(
-                        getDetailsTableModel().getFileColumnValue(f1, column),
-                        getDetailsTableModel().getFileColumnValue(f2, column)
-                );
-            }
-            // For this column we need to pass the file itself (not a
-            // column value) to the comparator
-            return comparator.compare(f1, f2);
-        }
+        public int compare(File f1, File f2) {throw new RuntimeException("cf-bug");} //{
+//            if (f1 != null && f2 != null) {
+//                boolean traversable1 = getFileChooser().isTraversable(f1);
+//                boolean traversable2 = getFileChooser().isTraversable(f2);
+//                // directories go first
+//                if (traversable1 && !traversable2) {
+//                    return -1;
+//                }
+//                if (!traversable1 && traversable2) {
+//                    return 1;
+//                }
+//            }
+//            if (detailsTableModel.getColumns()[column].isCompareByColumn()) {
+//                return comparator.compare(
+//                        getDetailsTableModel().getFileColumnValue(f1, column),
+//                        getDetailsTableModel().getFileColumnValue(f2, column)
+//                );
+//            }
+//            // For this column we need to pass the file itself (not a
+//            // column value) to the comparator
+//            return comparator.compare(f1, f2);
+//        }
     }
 
     private DetailsTableCellEditor tableCellEditor;
 
-    private DetailsTableCellEditor getDetailsTableCellEditor() {
-        if (tableCellEditor == null) {
-            tableCellEditor = new DetailsTableCellEditor(new JTextField());
-        }
-        return tableCellEditor;
-    }
+    private DetailsTableCellEditor getDetailsTableCellEditor() {throw new RuntimeException("cf-bug");} //{
+//        if (tableCellEditor == null) {
+//            tableCellEditor = new DetailsTableCellEditor(new JTextField());
+//        }
+//        return tableCellEditor;
+//    }
 
     private class DetailsTableCellEditor extends DefaultCellEditor {
         private final JTextField tf;
@@ -1014,15 +1014,15 @@
         }
 
         public Component getTableCellEditorComponent(JTable table, Object value,
-                                                     boolean isSelected, int row, int column) {
-            Component comp = super.getTableCellEditorComponent(table, value,
-                    isSelected, row, column);
-            if (value instanceof File) {
-                tf.setText(getFileChooser().getName((File) value));
-                tf.selectAll();
-            }
-            return comp;
-        }
+                                                     boolean isSelected, int row, int column) {throw new RuntimeException("cf-bug");} //{
+//            Component comp = super.getTableCellEditorComponent(table, value,
+//                    isSelected, row, column);
+//            if (value instanceof File) {
+//                tf.setText(getFileChooser().getName((File) value));
+//                tf.selectAll();
+//            }
+//            return comp;
+//        }
     }
 
 
@@ -1036,212 +1036,212 @@
                                                 chooser.getLocale());
         }
 
-        public void setBounds(int x, int y, int width, int height) {
-        if (getHorizontalAlignment() == SwingConstants.LEADING &&
-                    !fullRowSelection) {
-                // Restrict width to actual text
-                width = Math.min(width, this.getPreferredSize().width+4);
-            } else {
-                x -= 4;
-            }
-            super.setBounds(x, y, width, height);
-        }
-
-
-        public Insets getInsets(Insets i) {
-            // Provide some space between columns
-            i = super.getInsets(i);
-            i.left  += 4;
-            i.right += 4;
-            return i;
-        }
+        public void setBounds(int x, int y, int width, int height) {throw new RuntimeException("cf-bug");} //{
+//        if (getHorizontalAlignment() == SwingConstants.LEADING &&
+//                    !fullRowSelection) {
+//                // Restrict width to actual text
+//                width = Math.min(width, this.getPreferredSize().width+4);
+//            } else {
+//                x -= 4;
+//            }
+//            super.setBounds(x, y, width, height);
+//        }
+
+
+        public Insets getInsets(Insets i) {throw new RuntimeException("cf-bug");} //{
+//            // Provide some space between columns
+//            i = super.getInsets(i);
+//            i.left  += 4;
+//            i.right += 4;
+//            return i;
+//        }
 
         public Component getTableCellRendererComponent(JTable table, Object value,
-                              boolean isSelected, boolean hasFocus, int row, int column) {
-
-            if ((table.convertColumnIndexToModel(column) != COLUMN_FILENAME ||
-                    (listViewWindowsStyle && !table.isFocusOwner())) &&
-                    !fullRowSelection) {
-                isSelected = false;
-            }
-
-            super.getTableCellRendererComponent(table, value, isSelected,
-                                                       hasFocus, row, column);
-
-            setIcon(null);
-
-            int modelColumn = table.convertColumnIndexToModel(column);
-            ShellFolderColumnInfo columnInfo = detailsTableModel.getColumns()[modelColumn];
-
-            Integer alignment = columnInfo.getAlignment();
-            if (alignment == null) {
-                alignment = (value instanceof Number)
-                        ? SwingConstants.RIGHT
-                        : SwingConstants.LEADING;
-            }
-
-            setHorizontalAlignment(alignment);
-
-            // formatting cell text
-            // TODO: it's rather a temporary trick, to be revised
-            String text;
-
-            if (value == null) {
-                text = "";
-
-            } else if (value instanceof File) {
-                File file = (File)value;
-                text = chooser.getName(file);
-                Icon icon = chooser.getIcon(file);
-                setIcon(icon);
-
-            } else if (value instanceof Long) {
-                long len = ((Long) value) / 1024L;
-                if (listViewWindowsStyle) {
-                    text = MessageFormat.format(kiloByteString, len + 1);
-                } else if (len < 1024L) {
-                    text = MessageFormat.format(kiloByteString, (len == 0L) ? 1L : len);
-                } else {
-                    len /= 1024L;
-                    if (len < 1024L) {
-                        text = MessageFormat.format(megaByteString, len);
-                    } else {
-                        len /= 1024L;
-                        text = MessageFormat.format(gigaByteString, len);
-                    }
-                }
-
-            } else if (value instanceof Date) {
-                text = df.format((Date)value);
-
-            } else {
-                text = value.toString();
-            }
-
-            setText(text);
-
-            return this;
-        }
-    }
-
-    public JPanel createDetailsView() {
-        final JFileChooser chooser = getFileChooser();
-
-        JPanel p = new JPanel(new BorderLayout());
-
-        final JTable detailsTable = new JTable(getDetailsTableModel()) {
-            // Handle Escape key events here
-            protected boolean processKeyBinding(KeyStroke ks, KeyEvent e, int condition, boolean pressed) {
-                if (e.getKeyCode() == KeyEvent.VK_ESCAPE && getCellEditor() == null) {
-                    // We are not editing, forward to filechooser.
-                    chooser.dispatchEvent(e);
-                    return true;
-                }
-                return super.processKeyBinding(ks, e, condition, pressed);
-            }
-
-            public void tableChanged(TableModelEvent e) {
-                super.tableChanged(e);
-
-                if (e.getFirstRow() == TableModelEvent.HEADER_ROW) {
-                    // update header with possibly changed column set
-                    updateDetailsColumnModel(this);
-                }
-            }
-        };
-
-        detailsTable.setRowSorter(getRowSorter());
-        detailsTable.setAutoCreateColumnsFromModel(false);
-        detailsTable.setComponentOrientation(chooser.getComponentOrientation());
-        detailsTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
-        detailsTable.setShowGrid(false);
-        detailsTable.putClientProperty("JTable.autoStartsEdit", Boolean.FALSE);
-        detailsTable.addKeyListener(detailsKeyListener);
-
-        Font font = list.getFont();
-        detailsTable.setFont(font);
-        detailsTable.setIntercellSpacing(new Dimension(0, 0));
-
-        TableCellRenderer headerRenderer =
-                new AlignableTableHeaderRenderer(detailsTable.getTableHeader().getDefaultRenderer());
-        detailsTable.getTableHeader().setDefaultRenderer(headerRenderer);
-        TableCellRenderer cellRenderer = new DetailsTableCellRenderer(chooser);
-        detailsTable.setDefaultRenderer(Object.class, cellRenderer);
-
-        // So that drag can be started on a mouse press
-        detailsTable.getColumnModel().getSelectionModel().
-            setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
-
-        detailsTable.addMouseListener(getMouseHandler());
-        // No need to addListSelectionListener because selections are forwarded
-        // to our JList.
-
-        // 4835633 : tell BasicTableUI that this is a file list
-        detailsTable.putClientProperty("Table.isFileList", Boolean.TRUE);
-
-        if (listViewWindowsStyle) {
-            detailsTable.addFocusListener(repaintListener);
-        }
-
-        // TAB/SHIFT-TAB should transfer focus and ENTER should select an item.
-        // We don't want them to navigate within the table
-        ActionMap am = SwingUtilities.getUIActionMap(detailsTable);
-        am.remove("selectNextRowCell");
-        am.remove("selectPreviousRowCell");
-        am.remove("selectNextColumnCell");
-        am.remove("selectPreviousColumnCell");
-        detailsTable.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
-                     null);
-        detailsTable.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
-                     null);
-
-        JScrollPane scrollpane = new JScrollPane(detailsTable);
-        scrollpane.setComponentOrientation(chooser.getComponentOrientation());
-        LookAndFeel.installColors(scrollpane.getViewport(), "Table.background", "Table.foreground");
-
-        // Adjust width of first column so the table fills the viewport when
-        // first displayed (temporary listener).
-        scrollpane.addComponentListener(new ComponentAdapter() {
-            public void componentResized(ComponentEvent e) {
-                JScrollPane sp = (JScrollPane)e.getComponent();
-                fixNameColumnWidth(sp.getViewport().getSize().width);
-                sp.removeComponentListener(this);
-            }
-        });
-
-        // 4835633.
-        // If the mouse is pressed in the area below the Details view table, the
-        // event is not dispatched to the Table MouseListener but to the
-        // scrollpane.  Listen for that here so we can clear the selection.
-        scrollpane.addMouseListener(new MouseAdapter() {
-            public void mousePressed(MouseEvent e) {
-                JScrollPane jsp = ((JScrollPane)e.getComponent());
-                JTable table = (JTable)jsp.getViewport().getView();
-
-                if (!e.isShiftDown() || table.getSelectionModel().getSelectionMode() == ListSelectionModel.SINGLE_SELECTION) {
-                    clearSelection();
-                    TableCellEditor tce = table.getCellEditor();
-                    if (tce != null) {
-                        tce.stopCellEditing();
-                    }
-                }
-            }
-        });
-
-        detailsTable.setForeground(list.getForeground());
-        detailsTable.setBackground(list.getBackground());
-
-        if (listViewBorder != null) {
-            scrollpane.setBorder(listViewBorder);
-        }
-        p.add(scrollpane, BorderLayout.CENTER);
-
-        detailsTableModel.fireTableStructureChanged();
-
-        detailsTable.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY, filesDetailsAccessibleName);
-
-        return p;
-    } // createDetailsView
+                              boolean isSelected, boolean hasFocus, int row, int column) {throw new RuntimeException("cf-bug");} //{
+//
+//            if ((table.convertColumnIndexToModel(column) != COLUMN_FILENAME ||
+//                    (listViewWindowsStyle && !table.isFocusOwner())) &&
+//                    !fullRowSelection) {
+//                isSelected = false;
+//            }
+//
+//            super.getTableCellRendererComponent(table, value, isSelected,
+//                                                       hasFocus, row, column);
+//
+//            setIcon(null);
+//
+//            int modelColumn = table.convertColumnIndexToModel(column);
+//            ShellFolderColumnInfo columnInfo = detailsTableModel.getColumns()[modelColumn];
+//
+//            Integer alignment = columnInfo.getAlignment();
+//            if (alignment == null) {
+//                alignment = (value instanceof Number)
+//                        ? SwingConstants.RIGHT
+//                        : SwingConstants.LEADING;
+//            }
+//
+//            setHorizontalAlignment(alignment);
+//
+//            // formatting cell text
+//            // TODO: it's rather a temporary trick, to be revised
+//            String text;
+//
+//            if (value == null) {
+//                text = "";
+//
+//            } else if (value instanceof File) {
+//                File file = (File)value;
+//                text = chooser.getName(file);
+//                Icon icon = chooser.getIcon(file);
+//                setIcon(icon);
+//
+//            } else if (value instanceof Long) {
+//                long len = ((Long) value) / 1024L;
+//                if (listViewWindowsStyle) {
+//                    text = MessageFormat.format(kiloByteString, len + 1);
+//                } else if (len < 1024L) {
+//                    text = MessageFormat.format(kiloByteString, (len == 0L) ? 1L : len);
+//                } else {
+//                    len /= 1024L;
+//                    if (len < 1024L) {
+//                        text = MessageFormat.format(megaByteString, len);
+//                    } else {
+//                        len /= 1024L;
+//                        text = MessageFormat.format(gigaByteString, len);
+//                    }
+//                }
+//
+//            } else if (value instanceof Date) {
+//                text = df.format((Date)value);
+//
+//            } else {
+//                text = value.toString();
+//            }
+//
+//            setText(text);
+//
+//            return this;
+//        }
+    }
+
+    public JPanel createDetailsView() {throw new RuntimeException("cf-bug");} //{
+//        final JFileChooser chooser = getFileChooser();
+//
+//        JPanel p = new JPanel(new BorderLayout());
+//
+//        final JTable detailsTable = new JTable(getDetailsTableModel()) {
+//            // Handle Escape key events here
+//            protected boolean processKeyBinding(KeyStroke ks, KeyEvent e, int condition, boolean pressed) {
+//                if (e.getKeyCode() == KeyEvent.VK_ESCAPE && getCellEditor() == null) {
+//                    // We are not editing, forward to filechooser.
+//                    chooser.dispatchEvent(e);
+//                    return true;
+//                }
+//                return super.processKeyBinding(ks, e, condition, pressed);
+//            }
+//
+//            public void tableChanged(TableModelEvent e) {
+//                super.tableChanged(e);
+//
+//                if (e.getFirstRow() == TableModelEvent.HEADER_ROW) {
+//                    // update header with possibly changed column set
+//                    updateDetailsColumnModel(this);
+//                }
+//            }
+//        };
+//
+//        detailsTable.setRowSorter(getRowSorter());
+//        detailsTable.setAutoCreateColumnsFromModel(false);
+//        detailsTable.setComponentOrientation(chooser.getComponentOrientation());
+//        detailsTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
+//        detailsTable.setShowGrid(false);
+//        detailsTable.putClientProperty("JTable.autoStartsEdit", Boolean.FALSE);
+//        detailsTable.addKeyListener(detailsKeyListener);
+//
+//        Font font = list.getFont();
+//        detailsTable.setFont(font);
+//        detailsTable.setIntercellSpacing(new Dimension(0, 0));
+//
+//        TableCellRenderer headerRenderer =
+//                new AlignableTableHeaderRenderer(detailsTable.getTableHeader().getDefaultRenderer());
+//        detailsTable.getTableHeader().setDefaultRenderer(headerRenderer);
+//        TableCellRenderer cellRenderer = new DetailsTableCellRenderer(chooser);
+//        detailsTable.setDefaultRenderer(Object.class, cellRenderer);
+//
+//        // So that drag can be started on a mouse press
+//        detailsTable.getColumnModel().getSelectionModel().
+//            setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+//
+//        detailsTable.addMouseListener(getMouseHandler());
+//        // No need to addListSelectionListener because selections are forwarded
+//        // to our JList.
+//
+//        // 4835633 : tell BasicTableUI that this is a file list
+//        detailsTable.putClientProperty("Table.isFileList", Boolean.TRUE);
+//
+//        if (listViewWindowsStyle) {
+//            detailsTable.addFocusListener(repaintListener);
+//        }
+//
+//        // TAB/SHIFT-TAB should transfer focus and ENTER should select an item.
+//        // We don't want them to navigate within the table
+//        ActionMap am = SwingUtilities.getUIActionMap(detailsTable);
+//        am.remove("selectNextRowCell");
+//        am.remove("selectPreviousRowCell");
+//        am.remove("selectNextColumnCell");
+//        am.remove("selectPreviousColumnCell");
+//        detailsTable.setFocusTraversalKeys(KeyboardFocusManager.FORWARD_TRAVERSAL_KEYS,
+//                     null);
+//        detailsTable.setFocusTraversalKeys(KeyboardFocusManager.BACKWARD_TRAVERSAL_KEYS,
+//                     null);
+//
+//        JScrollPane scrollpane = new JScrollPane(detailsTable);
+//        scrollpane.setComponentOrientation(chooser.getComponentOrientation());
+//        LookAndFeel.installColors(scrollpane.getViewport(), "Table.background", "Table.foreground");
+//
+//        // Adjust width of first column so the table fills the viewport when
+//        // first displayed (temporary listener).
+//        scrollpane.addComponentListener(new ComponentAdapter() {
+//            public void componentResized(ComponentEvent e) {
+//                JScrollPane sp = (JScrollPane)e.getComponent();
+//                fixNameColumnWidth(sp.getViewport().getSize().width);
+//                sp.removeComponentListener(this);
+//            }
+//        });
+//
+//        // 4835633.
+//        // If the mouse is pressed in the area below the Details view table, the
+//        // event is not dispatched to the Table MouseListener but to the
+//        // scrollpane.  Listen for that here so we can clear the selection.
+//        scrollpane.addMouseListener(new MouseAdapter() {
+//            public void mousePressed(MouseEvent e) {
+//                JScrollPane jsp = ((JScrollPane)e.getComponent());
+//                JTable table = (JTable)jsp.getViewport().getView();
+//
+//                if (!e.isShiftDown() || table.getSelectionModel().getSelectionMode() == ListSelectionModel.SINGLE_SELECTION) {
+//                    clearSelection();
+//                    TableCellEditor tce = table.getCellEditor();
+//                    if (tce != null) {
+//                        tce.stopCellEditing();
+//                    }
+//                }
+//            }
+//        });
+//
+//        detailsTable.setForeground(list.getForeground());
+//        detailsTable.setBackground(list.getBackground());
+//
+//        if (listViewBorder != null) {
+//            scrollpane.setBorder(listViewBorder);
+//        }
+//        p.add(scrollpane, BorderLayout.CENTER);
+//
+//        detailsTableModel.fireTableStructureChanged();
+//
+//        detailsTable.putClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY, filesDetailsAccessibleName);
+//
+//        return p;
+//    } // createDetailsView
 
     private class AlignableTableHeaderRenderer implements TableCellRenderer {
         TableCellRenderer wrappedRenderer;
@@ -1252,34 +1252,34 @@
 
         public Component getTableCellRendererComponent(
                                 JTable table, Object value, boolean isSelected,
-                                boolean hasFocus, int row, int column) {
-
-            Component c = wrappedRenderer.getTableCellRendererComponent(
-                                table, value, isSelected, hasFocus, row, column);
-
-            int modelColumn = table.convertColumnIndexToModel(column);
-            ShellFolderColumnInfo columnInfo = detailsTableModel.getColumns()[modelColumn];
-
-            Integer alignment = columnInfo.getAlignment();
-            if (alignment == null) {
-                alignment = SwingConstants.CENTER;
-            }
-            if (c instanceof JLabel) {
-                ((JLabel) c).setHorizontalAlignment(alignment);
-            }
-
-            return c;
-        }
-    }
-
-    private void fixNameColumnWidth(int viewWidth) {
-        TableColumn nameCol = detailsTable.getColumnModel().getColumn(COLUMN_FILENAME);
-        int tableWidth = detailsTable.getPreferredSize().width;
-
-        if (tableWidth < viewWidth) {
-            nameCol.setPreferredWidth(nameCol.getPreferredWidth() + viewWidth - tableWidth);
-        }
-    }
+                                boolean hasFocus, int row, int column) {throw new RuntimeException("cf-bug");} //{
+//
+//            Component c = wrappedRenderer.getTableCellRendererComponent(
+//                                table, value, isSelected, hasFocus, row, column);
+//
+//            int modelColumn = table.convertColumnIndexToModel(column);
+//            ShellFolderColumnInfo columnInfo = detailsTableModel.getColumns()[modelColumn];
+//
+//            Integer alignment = columnInfo.getAlignment();
+//            if (alignment == null) {
+//                alignment = SwingConstants.CENTER;
+//            }
+//            if (c instanceof JLabel) {
+//                ((JLabel) c).setHorizontalAlignment(alignment);
+//            }
+//
+//            return c;
+//        }
+    }
+
+    private void fixNameColumnWidth(int viewWidth) {throw new RuntimeException("cf-bug");} //{
+//        TableColumn nameCol = detailsTable.getColumnModel().getColumn(COLUMN_FILENAME);
+//        int tableWidth = detailsTable.getPreferredSize().width;
+//
+//        if (tableWidth < viewWidth) {
+//            nameCol.setPreferredWidth(nameCol.getPreferredWidth() + viewWidth - tableWidth);
+//        }
+//    }
 
     private class DelayedSelectionUpdater implements Runnable {
         File editFile;
@@ -1295,14 +1295,14 @@
             }
         }
 
-        public void run() {
-            setFileSelected();
-            if (editFile != null) {
-                editFileName(getRowSorter().convertRowIndexToView(
-                        getModel().indexOf(editFile)));
-                editFile = null;
-            }
-        }
+        public void run() {throw new RuntimeException("cf-bug");} //{
+//            setFileSelected();
+//            if (editFile != null) {
+//                editFileName(getRowSorter().convertRowIndexToView(
+//                        getModel().indexOf(editFile)));
+//                editFile = null;
+//            }
+//        }
     }
 
 
@@ -1311,630 +1311,630 @@
      *
      * @return a <code>ListSelectionListener</code>
      */
-    public ListSelectionListener createListSelectionListener() {
-        return fileChooserUIAccessor.createListSelectionListener();
-    }
+    public ListSelectionListener createListSelectionListener() {throw new RuntimeException("cf-bug");} //{
+//        return fileChooserUIAccessor.createListSelectionListener();
+//    }
 
     int lastIndex = -1;
     File editFile = null;
 
-    private int getEditIndex() {
-        return lastIndex;
-    }
-
-    private void setEditIndex(int i) {
-        lastIndex = i;
-    }
-
-    private void resetEditIndex() {
-        lastIndex = -1;
-    }
-
-    private void cancelEdit() {
-        if (editFile != null) {
-            editFile = null;
-            list.remove(editCell);
-            repaint();
-        } else if (detailsTable != null && detailsTable.isEditing()) {
-            detailsTable.getCellEditor().cancelCellEditing();
-        }
-    }
+    private int getEditIndex() {throw new RuntimeException("cf-bug");} //{
+//        return lastIndex;
+//    }
+
+    private void setEditIndex(int i) {throw new RuntimeException("cf-bug");} //{
+//        lastIndex = i;
+//    }
+
+    private void resetEditIndex() {throw new RuntimeException("cf-bug");} //{
+//        lastIndex = -1;
+//    }
+
+    private void cancelEdit() {throw new RuntimeException("cf-bug");} //{
+//        if (editFile != null) {
+//            editFile = null;
+//            list.remove(editCell);
+//            repaint();
+//        } else if (detailsTable != null && detailsTable.isEditing()) {
+//            detailsTable.getCellEditor().cancelCellEditing();
+//        }
+//    }
 
     JTextField editCell = null;
 
     /**
      * @param index visual index of the file to be edited
      */
-    private void editFileName(int index) {
-        JFileChooser chooser = getFileChooser();
-        File currentDirectory = chooser.getCurrentDirectory();
-
-        if (readOnly || !canWrite(currentDirectory)) {
-            return;
-        }
-
-        ensureIndexIsVisible(index);
-        switch (viewType) {
-          case VIEWTYPE_LIST:
-            editFile = (File)getModel().getElementAt(getRowSorter().convertRowIndexToModel(index));
-            Rectangle r = list.getCellBounds(index, index);
-            if (editCell == null) {
-                editCell = new JTextField();
-                editCell.setName("Tree.cellEditor");
-                editCell.addActionListener(new EditActionListener());
-                editCell.addFocusListener(editorFocusListener);
-                editCell.setNextFocusableComponent(list);
-            }
-            list.add(editCell);
-            editCell.setText(chooser.getName(editFile));
-            ComponentOrientation orientation = list.getComponentOrientation();
-            editCell.setComponentOrientation(orientation);
-
-            Icon icon = chooser.getIcon(editFile);
-
-            // PENDING - grab padding (4) below from defaults table.
-            int editX = icon == null ? 20 : icon.getIconWidth() + 4;
-
-            if (orientation.isLeftToRight()) {
-                editCell.setBounds(editX + r.x, r.y, r.width - editX, r.height);
-            } else {
-                editCell.setBounds(r.x, r.y, r.width - editX, r.height);
-            }
-            editCell.requestFocus();
-            editCell.selectAll();
-            break;
-
-          case VIEWTYPE_DETAILS:
-            detailsTable.editCellAt(index, COLUMN_FILENAME);
-            break;
-        }
-    }
+    private void editFileName(int index) {throw new RuntimeException("cf-bug");} //{
+//        JFileChooser chooser = getFileChooser();
+//        File currentDirectory = chooser.getCurrentDirectory();
+//
+//        if (readOnly || !canWrite(currentDirectory)) {
+//            return;
+//        }
+//
+//        ensureIndexIsVisible(index);
+//        switch (viewType) {
+//          case VIEWTYPE_LIST:
+//            editFile = (File)getModel().getElementAt(getRowSorter().convertRowIndexToModel(index));
+//            Rectangle r = list.getCellBounds(index, index);
+//            if (editCell == null) {
+//                editCell = new JTextField();
+//                editCell.setName("Tree.cellEditor");
+//                editCell.addActionListener(new EditActionListener());
+//                editCell.addFocusListener(editorFocusListener);
+//                editCell.setNextFocusableComponent(list);
+//            }
+//            list.add(editCell);
+//            editCell.setText(chooser.getName(editFile));
+//            ComponentOrientation orientation = list.getComponentOrientation();
+//            editCell.setComponentOrientation(orientation);
+//
+//            Icon icon = chooser.getIcon(editFile);
+//
+//            // PENDING - grab padding (4) below from defaults table.
+//            int editX = icon == null ? 20 : icon.getIconWidth() + 4;
+//
+//            if (orientation.isLeftToRight()) {
+//                editCell.setBounds(editX + r.x, r.y, r.width - editX, r.height);
+//            } else {
+//                editCell.setBounds(r.x, r.y, r.width - editX, r.height);
+//            }
+//            editCell.requestFocus();
+//            editCell.selectAll();
+//            break;
+//
+//          case VIEWTYPE_DETAILS:
+//            detailsTable.editCellAt(index, COLUMN_FILENAME);
+//            break;
+//        }
+//    }
 
 
     class EditActionListener implements ActionListener {
-        public void actionPerformed(ActionEvent e) {
-            applyEdit();
-        }
-    }
-
-    private void applyEdit() {
-        if (editFile != null && editFile.exists()) {
-            JFileChooser chooser = getFileChooser();
-            String oldDisplayName = chooser.getName(editFile);
-            String oldFileName = editFile.getName();
-            String newDisplayName = editCell.getText().trim();
-            String newFileName;
-
-            if (!newDisplayName.equals(oldDisplayName)) {
-                newFileName = newDisplayName;
-                //Check if extension is hidden from user
-                int i1 = oldFileName.length();
-                int i2 = oldDisplayName.length();
-                if (i1 > i2 && oldFileName.charAt(i2) == '.') {
-                    newFileName = newDisplayName + oldFileName.substring(i2);
-                }
-
-                // rename
-                FileSystemView fsv = chooser.getFileSystemView();
-                File f2 = fsv.createFileObject(editFile.getParentFile(), newFileName);
-                if (f2.exists()) {
-                    JOptionPane.showMessageDialog(chooser, MessageFormat.format(renameErrorFileExistsText, oldFileName),
-                            renameErrorTitleText, JOptionPane.ERROR_MESSAGE);
-                } else {
-                    if (getModel().renameFile(editFile, f2)) {
-                        if (fsv.isParent(chooser.getCurrentDirectory(), f2)) {
-                            if (chooser.isMultiSelectionEnabled()) {
-                                chooser.setSelectedFiles(new File[]{f2});
-                            } else {
-                                chooser.setSelectedFile(f2);
-                            }
-                        } else {
-                            //Could be because of delay in updating Desktop folder
-                            //chooser.setSelectedFile(null);
-                        }
-                    } else {
-                        JOptionPane.showMessageDialog(chooser, MessageFormat.format(renameErrorText, oldFileName),
-                                renameErrorTitleText, JOptionPane.ERROR_MESSAGE);
-                    }
-                }
-            }
-        }
-        if (detailsTable != null && detailsTable.isEditing()) {
-            detailsTable.getCellEditor().stopCellEditing();
-        }
-        cancelEdit();
-    }
+        public void actionPerformed(ActionEvent e) {throw new RuntimeException("cf-bug");} //{
+//            applyEdit();
+//        }
+    }
+
+    private void applyEdit() {throw new RuntimeException("cf-bug");} //{
+//        if (editFile != null && editFile.exists()) {
+//            JFileChooser chooser = getFileChooser();
+//            String oldDisplayName = chooser.getName(editFile);
+//            String oldFileName = editFile.getName();
+//            String newDisplayName = editCell.getText().trim();
+//            String newFileName;
+//
+//            if (!newDisplayName.equals(oldDisplayName)) {
+//                newFileName = newDisplayName;
+//                //Check if extension is hidden from user
+//                int i1 = oldFileName.length();
+//                int i2 = oldDisplayName.length();
+//                if (i1 > i2 && oldFileName.charAt(i2) == '.') {
+//                    newFileName = newDisplayName + oldFileName.substring(i2);
+//                }
+//
+//                // rename
+//                FileSystemView fsv = chooser.getFileSystemView();
+//                File f2 = fsv.createFileObject(editFile.getParentFile(), newFileName);
+//                if (f2.exists()) {
+//                    JOptionPane.showMessageDialog(chooser, MessageFormat.format(renameErrorFileExistsText, oldFileName),
+//                            renameErrorTitleText, JOptionPane.ERROR_MESSAGE);
+//                } else {
+//                    if (getModel().renameFile(editFile, f2)) {
+//                        if (fsv.isParent(chooser.getCurrentDirectory(), f2)) {
+//                            if (chooser.isMultiSelectionEnabled()) {
+//                                chooser.setSelectedFiles(new File[]{f2});
+//                            } else {
+//                                chooser.setSelectedFile(f2);
+//                            }
+//                        } else {
+//                            //Could be because of delay in updating Desktop folder
+//                            //chooser.setSelectedFile(null);
+//                        }
+//                    } else {
+//                        JOptionPane.showMessageDialog(chooser, MessageFormat.format(renameErrorText, oldFileName),
+//                                renameErrorTitleText, JOptionPane.ERROR_MESSAGE);
+//                    }
+//                }
+//            }
+//        }
+//        if (detailsTable != null && detailsTable.isEditing()) {
+//            detailsTable.getCellEditor().stopCellEditing();
+//        }
+//        cancelEdit();
+//    }
 
     protected Action newFolderAction;
 
-    public Action getNewFolderAction() {
-        if (!readOnly && newFolderAction == null) {
-            newFolderAction = new AbstractAction(newFolderActionLabelText) {
-                private Action basicNewFolderAction;
-
-                // Initializer
-                {
-                    putValue(Action.ACTION_COMMAND_KEY, FilePane.ACTION_NEW_FOLDER);
-
-                    File currentDirectory = getFileChooser().getCurrentDirectory();
-                    if (currentDirectory != null) {
-                        setEnabled(canWrite(currentDirectory));
-                    }
-                }
-
-                public void actionPerformed(ActionEvent ev) {
-                    if (basicNewFolderAction == null) {
-                        basicNewFolderAction = fileChooserUIAccessor.getNewFolderAction();
-                    }
-                    JFileChooser fc = getFileChooser();
-                    File oldFile = fc.getSelectedFile();
-                    basicNewFolderAction.actionPerformed(ev);
-                    File newFile = fc.getSelectedFile();
-                    if (newFile != null && !newFile.equals(oldFile) && newFile.isDirectory()) {
-                        newFolderFile = newFile;
-                    }
-                }
-            };
-        }
-        return newFolderAction;
-    }
+    public Action getNewFolderAction() {throw new RuntimeException("cf-bug");} //{
+//        if (!readOnly && newFolderAction == null) {
+//            newFolderAction = new AbstractAction(newFolderActionLabelText) {
+//                private Action basicNewFolderAction;
+//
+//                // Initializer
+//                {
+//                    putValue(Action.ACTION_COMMAND_KEY, FilePane.ACTION_NEW_FOLDER);
+//
+//                    File currentDirectory = getFileChooser().getCurrentDirectory();
+//                    if (currentDirectory != null) {
+//                        setEnabled(canWrite(currentDirectory));
+//                    }
+//                }
+//
+//                public void actionPerformed(ActionEvent ev) {
+//                    if (basicNewFolderAction == null) {
+//                        basicNewFolderAction = fileChooserUIAccessor.getNewFolderAction();
+//                    }
+//                    JFileChooser fc = getFileChooser();
+//                    File oldFile = fc.getSelectedFile();
+//                    basicNewFolderAction.actionPerformed(ev);
+//                    File newFile = fc.getSelectedFile();
+//                    if (newFile != null && !newFile.equals(oldFile) && newFile.isDirectory()) {
+//                        newFolderFile = newFile;
+//                    }
+//                }
+//            };
+//        }
+//        return newFolderAction;
+//    }
 
     protected class FileRenderer extends DefaultListCellRenderer  {
 
         public Component getListCellRendererComponent(JList list, Object value,
                                                       int index, boolean isSelected,
-                                                      boolean cellHasFocus) {
-
-            if (listViewWindowsStyle && !list.isFocusOwner()) {
-                isSelected = false;
-            }
-
-            super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
-            File file = (File) value;
-            String fileName = getFileChooser().getName(file);
-            setText(fileName);
-            setFont(list.getFont());
-
-            Icon icon = getFileChooser().getIcon(file);
-            if (icon != null) {
-                setIcon(icon);
-            } else {
-                if (getFileChooser().getFileSystemView().isTraversable(file)) {
-                    setText(fileName+File.separator);
-                }
-            }
-
-            return this;
-        }
-    }
-
-
-    void setFileSelected() {
-        if (getFileChooser().isMultiSelectionEnabled() && !isDirectorySelected()) {
-            File[] files = getFileChooser().getSelectedFiles(); // Should be selected
-            Object[] selectedObjects = list.getSelectedValues(); // Are actually selected
-
-            listSelectionModel.setValueIsAdjusting(true);
-            try {
-                int lead = listSelectionModel.getLeadSelectionIndex();
-                int anchor = listSelectionModel.getAnchorSelectionIndex();
-
-                Arrays.sort(files);
-                Arrays.sort(selectedObjects);
-
-                int shouldIndex = 0;
-                int actuallyIndex = 0;
-
-                // Remove files that shouldn't be selected and add files which should be selected
-                // Note: Assume files are already sorted in compareTo order.
-                while (shouldIndex < files.length &&
-                       actuallyIndex < selectedObjects.length) {
-                    int comparison = files[shouldIndex].compareTo((File)selectedObjects[actuallyIndex]);
-                    if (comparison < 0) {
-                        doSelectFile(files[shouldIndex++]);
-                    } else if (comparison > 0) {
-                        doDeselectFile(selectedObjects[actuallyIndex++]);
-                    } else {
-                        // Do nothing
-                        shouldIndex++;
-                        actuallyIndex++;
-                    }
-
-                }
-
-                while (shouldIndex < files.length) {
-                    doSelectFile(files[shouldIndex++]);
-                }
-
-                while (actuallyIndex < selectedObjects.length) {
-                    doDeselectFile(selectedObjects[actuallyIndex++]);
-                }
-
-                // restore the anchor and lead
-                if (listSelectionModel instanceof DefaultListSelectionModel) {
-                    ((DefaultListSelectionModel)listSelectionModel).
-                        moveLeadSelectionIndex(lead);
-                    listSelectionModel.setAnchorSelectionIndex(anchor);
-                }
-            } finally {
-                listSelectionModel.setValueIsAdjusting(false);
-            }
-        } else {
-            JFileChooser chooser = getFileChooser();
-            File f;
-            if (isDirectorySelected()) {
-                f = getDirectory();
-            } else {
-                f = chooser.getSelectedFile();
-            }
-            int i;
-            if (f != null && (i = getModel().indexOf(f)) >= 0) {
-                int viewIndex = getRowSorter().convertRowIndexToView(i);
-                listSelectionModel.setSelectionInterval(viewIndex, viewIndex);
-                ensureIndexIsVisible(viewIndex);
-            } else {
-                clearSelection();
-            }
-        }
-    }
-
-    private void doSelectFile(File fileToSelect) {
-        int index = getModel().indexOf(fileToSelect);
-        // could be missed in the current directory if it changed
-        if (index >= 0) {
-            index = getRowSorter().convertRowIndexToView(index);
-            listSelectionModel.addSelectionInterval(index, index);
-        }
-    }
-
-    private void doDeselectFile(Object fileToDeselect) {
-        int index = getRowSorter().convertRowIndexToView(
-                                getModel().indexOf(fileToDeselect));
-        listSelectionModel.removeSelectionInterval(index, index);
-    }
+                                                      boolean cellHasFocus) {throw new RuntimeException("cf-bug");} //{
+//
+//            if (listViewWindowsStyle && !list.isFocusOwner()) {
+//                isSelected = false;
+//            }
+//
+//            super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
+//            File file = (File) value;
+//            String fileName = getFileChooser().getName(file);
+//            setText(fileName);
+//            setFont(list.getFont());
+//
+//            Icon icon = getFileChooser().getIcon(file);
+//            if (icon != null) {
+//                setIcon(icon);
+//            } else {
+//                if (getFileChooser().getFileSystemView().isTraversable(file)) {
+//                    setText(fileName+File.separator);
+//                }
+//            }
+//
+//            return this;
+//        }
+    }
+
+
+    void setFileSelected() {throw new RuntimeException("cf-bug");} //{
+//        if (getFileChooser().isMultiSelectionEnabled() && !isDirectorySelected()) {
+//            File[] files = getFileChooser().getSelectedFiles(); // Should be selected
+//            Object[] selectedObjects = list.getSelectedValues(); // Are actually selected
+//
+//            listSelectionModel.setValueIsAdjusting(true);
+//            try {
+//                int lead = listSelectionModel.getLeadSelectionIndex();
+//                int anchor = listSelectionModel.getAnchorSelectionIndex();
+//
+//                Arrays.sort(files);
+//                Arrays.sort(selectedObjects);
+//
+//                int shouldIndex = 0;
+//                int actuallyIndex = 0;
+//
+//                // Remove files that shouldn't be selected and add files which should be selected
+//                // Note: Assume files are already sorted in compareTo order.
+//                while (shouldIndex < files.length &&
+//                       actuallyIndex < selectedObjects.length) {
+//                    int comparison = files[shouldIndex].compareTo((File)selectedObjects[actuallyIndex]);
+//                    if (comparison < 0) {
+//                        doSelectFile(files[shouldIndex++]);
+//                    } else if (comparison > 0) {
+//                        doDeselectFile(selectedObjects[actuallyIndex++]);
+//                    } else {
+//                        // Do nothing
+//                        shouldIndex++;
+//                        actuallyIndex++;
+//                    }
+//
+//                }
+//
+//                while (shouldIndex < files.length) {
+//                    doSelectFile(files[shouldIndex++]);
+//                }
+//
+//                while (actuallyIndex < selectedObjects.length) {
+//                    doDeselectFile(selectedObjects[actuallyIndex++]);
+//                }
+//
+//                // restore the anchor and lead
+//                if (listSelectionModel instanceof DefaultListSelectionModel) {
+//                    ((DefaultListSelectionModel)listSelectionModel).
+//                        moveLeadSelectionIndex(lead);
+//                    listSelectionModel.setAnchorSelectionIndex(anchor);
+//                }
+//            } finally {
+//                listSelectionModel.setValueIsAdjusting(false);
+//            }
+//        } else {
+//            JFileChooser chooser = getFileChooser();
+//            File f;
+//            if (isDirectorySelected()) {
+//                f = getDirectory();
+//            } else {
+//                f = chooser.getSelectedFile();
+//            }
+//            int i;
+//            if (f != null && (i = getModel().indexOf(f)) >= 0) {
+//                int viewIndex = getRowSorter().convertRowIndexToView(i);
+//                listSelectionModel.setSelectionInterval(viewIndex, viewIndex);
+//                ensureIndexIsVisible(viewIndex);
+//            } else {
+//                clearSelection();
+//            }
+//        }
+//    }
+
+    private void doSelectFile(File fileToSelect) {throw new RuntimeException("cf-bug");} //{
+//        int index = getModel().indexOf(fileToSelect);
+//        // could be missed in the current directory if it changed
+//        if (index >= 0) {
+//            index = getRowSorter().convertRowIndexToView(index);
+//            listSelectionModel.addSelectionInterval(index, index);
+//        }
+//    }
+
+    private void doDeselectFile(Object fileToDeselect) {throw new RuntimeException("cf-bug");} //{
+//        int index = getRowSorter().convertRowIndexToView(
+//                                getModel().indexOf(fileToDeselect));
+//        listSelectionModel.removeSelectionInterval(index, index);
+//    }
 
     /* The following methods are used by the PropertyChange Listener */
 
-    private void doSelectedFileChanged(PropertyChangeEvent e) {
-        applyEdit();
-        File f = (File) e.getNewValue();
-        JFileChooser fc = getFileChooser();
-        if (f != null
-            && ((fc.isFileSelectionEnabled() && !f.isDirectory())
-                || (f.isDirectory() && fc.isDirectorySelectionEnabled()))) {
-
-            setFileSelected();
-        }
-    }
-
-    private void doSelectedFilesChanged(PropertyChangeEvent e) {
-        applyEdit();
-        File[] files = (File[]) e.getNewValue();
-        JFileChooser fc = getFileChooser();
-        if (files != null
-            && files.length > 0
-            && (files.length > 1 || fc.isDirectorySelectionEnabled() || !files[0].isDirectory())) {
-            setFileSelected();
-        }
-    }
-
-    private void doDirectoryChanged(PropertyChangeEvent e) {
-        getDetailsTableModel().updateColumnInfo();
-
-        JFileChooser fc = getFileChooser();
-        FileSystemView fsv = fc.getFileSystemView();
-
-        applyEdit();
-        resetEditIndex();
-        ensureIndexIsVisible(0);
-        File currentDirectory = fc.getCurrentDirectory();
-        if (currentDirectory != null) {
-            if (!readOnly) {
-                getNewFolderAction().setEnabled(canWrite(currentDirectory));
-            }
-            fileChooserUIAccessor.getChangeToParentDirectoryAction().setEnabled(!fsv.isRoot(currentDirectory));
-        }
-        if (list != null) {
-            list.clearSelection();
-        }
-    }
-
-    private void doFilterChanged(PropertyChangeEvent e) {
-        applyEdit();
-        resetEditIndex();
-        clearSelection();
-    }
-
-    private void doFileSelectionModeChanged(PropertyChangeEvent e) {
-        applyEdit();
-        resetEditIndex();
-        clearSelection();
-    }
-
-    private void doMultiSelectionChanged(PropertyChangeEvent e) {
-        if (getFileChooser().isMultiSelectionEnabled()) {
-            listSelectionModel.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
-        } else {
-            listSelectionModel.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
-            clearSelection();
-            getFileChooser().setSelectedFiles(null);
-        }
-    }
+    private void doSelectedFileChanged(PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//        applyEdit();
+//        File f = (File) e.getNewValue();
+//        JFileChooser fc = getFileChooser();
+//        if (f != null
+//            && ((fc.isFileSelectionEnabled() && !f.isDirectory())
+//                || (f.isDirectory() && fc.isDirectorySelectionEnabled()))) {
+//
+//            setFileSelected();
+//        }
+//    }
+
+    private void doSelectedFilesChanged(PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//        applyEdit();
+//        File[] files = (File[]) e.getNewValue();
+//        JFileChooser fc = getFileChooser();
+//        if (files != null
+//            && files.length > 0
+//            && (files.length > 1 || fc.isDirectorySelectionEnabled() || !files[0].isDirectory())) {
+//            setFileSelected();
+//        }
+//    }
+
+    private void doDirectoryChanged(PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//        getDetailsTableModel().updateColumnInfo();
+//
+//        JFileChooser fc = getFileChooser();
+//        FileSystemView fsv = fc.getFileSystemView();
+//
+//        applyEdit();
+//        resetEditIndex();
+//        ensureIndexIsVisible(0);
+//        File currentDirectory = fc.getCurrentDirectory();
+//        if (currentDirectory != null) {
+//            if (!readOnly) {
+//                getNewFolderAction().setEnabled(canWrite(currentDirectory));
+//            }
+//            fileChooserUIAccessor.getChangeToParentDirectoryAction().setEnabled(!fsv.isRoot(currentDirectory));
+//        }
+//        if (list != null) {
+//            list.clearSelection();
+//        }
+//    }
+
+    private void doFilterChanged(PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//        applyEdit();
+//        resetEditIndex();
+//        clearSelection();
+//    }
+
+    private void doFileSelectionModeChanged(PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//        applyEdit();
+//        resetEditIndex();
+//        clearSelection();
+//    }
+
+    private void doMultiSelectionChanged(PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//        if (getFileChooser().isMultiSelectionEnabled()) {
+//            listSelectionModel.setSelectionMode(ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
+//        } else {
+//            listSelectionModel.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);
+//            clearSelection();
+//            getFileChooser().setSelectedFiles(null);
+//        }
+//    }
 
     /*
      * Listen for filechooser property changes, such as
      * the selected file changing, or the type of the dialog changing.
      */
-    public void propertyChange(PropertyChangeEvent e) {
-            if (viewType == -1) {
-                setViewType(VIEWTYPE_LIST);
-            }
-
-        String s = e.getPropertyName();
-        if (s.equals(JFileChooser.SELECTED_FILE_CHANGED_PROPERTY)) {
-            doSelectedFileChanged(e);
-        } else if (s.equals(JFileChooser.SELECTED_FILES_CHANGED_PROPERTY)) {
-            doSelectedFilesChanged(e);
-        } else if (s.equals(JFileChooser.DIRECTORY_CHANGED_PROPERTY)) {
-            doDirectoryChanged(e);
-        } else if (s.equals(JFileChooser.FILE_FILTER_CHANGED_PROPERTY)) {
-            doFilterChanged(e);
-        } else if (s.equals(JFileChooser.FILE_SELECTION_MODE_CHANGED_PROPERTY)) {
-            doFileSelectionModeChanged(e);
-        } else if (s.equals(JFileChooser.MULTI_SELECTION_ENABLED_CHANGED_PROPERTY)) {
-            doMultiSelectionChanged(e);
-        } else if (s.equals(JFileChooser.CANCEL_SELECTION)) {
-            applyEdit();
-        } else if (s.equals("busy")) {
-            setCursor((Boolean)e.getNewValue() ? waitCursor : null);
-        } else if (s.equals("componentOrientation")) {
-            ComponentOrientation o = (ComponentOrientation)e.getNewValue();
-            JFileChooser cc = (JFileChooser)e.getSource();
-            if (o != e.getOldValue()) {
-                cc.applyComponentOrientation(o);
-            }
-            if (detailsTable != null) {
-                detailsTable.setComponentOrientation(o);
-                detailsTable.getParent().getParent().setComponentOrientation(o);
-            }
-        }
-    }
-
-    private void ensureIndexIsVisible(int i) {
-        if (i >= 0) {
-            if (list != null) {
-                list.ensureIndexIsVisible(i);
-            }
-            if (detailsTable != null) {
-                detailsTable.scrollRectToVisible(detailsTable.getCellRect(i, COLUMN_FILENAME, true));
-            }
-        }
-    }
-
-    public void ensureFileIsVisible(JFileChooser fc, File f) {
-        int modelIndex = getModel().indexOf(f);
-        if (modelIndex >= 0) {
-            ensureIndexIsVisible(getRowSorter().convertRowIndexToView(modelIndex));
-        }
-    }
-
-    public void rescanCurrentDirectory() {
-        getModel().validateFileCache();
-    }
-
-    public void clearSelection() {
-        if (listSelectionModel != null) {
-            listSelectionModel.clearSelection();
-            if (listSelectionModel instanceof DefaultListSelectionModel) {
-                ((DefaultListSelectionModel)listSelectionModel).moveLeadSelectionIndex(0);
-                listSelectionModel.setAnchorSelectionIndex(0);
-            }
-        }
-    }
-
-    public JMenu getViewMenu() {
-        if (viewMenu == null) {
-            viewMenu = new JMenu(viewMenuLabelText);
-            ButtonGroup viewButtonGroup = new ButtonGroup();
-
-            for (int i = 0; i < VIEWTYPE_COUNT; i++) {
-                JRadioButtonMenuItem mi =
-                    new JRadioButtonMenuItem(new ViewTypeAction(i));
-                viewButtonGroup.add(mi);
-                viewMenu.add(mi);
-            }
-            updateViewMenu();
-        }
-        return viewMenu;
-    }
-
-    private void updateViewMenu() {
-        if (viewMenu != null) {
-            Component[] comps = viewMenu.getMenuComponents();
-            for (Component comp : comps) {
-                if (comp instanceof JRadioButtonMenuItem) {
-                    JRadioButtonMenuItem mi = (JRadioButtonMenuItem) comp;
-                    if (((ViewTypeAction)mi.getAction()).viewType == viewType) {
-                        mi.setSelected(true);
-                    }
-                }
-            }
-        }
-    }
-
-    public JPopupMenu getComponentPopupMenu() {
-        JPopupMenu popupMenu = getFileChooser().getComponentPopupMenu();
-        if (popupMenu != null) {
-            return popupMenu;
-        }
-
-        JMenu viewMenu = getViewMenu();
-        if (contextMenu == null) {
-            contextMenu = new JPopupMenu();
-            if (viewMenu != null) {
-                contextMenu.add(viewMenu);
-                if (listViewWindowsStyle) {
-                    contextMenu.addSeparator();
-                }
-            }
-            ActionMap actionMap = getActionMap();
-            Action refreshAction   = actionMap.get(ACTION_REFRESH);
-            Action newFolderAction = actionMap.get(ACTION_NEW_FOLDER);
-            if (refreshAction != null) {
-                contextMenu.add(refreshAction);
-                if (listViewWindowsStyle && newFolderAction != null) {
-                    contextMenu.addSeparator();
-                }
-            }
-            if (newFolderAction != null) {
-                contextMenu.add(newFolderAction);
-            }
-        }
-        if (viewMenu != null) {
-            viewMenu.getPopupMenu().setInvoker(viewMenu);
-        }
-        return contextMenu;
-    }
+    public void propertyChange(PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//            if (viewType == -1) {
+//                setViewType(VIEWTYPE_LIST);
+//            }
+//
+//        String s = e.getPropertyName();
+//        if (s.equals(JFileChooser.SELECTED_FILE_CHANGED_PROPERTY)) {
+//            doSelectedFileChanged(e);
+//        } else if (s.equals(JFileChooser.SELECTED_FILES_CHANGED_PROPERTY)) {
+//            doSelectedFilesChanged(e);
+//        } else if (s.equals(JFileChooser.DIRECTORY_CHANGED_PROPERTY)) {
+//            doDirectoryChanged(e);
+//        } else if (s.equals(JFileChooser.FILE_FILTER_CHANGED_PROPERTY)) {
+//            doFilterChanged(e);
+//        } else if (s.equals(JFileChooser.FILE_SELECTION_MODE_CHANGED_PROPERTY)) {
+//            doFileSelectionModeChanged(e);
+//        } else if (s.equals(JFileChooser.MULTI_SELECTION_ENABLED_CHANGED_PROPERTY)) {
+//            doMultiSelectionChanged(e);
+//        } else if (s.equals(JFileChooser.CANCEL_SELECTION)) {
+//            applyEdit();
+//        } else if (s.equals("busy")) {
+//            setCursor((Boolean)e.getNewValue() ? waitCursor : null);
+//        } else if (s.equals("componentOrientation")) {
+//            ComponentOrientation o = (ComponentOrientation)e.getNewValue();
+//            JFileChooser cc = (JFileChooser)e.getSource();
+//            if (o != e.getOldValue()) {
+//                cc.applyComponentOrientation(o);
+//            }
+//            if (detailsTable != null) {
+//                detailsTable.setComponentOrientation(o);
+//                detailsTable.getParent().getParent().setComponentOrientation(o);
+//            }
+//        }
+//    }
+
+    private void ensureIndexIsVisible(int i) {throw new RuntimeException("cf-bug");} //{
+//        if (i >= 0) {
+//            if (list != null) {
+//                list.ensureIndexIsVisible(i);
+//            }
+//            if (detailsTable != null) {
+//                detailsTable.scrollRectToVisible(detailsTable.getCellRect(i, COLUMN_FILENAME, true));
+//            }
+//        }
+//    }
+
+    public void ensureFileIsVisible(JFileChooser fc, File f) {throw new RuntimeException("cf-bug");} //{
+//        int modelIndex = getModel().indexOf(f);
+//        if (modelIndex >= 0) {
+//            ensureIndexIsVisible(getRowSorter().convertRowIndexToView(modelIndex));
+//        }
+//    }
+
+    public void rescanCurrentDirectory() {throw new RuntimeException("cf-bug");} //{
+//        getModel().validateFileCache();
+//    }
+
+    public void clearSelection() {throw new RuntimeException("cf-bug");} //{
+//        if (listSelectionModel != null) {
+//            listSelectionModel.clearSelection();
+//            if (listSelectionModel instanceof DefaultListSelectionModel) {
+//                ((DefaultListSelectionModel)listSelectionModel).moveLeadSelectionIndex(0);
+//                listSelectionModel.setAnchorSelectionIndex(0);
+//            }
+//        }
+//    }
+
+    public JMenu getViewMenu() {throw new RuntimeException("cf-bug");} //{
+//        if (viewMenu == null) {
+//            viewMenu = new JMenu(viewMenuLabelText);
+//            ButtonGroup viewButtonGroup = new ButtonGroup();
+//
+//            for (int i = 0; i < VIEWTYPE_COUNT; i++) {
+//                JRadioButtonMenuItem mi =
+//                    new JRadioButtonMenuItem(new ViewTypeAction(i));
+//                viewButtonGroup.add(mi);
+//                viewMenu.add(mi);
+//            }
+//            updateViewMenu();
+//        }
+//        return viewMenu;
+//    }
+
+    private void updateViewMenu() {throw new RuntimeException("cf-bug");} //{
+//        if (viewMenu != null) {
+//            Component[] comps = viewMenu.getMenuComponents();
+//            for (Component comp : comps) {
+//                if (comp instanceof JRadioButtonMenuItem) {
+//                    JRadioButtonMenuItem mi = (JRadioButtonMenuItem) comp;
+//                    if (((ViewTypeAction)mi.getAction()).viewType == viewType) {
+//                        mi.setSelected(true);
+//                    }
+//                }
+//            }
+//        }
+//    }
+
+    public JPopupMenu getComponentPopupMenu() {throw new RuntimeException("cf-bug");} //{
+//        JPopupMenu popupMenu = getFileChooser().getComponentPopupMenu();
+//        if (popupMenu != null) {
+//            return popupMenu;
+//        }
+//
+//        JMenu viewMenu = getViewMenu();
+//        if (contextMenu == null) {
+//            contextMenu = new JPopupMenu();
+//            if (viewMenu != null) {
+//                contextMenu.add(viewMenu);
+//                if (listViewWindowsStyle) {
+//                    contextMenu.addSeparator();
+//                }
+//            }
+//            ActionMap actionMap = getActionMap();
+//            Action refreshAction   = actionMap.get(ACTION_REFRESH);
+//            Action newFolderAction = actionMap.get(ACTION_NEW_FOLDER);
+//            if (refreshAction != null) {
+//                contextMenu.add(refreshAction);
+//                if (listViewWindowsStyle && newFolderAction != null) {
+//                    contextMenu.addSeparator();
+//                }
+//            }
+//            if (newFolderAction != null) {
+//                contextMenu.add(newFolderAction);
+//            }
+//        }
+//        if (viewMenu != null) {
+//            viewMenu.getPopupMenu().setInvoker(viewMenu);
+//        }
+//        return contextMenu;
+//    }
 
 
     private Handler handler;
 
-    protected Handler getMouseHandler() {
-        if (handler == null) {
-            handler = new Handler();
-        }
-        return handler;
-    }
+    protected Handler getMouseHandler() {throw new RuntimeException("cf-bug");} //{
+//        if (handler == null) {
+//            handler = new Handler();
+//        }
+//        return handler;
+//    }
 
     private class Handler implements MouseListener {
         private MouseListener doubleClickListener;
 
-        public void mouseClicked(MouseEvent evt) {
-            JComponent source = (JComponent)evt.getSource();
-
-            int index;
-            if (source instanceof JList) {
-                index = SwingUtilities2.loc2IndexFileList(list, evt.getPoint());
-            } else if (source instanceof JTable) {
-                JTable table = (JTable)source;
-                Point p = evt.getPoint();
-                index = table.rowAtPoint(p);
-
-                boolean pointOutsidePrefSize =
-                        SwingUtilities2.pointOutsidePrefSize(
-                            table, index, table.columnAtPoint(p), p);
-
-                if (pointOutsidePrefSize && !fullRowSelection) {
-                    return;
-                }
-
-                // Translate point from table to list
-                if (index >= 0 && list != null &&
-                    listSelectionModel.isSelectedIndex(index)) {
-
-                    // Make a new event with the list as source, placing the
-                    // click in the corresponding list cell.
-                    Rectangle r = list.getCellBounds(index, index);
-                    evt = new MouseEvent(list, evt.getID(),
-                                         evt.getWhen(), evt.getModifiers(),
-                                         r.x + 1, r.y + r.height/2,
-                                         evt.getXOnScreen(),
-                                         evt.getYOnScreen(),
-                                         evt.getClickCount(), evt.isPopupTrigger(),
-                                         evt.getButton());
-                }
-            } else {
-                return;
-            }
-
-            if (index >= 0 && SwingUtilities.isLeftMouseButton(evt)) {
-                JFileChooser fc = getFileChooser();
-
-                // For single click, we handle editing file name
-                if (evt.getClickCount() == 1 && source instanceof JList) {
-                    if ((!fc.isMultiSelectionEnabled() || fc.getSelectedFiles().length <= 1)
-                        && index >= 0 && listSelectionModel.isSelectedIndex(index)
-                        && getEditIndex() == index && editFile == null) {
-
-                        editFileName(index);
-                    } else {
-                        if (index >= 0) {
-                            setEditIndex(index);
-                        } else {
-                            resetEditIndex();
-                        }
-                    }
-                } else if (evt.getClickCount() == 2) {
-                    // on double click (open or drill down one directory) be
-                    // sure to clear the edit index
-                    resetEditIndex();
-                }
-            }
-
-            // Forward event to Basic
-            if (getDoubleClickListener() != null) {
-                getDoubleClickListener().mouseClicked(evt);
-            }
-        }
-
-        public void mouseEntered(MouseEvent evt) {
-            JComponent source = (JComponent)evt.getSource();
-            if (source instanceof JTable) {
-                JTable table = (JTable)evt.getSource();
-
-                TransferHandler th1 = getFileChooser().getTransferHandler();
-                TransferHandler th2 = table.getTransferHandler();
-                if (th1 != th2) {
-                    table.setTransferHandler(th1);
-                }
-
-                boolean dragEnabled = getFileChooser().getDragEnabled();
-                if (dragEnabled != table.getDragEnabled()) {
-                    table.setDragEnabled(dragEnabled);
-                }
-            } else if (source instanceof JList) {
-                // Forward event to Basic
-                if (getDoubleClickListener() != null) {
-                    getDoubleClickListener().mouseEntered(evt);
-                }
-            }
-        }
-
-        public void mouseExited(MouseEvent evt) {
-            if (evt.getSource() instanceof JList) {
-                // Forward event to Basic
-                if (getDoubleClickListener() != null) {
-                    getDoubleClickListener().mouseExited(evt);
-                }
-            }
-        }
-
-        public void mousePressed(MouseEvent evt) {
-            if (evt.getSource() instanceof JList) {
-                // Forward event to Basic
-                if (getDoubleClickListener() != null) {
-                    getDoubleClickListener().mousePressed(evt);
-                }
-            }
-        }
-
-        public void mouseReleased(MouseEvent evt) {
-            if (evt.getSource() instanceof JList) {
-                // Forward event to Basic
-                if (getDoubleClickListener() != null) {
-                    getDoubleClickListener().mouseReleased(evt);
-                }
-            }
-        }
-
-        private MouseListener getDoubleClickListener() {
-            // Lazy creation of Basic's listener
-            if (doubleClickListener == null && list != null) {
-                doubleClickListener =
-                    fileChooserUIAccessor.createDoubleClickListener(list);
-            }
-            return doubleClickListener;
-        }
+        public void mouseClicked(MouseEvent evt) {throw new RuntimeException("cf-bug");} //{
+//            JComponent source = (JComponent)evt.getSource();
+//
+//            int index;
+//            if (source instanceof JList) {
+//                index = SwingUtilities2.loc2IndexFileList(list, evt.getPoint());
+//            } else if (source instanceof JTable) {
+//                JTable table = (JTable)source;
+//                Point p = evt.getPoint();
+//                index = table.rowAtPoint(p);
+//
+//                boolean pointOutsidePrefSize =
+//                        SwingUtilities2.pointOutsidePrefSize(
+//                            table, index, table.columnAtPoint(p), p);
+//
+//                if (pointOutsidePrefSize && !fullRowSelection) {
+//                    return;
+//                }
+//
+//                // Translate point from table to list
+//                if (index >= 0 && list != null &&
+//                    listSelectionModel.isSelectedIndex(index)) {
+//
+//                    // Make a new event with the list as source, placing the
+//                    // click in the corresponding list cell.
+//                    Rectangle r = list.getCellBounds(index, index);
+//                    evt = new MouseEvent(list, evt.getID(),
+//                                         evt.getWhen(), evt.getModifiers(),
+//                                         r.x + 1, r.y + r.height/2,
+//                                         evt.getXOnScreen(),
+//                                         evt.getYOnScreen(),
+//                                         evt.getClickCount(), evt.isPopupTrigger(),
+//                                         evt.getButton());
+//                }
+//            } else {
+//                return;
+//            }
+//
+//            if (index >= 0 && SwingUtilities.isLeftMouseButton(evt)) {
+//                JFileChooser fc = getFileChooser();
+//
+//                // For single click, we handle editing file name
+//                if (evt.getClickCount() == 1 && source instanceof JList) {
+//                    if ((!fc.isMultiSelectionEnabled() || fc.getSelectedFiles().length <= 1)
+//                        && index >= 0 && listSelectionModel.isSelectedIndex(index)
+//                        && getEditIndex() == index && editFile == null) {
+//
+//                        editFileName(index);
+//                    } else {
+//                        if (index >= 0) {
+//                            setEditIndex(index);
+//                        } else {
+//                            resetEditIndex();
+//                        }
+//                    }
+//                } else if (evt.getClickCount() == 2) {
+//                    // on double click (open or drill down one directory) be
+//                    // sure to clear the edit index
+//                    resetEditIndex();
+//                }
+//            }
+//
+//            // Forward event to Basic
+//            if (getDoubleClickListener() != null) {
+//                getDoubleClickListener().mouseClicked(evt);
+//            }
+//        }
+
+        public void mouseEntered(MouseEvent evt) {throw new RuntimeException("cf-bug");} //{
+//            JComponent source = (JComponent)evt.getSource();
+//            if (source instanceof JTable) {
+//                JTable table = (JTable)evt.getSource();
+//
+//                TransferHandler th1 = getFileChooser().getTransferHandler();
+//                TransferHandler th2 = table.getTransferHandler();
+//                if (th1 != th2) {
+//                    table.setTransferHandler(th1);
+//                }
+//
+//                boolean dragEnabled = getFileChooser().getDragEnabled();
+//                if (dragEnabled != table.getDragEnabled()) {
+//                    table.setDragEnabled(dragEnabled);
+//                }
+//            } else if (source instanceof JList) {
+//                // Forward event to Basic
+//                if (getDoubleClickListener() != null) {
+//                    getDoubleClickListener().mouseEntered(evt);
+//                }
+//            }
+//        }
+
+        public void mouseExited(MouseEvent evt) {throw new RuntimeException("cf-bug");} //{
+//            if (evt.getSource() instanceof JList) {
+//                // Forward event to Basic
+//                if (getDoubleClickListener() != null) {
+//                    getDoubleClickListener().mouseExited(evt);
+//                }
+//            }
+//        }
+
+        public void mousePressed(MouseEvent evt) {throw new RuntimeException("cf-bug");} //{
+//            if (evt.getSource() instanceof JList) {
+//                // Forward event to Basic
+//                if (getDoubleClickListener() != null) {
+//                    getDoubleClickListener().mousePressed(evt);
+//                }
+//            }
+//        }
+
+        public void mouseReleased(MouseEvent evt) {throw new RuntimeException("cf-bug");} //{
+//            if (evt.getSource() instanceof JList) {
+//                // Forward event to Basic
+//                if (getDoubleClickListener() != null) {
+//                    getDoubleClickListener().mouseReleased(evt);
+//                }
+//            }
+//        }
+
+        private MouseListener getDoubleClickListener() {throw new RuntimeException("cf-bug");} //{
+//            // Lazy creation of Basic's listener
+//            if (doubleClickListener == null && list != null) {
+//                doubleClickListener =
+//                    fileChooserUIAccessor.createDoubleClickListener(list);
+//            }
+//            return doubleClickListener;
+//        }
     }
 
     /**
@@ -1942,9 +1942,9 @@
      *
      * @return <code>true</code> iff a directory is currently selected.
      */
-    protected boolean isDirectorySelected() {
-        return fileChooserUIAccessor.isDirectorySelected();
-    }
+    protected boolean isDirectorySelected() {throw new RuntimeException("cf-bug");} //{
+//        return fileChooserUIAccessor.isDirectorySelected();
+//    }
 
 
     /**
@@ -1953,62 +1953,62 @@
      * @return the value of the <code>directory</code> property
      * @see javax.swing.plaf.basic.BasicFileChooserUI#setDirectory
      */
-    protected File getDirectory() {
-        return fileChooserUIAccessor.getDirectory();
-    }
-
-    private Component findChildComponent(Container container, Class cls) {
-        int n = container.getComponentCount();
-        for (int i = 0; i < n; i++) {
-            Component comp = container.getComponent(i);
-            if (cls.isInstance(comp)) {
-                return comp;
-            } else if (comp instanceof Container) {
-                Component c = findChildComponent((Container)comp, cls);
-                if (c != null) {
-                    return c;
-                }
-            }
-        }
-        return null;
-    }
-
-    public boolean canWrite(File f) {
-        // Return false for non FileSystem files or if file doesn't exist.
-        if (!f.exists()) {
-            return false;
-        }
-
-        try {
-            if (f instanceof ShellFolder) {
-                return f.canWrite();
-            } else {
-                if (usesShellFolder(getFileChooser())) {
-                    try {
-                        return ShellFolder.getShellFolder(f).canWrite();
-                    } catch (FileNotFoundException ex) {
-                        // File doesn't exist
-                        return false;
-                    }
-                } else {
-                    // Ordinary file
-                    return f.canWrite();
-                }
-            }
-        } catch (SecurityException e) {
-            return false;
-        }
-    }
+    protected File getDirectory() {throw new RuntimeException("cf-bug");} //{
+//        return fileChooserUIAccessor.getDirectory();
+//    }
+
+    private Component findChildComponent(Container container, Class cls) {throw new RuntimeException("cf-bug");} //{
+//        int n = container.getComponentCount();
+//        for (int i = 0; i < n; i++) {
+//            Component comp = container.getComponent(i);
+//            if (cls.isInstance(comp)) {
+//                return comp;
+//            } else if (comp instanceof Container) {
+//                Component c = findChildComponent((Container)comp, cls);
+//                if (c != null) {
+//                    return c;
+//                }
+//            }
+//        }
+//        return null;
+//    }
+
+    public boolean canWrite(File f) {throw new RuntimeException("cf-bug");} //{
+//        // Return false for non FileSystem files or if file doesn't exist.
+//        if (!f.exists()) {
+//            return false;
+//        }
+//
+//        try {
+//            if (f instanceof ShellFolder) {
+//                return f.canWrite();
+//            } else {
+//                if (usesShellFolder(getFileChooser())) {
+//                    try {
+//                        return ShellFolder.getShellFolder(f).canWrite();
+//                    } catch (FileNotFoundException ex) {
+//                        // File doesn't exist
+//                        return false;
+//                    }
+//                } else {
+//                    // Ordinary file
+//                    return f.canWrite();
+//                }
+//            }
+//        } catch (SecurityException e) {
+//            return false;
+//        }
+//    }
 
     /**
      * Returns true if specified FileChooser should use ShellFolder
      */
-    public static boolean usesShellFolder(JFileChooser chooser) {
-        Boolean prop = (Boolean) chooser.getClientProperty("FileChooser.useShellFolder");
-
-        return prop == null ? chooser.getFileSystemView().equals(FileSystemView.getFileSystemView())
-                : prop.booleanValue();
-    }
+    public static boolean usesShellFolder(JFileChooser chooser) {throw new RuntimeException("cf-bug");} //{
+//        Boolean prop = (Boolean) chooser.getClientProperty("FileChooser.useShellFolder");
+//
+//        return prop == null ? chooser.getFileSystemView().equals(FileSystemView.getFileSystemView())
+//                : prop.booleanValue();
+//    }
 
     // This interface is used to access methods in the FileChooserUI
     // that are not public.
--- a/sun/swing/MenuItemLayoutHelper.java	2016-06-22 19:55:36.645973678 -0700
+++ b/sun/swing/MenuItemLayoutHelper.java	2016-06-29 12:46:40.800379837 -0700
@@ -111,239 +111,239 @@
     protected void reset(JMenuItem mi, Icon checkIcon, Icon arrowIcon,
                       Rectangle viewRect, int gap, String accDelimiter,
                       boolean isLeftToRight, Font font, Font accFont,
-                      boolean useCheckAndArrow, String propertyPrefix) {
-        this.mi = mi;
-        this.miParent = getMenuItemParent(mi);
-        this.accText = getAccText(accDelimiter);
-        this.verticalAlignment = mi.getVerticalAlignment();
-        this.horizontalAlignment = mi.getHorizontalAlignment();
-        this.verticalTextPosition = mi.getVerticalTextPosition();
-        this.horizontalTextPosition = mi.getHorizontalTextPosition();
-        this.useCheckAndArrow = useCheckAndArrow;
-        this.font = font;
-        this.accFont = accFont;
-        this.fm = mi.getFontMetrics(font);
-        this.accFm = mi.getFontMetrics(accFont);
-        this.isLeftToRight = isLeftToRight;
-        this.isColumnLayout = isColumnLayout(isLeftToRight,
-                horizontalAlignment, horizontalTextPosition,
-                verticalTextPosition);
-        this.isTopLevelMenu = (this.miParent == null) ? true : false;
-        this.checkIcon = checkIcon;
-        this.icon = getIcon(propertyPrefix);
-        this.arrowIcon = arrowIcon;
-        this.text = mi.getText();
-        this.gap = gap;
-        this.afterCheckIconGap = getAfterCheckIconGap(propertyPrefix);
-        this.minTextOffset = getMinTextOffset(propertyPrefix);
-        this.htmlView = (View) mi.getClientProperty(BasicHTML.propertyKey);
-        this.viewRect = viewRect;
-
-        this.iconSize = new RectSize();
-        this.textSize = new RectSize();
-        this.accSize = new RectSize();
-        this.checkSize = new RectSize();
-        this.arrowSize = new RectSize();
-        this.labelSize = new RectSize();
-        calcExtraWidths();
-        calcWidthsAndHeights();
-        setOriginalWidths();
-        calcMaxWidths();
-
-        this.leadingGap = getLeadingGap(propertyPrefix);
-        calcMaxTextOffset(viewRect);
-    }
-
-    private void calcExtraWidths() {
-        leftTextExtraWidth = getLeftExtraWidth(text);
-    }
-
-    private int getLeftExtraWidth(String str) {
-        int lsb = SwingUtilities2.getLeftSideBearing(mi, fm, str);
-        if (lsb < 0) {
-            return -lsb;
-        } else {
-            return 0;
-        }
-    }
-
-    private void setOriginalWidths() {
-        iconSize.origWidth = iconSize.width;
-        textSize.origWidth = textSize.width;
-        accSize.origWidth = accSize.width;
-        checkSize.origWidth = checkSize.width;
-        arrowSize.origWidth = arrowSize.width;
-    }
-
-    private String getAccText(String acceleratorDelimiter) {
-        String accText = "";
-        KeyStroke accelerator = mi.getAccelerator();
-        if (accelerator != null) {
-            int modifiers = accelerator.getModifiers();
-            if (modifiers > 0) {
-                accText = KeyEvent.getKeyModifiersText(modifiers);
-                accText += acceleratorDelimiter;
-            }
-            int keyCode = accelerator.getKeyCode();
-            if (keyCode != 0) {
-                accText += KeyEvent.getKeyText(keyCode);
-            } else {
-                accText += accelerator.getKeyChar();
-            }
-        }
-        return accText;
-    }
-
-    private Icon getIcon(String propertyPrefix) {
-        // In case of column layout, .checkIconFactory is defined for this UI,
-        // the icon is compatible with it and useCheckAndArrow() is true,
-        // then the icon is handled by the checkIcon.
-        Icon icon = null;
-        MenuItemCheckIconFactory iconFactory =
-                (MenuItemCheckIconFactory) UIManager.get(propertyPrefix
-                        + ".checkIconFactory");
-        if (!isColumnLayout || !useCheckAndArrow || iconFactory == null
-                || !iconFactory.isCompatible(checkIcon, propertyPrefix)) {
-            icon = mi.getIcon();
-        }
-        return icon;
-    }
-
-    private int getMinTextOffset(String propertyPrefix) {
-        int minimumTextOffset = 0;
-        Object minimumTextOffsetObject =
-                UIManager.get(propertyPrefix + ".minimumTextOffset");
-        if (minimumTextOffsetObject instanceof Integer) {
-            minimumTextOffset = (Integer) minimumTextOffsetObject;
-        }
-        return minimumTextOffset;
-    }
-
-    private int getAfterCheckIconGap(String propertyPrefix) {
-        int afterCheckIconGap = gap;
-        Object afterCheckIconGapObject =
-                UIManager.get(propertyPrefix + ".afterCheckIconGap");
-        if (afterCheckIconGapObject instanceof Integer) {
-            afterCheckIconGap = (Integer) afterCheckIconGapObject;
-        }
-        return afterCheckIconGap;
-    }
-
-    private int getLeadingGap(String propertyPrefix) {
-        if (checkSize.getMaxWidth() > 0) {
-            return getCheckOffset(propertyPrefix);
-        } else {
-            return gap; // There is no any check icon
-        }
-    }
-
-    private int getCheckOffset(String propertyPrefix) {
-        int checkIconOffset = gap;
-        Object checkIconOffsetObject =
-                UIManager.get(propertyPrefix + ".checkIconOffset");
-        if (checkIconOffsetObject instanceof Integer) {
-            checkIconOffset = (Integer) checkIconOffsetObject;
-        }
-        return checkIconOffset;
-    }
-
-    protected void calcWidthsAndHeights() {
-        // iconRect
-        if (icon != null) {
-            iconSize.width = icon.getIconWidth();
-            iconSize.height = icon.getIconHeight();
-        }
-
-        // accRect
-        if (!accText.equals("")) {
-            accSize.width = SwingUtilities2.stringWidth(mi, accFm, accText);
-            accSize.height = accFm.getHeight();
-        }
-
-        // textRect
-        if (text == null) {
-            text = "";
-        } else if (!text.equals("")) {
-            if (htmlView != null) {
-                // Text is HTML
-                textSize.width =
-                        (int) htmlView.getPreferredSpan(View.X_AXIS);
-                textSize.height =
-                        (int) htmlView.getPreferredSpan(View.Y_AXIS);
-            } else {
-                // Text isn't HTML
-                textSize.width = SwingUtilities2.stringWidth(mi, fm, text);
-                textSize.height = fm.getHeight();
-            }
-        }
-
-        if (useCheckAndArrow) {
-            // checkIcon
-            if (checkIcon != null) {
-                checkSize.width = checkIcon.getIconWidth();
-                checkSize.height = checkIcon.getIconHeight();
-            }
-            // arrowRect
-            if (arrowIcon != null) {
-                arrowSize.width = arrowIcon.getIconWidth();
-                arrowSize.height = arrowIcon.getIconHeight();
-            }
-        }
-
-        // labelRect
-        if (isColumnLayout) {
-            labelSize.width = iconSize.width + textSize.width + gap;
-            labelSize.height = max(checkSize.height, iconSize.height,
-                    textSize.height, accSize.height, arrowSize.height);
-        } else {
-            Rectangle textRect = new Rectangle();
-            Rectangle iconRect = new Rectangle();
-            SwingUtilities.layoutCompoundLabel(mi, fm, text, icon,
-                    verticalAlignment, horizontalAlignment,
-                    verticalTextPosition, horizontalTextPosition,
-                    viewRect, iconRect, textRect, gap);
-            textRect.width += leftTextExtraWidth;
-            Rectangle labelRect = iconRect.union(textRect);
-            labelSize.height = labelRect.height;
-            labelSize.width = labelRect.width;
-        }
-    }
-
-    protected void calcMaxWidths() {
-        calcMaxWidth(checkSize, MAX_CHECK_WIDTH);
-        calcMaxWidth(arrowSize, MAX_ARROW_WIDTH);
-        calcMaxWidth(accSize, MAX_ACC_WIDTH);
-
-        if (isColumnLayout) {
-            calcMaxWidth(iconSize, MAX_ICON_WIDTH);
-            calcMaxWidth(textSize, MAX_TEXT_WIDTH);
-            int curGap = gap;
-            if ((iconSize.getMaxWidth() == 0)
-                    || (textSize.getMaxWidth() == 0)) {
-                curGap = 0;
-            }
-            labelSize.maxWidth =
-                    calcMaxValue(MAX_LABEL_WIDTH, iconSize.maxWidth
-                            + textSize.maxWidth + curGap);
-        } else {
-            // We shouldn't use current icon and text widths
-            // in maximal widths calculation for complex layout.
-            iconSize.maxWidth = getParentIntProperty(MAX_ICON_WIDTH);
-            calcMaxWidth(labelSize, MAX_LABEL_WIDTH);
-            // If maxLabelWidth is wider
-            // than the widest icon + the widest text + gap,
-            // we should update the maximal text witdh
-            int candidateTextWidth = labelSize.maxWidth - iconSize.maxWidth;
-            if (iconSize.maxWidth > 0) {
-                candidateTextWidth -= gap;
-            }
-            textSize.maxWidth = calcMaxValue(MAX_TEXT_WIDTH, candidateTextWidth);
-        }
-    }
-
-    protected void calcMaxWidth(RectSize rs, Object key) {
-        rs.maxWidth = calcMaxValue(key, rs.width);
-    }
+                      boolean useCheckAndArrow, String propertyPrefix) {throw new RuntimeException("cf-bug");} //{
+//        this.mi = mi;
+//        this.miParent = getMenuItemParent(mi);
+//        this.accText = getAccText(accDelimiter);
+//        this.verticalAlignment = mi.getVerticalAlignment();
+//        this.horizontalAlignment = mi.getHorizontalAlignment();
+//        this.verticalTextPosition = mi.getVerticalTextPosition();
+//        this.horizontalTextPosition = mi.getHorizontalTextPosition();
+//        this.useCheckAndArrow = useCheckAndArrow;
+//        this.font = font;
+//        this.accFont = accFont;
+//        this.fm = mi.getFontMetrics(font);
+//        this.accFm = mi.getFontMetrics(accFont);
+//        this.isLeftToRight = isLeftToRight;
+//        this.isColumnLayout = isColumnLayout(isLeftToRight,
+//                horizontalAlignment, horizontalTextPosition,
+//                verticalTextPosition);
+//        this.isTopLevelMenu = (this.miParent == null) ? true : false;
+//        this.checkIcon = checkIcon;
+//        this.icon = getIcon(propertyPrefix);
+//        this.arrowIcon = arrowIcon;
+//        this.text = mi.getText();
+//        this.gap = gap;
+//        this.afterCheckIconGap = getAfterCheckIconGap(propertyPrefix);
+//        this.minTextOffset = getMinTextOffset(propertyPrefix);
+//        this.htmlView = (View) mi.getClientProperty(BasicHTML.propertyKey);
+//        this.viewRect = viewRect;
+//
+//        this.iconSize = new RectSize();
+//        this.textSize = new RectSize();
+//        this.accSize = new RectSize();
+//        this.checkSize = new RectSize();
+//        this.arrowSize = new RectSize();
+//        this.labelSize = new RectSize();
+//        calcExtraWidths();
+//        calcWidthsAndHeights();
+//        setOriginalWidths();
+//        calcMaxWidths();
+//
+//        this.leadingGap = getLeadingGap(propertyPrefix);
+//        calcMaxTextOffset(viewRect);
+//    }
+
+    private void calcExtraWidths() {throw new RuntimeException("cf-bug");} //{
+//        leftTextExtraWidth = getLeftExtraWidth(text);
+//    }
+
+    private int getLeftExtraWidth(String str) {throw new RuntimeException("cf-bug");} //{
+//        int lsb = SwingUtilities2.getLeftSideBearing(mi, fm, str);
+//        if (lsb < 0) {
+//            return -lsb;
+//        } else {
+//            return 0;
+//        }
+//    }
+
+    private void setOriginalWidths() {throw new RuntimeException("cf-bug");} //{
+//        iconSize.origWidth = iconSize.width;
+//        textSize.origWidth = textSize.width;
+//        accSize.origWidth = accSize.width;
+//        checkSize.origWidth = checkSize.width;
+//        arrowSize.origWidth = arrowSize.width;
+//    }
+
+    private String getAccText(String acceleratorDelimiter) {throw new RuntimeException("cf-bug");} //{
+//        String accText = "";
+//        KeyStroke accelerator = mi.getAccelerator();
+//        if (accelerator != null) {
+//            int modifiers = accelerator.getModifiers();
+//            if (modifiers > 0) {
+//                accText = KeyEvent.getKeyModifiersText(modifiers);
+//                accText += acceleratorDelimiter;
+//            }
+//            int keyCode = accelerator.getKeyCode();
+//            if (keyCode != 0) {
+//                accText += KeyEvent.getKeyText(keyCode);
+//            } else {
+//                accText += accelerator.getKeyChar();
+//            }
+//        }
+//        return accText;
+//    }
+
+    private Icon getIcon(String propertyPrefix) {throw new RuntimeException("cf-bug");} //{
+//        // In case of column layout, .checkIconFactory is defined for this UI,
+//        // the icon is compatible with it and useCheckAndArrow() is true,
+//        // then the icon is handled by the checkIcon.
+//        Icon icon = null;
+//        MenuItemCheckIconFactory iconFactory =
+//                (MenuItemCheckIconFactory) UIManager.get(propertyPrefix
+//                        + ".checkIconFactory");
+//        if (!isColumnLayout || !useCheckAndArrow || iconFactory == null
+//                || !iconFactory.isCompatible(checkIcon, propertyPrefix)) {
+//            icon = mi.getIcon();
+//        }
+//        return icon;
+//    }
+
+    private int getMinTextOffset(String propertyPrefix) {throw new RuntimeException("cf-bug");} //{
+//        int minimumTextOffset = 0;
+//        Object minimumTextOffsetObject =
+//                UIManager.get(propertyPrefix + ".minimumTextOffset");
+//        if (minimumTextOffsetObject instanceof Integer) {
+//            minimumTextOffset = (Integer) minimumTextOffsetObject;
+//        }
+//        return minimumTextOffset;
+//    }
+
+    private int getAfterCheckIconGap(String propertyPrefix) {throw new RuntimeException("cf-bug");} //{
+//        int afterCheckIconGap = gap;
+//        Object afterCheckIconGapObject =
+//                UIManager.get(propertyPrefix + ".afterCheckIconGap");
+//        if (afterCheckIconGapObject instanceof Integer) {
+//            afterCheckIconGap = (Integer) afterCheckIconGapObject;
+//        }
+//        return afterCheckIconGap;
+//    }
+
+    private int getLeadingGap(String propertyPrefix) {throw new RuntimeException("cf-bug");} //{
+//        if (checkSize.getMaxWidth() > 0) {
+//            return getCheckOffset(propertyPrefix);
+//        } else {
+//            return gap; // There is no any check icon
+//        }
+//    }
+
+    private int getCheckOffset(String propertyPrefix) {throw new RuntimeException("cf-bug");} //{
+//        int checkIconOffset = gap;
+//        Object checkIconOffsetObject =
+//                UIManager.get(propertyPrefix + ".checkIconOffset");
+//        if (checkIconOffsetObject instanceof Integer) {
+//            checkIconOffset = (Integer) checkIconOffsetObject;
+//        }
+//        return checkIconOffset;
+//    }
+
+    protected void calcWidthsAndHeights() {throw new RuntimeException("cf-bug");} //{
+//        // iconRect
+//        if (icon != null) {
+//            iconSize.width = icon.getIconWidth();
+//            iconSize.height = icon.getIconHeight();
+//        }
+//
+//        // accRect
+//        if (!accText.equals("")) {
+//            accSize.width = SwingUtilities2.stringWidth(mi, accFm, accText);
+//            accSize.height = accFm.getHeight();
+//        }
+//
+//        // textRect
+//        if (text == null) {
+//            text = "";
+//        } else if (!text.equals("")) {
+//            if (htmlView != null) {
+//                // Text is HTML
+//                textSize.width =
+//                        (int) htmlView.getPreferredSpan(View.X_AXIS);
+//                textSize.height =
+//                        (int) htmlView.getPreferredSpan(View.Y_AXIS);
+//            } else {
+//                // Text isn't HTML
+//                textSize.width = SwingUtilities2.stringWidth(mi, fm, text);
+//                textSize.height = fm.getHeight();
+//            }
+//        }
+//
+//        if (useCheckAndArrow) {
+//            // checkIcon
+//            if (checkIcon != null) {
+//                checkSize.width = checkIcon.getIconWidth();
+//                checkSize.height = checkIcon.getIconHeight();
+//            }
+//            // arrowRect
+//            if (arrowIcon != null) {
+//                arrowSize.width = arrowIcon.getIconWidth();
+//                arrowSize.height = arrowIcon.getIconHeight();
+//            }
+//        }
+//
+//        // labelRect
+//        if (isColumnLayout) {
+//            labelSize.width = iconSize.width + textSize.width + gap;
+//            labelSize.height = max(checkSize.height, iconSize.height,
+//                    textSize.height, accSize.height, arrowSize.height);
+//        } else {
+//            Rectangle textRect = new Rectangle();
+//            Rectangle iconRect = new Rectangle();
+//            SwingUtilities.layoutCompoundLabel(mi, fm, text, icon,
+//                    verticalAlignment, horizontalAlignment,
+//                    verticalTextPosition, horizontalTextPosition,
+//                    viewRect, iconRect, textRect, gap);
+//            textRect.width += leftTextExtraWidth;
+//            Rectangle labelRect = iconRect.union(textRect);
+//            labelSize.height = labelRect.height;
+//            labelSize.width = labelRect.width;
+//        }
+//    }
+
+    protected void calcMaxWidths() {throw new RuntimeException("cf-bug");} //{
+//        calcMaxWidth(checkSize, MAX_CHECK_WIDTH);
+//        calcMaxWidth(arrowSize, MAX_ARROW_WIDTH);
+//        calcMaxWidth(accSize, MAX_ACC_WIDTH);
+//
+//        if (isColumnLayout) {
+//            calcMaxWidth(iconSize, MAX_ICON_WIDTH);
+//            calcMaxWidth(textSize, MAX_TEXT_WIDTH);
+//            int curGap = gap;
+//            if ((iconSize.getMaxWidth() == 0)
+//                    || (textSize.getMaxWidth() == 0)) {
+//                curGap = 0;
+//            }
+//            labelSize.maxWidth =
+//                    calcMaxValue(MAX_LABEL_WIDTH, iconSize.maxWidth
+//                            + textSize.maxWidth + curGap);
+//        } else {
+//            // We shouldn't use current icon and text widths
+//            // in maximal widths calculation for complex layout.
+//            iconSize.maxWidth = getParentIntProperty(MAX_ICON_WIDTH);
+//            calcMaxWidth(labelSize, MAX_LABEL_WIDTH);
+//            // If maxLabelWidth is wider
+//            // than the widest icon + the widest text + gap,
+//            // we should update the maximal text witdh
+//            int candidateTextWidth = labelSize.maxWidth - iconSize.maxWidth;
+//            if (iconSize.maxWidth > 0) {
+//                candidateTextWidth -= gap;
+//            }
+//            textSize.maxWidth = calcMaxValue(MAX_TEXT_WIDTH, candidateTextWidth);
+//        }
+//    }
+
+    protected void calcMaxWidth(RectSize rs, Object key) {throw new RuntimeException("cf-bug");} //{
+//        rs.maxWidth = calcMaxValue(key, rs.width);
+//    }
 
     /**
      * Calculates and returns maximal value through specified parent component
@@ -353,42 +353,42 @@
      * @param value a value which pretends to be maximal
      * @return maximal value among the parent property and the value.
      */
-    protected int calcMaxValue(Object propertyName, int value) {
-        // Get maximal value from parent client property
-        int maxValue = getParentIntProperty(propertyName);
-        // Store new maximal width in parent client property
-        if (value > maxValue) {
-            if (miParent != null) {
-                miParent.putClientProperty(propertyName, value);
-            }
-            return value;
-        } else {
-            return maxValue;
-        }
-    }
+    protected int calcMaxValue(Object propertyName, int value) {throw new RuntimeException("cf-bug");} //{
+//        // Get maximal value from parent client property
+//        int maxValue = getParentIntProperty(propertyName);
+//        // Store new maximal width in parent client property
+//        if (value > maxValue) {
+//            if (miParent != null) {
+//                miParent.putClientProperty(propertyName, value);
+//            }
+//            return value;
+//        } else {
+//            return maxValue;
+//        }
+//    }
 
     /**
      * Returns parent client property as int.
      * @param propertyName name of the parent property.
      * @return value of the property as int.
      */
-    protected int getParentIntProperty(Object propertyName) {
-        Object value = null;
-        if (miParent != null) {
-            value = miParent.getClientProperty(propertyName);
-        }
-        if ((value == null) || !(value instanceof Integer)) {
-            value = 0;
-        }
-        return (Integer) value;
-    }
+    protected int getParentIntProperty(Object propertyName) {throw new RuntimeException("cf-bug");} //{
+//        Object value = null;
+//        if (miParent != null) {
+//            value = miParent.getClientProperty(propertyName);
+//        }
+//        if ((value == null) || !(value instanceof Integer)) {
+//            value = 0;
+//        }
+//        return (Integer) value;
+//    }
 
     public static boolean isColumnLayout(boolean isLeftToRight,
-                                         JMenuItem mi) {
-        assert(mi != null);
-        return isColumnLayout(isLeftToRight, mi.getHorizontalAlignment(),
-                mi.getHorizontalTextPosition(), mi.getVerticalTextPosition());
-    }
+                                         JMenuItem mi) {throw new RuntimeException("cf-bug");} //{
+//        assert(mi != null);
+//        return isColumnLayout(isLeftToRight, mi.getHorizontalAlignment(),
+//                mi.getHorizontalTextPosition(), mi.getVerticalTextPosition());
+//    }
 
     /**
      * Answers should we do column layout for a menu item or not.
@@ -398,31 +398,31 @@
     public static boolean isColumnLayout(boolean isLeftToRight,
                                          int horizontalAlignment,
                                          int horizontalTextPosition,
-                                         int verticalTextPosition) {
-        if (verticalTextPosition != SwingConstants.CENTER) {
-            return false;
-        }
-        if (isLeftToRight) {
-            if (horizontalAlignment != SwingConstants.LEADING
-                    && horizontalAlignment != SwingConstants.LEFT) {
-                return false;
-            }
-            if (horizontalTextPosition != SwingConstants.TRAILING
-                    && horizontalTextPosition != SwingConstants.RIGHT) {
-                return false;
-            }
-        } else {
-            if (horizontalAlignment != SwingConstants.LEADING
-                    && horizontalAlignment != SwingConstants.RIGHT) {
-                return false;
-            }
-            if (horizontalTextPosition != SwingConstants.TRAILING
-                    && horizontalTextPosition != SwingConstants.LEFT) {
-                return false;
-            }
-        }
-        return true;
-    }
+                                         int verticalTextPosition) {throw new RuntimeException("cf-bug");} //{
+//        if (verticalTextPosition != SwingConstants.CENTER) {
+//            return false;
+//        }
+//        if (isLeftToRight) {
+//            if (horizontalAlignment != SwingConstants.LEADING
+//                    && horizontalAlignment != SwingConstants.LEFT) {
+//                return false;
+//            }
+//            if (horizontalTextPosition != SwingConstants.TRAILING
+//                    && horizontalTextPosition != SwingConstants.RIGHT) {
+//                return false;
+//            }
+//        } else {
+//            if (horizontalAlignment != SwingConstants.LEADING
+//                    && horizontalAlignment != SwingConstants.RIGHT) {
+//                return false;
+//            }
+//            if (horizontalTextPosition != SwingConstants.TRAILING
+//                    && horizontalTextPosition != SwingConstants.LEFT) {
+//                return false;
+//            }
+//        }
+//        return true;
+//    }
 
     /**
      * Calculates maximal text offset.
@@ -432,29 +432,29 @@
      * @param viewRect the rectangle, the maximal text offset
      * will be calculated for.
      */
-    private void calcMaxTextOffset(Rectangle viewRect) {
-        if (!isColumnLayout || !isLeftToRight) {
-            return;
-        }
-
-        // Calculate the current text offset
-        int offset = viewRect.x + leadingGap + checkSize.maxWidth
-                + afterCheckIconGap + iconSize.maxWidth + gap;
-        if (checkSize.maxWidth == 0) {
-            offset -= afterCheckIconGap;
-        }
-        if (iconSize.maxWidth == 0) {
-            offset -= gap;
-        }
-
-        // maximal text offset shouldn't be less than minimal text offset;
-        if (offset < minTextOffset) {
-            offset = minTextOffset;
-        }
-
-        // Calculate and store the maximal text offset
-        calcMaxValue(SwingUtilities2.BASICMENUITEMUI_MAX_TEXT_OFFSET, offset);
-    }
+    private void calcMaxTextOffset(Rectangle viewRect) {throw new RuntimeException("cf-bug");} //{
+//        if (!isColumnLayout || !isLeftToRight) {
+//            return;
+//        }
+//
+//        // Calculate the current text offset
+//        int offset = viewRect.x + leadingGap + checkSize.maxWidth
+//                + afterCheckIconGap + iconSize.maxWidth + gap;
+//        if (checkSize.maxWidth == 0) {
+//            offset -= afterCheckIconGap;
+//        }
+//        if (iconSize.maxWidth == 0) {
+//            offset -= gap;
+//        }
+//
+//        // maximal text offset shouldn't be less than minimal text offset;
+//        if (offset < minTextOffset) {
+//            offset = minTextOffset;
+//        }
+//
+//        // Calculate and store the maximal text offset
+//        calcMaxValue(SwingUtilities2.BASICMENUITEMUI_MAX_TEXT_OFFSET, offset);
+//    }
 
     /**
      * Layout icon, text, check icon, accelerator text and arrow icon
@@ -472,326 +472,326 @@
      * The order of columns can be reversed.
      * It depends on the menu item orientation.
      */
-    public LayoutResult layoutMenuItem() {
-        LayoutResult lr = createLayoutResult();
-        prepareForLayout(lr);
-
-        if (isColumnLayout()) {
-            if (isLeftToRight()) {
-                doLTRColumnLayout(lr, getLTRColumnAlignment());
-            } else {
-                doRTLColumnLayout(lr, getRTLColumnAlignment());
-            }
-        } else {
-            if (isLeftToRight()) {
-                doLTRComplexLayout(lr, getLTRColumnAlignment());
-            } else {
-                doRTLComplexLayout(lr, getRTLColumnAlignment());
-            }
-        }
-
-        alignAccCheckAndArrowVertically(lr);
-        return lr;
-    }
-
-    private LayoutResult createLayoutResult() {
-        return new LayoutResult(
-                new Rectangle(iconSize.width, iconSize.height),
-                new Rectangle(textSize.width, textSize.height),
-                new Rectangle(accSize.width,  accSize.height),
-                new Rectangle(checkSize.width, checkSize.height),
-                new Rectangle(arrowSize.width, arrowSize.height),
-                new Rectangle(labelSize.width, labelSize.height)
-        );
-    }
-
-    public ColumnAlignment getLTRColumnAlignment() {
-        return ColumnAlignment.LEFT_ALIGNMENT;
-    }
-
-    public ColumnAlignment getRTLColumnAlignment() {
-        return ColumnAlignment.RIGHT_ALIGNMENT;
-    }
-
-    protected void prepareForLayout(LayoutResult lr) {
-        lr.checkRect.width = checkSize.maxWidth;
-        lr.accRect.width = accSize.maxWidth;
-        lr.arrowRect.width = arrowSize.maxWidth;
-    }
+    public LayoutResult layoutMenuItem() {throw new RuntimeException("cf-bug");} //{
+//        LayoutResult lr = createLayoutResult();
+//        prepareForLayout(lr);
+//
+//        if (isColumnLayout()) {
+//            if (isLeftToRight()) {
+//                doLTRColumnLayout(lr, getLTRColumnAlignment());
+//            } else {
+//                doRTLColumnLayout(lr, getRTLColumnAlignment());
+//            }
+//        } else {
+//            if (isLeftToRight()) {
+//                doLTRComplexLayout(lr, getLTRColumnAlignment());
+//            } else {
+//                doRTLComplexLayout(lr, getRTLColumnAlignment());
+//            }
+//        }
+//
+//        alignAccCheckAndArrowVertically(lr);
+//        return lr;
+//    }
+
+    private LayoutResult createLayoutResult() {throw new RuntimeException("cf-bug");} //{
+//        return new LayoutResult(
+//                new Rectangle(iconSize.width, iconSize.height),
+//                new Rectangle(textSize.width, textSize.height),
+//                new Rectangle(accSize.width,  accSize.height),
+//                new Rectangle(checkSize.width, checkSize.height),
+//                new Rectangle(arrowSize.width, arrowSize.height),
+//                new Rectangle(labelSize.width, labelSize.height)
+//        );
+//    }
+
+    public ColumnAlignment getLTRColumnAlignment() {throw new RuntimeException("cf-bug");} //{
+//        return ColumnAlignment.LEFT_ALIGNMENT;
+//    }
+
+    public ColumnAlignment getRTLColumnAlignment() {throw new RuntimeException("cf-bug");} //{
+//        return ColumnAlignment.RIGHT_ALIGNMENT;
+//    }
+
+    protected void prepareForLayout(LayoutResult lr) {throw new RuntimeException("cf-bug");} //{
+//        lr.checkRect.width = checkSize.maxWidth;
+//        lr.accRect.width = accSize.maxWidth;
+//        lr.arrowRect.width = arrowSize.maxWidth;
+//    }
 
     /**
      * Aligns the accelertor text and the check and arrow icons vertically
      * with the center of the label rect.
      */
-    private void alignAccCheckAndArrowVertically(LayoutResult lr) {
-        lr.accRect.y = (int)(lr.labelRect.y
-                + (float)lr.labelRect.height/2
-                - (float)lr.accRect.height/2);
-        fixVerticalAlignment(lr, lr.accRect);
-        if (useCheckAndArrow) {
-            lr.arrowRect.y = (int)(lr.labelRect.y
-                    + (float)lr.labelRect.height/2
-                    - (float)lr.arrowRect.height/2);
-            lr.checkRect.y = (int)(lr.labelRect.y
-                    + (float)lr.labelRect.height/2
-                    - (float)lr.checkRect.height/2);
-            fixVerticalAlignment(lr, lr.arrowRect);
-            fixVerticalAlignment(lr, lr.checkRect);
-        }
-    }
+    private void alignAccCheckAndArrowVertically(LayoutResult lr) {throw new RuntimeException("cf-bug");} //{
+//        lr.accRect.y = (int)(lr.labelRect.y
+//                + (float)lr.labelRect.height/2
+//                - (float)lr.accRect.height/2);
+//        fixVerticalAlignment(lr, lr.accRect);
+//        if (useCheckAndArrow) {
+//            lr.arrowRect.y = (int)(lr.labelRect.y
+//                    + (float)lr.labelRect.height/2
+//                    - (float)lr.arrowRect.height/2);
+//            lr.checkRect.y = (int)(lr.labelRect.y
+//                    + (float)lr.labelRect.height/2
+//                    - (float)lr.checkRect.height/2);
+//            fixVerticalAlignment(lr, lr.arrowRect);
+//            fixVerticalAlignment(lr, lr.checkRect);
+//        }
+//    }
 
     /**
      * Fixes vertical alignment of all menu item elements if rect.y
      * or (rect.y + rect.height) is out of viewRect bounds
      */
-    private void fixVerticalAlignment(LayoutResult lr, Rectangle r) {
-        int delta = 0;
-        if (r.y < viewRect.y) {
-            delta = viewRect.y - r.y;
-        } else if (r.y + r.height > viewRect.y + viewRect.height) {
-            delta = viewRect.y + viewRect.height - r.y - r.height;
-        }
-        if (delta != 0) {
-            lr.checkRect.y += delta;
-            lr.iconRect.y += delta;
-            lr.textRect.y += delta;
-            lr.accRect.y += delta;
-            lr.arrowRect.y += delta;
-            lr.labelRect.y += delta;
-        }
-    }
-
-    private void doLTRColumnLayout(LayoutResult lr, ColumnAlignment alignment) {
-        // Set maximal width for all the five basic rects
-        // (three other ones are already maximal)
-        lr.iconRect.width = iconSize.maxWidth;
-        lr.textRect.width = textSize.maxWidth;
-
-        // Set X coordinates
-        // All rects will be aligned at the left side
-        calcXPositionsLTR(viewRect.x, leadingGap, gap, lr.checkRect,
-                lr.iconRect, lr.textRect);
-
-        // Tune afterCheckIconGap
-        if (lr.checkRect.width > 0) { // there is the afterCheckIconGap
-            lr.iconRect.x += afterCheckIconGap - gap;
-            lr.textRect.x += afterCheckIconGap - gap;
-        }
-
-        calcXPositionsRTL(viewRect.x + viewRect.width, leadingGap, gap,
-                lr.arrowRect, lr.accRect);
-
-        // Take into account minimal text offset
-        int textOffset = lr.textRect.x - viewRect.x;
-        if (!isTopLevelMenu && (textOffset < minTextOffset)) {
-            lr.textRect.x += minTextOffset - textOffset;
-        }
-
-        alignRects(lr, alignment);
-
-        // Set Y coordinate for text and icon.
-        // Y coordinates for other rects
-        // will be calculated later in layoutMenuItem.
-        calcTextAndIconYPositions(lr);
-
-        // Calculate valid X and Y coordinates for labelRect
-        lr.setLabelRect(lr.textRect.union(lr.iconRect));
-    }
-
-    private void doLTRComplexLayout(LayoutResult lr, ColumnAlignment alignment) {
-        lr.labelRect.width = labelSize.maxWidth;
-
-        // Set X coordinates
-        calcXPositionsLTR(viewRect.x, leadingGap, gap, lr.checkRect,
-                lr.labelRect);
-
-        // Tune afterCheckIconGap
-        if (lr.checkRect.width > 0) { // there is the afterCheckIconGap
-            lr.labelRect.x += afterCheckIconGap - gap;
-        }
-
-        calcXPositionsRTL(viewRect.x + viewRect.width,
-                leadingGap, gap, lr.arrowRect, lr.accRect);
-
-        // Take into account minimal text offset
-        int labelOffset = lr.labelRect.x - viewRect.x;
-        if (!isTopLevelMenu && (labelOffset < minTextOffset)) {
-            lr.labelRect.x += minTextOffset - labelOffset;
-        }
-
-        alignRects(lr, alignment);
-
-        // Center labelRect vertically
-        calcLabelYPosition(lr);
-
-        layoutIconAndTextInLabelRect(lr);
-    }
-
-    private void doRTLColumnLayout(LayoutResult lr, ColumnAlignment alignment) {
-        // Set maximal width for all the five basic rects
-        // (three other ones are already maximal)
-        lr.iconRect.width = iconSize.maxWidth;
-        lr.textRect.width = textSize.maxWidth;
-
-        // Set X coordinates
-        calcXPositionsRTL(viewRect.x + viewRect.width, leadingGap, gap,
-                lr.checkRect, lr.iconRect, lr.textRect);
-
-        // Tune the gap after check icon
-        if (lr.checkRect.width > 0) { // there is the gap after check icon
-            lr.iconRect.x -= afterCheckIconGap - gap;
-            lr.textRect.x -= afterCheckIconGap - gap;
-        }
-
-        calcXPositionsLTR(viewRect.x, leadingGap, gap, lr.arrowRect,
-                lr.accRect);
-
-        // Take into account minimal text offset
-        int textOffset = (viewRect.x + viewRect.width)
-                       - (lr.textRect.x + lr.textRect.width);
-        if (!isTopLevelMenu && (textOffset < minTextOffset)) {
-            lr.textRect.x -= minTextOffset - textOffset;
-        }
-
-        alignRects(lr, alignment);
-
-        // Set Y coordinates for text and icon.
-        // Y coordinates for other rects
-        // will be calculated later in layoutMenuItem.
-        calcTextAndIconYPositions(lr);
-
-        // Calculate valid X and Y coordinate for labelRect
-        lr.setLabelRect(lr.textRect.union(lr.iconRect));
-    }
-
-    private void doRTLComplexLayout(LayoutResult lr, ColumnAlignment alignment) {
-        lr.labelRect.width = labelSize.maxWidth;
-
-        // Set X coordinates
-        calcXPositionsRTL(viewRect.x + viewRect.width, leadingGap, gap,
-                lr.checkRect, lr.labelRect);
-
-        // Tune the gap after check icon
-        if (lr.checkRect.width > 0) { // there is the gap after check icon
-            lr.labelRect.x -= afterCheckIconGap - gap;
-        }
-
-        calcXPositionsLTR(viewRect.x, leadingGap, gap, lr.arrowRect, lr.accRect);
-
-        // Take into account minimal text offset
-        int labelOffset = (viewRect.x + viewRect.width)
-                        - (lr.labelRect.x + lr.labelRect.width);
-        if (!isTopLevelMenu && (labelOffset < minTextOffset)) {
-            lr.labelRect.x -= minTextOffset - labelOffset;
-        }
-
-        alignRects(lr, alignment);
-
-        // Center labelRect vertically
-        calcLabelYPosition(lr);
-
-        layoutIconAndTextInLabelRect(lr);
-    }
-
-    private void alignRects(LayoutResult lr, ColumnAlignment alignment) {
-        alignRect(lr.checkRect, alignment.getCheckAlignment(),
-                  checkSize.getOrigWidth());
-        alignRect(lr.iconRect, alignment.getIconAlignment(),
-                  iconSize.getOrigWidth());
-        alignRect(lr.textRect, alignment.getTextAlignment(),
-                  textSize.getOrigWidth());
-        alignRect(lr.accRect, alignment.getAccAlignment(),
-                  accSize.getOrigWidth());
-        alignRect(lr.arrowRect, alignment.getArrowAlignment(),
-                  arrowSize.getOrigWidth());
-    }
-
-    private void alignRect(Rectangle rect, int alignment, int origWidth) {
-        if (alignment == SwingConstants.RIGHT) {
-            rect.x = rect.x + rect.width - origWidth;
-        }
-        rect.width = origWidth;
-    }
-
-    protected void layoutIconAndTextInLabelRect(LayoutResult lr) {
-        lr.setTextRect(new Rectangle());
-        lr.setIconRect(new Rectangle());
-        SwingUtilities.layoutCompoundLabel(
-                mi, fm, text,icon, verticalAlignment, horizontalAlignment,
-                verticalTextPosition, horizontalTextPosition, lr.labelRect,
-                lr.iconRect, lr.textRect, gap);
-    }
+    private void fixVerticalAlignment(LayoutResult lr, Rectangle r) {throw new RuntimeException("cf-bug");} //{
+//        int delta = 0;
+//        if (r.y < viewRect.y) {
+//            delta = viewRect.y - r.y;
+//        } else if (r.y + r.height > viewRect.y + viewRect.height) {
+//            delta = viewRect.y + viewRect.height - r.y - r.height;
+//        }
+//        if (delta != 0) {
+//            lr.checkRect.y += delta;
+//            lr.iconRect.y += delta;
+//            lr.textRect.y += delta;
+//            lr.accRect.y += delta;
+//            lr.arrowRect.y += delta;
+//            lr.labelRect.y += delta;
+//        }
+//    }
+
+    private void doLTRColumnLayout(LayoutResult lr, ColumnAlignment alignment) {throw new RuntimeException("cf-bug");} //{
+//        // Set maximal width for all the five basic rects
+//        // (three other ones are already maximal)
+//        lr.iconRect.width = iconSize.maxWidth;
+//        lr.textRect.width = textSize.maxWidth;
+//
+//        // Set X coordinates
+//        // All rects will be aligned at the left side
+//        calcXPositionsLTR(viewRect.x, leadingGap, gap, lr.checkRect,
+//                lr.iconRect, lr.textRect);
+//
+//        // Tune afterCheckIconGap
+//        if (lr.checkRect.width > 0) { // there is the afterCheckIconGap
+//            lr.iconRect.x += afterCheckIconGap - gap;
+//            lr.textRect.x += afterCheckIconGap - gap;
+//        }
+//
+//        calcXPositionsRTL(viewRect.x + viewRect.width, leadingGap, gap,
+//                lr.arrowRect, lr.accRect);
+//
+//        // Take into account minimal text offset
+//        int textOffset = lr.textRect.x - viewRect.x;
+//        if (!isTopLevelMenu && (textOffset < minTextOffset)) {
+//            lr.textRect.x += minTextOffset - textOffset;
+//        }
+//
+//        alignRects(lr, alignment);
+//
+//        // Set Y coordinate for text and icon.
+//        // Y coordinates for other rects
+//        // will be calculated later in layoutMenuItem.
+//        calcTextAndIconYPositions(lr);
+//
+//        // Calculate valid X and Y coordinates for labelRect
+//        lr.setLabelRect(lr.textRect.union(lr.iconRect));
+//    }
+
+    private void doLTRComplexLayout(LayoutResult lr, ColumnAlignment alignment) {throw new RuntimeException("cf-bug");} //{
+//        lr.labelRect.width = labelSize.maxWidth;
+//
+//        // Set X coordinates
+//        calcXPositionsLTR(viewRect.x, leadingGap, gap, lr.checkRect,
+//                lr.labelRect);
+//
+//        // Tune afterCheckIconGap
+//        if (lr.checkRect.width > 0) { // there is the afterCheckIconGap
+//            lr.labelRect.x += afterCheckIconGap - gap;
+//        }
+//
+//        calcXPositionsRTL(viewRect.x + viewRect.width,
+//                leadingGap, gap, lr.arrowRect, lr.accRect);
+//
+//        // Take into account minimal text offset
+//        int labelOffset = lr.labelRect.x - viewRect.x;
+//        if (!isTopLevelMenu && (labelOffset < minTextOffset)) {
+//            lr.labelRect.x += minTextOffset - labelOffset;
+//        }
+//
+//        alignRects(lr, alignment);
+//
+//        // Center labelRect vertically
+//        calcLabelYPosition(lr);
+//
+//        layoutIconAndTextInLabelRect(lr);
+//    }
+
+    private void doRTLColumnLayout(LayoutResult lr, ColumnAlignment alignment) {throw new RuntimeException("cf-bug");} //{
+//        // Set maximal width for all the five basic rects
+//        // (three other ones are already maximal)
+//        lr.iconRect.width = iconSize.maxWidth;
+//        lr.textRect.width = textSize.maxWidth;
+//
+//        // Set X coordinates
+//        calcXPositionsRTL(viewRect.x + viewRect.width, leadingGap, gap,
+//                lr.checkRect, lr.iconRect, lr.textRect);
+//
+//        // Tune the gap after check icon
+//        if (lr.checkRect.width > 0) { // there is the gap after check icon
+//            lr.iconRect.x -= afterCheckIconGap - gap;
+//            lr.textRect.x -= afterCheckIconGap - gap;
+//        }
+//
+//        calcXPositionsLTR(viewRect.x, leadingGap, gap, lr.arrowRect,
+//                lr.accRect);
+//
+//        // Take into account minimal text offset
+//        int textOffset = (viewRect.x + viewRect.width)
+//                       - (lr.textRect.x + lr.textRect.width);
+//        if (!isTopLevelMenu && (textOffset < minTextOffset)) {
+//            lr.textRect.x -= minTextOffset - textOffset;
+//        }
+//
+//        alignRects(lr, alignment);
+//
+//        // Set Y coordinates for text and icon.
+//        // Y coordinates for other rects
+//        // will be calculated later in layoutMenuItem.
+//        calcTextAndIconYPositions(lr);
+//
+//        // Calculate valid X and Y coordinate for labelRect
+//        lr.setLabelRect(lr.textRect.union(lr.iconRect));
+//    }
+
+    private void doRTLComplexLayout(LayoutResult lr, ColumnAlignment alignment) {throw new RuntimeException("cf-bug");} //{
+//        lr.labelRect.width = labelSize.maxWidth;
+//
+//        // Set X coordinates
+//        calcXPositionsRTL(viewRect.x + viewRect.width, leadingGap, gap,
+//                lr.checkRect, lr.labelRect);
+//
+//        // Tune the gap after check icon
+//        if (lr.checkRect.width > 0) { // there is the gap after check icon
+//            lr.labelRect.x -= afterCheckIconGap - gap;
+//        }
+//
+//        calcXPositionsLTR(viewRect.x, leadingGap, gap, lr.arrowRect, lr.accRect);
+//
+//        // Take into account minimal text offset
+//        int labelOffset = (viewRect.x + viewRect.width)
+//                        - (lr.labelRect.x + lr.labelRect.width);
+//        if (!isTopLevelMenu && (labelOffset < minTextOffset)) {
+//            lr.labelRect.x -= minTextOffset - labelOffset;
+//        }
+//
+//        alignRects(lr, alignment);
+//
+//        // Center labelRect vertically
+//        calcLabelYPosition(lr);
+//
+//        layoutIconAndTextInLabelRect(lr);
+//    }
+
+    private void alignRects(LayoutResult lr, ColumnAlignment alignment) {throw new RuntimeException("cf-bug");} //{
+//        alignRect(lr.checkRect, alignment.getCheckAlignment(),
+//                  checkSize.getOrigWidth());
+//        alignRect(lr.iconRect, alignment.getIconAlignment(),
+//                  iconSize.getOrigWidth());
+//        alignRect(lr.textRect, alignment.getTextAlignment(),
+//                  textSize.getOrigWidth());
+//        alignRect(lr.accRect, alignment.getAccAlignment(),
+//                  accSize.getOrigWidth());
+//        alignRect(lr.arrowRect, alignment.getArrowAlignment(),
+//                  arrowSize.getOrigWidth());
+//    }
+
+    private void alignRect(Rectangle rect, int alignment, int origWidth) {throw new RuntimeException("cf-bug");} //{
+//        if (alignment == SwingConstants.RIGHT) {
+//            rect.x = rect.x + rect.width - origWidth;
+//        }
+//        rect.width = origWidth;
+//    }
+
+    protected void layoutIconAndTextInLabelRect(LayoutResult lr) {throw new RuntimeException("cf-bug");} //{
+//        lr.setTextRect(new Rectangle());
+//        lr.setIconRect(new Rectangle());
+//        SwingUtilities.layoutCompoundLabel(
+//                mi, fm, text,icon, verticalAlignment, horizontalAlignment,
+//                verticalTextPosition, horizontalTextPosition, lr.labelRect,
+//                lr.iconRect, lr.textRect, gap);
+//    }
 
     private void calcXPositionsLTR(int startXPos, int leadingGap,
-                                   int gap, Rectangle... rects) {
-        int curXPos = startXPos + leadingGap;
-        for (Rectangle rect : rects) {
-            rect.x = curXPos;
-            if (rect.width > 0) {
-                curXPos += rect.width + gap;
-            }
-        }
-    }
+                                   int gap, Rectangle... rects) {throw new RuntimeException("cf-bug");} //{
+//        int curXPos = startXPos + leadingGap;
+//        for (Rectangle rect : rects) {
+//            rect.x = curXPos;
+//            if (rect.width > 0) {
+//                curXPos += rect.width + gap;
+//            }
+//        }
+//    }
 
     private void calcXPositionsRTL(int startXPos, int leadingGap,
-                                   int gap, Rectangle... rects) {
-        int curXPos = startXPos - leadingGap;
-        for (Rectangle rect : rects) {
-            rect.x = curXPos - rect.width;
-            if (rect.width > 0) {
-                curXPos -= rect.width + gap;
-            }
-        }
-    }
+                                   int gap, Rectangle... rects) {throw new RuntimeException("cf-bug");} //{
+//        int curXPos = startXPos - leadingGap;
+//        for (Rectangle rect : rects) {
+//            rect.x = curXPos - rect.width;
+//            if (rect.width > 0) {
+//                curXPos -= rect.width + gap;
+//            }
+//        }
+//    }
 
    /**
      * Sets Y coordinates of text and icon
      * taking into account the vertical alignment
      */
-    private void calcTextAndIconYPositions(LayoutResult lr) {
-        if (verticalAlignment == SwingUtilities.TOP) {
-            lr.textRect.y  = (int)(viewRect.y
-                    + (float)lr.labelRect.height/2
-                    - (float)lr.textRect.height/2);
-            lr.iconRect.y  = (int)(viewRect.y
-                    + (float)lr.labelRect.height/2
-                    - (float)lr.iconRect.height/2);
-        } else if (verticalAlignment == SwingUtilities.CENTER) {
-            lr.textRect.y = (int)(viewRect.y
-                    + (float)viewRect.height/2
-                    - (float)lr.textRect.height/2);
-            lr.iconRect.y = (int)(viewRect.y
-                    + (float)viewRect.height/2
-                    - (float)lr.iconRect.height/2);
-        }
-        else if (verticalAlignment == SwingUtilities.BOTTOM) {
-            lr.textRect.y = (int)(viewRect.y
-                    + viewRect.height
-                    - (float)lr.labelRect.height/2
-                    - (float)lr.textRect.height/2);
-            lr.iconRect.y = (int)(viewRect.y
-                    + viewRect.height
-                    - (float)lr.labelRect.height/2
-                    - (float)lr.iconRect.height/2);
-        }
-    }
+    private void calcTextAndIconYPositions(LayoutResult lr) {throw new RuntimeException("cf-bug");} //{
+//        if (verticalAlignment == SwingUtilities.TOP) {
+//            lr.textRect.y  = (int)(viewRect.y
+//                    + (float)lr.labelRect.height/2
+//                    - (float)lr.textRect.height/2);
+//            lr.iconRect.y  = (int)(viewRect.y
+//                    + (float)lr.labelRect.height/2
+//                    - (float)lr.iconRect.height/2);
+//        } else if (verticalAlignment == SwingUtilities.CENTER) {
+//            lr.textRect.y = (int)(viewRect.y
+//                    + (float)viewRect.height/2
+//                    - (float)lr.textRect.height/2);
+//            lr.iconRect.y = (int)(viewRect.y
+//                    + (float)viewRect.height/2
+//                    - (float)lr.iconRect.height/2);
+//        }
+//        else if (verticalAlignment == SwingUtilities.BOTTOM) {
+//            lr.textRect.y = (int)(viewRect.y
+//                    + viewRect.height
+//                    - (float)lr.labelRect.height/2
+//                    - (float)lr.textRect.height/2);
+//            lr.iconRect.y = (int)(viewRect.y
+//                    + viewRect.height
+//                    - (float)lr.labelRect.height/2
+//                    - (float)lr.iconRect.height/2);
+//        }
+//    }
 
     /**
      * Sets labelRect Y coordinate
      * taking into account the vertical alignment
      */
-    private void calcLabelYPosition(LayoutResult lr) {
-        if (verticalAlignment == SwingUtilities.TOP) {
-            lr.labelRect.y  = viewRect.y;
-        } else if (verticalAlignment == SwingUtilities.CENTER) {
-            lr.labelRect.y = (int)(viewRect.y
-                    + (float)viewRect.height/2
-                    - (float)lr.labelRect.height/2);
-        } else if (verticalAlignment == SwingUtilities.BOTTOM) {
-            lr.labelRect.y  = viewRect.y + viewRect.height
-                    - lr.labelRect.height;
-        }
-    }
+    private void calcLabelYPosition(LayoutResult lr) {throw new RuntimeException("cf-bug");} //{
+//        if (verticalAlignment == SwingUtilities.TOP) {
+//            lr.labelRect.y  = viewRect.y;
+//        } else if (verticalAlignment == SwingUtilities.CENTER) {
+//            lr.labelRect.y = (int)(viewRect.y
+//                    + (float)viewRect.height/2
+//                    - (float)lr.labelRect.height/2);
+//        } else if (verticalAlignment == SwingUtilities.BOTTOM) {
+//            lr.labelRect.y  = viewRect.y + viewRect.height
+//                    - lr.labelRect.height;
+//        }
+//    }
 
     /**
      * Returns parent of this component if it is not a top-level menu
@@ -800,328 +800,328 @@
      * @return parent of this component if it is not a top-level menu
      * Otherwise returns null.
      */
-    public static JComponent getMenuItemParent(JMenuItem menuItem) {
-        Container parent = menuItem.getParent();
-        if ((parent instanceof JComponent) &&
-             (!(menuItem instanceof JMenu) ||
-               !((JMenu)menuItem).isTopLevelMenu())) {
-            return (JComponent) parent;
-        } else {
-            return null;
-        }
-    }
-
-    public static void clearUsedParentClientProperties(JMenuItem menuItem) {
-        clearUsedClientProperties(getMenuItemParent(menuItem));
-    }
-
-    public static void clearUsedClientProperties(JComponent c) {
-        if (c != null) {
-            c.putClientProperty(MAX_ARROW_WIDTH, null);
-            c.putClientProperty(MAX_CHECK_WIDTH, null);
-            c.putClientProperty(MAX_ACC_WIDTH, null);
-            c.putClientProperty(MAX_TEXT_WIDTH, null);
-            c.putClientProperty(MAX_ICON_WIDTH, null);
-            c.putClientProperty(MAX_LABEL_WIDTH, null);
-            c.putClientProperty(BASICMENUITEMUI_MAX_TEXT_OFFSET, null);
-        }
-    }
+    public static JComponent getMenuItemParent(JMenuItem menuItem) {throw new RuntimeException("cf-bug");} //{
+//        Container parent = menuItem.getParent();
+//        if ((parent instanceof JComponent) &&
+//             (!(menuItem instanceof JMenu) ||
+//               !((JMenu)menuItem).isTopLevelMenu())) {
+//            return (JComponent) parent;
+//        } else {
+//            return null;
+//        }
+//    }
+
+    public static void clearUsedParentClientProperties(JMenuItem menuItem) {throw new RuntimeException("cf-bug");} //{
+//        clearUsedClientProperties(getMenuItemParent(menuItem));
+//    }
+
+    public static void clearUsedClientProperties(JComponent c) {throw new RuntimeException("cf-bug");} //{
+//        if (c != null) {
+//            c.putClientProperty(MAX_ARROW_WIDTH, null);
+//            c.putClientProperty(MAX_CHECK_WIDTH, null);
+//            c.putClientProperty(MAX_ACC_WIDTH, null);
+//            c.putClientProperty(MAX_TEXT_WIDTH, null);
+//            c.putClientProperty(MAX_ICON_WIDTH, null);
+//            c.putClientProperty(MAX_LABEL_WIDTH, null);
+//            c.putClientProperty(BASICMENUITEMUI_MAX_TEXT_OFFSET, null);
+//        }
+//    }
 
     /**
      * Finds and returns maximal integer value in the given array.
      * @param values array where the search will be performed.
      * @return maximal vaule.
      */
-    public static int max(int... values) {
-        int maxValue = Integer.MIN_VALUE;
-        for (int i : values) {
-            if (i > maxValue) {
-                maxValue = i;
-            }
-        }
-        return maxValue;
-    }
-
-    public static Rectangle createMaxRect() {
-        return new Rectangle(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE);
-    }
-
-    public static void addMaxWidth(RectSize size, int gap, Dimension result) {
-        if (size.maxWidth > 0) {
-            result.width += size.maxWidth + gap;
-        }
-    }
-
-    public static void addWidth(int width, int gap, Dimension result) {
-        if (width > 0) {
-            result.width += width + gap;
-        }
-    }
-
-    public JMenuItem getMenuItem() {
-        return mi;
-    }
-
-    public JComponent getMenuItemParent() {
-        return miParent;
-    }
-
-    public Font getFont() {
-        return font;
-    }
-
-    public Font getAccFont() {
-        return accFont;
-    }
-
-    public FontMetrics getFontMetrics() {
-        return fm;
-    }
-
-    public FontMetrics getAccFontMetrics() {
-        return accFm;
-    }
-
-    public Icon getIcon() {
-        return icon;
-    }
-
-    public Icon getCheckIcon() {
-        return checkIcon;
-    }
-
-    public Icon getArrowIcon() {
-        return arrowIcon;
-    }
-
-    public String getText() {
-        return text;
-    }
-
-    public String getAccText() {
-        return accText;
-    }
-
-    public boolean isColumnLayout() {
-        return isColumnLayout;
-    }
-
-    public boolean useCheckAndArrow() {
-        return useCheckAndArrow;
-    }
-
-    public boolean isLeftToRight() {
-        return isLeftToRight;
-    }
-
-    public boolean isTopLevelMenu() {
-        return isTopLevelMenu;
-    }
-
-    public View getHtmlView() {
-        return htmlView;
-    }
-
-    public int getVerticalAlignment() {
-        return verticalAlignment;
-    }
-
-    public int getHorizontalAlignment() {
-        return horizontalAlignment;
-    }
-
-    public int getVerticalTextPosition() {
-        return verticalTextPosition;
-    }
-
-    public int getHorizontalTextPosition() {
-        return horizontalTextPosition;
-    }
-
-    public int getGap() {
-        return gap;
-    }
-
-    public int getLeadingGap() {
-        return leadingGap;
-    }
-
-    public int getAfterCheckIconGap() {
-        return afterCheckIconGap;
-    }
-
-    public int getMinTextOffset() {
-        return minTextOffset;
-    }
-
-    public Rectangle getViewRect() {
-        return viewRect;
-    }
-
-    public RectSize getIconSize() {
-        return iconSize;
-    }
-
-    public RectSize getTextSize() {
-        return textSize;
-    }
-
-    public RectSize getAccSize() {
-        return accSize;
-    }
-
-    public RectSize getCheckSize() {
-        return checkSize;
-    }
-
-    public RectSize getArrowSize() {
-        return arrowSize;
-    }
-
-    public RectSize getLabelSize() {
-        return labelSize;
-    }
-
-    protected void setMenuItem(JMenuItem mi) {
-        this.mi = mi;
-    }
-
-    protected void setMenuItemParent(JComponent miParent) {
-        this.miParent = miParent;
-    }
-
-    protected void setFont(Font font) {
-        this.font = font;
-    }
-
-    protected void setAccFont(Font accFont) {
-        this.accFont = accFont;
-    }
-
-    protected void setFontMetrics(FontMetrics fm) {
-        this.fm = fm;
-    }
-
-    protected void setAccFontMetrics(FontMetrics accFm) {
-        this.accFm = accFm;
-    }
-
-    protected void setIcon(Icon icon) {
-        this.icon = icon;
-    }
-
-    protected void setCheckIcon(Icon checkIcon) {
-        this.checkIcon = checkIcon;
-    }
-
-    protected void setArrowIcon(Icon arrowIcon) {
-        this.arrowIcon = arrowIcon;
-    }
-
-    protected void setText(String text) {
-        this.text = text;
-    }
-
-    protected void setAccText(String accText) {
-        this.accText = accText;
-    }
-
-    protected void setColumnLayout(boolean columnLayout) {
-        isColumnLayout = columnLayout;
-    }
-
-    protected void setUseCheckAndArrow(boolean useCheckAndArrow) {
-        this.useCheckAndArrow = useCheckAndArrow;
-    }
-
-    protected void setLeftToRight(boolean leftToRight) {
-        isLeftToRight = leftToRight;
-    }
-
-    protected void setTopLevelMenu(boolean topLevelMenu) {
-        isTopLevelMenu = topLevelMenu;
-    }
-
-    protected void setHtmlView(View htmlView) {
-        this.htmlView = htmlView;
-    }
-
-    protected void setVerticalAlignment(int verticalAlignment) {
-        this.verticalAlignment = verticalAlignment;
-    }
-
-    protected void setHorizontalAlignment(int horizontalAlignment) {
-        this.horizontalAlignment = horizontalAlignment;
-    }
-
-    protected void setVerticalTextPosition(int verticalTextPosition) {
-        this.verticalTextPosition = verticalTextPosition;
-    }
-
-    protected void setHorizontalTextPosition(int horizontalTextPosition) {
-        this.horizontalTextPosition = horizontalTextPosition;
-    }
-
-    protected void setGap(int gap) {
-        this.gap = gap;
-    }
-
-    protected void setLeadingGap(int leadingGap) {
-        this.leadingGap = leadingGap;
-    }
-
-    protected void setAfterCheckIconGap(int afterCheckIconGap) {
-        this.afterCheckIconGap = afterCheckIconGap;
-    }
-
-    protected void setMinTextOffset(int minTextOffset) {
-        this.minTextOffset = minTextOffset;
-    }
-
-    protected void setViewRect(Rectangle viewRect) {
-        this.viewRect = viewRect;
-    }
-
-    protected void setIconSize(RectSize iconSize) {
-        this.iconSize = iconSize;
-    }
-
-    protected void setTextSize(RectSize textSize) {
-        this.textSize = textSize;
-    }
-
-    protected void setAccSize(RectSize accSize) {
-        this.accSize = accSize;
-    }
-
-    protected void setCheckSize(RectSize checkSize) {
-        this.checkSize = checkSize;
-    }
-
-    protected void setArrowSize(RectSize arrowSize) {
-        this.arrowSize = arrowSize;
-    }
-
-    protected void setLabelSize(RectSize labelSize) {
-        this.labelSize = labelSize;
-    }
-
-    public int getLeftTextExtraWidth() {
-        return leftTextExtraWidth;
-    }
+    public static int max(int... values) {throw new RuntimeException("cf-bug");} //{
+//        int maxValue = Integer.MIN_VALUE;
+//        for (int i : values) {
+//            if (i > maxValue) {
+//                maxValue = i;
+//            }
+//        }
+//        return maxValue;
+//    }
+
+    public static Rectangle createMaxRect() {throw new RuntimeException("cf-bug");} //{
+//        return new Rectangle(0, 0, Integer.MAX_VALUE, Integer.MAX_VALUE);
+//    }
+
+    public static void addMaxWidth(RectSize size, int gap, Dimension result) {throw new RuntimeException("cf-bug");} //{
+//        if (size.maxWidth > 0) {
+//            result.width += size.maxWidth + gap;
+//        }
+//    }
+
+    public static void addWidth(int width, int gap, Dimension result) {throw new RuntimeException("cf-bug");} //{
+//        if (width > 0) {
+//            result.width += width + gap;
+//        }
+//    }
+
+    public JMenuItem getMenuItem() {throw new RuntimeException("cf-bug");} //{
+//        return mi;
+//    }
+
+    public JComponent getMenuItemParent() {throw new RuntimeException("cf-bug");} //{
+//        return miParent;
+//    }
+
+    public Font getFont() {throw new RuntimeException("cf-bug");} //{
+//        return font;
+//    }
+
+    public Font getAccFont() {throw new RuntimeException("cf-bug");} //{
+//        return accFont;
+//    }
+
+    public FontMetrics getFontMetrics() {throw new RuntimeException("cf-bug");} //{
+//        return fm;
+//    }
+
+    public FontMetrics getAccFontMetrics() {throw new RuntimeException("cf-bug");} //{
+//        return accFm;
+//    }
+
+    public Icon getIcon() {throw new RuntimeException("cf-bug");} //{
+//        return icon;
+//    }
+
+    public Icon getCheckIcon() {throw new RuntimeException("cf-bug");} //{
+//        return checkIcon;
+//    }
+
+    public Icon getArrowIcon() {throw new RuntimeException("cf-bug");} //{
+//        return arrowIcon;
+//    }
+
+    public String getText() {throw new RuntimeException("cf-bug");} //{
+//        return text;
+//    }
+
+    public String getAccText() {throw new RuntimeException("cf-bug");} //{
+//        return accText;
+//    }
+
+    public boolean isColumnLayout() {throw new RuntimeException("cf-bug");} //{
+//        return isColumnLayout;
+//    }
+
+    public boolean useCheckAndArrow() {throw new RuntimeException("cf-bug");} //{
+//        return useCheckAndArrow;
+//    }
+
+    public boolean isLeftToRight() {throw new RuntimeException("cf-bug");} //{
+//        return isLeftToRight;
+//    }
+
+    public boolean isTopLevelMenu() {throw new RuntimeException("cf-bug");} //{
+//        return isTopLevelMenu;
+//    }
+
+    public View getHtmlView() {throw new RuntimeException("cf-bug");} //{
+//        return htmlView;
+//    }
+
+    public int getVerticalAlignment() {throw new RuntimeException("cf-bug");} //{
+//        return verticalAlignment;
+//    }
+
+    public int getHorizontalAlignment() {throw new RuntimeException("cf-bug");} //{
+//        return horizontalAlignment;
+//    }
+
+    public int getVerticalTextPosition() {throw new RuntimeException("cf-bug");} //{
+//        return verticalTextPosition;
+//    }
+
+    public int getHorizontalTextPosition() {throw new RuntimeException("cf-bug");} //{
+//        return horizontalTextPosition;
+//    }
+
+    public int getGap() {throw new RuntimeException("cf-bug");} //{
+//        return gap;
+//    }
+
+    public int getLeadingGap() {throw new RuntimeException("cf-bug");} //{
+//        return leadingGap;
+//    }
+
+    public int getAfterCheckIconGap() {throw new RuntimeException("cf-bug");} //{
+//        return afterCheckIconGap;
+//    }
+
+    public int getMinTextOffset() {throw new RuntimeException("cf-bug");} //{
+//        return minTextOffset;
+//    }
+
+    public Rectangle getViewRect() {throw new RuntimeException("cf-bug");} //{
+//        return viewRect;
+//    }
+
+    public RectSize getIconSize() {throw new RuntimeException("cf-bug");} //{
+//        return iconSize;
+//    }
+
+    public RectSize getTextSize() {throw new RuntimeException("cf-bug");} //{
+//        return textSize;
+//    }
+
+    public RectSize getAccSize() {throw new RuntimeException("cf-bug");} //{
+//        return accSize;
+//    }
+
+    public RectSize getCheckSize() {throw new RuntimeException("cf-bug");} //{
+//        return checkSize;
+//    }
+
+    public RectSize getArrowSize() {throw new RuntimeException("cf-bug");} //{
+//        return arrowSize;
+//    }
+
+    public RectSize getLabelSize() {throw new RuntimeException("cf-bug");} //{
+//        return labelSize;
+//    }
+
+    protected void setMenuItem(JMenuItem mi) {throw new RuntimeException("cf-bug");} //{
+//        this.mi = mi;
+//    }
+
+    protected void setMenuItemParent(JComponent miParent) {throw new RuntimeException("cf-bug");} //{
+//        this.miParent = miParent;
+//    }
+
+    protected void setFont(Font font) {throw new RuntimeException("cf-bug");} //{
+//        this.font = font;
+//    }
+
+    protected void setAccFont(Font accFont) {throw new RuntimeException("cf-bug");} //{
+//        this.accFont = accFont;
+//    }
+
+    protected void setFontMetrics(FontMetrics fm) {throw new RuntimeException("cf-bug");} //{
+//        this.fm = fm;
+//    }
+
+    protected void setAccFontMetrics(FontMetrics accFm) {throw new RuntimeException("cf-bug");} //{
+//        this.accFm = accFm;
+//    }
+
+    protected void setIcon(Icon icon) {throw new RuntimeException("cf-bug");} //{
+//        this.icon = icon;
+//    }
+
+    protected void setCheckIcon(Icon checkIcon) {throw new RuntimeException("cf-bug");} //{
+//        this.checkIcon = checkIcon;
+//    }
+
+    protected void setArrowIcon(Icon arrowIcon) {throw new RuntimeException("cf-bug");} //{
+//        this.arrowIcon = arrowIcon;
+//    }
+
+    protected void setText(String text) {throw new RuntimeException("cf-bug");} //{
+//        this.text = text;
+//    }
+
+    protected void setAccText(String accText) {throw new RuntimeException("cf-bug");} //{
+//        this.accText = accText;
+//    }
+
+    protected void setColumnLayout(boolean columnLayout) {throw new RuntimeException("cf-bug");} //{
+//        isColumnLayout = columnLayout;
+//    }
+
+    protected void setUseCheckAndArrow(boolean useCheckAndArrow) {throw new RuntimeException("cf-bug");} //{
+//        this.useCheckAndArrow = useCheckAndArrow;
+//    }
+
+    protected void setLeftToRight(boolean leftToRight) {throw new RuntimeException("cf-bug");} //{
+//        isLeftToRight = leftToRight;
+//    }
+
+    protected void setTopLevelMenu(boolean topLevelMenu) {throw new RuntimeException("cf-bug");} //{
+//        isTopLevelMenu = topLevelMenu;
+//    }
+
+    protected void setHtmlView(View htmlView) {throw new RuntimeException("cf-bug");} //{
+//        this.htmlView = htmlView;
+//    }
+
+    protected void setVerticalAlignment(int verticalAlignment) {throw new RuntimeException("cf-bug");} //{
+//        this.verticalAlignment = verticalAlignment;
+//    }
+
+    protected void setHorizontalAlignment(int horizontalAlignment) {throw new RuntimeException("cf-bug");} //{
+//        this.horizontalAlignment = horizontalAlignment;
+//    }
+
+    protected void setVerticalTextPosition(int verticalTextPosition) {throw new RuntimeException("cf-bug");} //{
+//        this.verticalTextPosition = verticalTextPosition;
+//    }
+
+    protected void setHorizontalTextPosition(int horizontalTextPosition) {throw new RuntimeException("cf-bug");} //{
+//        this.horizontalTextPosition = horizontalTextPosition;
+//    }
+
+    protected void setGap(int gap) {throw new RuntimeException("cf-bug");} //{
+//        this.gap = gap;
+//    }
+
+    protected void setLeadingGap(int leadingGap) {throw new RuntimeException("cf-bug");} //{
+//        this.leadingGap = leadingGap;
+//    }
+
+    protected void setAfterCheckIconGap(int afterCheckIconGap) {throw new RuntimeException("cf-bug");} //{
+//        this.afterCheckIconGap = afterCheckIconGap;
+//    }
+
+    protected void setMinTextOffset(int minTextOffset) {throw new RuntimeException("cf-bug");} //{
+//        this.minTextOffset = minTextOffset;
+//    }
+
+    protected void setViewRect(Rectangle viewRect) {throw new RuntimeException("cf-bug");} //{
+//        this.viewRect = viewRect;
+//    }
+
+    protected void setIconSize(RectSize iconSize) {throw new RuntimeException("cf-bug");} //{
+//        this.iconSize = iconSize;
+//    }
+
+    protected void setTextSize(RectSize textSize) {throw new RuntimeException("cf-bug");} //{
+//        this.textSize = textSize;
+//    }
+
+    protected void setAccSize(RectSize accSize) {throw new RuntimeException("cf-bug");} //{
+//        this.accSize = accSize;
+//    }
+
+    protected void setCheckSize(RectSize checkSize) {throw new RuntimeException("cf-bug");} //{
+//        this.checkSize = checkSize;
+//    }
+
+    protected void setArrowSize(RectSize arrowSize) {throw new RuntimeException("cf-bug");} //{
+//        this.arrowSize = arrowSize;
+//    }
+
+    protected void setLabelSize(RectSize labelSize) {throw new RuntimeException("cf-bug");} //{
+//        this.labelSize = labelSize;
+//    }
+
+    public int getLeftTextExtraWidth() {throw new RuntimeException("cf-bug");} //{
+//        return leftTextExtraWidth;
+//    }
 
     /**
      * Returns false if the component is a JMenu and it is a top
      * level menu (on the menubar).
      */
-    public static boolean useCheckAndArrow(JMenuItem menuItem) {
-        boolean b = true;
-        if ((menuItem instanceof JMenu) &&
-                (((JMenu) menuItem).isTopLevelMenu())) {
-            b = false;
-        }
-        return b;
-    }
+    public static boolean useCheckAndArrow(JMenuItem menuItem) {throw new RuntimeException("cf-bug");} //{
+//        boolean b = true;
+//        if ((menuItem instanceof JMenu) &&
+//                (((JMenu) menuItem).isTopLevelMenu())) {
+//            b = false;
+//        }
+//        return b;
+//    }
 
     public static class LayoutResult {
         private Rectangle iconRect;
@@ -1151,64 +1151,64 @@
             this.labelRect = labelRect;
         }
 
-        public Rectangle getIconRect() {
-            return iconRect;
-        }
-
-        public void setIconRect(Rectangle iconRect) {
-            this.iconRect = iconRect;
-        }
-
-        public Rectangle getTextRect() {
-            return textRect;
-        }
-
-        public void setTextRect(Rectangle textRect) {
-            this.textRect = textRect;
-        }
-
-        public Rectangle getAccRect() {
-            return accRect;
-        }
-
-        public void setAccRect(Rectangle accRect) {
-            this.accRect = accRect;
-        }
-
-        public Rectangle getCheckRect() {
-            return checkRect;
-        }
-
-        public void setCheckRect(Rectangle checkRect) {
-            this.checkRect = checkRect;
-        }
-
-        public Rectangle getArrowRect() {
-            return arrowRect;
-        }
-
-        public void setArrowRect(Rectangle arrowRect) {
-            this.arrowRect = arrowRect;
-        }
-
-        public Rectangle getLabelRect() {
-            return labelRect;
-        }
-
-        public void setLabelRect(Rectangle labelRect) {
-            this.labelRect = labelRect;
-        }
-
-        public Map<String, Rectangle> getAllRects() {
-            Map<String, Rectangle> result = new HashMap<String, Rectangle>();
-            result.put("checkRect", checkRect);
-            result.put("iconRect", iconRect);
-            result.put("textRect", textRect);
-            result.put("accRect", accRect);
-            result.put("arrowRect", arrowRect);
-            result.put("labelRect", labelRect);
-            return result;
-        }
+        public Rectangle getIconRect() {throw new RuntimeException("cf-bug");} //{
+//            return iconRect;
+//        }
+
+        public void setIconRect(Rectangle iconRect) {throw new RuntimeException("cf-bug");} //{
+//            this.iconRect = iconRect;
+//        }
+
+        public Rectangle getTextRect() {throw new RuntimeException("cf-bug");} //{
+//            return textRect;
+//        }
+
+        public void setTextRect(Rectangle textRect) {throw new RuntimeException("cf-bug");} //{
+//            this.textRect = textRect;
+//        }
+
+        public Rectangle getAccRect() {throw new RuntimeException("cf-bug");} //{
+//            return accRect;
+//        }
+
+        public void setAccRect(Rectangle accRect) {throw new RuntimeException("cf-bug");} //{
+//            this.accRect = accRect;
+//        }
+
+        public Rectangle getCheckRect() {throw new RuntimeException("cf-bug");} //{
+//            return checkRect;
+//        }
+
+        public void setCheckRect(Rectangle checkRect) {throw new RuntimeException("cf-bug");} //{
+//            this.checkRect = checkRect;
+//        }
+
+        public Rectangle getArrowRect() {throw new RuntimeException("cf-bug");} //{
+//            return arrowRect;
+//        }
+
+        public void setArrowRect(Rectangle arrowRect) {throw new RuntimeException("cf-bug");} //{
+//            this.arrowRect = arrowRect;
+//        }
+
+        public Rectangle getLabelRect() {throw new RuntimeException("cf-bug");} //{
+//            return labelRect;
+//        }
+
+        public void setLabelRect(Rectangle labelRect) {throw new RuntimeException("cf-bug");} //{
+//            this.labelRect = labelRect;
+//        }
+
+        public Map<String, Rectangle> getAllRects() {throw new RuntimeException("cf-bug");} //{
+//            Map<String, Rectangle> result = new HashMap<String, Rectangle>();
+//            result.put("checkRect", checkRect);
+//            result.put("iconRect", iconRect);
+//            result.put("textRect", textRect);
+//            result.put("accRect", accRect);
+//            result.put("arrowRect", arrowRect);
+//            result.put("labelRect", labelRect);
+//            return result;
+//        }
     }
 
     public static class ColumnAlignment {
@@ -1238,33 +1238,33 @@
 
         public ColumnAlignment(int checkAlignment, int iconAlignment,
                                int textAlignment, int accAlignment,
-                               int arrowAlignment) {
-            this.checkAlignment = checkAlignment;
-            this.iconAlignment = iconAlignment;
-            this.textAlignment = textAlignment;
-            this.accAlignment = accAlignment;
-            this.arrowAlignment = arrowAlignment;
-        }
-
-        public int getCheckAlignment() {
-            return checkAlignment;
-        }
-
-        public int getIconAlignment() {
-            return iconAlignment;
-        }
-
-        public int getTextAlignment() {
-            return textAlignment;
-        }
-
-        public int getAccAlignment() {
-            return accAlignment;
-        }
-
-        public int getArrowAlignment() {
-            return arrowAlignment;
-        }
+                               int arrowAlignment) {throw new RuntimeException("cf-bug");} //{
+//            this.checkAlignment = checkAlignment;
+//            this.iconAlignment = iconAlignment;
+//            this.textAlignment = textAlignment;
+//            this.accAlignment = accAlignment;
+//            this.arrowAlignment = arrowAlignment;
+//        }
+
+        public int getCheckAlignment() {throw new RuntimeException("cf-bug");} //{
+//            return checkAlignment;
+//        }
+
+        public int getIconAlignment() {throw new RuntimeException("cf-bug");} //{
+//            return iconAlignment;
+//        }
+
+        public int getTextAlignment() {throw new RuntimeException("cf-bug");} //{
+//            return textAlignment;
+//        }
+
+        public int getAccAlignment() {throw new RuntimeException("cf-bug");} //{
+//            return accAlignment;
+//        }
+
+        public int getArrowAlignment() {throw new RuntimeException("cf-bug");} //{
+//            return arrowAlignment;
+//        }
     }
 
     public static class RectSize {
@@ -1283,41 +1283,41 @@
             this.maxWidth = maxWidth;
         }
 
-        public int getWidth() {
-            return width;
-        }
-
-        public int getHeight() {
-            return height;
-        }
-
-        public int getOrigWidth() {
-            return origWidth;
-        }
-
-        public int getMaxWidth() {
-            return maxWidth;
-        }
-
-        public void setWidth(int width) {
-            this.width = width;
-        }
-
-        public void setHeight(int height) {
-            this.height = height;
-        }
-
-        public void setOrigWidth(int origWidth) {
-            this.origWidth = origWidth;
-        }
-
-        public void setMaxWidth(int maxWidth) {
-            this.maxWidth = maxWidth;
-        }
-
-        public String toString() {
-            return "[w=" + width + ",h=" + height + ",ow="
-                    + origWidth + ",mw=" + maxWidth + "]";
-        }
+        public int getWidth() {throw new RuntimeException("cf-bug");} //{
+//            return width;
+//        }
+
+        public int getHeight() {throw new RuntimeException("cf-bug");} //{
+//            return height;
+//        }
+
+        public int getOrigWidth() {throw new RuntimeException("cf-bug");} //{
+//            return origWidth;
+//        }
+
+        public int getMaxWidth() {throw new RuntimeException("cf-bug");} //{
+//            return maxWidth;
+//        }
+
+        public void setWidth(int width) {throw new RuntimeException("cf-bug");} //{
+//            this.width = width;
+//        }
+
+        public void setHeight(int height) {throw new RuntimeException("cf-bug");} //{
+//            this.height = height;
+//        }
+
+        public void setOrigWidth(int origWidth) {throw new RuntimeException("cf-bug");} //{
+//            this.origWidth = origWidth;
+//        }
+
+        public void setMaxWidth(int maxWidth) {throw new RuntimeException("cf-bug");} //{
+//            this.maxWidth = maxWidth;
+//        }
+
+        public String toString() {throw new RuntimeException("cf-bug");} //{
+//            return "[w=" + width + ",h=" + height + ",ow="
+//                    + origWidth + ",mw=" + maxWidth + "]";
+//        }
     }
 }
--- a/sun/swing/JLightweightFrame.java	2016-06-22 19:55:36.618973545 -0700
+++ b/sun/swing/JLightweightFrame.java	2016-06-29 12:42:27.581234172 -0700
@@ -108,9 +108,9 @@
     static {
         SwingAccessor.setJLightweightFrameAccessor(new SwingAccessor.JLightweightFrameAccessor() {
             @Override
-            public void updateCursor(JLightweightFrame frame) {
-                frame.updateClientCursor();
-            }
+            public void updateCursor(JLightweightFrame frame) {throw new RuntimeException("cf-bug");} //{
+//                frame.updateClientCursor();
+//            }
         });
         copyBufferEnabled = "true".equals(AccessController.
             doPrivileged(new GetPropertyAction("swing.jlf.copyBufferEnabled", "true")));
@@ -133,19 +133,19 @@
 
         layoutSizeListener = new PropertyChangeListener() {
             @Override
-            public void propertyChange(PropertyChangeEvent e) {
-                Dimension d = (Dimension)e.getNewValue();
-
-                if ("preferredSize".equals(e.getPropertyName())) {
-                    content.preferredSizeChanged(d.width, d.height);
-
-                } else if ("maximumSize".equals(e.getPropertyName())) {
-                    content.maximumSizeChanged(d.width, d.height);
-
-                } else if ("minimumSize".equals(e.getPropertyName())) {
-                    content.minimumSizeChanged(d.width, d.height);
-                }
-            }
+            public void propertyChange(PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//                Dimension d = (Dimension)e.getNewValue();
+//
+//                if ("preferredSize".equals(e.getPropertyName())) {
+//                    content.preferredSizeChanged(d.width, d.height);
+//
+//                } else if ("maximumSize".equals(e.getPropertyName())) {
+//                    content.maximumSizeChanged(d.width, d.height);
+//
+//                } else if ("minimumSize".equals(e.getPropertyName())) {
+//                    content.minimumSizeChanged(d.width, d.height);
+//                }
+//            }
         };
 
         repaintListener = (JComponent c, int x, int y, int w, int h) -> {
@@ -168,11 +168,11 @@
     }
 
     @Override
-    public void dispose() {
-        SwingAccessor.getRepaintManagerAccessor().removeRepaintListener(
-            RepaintManager.currentManager(this), repaintListener);
-        super.dispose();
-    }
+    public void dispose() {throw new RuntimeException("cf-bug");} //{
+//        SwingAccessor.getRepaintManagerAccessor().removeRepaintListener(
+//            RepaintManager.currentManager(this), repaintListener);
+//        super.dispose();
+//    }
 
     /**
      * Sets the {@link LightweightContent} instance for this frame.
@@ -182,37 +182,37 @@
      *
      * @param content the {@link LightweightContent} instance
      */
-    public void setContent(final LightweightContent content) {
-        if (content == null) {
-            System.err.println("JLightweightFrame.setContent: content may not be null!");
-            return;
-        }
-        this.content = content;
-        this.component = content.getComponent();
-
-        Dimension d = this.component.getPreferredSize();
-        content.preferredSizeChanged(d.width, d.height);
-
-        d = this.component.getMaximumSize();
-        content.maximumSizeChanged(d.width, d.height);
-
-        d = this.component.getMinimumSize();
-        content.minimumSizeChanged(d.width, d.height);
-
-        initInterior();
-    }
-
-    @Override
-    public Graphics getGraphics() {
-        if (bbImage == null) return null;
-
-        Graphics2D g = bbImage.createGraphics();
-        g.setBackground(getBackground());
-        g.setColor(getForeground());
-        g.setFont(getFont());
-        g.scale(scaleFactor, scaleFactor);
-        return g;
-    }
+    public void setContent(final LightweightContent content) {throw new RuntimeException("cf-bug");} //{
+//        if (content == null) {
+//            System.err.println("JLightweightFrame.setContent: content may not be null!");
+//            return;
+//        }
+//        this.content = content;
+//        this.component = content.getComponent();
+//
+//        Dimension d = this.component.getPreferredSize();
+//        content.preferredSizeChanged(d.width, d.height);
+//
+//        d = this.component.getMaximumSize();
+//        content.maximumSizeChanged(d.width, d.height);
+//
+//        d = this.component.getMinimumSize();
+//        content.minimumSizeChanged(d.width, d.height);
+//
+//        initInterior();
+//    }
+
+    @Override
+    public Graphics getGraphics() {throw new RuntimeException("cf-bug");} //{
+//        if (bbImage == null) return null;
+//
+//        Graphics2D g = bbImage.createGraphics();
+//        g.setBackground(getBackground());
+//        g.setColor(getForeground());
+//        g.setFont(getFont());
+//        g.scale(scaleFactor, scaleFactor);
+//        return g;
+//    }
 
     /**
      * {@inheritDoc}
@@ -220,9 +220,9 @@
      * @see LightweightContent#focusGrabbed()
      */
     @Override
-    public void grabFocus() {
-        if (content != null) content.focusGrabbed();
-    }
+    public void grabFocus() {throw new RuntimeException("cf-bug");} //{
+//        if (content != null) content.focusGrabbed();
+//    }
 
     /**
      * {@inheritDoc}
@@ -230,236 +230,236 @@
      * @see LightweightContent#focusUngrabbed()
      */
     @Override
-    public void ungrabFocus() {
-        if (content != null) content.focusUngrabbed();
-    }
-
-    @Override
-    public int getScaleFactor() {
-        return scaleFactor;
-    }
-
-    @Override
-    public void notifyDisplayChanged(final int scaleFactor) {
-        if (scaleFactor != this.scaleFactor) {
-            if (!copyBufferEnabled) content.paintLock();
-            try {
-                if (bbImage != null) {
-                    resizeBuffer(getWidth(), getHeight(), scaleFactor);
-                }
-            } finally {
-                if (!copyBufferEnabled) content.paintUnlock();
-            }
-            this.scaleFactor = scaleFactor;
-        }
-        if (getPeer() instanceof DisplayChangedListener) {
-            ((DisplayChangedListener)getPeer()).displayChanged();
-        }
-        repaint();
-    }
-
-    @Override
-    public void addNotify() {
-        super.addNotify();
-        if (getPeer() instanceof DisplayChangedListener) {
-            ((DisplayChangedListener)getPeer()).displayChanged();
-        }
-    }
-
-    private void syncCopyBuffer(boolean reset, int x, int y, int w, int h, int scale) {
-        content.paintLock();
-        try {
-            int[] srcBuffer = ((DataBufferInt)bbImage.getRaster().getDataBuffer()).getData();
-            if (reset) {
-                copyBuffer = new int[srcBuffer.length];
-            }
-            int linestride = bbImage.getWidth();
-
-            x *= scale;
-            y *= scale;
-            w *= scale;
-            h *= scale;
-
-            for (int i=0; i<h; i++) {
-                int from = (y + i) * linestride + x;
-                System.arraycopy(srcBuffer, from, copyBuffer, from, w);
-            }
-        } finally {
-            content.paintUnlock();
-        }
-    }
-
-    private void notifyImageUpdated(int x, int y, int width, int height) {
-        if (copyBufferEnabled) {
-            syncCopyBuffer(false, x, y, width, height, scaleFactor);
-        }
-        content.imageUpdated(x, y, width, height);
-    }
-
-    private void initInterior() {
-        contentPane = new JPanel() {
-            @Override
-            public void paint(Graphics g) {
-                if (!copyBufferEnabled) {
-                    content.paintLock();
-                }
-                try {
-                    super.paint(g);
-
-                    final Rectangle clip = g.getClipBounds() != null ?
-                            g.getClipBounds() :
-                            new Rectangle(0, 0, contentPane.getWidth(), contentPane.getHeight());
-
-                    clip.x = Math.max(0, clip.x);
-                    clip.y = Math.max(0, clip.y);
-                    clip.width = Math.min(contentPane.getWidth(), clip.width);
-                    clip.height = Math.min(contentPane.getHeight(), clip.height);
-
-                    EventQueue.invokeLater(new Runnable() {
-                        @Override
-                        public void run() {
-                            Rectangle c = contentPane.getBounds().intersection(clip);
-                            notifyImageUpdated(c.x, c.y, c.width, c.height);
-                        }
-                    });
-                } finally {
-                    if (!copyBufferEnabled) {
-                        content.paintUnlock();
-                    }
-                }
-            }
-            @Override
-            protected boolean isPaintingOrigin() {
-                return true;
-            }
-        };
-        contentPane.setLayout(new BorderLayout());
-        contentPane.add(component);
-        if ("true".equals(AccessController.
-            doPrivileged(new GetPropertyAction("swing.jlf.contentPaneTransparent", "false"))))
-        {
-            contentPane.setOpaque(false);
-        }
-        setContentPane(contentPane);
-
-        contentPane.addContainerListener(new ContainerListener() {
-            @Override
-            public void componentAdded(ContainerEvent e) {
-                Component c = JLightweightFrame.this.component;
-                if (e.getChild() == c) {
-                    c.addPropertyChangeListener("preferredSize", layoutSizeListener);
-                    c.addPropertyChangeListener("maximumSize", layoutSizeListener);
-                    c.addPropertyChangeListener("minimumSize", layoutSizeListener);
-                }
-            }
-            @Override
-            public void componentRemoved(ContainerEvent e) {
-                Component c = JLightweightFrame.this.component;
-                if (e.getChild() == c) {
-                    c.removePropertyChangeListener(layoutSizeListener);
-                }
-            }
-        });
-    }
+    public void ungrabFocus() {throw new RuntimeException("cf-bug");} //{
+//        if (content != null) content.focusUngrabbed();
+//    }
+
+    @Override
+    public int getScaleFactor() {throw new RuntimeException("cf-bug");} //{
+//        return scaleFactor;
+//    }
+
+    @Override
+    public void notifyDisplayChanged(final int scaleFactor) {throw new RuntimeException("cf-bug");} //{
+//        if (scaleFactor != this.scaleFactor) {
+//            if (!copyBufferEnabled) content.paintLock();
+//            try {
+//                if (bbImage != null) {
+//                    resizeBuffer(getWidth(), getHeight(), scaleFactor);
+//                }
+//            } finally {
+//                if (!copyBufferEnabled) content.paintUnlock();
+//            }
+//            this.scaleFactor = scaleFactor;
+//        }
+//        if (getPeer() instanceof DisplayChangedListener) {
+//            ((DisplayChangedListener)getPeer()).displayChanged();
+//        }
+//        repaint();
+//    }
+
+    @Override
+    public void addNotify() {throw new RuntimeException("cf-bug");} //{
+//        super.addNotify();
+//        if (getPeer() instanceof DisplayChangedListener) {
+//            ((DisplayChangedListener)getPeer()).displayChanged();
+//        }
+//    }
+
+    private void syncCopyBuffer(boolean reset, int x, int y, int w, int h, int scale) {throw new RuntimeException("cf-bug");} //{
+//        content.paintLock();
+//        try {
+//            int[] srcBuffer = ((DataBufferInt)bbImage.getRaster().getDataBuffer()).getData();
+//            if (reset) {
+//                copyBuffer = new int[srcBuffer.length];
+//            }
+//            int linestride = bbImage.getWidth();
+//
+//            x *= scale;
+//            y *= scale;
+//            w *= scale;
+//            h *= scale;
+//
+//            for (int i=0; i<h; i++) {
+//                int from = (y + i) * linestride + x;
+//                System.arraycopy(srcBuffer, from, copyBuffer, from, w);
+//            }
+//        } finally {
+//            content.paintUnlock();
+//        }
+//    }
+
+    private void notifyImageUpdated(int x, int y, int width, int height) {throw new RuntimeException("cf-bug");} //{
+//        if (copyBufferEnabled) {
+//            syncCopyBuffer(false, x, y, width, height, scaleFactor);
+//        }
+//        content.imageUpdated(x, y, width, height);
+//    }
+
+    private void initInterior() {throw new RuntimeException("cf-bug");} //{
+//        contentPane = new JPanel() {
+//            @Override
+//            public void paint(Graphics g) {
+//                if (!copyBufferEnabled) {
+//                    content.paintLock();
+//                }
+//                try {
+//                    super.paint(g);
+//
+//                    final Rectangle clip = g.getClipBounds() != null ?
+//                            g.getClipBounds() :
+//                            new Rectangle(0, 0, contentPane.getWidth(), contentPane.getHeight());
+//
+//                    clip.x = Math.max(0, clip.x);
+//                    clip.y = Math.max(0, clip.y);
+//                    clip.width = Math.min(contentPane.getWidth(), clip.width);
+//                    clip.height = Math.min(contentPane.getHeight(), clip.height);
+//
+//                    EventQueue.invokeLater(new Runnable() {
+//                        @Override
+//                        public void run() {
+//                            Rectangle c = contentPane.getBounds().intersection(clip);
+//                            notifyImageUpdated(c.x, c.y, c.width, c.height);
+//                        }
+//                    });
+//                } finally {
+//                    if (!copyBufferEnabled) {
+//                        content.paintUnlock();
+//                    }
+//                }
+//            }
+//            @Override
+//            protected boolean isPaintingOrigin() {
+//                return true;
+//            }
+//        };
+//        contentPane.setLayout(new BorderLayout());
+//        contentPane.add(component);
+//        if ("true".equals(AccessController.
+//            doPrivileged(new GetPropertyAction("swing.jlf.contentPaneTransparent", "false"))))
+//        {
+//            contentPane.setOpaque(false);
+//        }
+//        setContentPane(contentPane);
+//
+//        contentPane.addContainerListener(new ContainerListener() {
+//            @Override
+//            public void componentAdded(ContainerEvent e) {
+//                Component c = JLightweightFrame.this.component;
+//                if (e.getChild() == c) {
+//                    c.addPropertyChangeListener("preferredSize", layoutSizeListener);
+//                    c.addPropertyChangeListener("maximumSize", layoutSizeListener);
+//                    c.addPropertyChangeListener("minimumSize", layoutSizeListener);
+//                }
+//            }
+//            @Override
+//            public void componentRemoved(ContainerEvent e) {
+//                Component c = JLightweightFrame.this.component;
+//                if (e.getChild() == c) {
+//                    c.removePropertyChangeListener(layoutSizeListener);
+//                }
+//            }
+//        });
+//    }
 
     @SuppressWarnings("deprecation")
-    @Override public void reshape(int x, int y, int width, int height) {
-        super.reshape(x, y, width, height);
-
-        if (width == 0 || height == 0) {
-            return;
-        }
-        if (!copyBufferEnabled) {
-            content.paintLock();
-        }
-        try {
-            boolean createBB = (bbImage == null);
-            int newW = width;
-            int newH = height;
-            if (bbImage != null) {
-                int imgWidth = bbImage.getWidth() / scaleFactor;
-                int imgHeight = bbImage.getHeight() / scaleFactor;
-                if (width != imgWidth || height != imgHeight) {
-                    createBB = true;
-                    if (bbImage != null) {
-                        int oldW = imgWidth;
-                        int oldH = imgHeight;
-                        if ((oldW >= newW) && (oldH >= newH)) {
-                            createBB = false;
-                        } else {
-                            if (oldW >= newW) {
-                                newW = oldW;
-                            } else {
-                                newW = Math.max((int)(oldW * 1.2), width);
-                            }
-                            if (oldH >= newH) {
-                                newH = oldH;
-                            } else {
-                                newH = Math.max((int)(oldH * 1.2), height);
-                            }
-                        }
-                    }
-                }
-            }
-            if (createBB) {
-                resizeBuffer(newW, newH, scaleFactor);
-                return;
-            }
-            content.imageReshaped(0, 0, width, height);
-
-        } finally {
-            if (!copyBufferEnabled) {
-                content.paintUnlock();
-            }
-        }
-    }
-
-    private void resizeBuffer(int width, int height, int newScaleFactor) {
-            bbImage = new BufferedImage(width*newScaleFactor,height*newScaleFactor,
-                                        BufferedImage.TYPE_INT_ARGB_PRE);
-        int[] pixels= ((DataBufferInt)bbImage.getRaster().getDataBuffer()).getData();
-        if (copyBufferEnabled) {
-            syncCopyBuffer(true, 0, 0, width, height, newScaleFactor);
-            pixels = copyBuffer;
-        }
-        content.imageBufferReset(pixels, 0, 0, width, height,
-                                 width * newScaleFactor, newScaleFactor);
-    }
-
-    @Override
-    public JRootPane getRootPane() {
-        return rootPane;
-    }
-
-    @Override
-    public void setContentPane(Container contentPane) {
-        getRootPane().setContentPane(contentPane);
-    }
-
-    @Override
-    public Container getContentPane() {
-        return getRootPane().getContentPane();
-    }
-
-    @Override
-    public void setLayeredPane(JLayeredPane layeredPane) {
-        getRootPane().setLayeredPane(layeredPane);
-    }
-
-    @Override
-    public JLayeredPane getLayeredPane() {
-        return getRootPane().getLayeredPane();
-    }
-
-    @Override
-    public void setGlassPane(Component glassPane) {
-        getRootPane().setGlassPane(glassPane);
-    }
-
-    @Override
-    public Component getGlassPane() {
-        return getRootPane().getGlassPane();
-    }
+    @Override public void reshape(int x, int y, int width, int height) {throw new RuntimeException("cf-bug");} //{
+//        super.reshape(x, y, width, height);
+//
+//        if (width == 0 || height == 0) {
+//            return;
+//        }
+//        if (!copyBufferEnabled) {
+//            content.paintLock();
+//        }
+//        try {
+//            boolean createBB = (bbImage == null);
+//            int newW = width;
+//            int newH = height;
+//            if (bbImage != null) {
+//                int imgWidth = bbImage.getWidth() / scaleFactor;
+//                int imgHeight = bbImage.getHeight() / scaleFactor;
+//                if (width != imgWidth || height != imgHeight) {
+//                    createBB = true;
+//                    if (bbImage != null) {
+//                        int oldW = imgWidth;
+//                        int oldH = imgHeight;
+//                        if ((oldW >= newW) && (oldH >= newH)) {
+//                            createBB = false;
+//                        } else {
+//                            if (oldW >= newW) {
+//                                newW = oldW;
+//                            } else {
+//                                newW = Math.max((int)(oldW * 1.2), width);
+//                            }
+//                            if (oldH >= newH) {
+//                                newH = oldH;
+//                            } else {
+//                                newH = Math.max((int)(oldH * 1.2), height);
+//                            }
+//                        }
+//                    }
+//                }
+//            }
+//            if (createBB) {
+//                resizeBuffer(newW, newH, scaleFactor);
+//                return;
+//            }
+//            content.imageReshaped(0, 0, width, height);
+//
+//        } finally {
+//            if (!copyBufferEnabled) {
+//                content.paintUnlock();
+//            }
+//        }
+//    }
+
+    private void resizeBuffer(int width, int height, int newScaleFactor) {throw new RuntimeException("cf-bug");} //{
+//            bbImage = new BufferedImage(width*newScaleFactor,height*newScaleFactor,
+//                                        BufferedImage.TYPE_INT_ARGB_PRE);
+//        int[] pixels= ((DataBufferInt)bbImage.getRaster().getDataBuffer()).getData();
+//        if (copyBufferEnabled) {
+//            syncCopyBuffer(true, 0, 0, width, height, newScaleFactor);
+//            pixels = copyBuffer;
+//        }
+//        content.imageBufferReset(pixels, 0, 0, width, height,
+//                                 width * newScaleFactor, newScaleFactor);
+//    }
+
+    @Override
+    public JRootPane getRootPane() {throw new RuntimeException("cf-bug");} //{
+//        return rootPane;
+//    }
+
+    @Override
+    public void setContentPane(Container contentPane) {throw new RuntimeException("cf-bug");} //{
+//        getRootPane().setContentPane(contentPane);
+//    }
+
+    @Override
+    public Container getContentPane() {throw new RuntimeException("cf-bug");} //{
+//        return getRootPane().getContentPane();
+//    }
+
+    @Override
+    public void setLayeredPane(JLayeredPane layeredPane) {throw new RuntimeException("cf-bug");} //{
+//        getRootPane().setLayeredPane(layeredPane);
+//    }
+
+    @Override
+    public JLayeredPane getLayeredPane() {throw new RuntimeException("cf-bug");} //{
+//        return getRootPane().getLayeredPane();
+//    }
+
+    @Override
+    public void setGlassPane(Component glassPane) {throw new RuntimeException("cf-bug");} //{
+//        getRootPane().setGlassPane(glassPane);
+//    }
+
+    @Override
+    public Component getGlassPane() {throw new RuntimeException("cf-bug");} //{
+//        return getRootPane().getGlassPane();
+//    }
 
 
     /*
@@ -469,35 +469,35 @@
      * Component.updateCursorImmediately method is final
      * and could not be overridden.
      */
-    private void updateClientCursor() {
-        Point p = MouseInfo.getPointerInfo().getLocation();
-        SwingUtilities.convertPointFromScreen(p, this);
-        Component target = SwingUtilities.getDeepestComponentAt(this, p.x, p.y);
-        if (target != null) {
-            content.setCursor(target.getCursor());
-        }
-    }
+    private void updateClientCursor() {throw new RuntimeException("cf-bug");} //{
+//        Point p = MouseInfo.getPointerInfo().getLocation();
+//        SwingUtilities.convertPointFromScreen(p, this);
+//        Component target = SwingUtilities.getDeepestComponentAt(this, p.x, p.y);
+//        if (target != null) {
+//            content.setCursor(target.getCursor());
+//        }
+//    }
 
     public <T extends DragGestureRecognizer> T createDragGestureRecognizer(
             Class<T> abstractRecognizerClass,
             DragSource ds, Component c, int srcActions,
             DragGestureListener dgl)
-    {
-        return content == null ? null : content.createDragGestureRecognizer(
-                abstractRecognizerClass, ds, c, srcActions, dgl);
-    }
-
-    public DragSourceContextPeer createDragSourceContextPeer(DragGestureEvent dge) throws InvalidDnDOperationException {
-        return content == null ? null : content.createDragSourceContextPeer(dge);
-    }
-
-    public void addDropTarget(DropTarget dt) {
-        if (content == null) return;
-        content.addDropTarget(dt);
-    }
-
-    public void removeDropTarget(DropTarget dt) {
-        if (content == null) return;
-        content.removeDropTarget(dt);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        return content == null ? null : content.createDragGestureRecognizer(
+//                abstractRecognizerClass, ds, c, srcActions, dgl);
+//    }
+
+    public DragSourceContextPeer createDragSourceContextPeer(DragGestureEvent dge) throws InvalidDnDOperationException {throw new RuntimeException("cf-bug");} //{
+//        return content == null ? null : content.createDragSourceContextPeer(dge);
+//    }
+
+    public void addDropTarget(DropTarget dt) {throw new RuntimeException("cf-bug");} //{
+//        if (content == null) return;
+//        content.addDropTarget(dt);
+//    }
+
+    public void removeDropTarget(DropTarget dt) {throw new RuntimeException("cf-bug");} //{
+//        if (content == null) return;
+//        content.removeDropTarget(dt);
+//    }
 }
--- a/sun/swing/DefaultLayoutStyle.java	2016-06-22 19:55:36.590973407 -0700
+++ b/sun/swing/DefaultLayoutStyle.java	2016-06-29 12:36:38.182664126 -0700
@@ -41,54 +41,54 @@
     private static final DefaultLayoutStyle INSTANCE =
             new DefaultLayoutStyle();
 
-    public static LayoutStyle getInstance() {
-        return INSTANCE;
-    }
+    public static LayoutStyle getInstance() {throw new RuntimeException("cf-bug");} //{
+//        return INSTANCE;
+//    }
 
     @Override
     public int getPreferredGap(JComponent component1, JComponent component2,
-            ComponentPlacement type, int position, Container parent) {
-        if (component1 == null || component2 == null || type == null) {
-            throw new NullPointerException();
-        }
-
-        checkPosition(position);
-
-        if (type == ComponentPlacement.INDENT &&
-                (position == SwingConstants.EAST ||
-                 position == SwingConstants.WEST)) {
-            int indent = getIndent(component1, position);
-            if (indent > 0) {
-                return indent;
-            }
-        }
-        return (type == ComponentPlacement.UNRELATED) ? 12 : 6;
-    }
+            ComponentPlacement type, int position, Container parent) {throw new RuntimeException("cf-bug");} //{
+//        if (component1 == null || component2 == null || type == null) {
+//            throw new NullPointerException();
+//        }
+//
+//        checkPosition(position);
+//
+//        if (type == ComponentPlacement.INDENT &&
+//                (position == SwingConstants.EAST ||
+//                 position == SwingConstants.WEST)) {
+//            int indent = getIndent(component1, position);
+//            if (indent > 0) {
+//                return indent;
+//            }
+//        }
+//        return (type == ComponentPlacement.UNRELATED) ? 12 : 6;
+//    }
 
     @Override
     public int getContainerGap(JComponent component, int position,
-                               Container parent) {
-        if (component == null) {
-            throw new NullPointerException();
-        }
-        checkPosition(position);
-        return 6;
-    }
+                               Container parent) {throw new RuntimeException("cf-bug");} //{
+//        if (component == null) {
+//            throw new NullPointerException();
+//        }
+//        checkPosition(position);
+//        return 6;
+//    }
 
     /**
      * Returns true if the classes identify a JLabel and a non-JLabel
      * along the horizontal axis.
      */
     protected boolean isLabelAndNonlabel(JComponent c1, JComponent c2,
-                                         int position) {
-        if (position == SwingConstants.EAST ||
-                position == SwingConstants.WEST) {
-            boolean c1Label = (c1 instanceof JLabel);
-            boolean c2Label = (c2 instanceof JLabel);
-            return ((c1Label || c2Label) && (c1Label != c2Label));
-        }
-        return false;
-    }
+                                         int position) {throw new RuntimeException("cf-bug");} //{
+//        if (position == SwingConstants.EAST ||
+//                position == SwingConstants.WEST) {
+//            boolean c1Label = (c1 instanceof JLabel);
+//            boolean c2Label = (c2 instanceof JLabel);
+//            return ((c1Label || c2Label) && (c1Label != c2Label));
+//        }
+//        return false;
+//    }
 
     /**
      * For some look and feels check boxs and radio buttons typically
@@ -104,16 +104,16 @@
      * @return offset - border/margin around the component.
      */
     protected int getButtonGap(JComponent source, JComponent target,
-                               int position, int offset) {
-        offset -= getButtonGap(source, position);
-        if (offset > 0) {
-            offset -= getButtonGap(target, flipDirection(position));
-        }
-        if (offset < 0) {
-            return 0;
-        }
-        return offset;
-    }
+                               int position, int offset) {throw new RuntimeException("cf-bug");} //{
+//        offset -= getButtonGap(source, position);
+//        if (offset > 0) {
+//            offset -= getButtonGap(target, flipDirection(position));
+//        }
+//        if (offset < 0) {
+//            return 0;
+//        }
+//        return offset;
+//    }
 
     /**
      * For some look and feels check boxs and radio buttons typically
@@ -127,133 +127,133 @@
      * @param offset Ideal offset, not including border/margin
      * @return offset - border/margin around the component.
      */
-    protected int getButtonGap(JComponent source, int position, int offset) {
-        offset -= getButtonGap(source, position);
-        return Math.max(offset, 0);
-    }
+    protected int getButtonGap(JComponent source, int position, int offset) {throw new RuntimeException("cf-bug");} //{
+//        offset -= getButtonGap(source, position);
+//        return Math.max(offset, 0);
+//    }
 
     /**
      * If <code>c</code> is a check box or radio button, and the border is
      * not painted this returns the inset along the specified axis.
      */
-    public int getButtonGap(JComponent c, int position) {
-        String classID = c.getUIClassID();
-        if ((classID == "CheckBoxUI" || classID == "RadioButtonUI") &&
-                !((AbstractButton)c).isBorderPainted()) {
-            Border border = c.getBorder();
-            if (border instanceof UIResource) {
-                return getInset(c, position);
-            }
-        }
-        return 0;
-    }
-
-    private void checkPosition(int position) {
-        if (position != SwingConstants.NORTH &&
-                position != SwingConstants.SOUTH &&
-                position != SwingConstants.WEST &&
-                position != SwingConstants.EAST) {
-            throw new IllegalArgumentException();
-        }
-    }
-
-    protected int flipDirection(int position) {
-        switch(position) {
-        case SwingConstants.NORTH:
-            return SwingConstants.SOUTH;
-        case SwingConstants.SOUTH:
-            return SwingConstants.NORTH;
-        case SwingConstants.EAST:
-            return SwingConstants.WEST;
-        case SwingConstants.WEST:
-            return SwingConstants.EAST;
-        }
-        assert false;
-        return 0;
-    }
+    public int getButtonGap(JComponent c, int position) {throw new RuntimeException("cf-bug");} //{
+//        String classID = c.getUIClassID();
+//        if ((classID == "CheckBoxUI" || classID == "RadioButtonUI") &&
+//                !((AbstractButton)c).isBorderPainted()) {
+//            Border border = c.getBorder();
+//            if (border instanceof UIResource) {
+//                return getInset(c, position);
+//            }
+//        }
+//        return 0;
+//    }
+
+    private void checkPosition(int position) {throw new RuntimeException("cf-bug");} //{
+//        if (position != SwingConstants.NORTH &&
+//                position != SwingConstants.SOUTH &&
+//                position != SwingConstants.WEST &&
+//                position != SwingConstants.EAST) {
+//            throw new IllegalArgumentException();
+//        }
+//    }
+
+    protected int flipDirection(int position) {throw new RuntimeException("cf-bug");} //{
+//        switch(position) {
+//        case SwingConstants.NORTH:
+//            return SwingConstants.SOUTH;
+//        case SwingConstants.SOUTH:
+//            return SwingConstants.NORTH;
+//        case SwingConstants.EAST:
+//            return SwingConstants.WEST;
+//        case SwingConstants.WEST:
+//            return SwingConstants.EAST;
+//        }
+//        assert false;
+//        return 0;
+//    }
 
     /**
      * Returns the amount to indent the specified component if it's
      * a JCheckBox or JRadioButton.  If the component is not a JCheckBox or
      * JRadioButton, 0 will be returned.
      */
-    protected int getIndent(JComponent c, int position) {
-        String classID = c.getUIClassID();
-        if (classID == "CheckBoxUI" || classID == "RadioButtonUI") {
-            AbstractButton button = (AbstractButton)c;
-            Insets insets = c.getInsets();
-            Icon icon = getIcon(button);
-            int gap = button.getIconTextGap();
-            if (isLeftAligned(button, position)) {
-                return insets.left + icon.getIconWidth() + gap;
-            } else if (isRightAligned(button, position)) {
-                return insets.right + icon.getIconWidth() + gap;
-            }
-        }
-        return 0;
-    }
-
-    private Icon getIcon(AbstractButton button) {
-        Icon icon = button.getIcon();
-        if (icon != null) {
-            return icon;
-        }
-        String key = null;
-        if (button instanceof JCheckBox) {
-            key = "CheckBox.icon";
-        } else if (button instanceof JRadioButton) {
-            key = "RadioButton.icon";
-        }
-        if (key != null) {
-            Object oIcon = UIManager.get(key);
-            if (oIcon instanceof Icon) {
-                return (Icon)oIcon;
-            }
-        }
-        return null;
-    }
-
-    private boolean isLeftAligned(AbstractButton button, int position) {
-        if (position == SwingConstants.WEST) {
-            boolean ltr = button.getComponentOrientation().isLeftToRight();
-            int hAlign = button.getHorizontalAlignment();
-            return ((ltr && (hAlign == SwingConstants.LEFT ||
-                             hAlign == SwingConstants.LEADING)) ||
-                    (!ltr && (hAlign == SwingConstants.TRAILING)));
-        }
-        return false;
-    }
-
-    private boolean isRightAligned(AbstractButton button, int position) {
-        if (position == SwingConstants.EAST) {
-            boolean ltr = button.getComponentOrientation().isLeftToRight();
-            int hAlign = button.getHorizontalAlignment();
-            return ((ltr && (hAlign == SwingConstants.RIGHT ||
-                             hAlign == SwingConstants.TRAILING)) ||
-                    (!ltr && (hAlign == SwingConstants.LEADING)));
-        }
-        return false;
-    }
-
-    private int getInset(JComponent c, int position) {
-        return getInset(c.getInsets(), position);
-    }
-
-    private int getInset(Insets insets, int position) {
-        if (insets == null) {
-            return 0;
-        }
-        switch(position) {
-        case SwingConstants.NORTH:
-            return insets.top;
-        case SwingConstants.SOUTH:
-            return insets.bottom;
-        case SwingConstants.EAST:
-            return insets.right;
-        case SwingConstants.WEST:
-            return insets.left;
-        }
-        assert false;
-        return 0;
-    }
+    protected int getIndent(JComponent c, int position) {throw new RuntimeException("cf-bug");} //{
+//        String classID = c.getUIClassID();
+//        if (classID == "CheckBoxUI" || classID == "RadioButtonUI") {
+//            AbstractButton button = (AbstractButton)c;
+//            Insets insets = c.getInsets();
+//            Icon icon = getIcon(button);
+//            int gap = button.getIconTextGap();
+//            if (isLeftAligned(button, position)) {
+//                return insets.left + icon.getIconWidth() + gap;
+//            } else if (isRightAligned(button, position)) {
+//                return insets.right + icon.getIconWidth() + gap;
+//            }
+//        }
+//        return 0;
+//    }
+
+    private Icon getIcon(AbstractButton button) {throw new RuntimeException("cf-bug");} //{
+//        Icon icon = button.getIcon();
+//        if (icon != null) {
+//            return icon;
+//        }
+//        String key = null;
+//        if (button instanceof JCheckBox) {
+//            key = "CheckBox.icon";
+//        } else if (button instanceof JRadioButton) {
+//            key = "RadioButton.icon";
+//        }
+//        if (key != null) {
+//            Object oIcon = UIManager.get(key);
+//            if (oIcon instanceof Icon) {
+//                return (Icon)oIcon;
+//            }
+//        }
+//        return null;
+//    }
+
+    private boolean isLeftAligned(AbstractButton button, int position) {throw new RuntimeException("cf-bug");} //{
+//        if (position == SwingConstants.WEST) {
+//            boolean ltr = button.getComponentOrientation().isLeftToRight();
+//            int hAlign = button.getHorizontalAlignment();
+//            return ((ltr && (hAlign == SwingConstants.LEFT ||
+//                             hAlign == SwingConstants.LEADING)) ||
+//                    (!ltr && (hAlign == SwingConstants.TRAILING)));
+//        }
+//        return false;
+//    }
+
+    private boolean isRightAligned(AbstractButton button, int position) {throw new RuntimeException("cf-bug");} //{
+//        if (position == SwingConstants.EAST) {
+//            boolean ltr = button.getComponentOrientation().isLeftToRight();
+//            int hAlign = button.getHorizontalAlignment();
+//            return ((ltr && (hAlign == SwingConstants.RIGHT ||
+//                             hAlign == SwingConstants.TRAILING)) ||
+//                    (!ltr && (hAlign == SwingConstants.LEADING)));
+//        }
+//        return false;
+//    }
+
+    private int getInset(JComponent c, int position) {throw new RuntimeException("cf-bug");} //{
+//        return getInset(c.getInsets(), position);
+//    }
+
+    private int getInset(Insets insets, int position) {throw new RuntimeException("cf-bug");} //{
+//        if (insets == null) {
+//            return 0;
+//        }
+//        switch(position) {
+//        case SwingConstants.NORTH:
+//            return insets.top;
+//        case SwingConstants.SOUTH:
+//            return insets.bottom;
+//        case SwingConstants.EAST:
+//            return insets.right;
+//        case SwingConstants.WEST:
+//            return insets.left;
+//        }
+//        assert false;
+//        return 0;
+//    }
 }
--- a/sun/swing/text/TextComponentPrintable.java	2016-06-22 19:55:36.794974412 -0700
+++ b/sun/swing/text/TextComponentPrintable.java	2016-06-29 12:47:55.229717702 -0700
@@ -148,25 +148,25 @@
      */
     public static Printable getPrintable(final JTextComponent textComponent,
             final MessageFormat headerFormat,
-            final MessageFormat footerFormat) {
-
-        if (textComponent instanceof JEditorPane
-                && isFrameSetDocument(textComponent.getDocument())) {
-            //for document with frames we create one printable per
-            //frame and merge them with the CompoundPrintable.
-            List<JEditorPane> frames = getFrames((JEditorPane) textComponent);
-            List<CountingPrintable> printables =
-                new ArrayList<CountingPrintable>();
-            for (JEditorPane frame : frames) {
-                printables.add((CountingPrintable)
-                               getPrintable(frame, headerFormat, footerFormat));
-            }
-            return new CompoundPrintable(printables);
-        } else {
-            return new TextComponentPrintable(textComponent,
-               headerFormat, footerFormat);
-        }
-    }
+            final MessageFormat footerFormat) {throw new RuntimeException("cf-bug");} //{
+//
+//        if (textComponent instanceof JEditorPane
+//                && isFrameSetDocument(textComponent.getDocument())) {
+//            //for document with frames we create one printable per
+//            //frame and merge them with the CompoundPrintable.
+//            List<JEditorPane> frames = getFrames((JEditorPane) textComponent);
+//            List<CountingPrintable> printables =
+//                new ArrayList<CountingPrintable>();
+//            for (JEditorPane frame : frames) {
+//                printables.add((CountingPrintable)
+//                               getPrintable(frame, headerFormat, footerFormat));
+//            }
+//            return new CompoundPrintable(printables);
+//        } else {
+//            return new TextComponentPrintable(textComponent,
+//               headerFormat, footerFormat);
+//        }
+//    }
 
     /**
      * Checks whether the document has frames. Only HTMLDocument might
@@ -175,16 +175,16 @@
      * @param document the {@code Document} to check
      * @return {@code true} if the {@code document} has frames
      */
-    private static boolean isFrameSetDocument(final Document document) {
-        boolean ret = false;
-        if (document instanceof HTMLDocument) {
-            HTMLDocument htmlDocument = (HTMLDocument)document;
-            if (htmlDocument.getIterator(HTML.Tag.FRAME).isValid()) {
-                ret = true;
-            }
-        }
-        return ret;
-    }
+    private static boolean isFrameSetDocument(final Document document) {throw new RuntimeException("cf-bug");} //{
+//        boolean ret = false;
+//        if (document instanceof HTMLDocument) {
+//            HTMLDocument htmlDocument = (HTMLDocument)document;
+//            if (htmlDocument.getIterator(HTML.Tag.FRAME).isValid()) {
+//                ret = true;
+//            }
+//        }
+//        return ret;
+//    }
 
 
     /**
@@ -194,17 +194,17 @@
      * @param editor the {@JEditorPane} to find the frames for
      * @return list of all frames
      */
-    private static List<JEditorPane> getFrames(final JEditorPane editor) {
-        List<JEditorPane> list = new ArrayList<JEditorPane>();
-        getFrames(editor, list);
-        if (list.size() == 0) {
-            //the frames have not been created yet.
-            //let's trigger the frames creation.
-            createFrames(editor);
-            getFrames(editor, list);
-        }
-        return list;
-    }
+    private static List<JEditorPane> getFrames(final JEditorPane editor) {throw new RuntimeException("cf-bug");} //{
+//        List<JEditorPane> list = new ArrayList<JEditorPane>();
+//        getFrames(editor, list);
+//        if (list.size() == 0) {
+//            //the frames have not been created yet.
+//            //let's trigger the frames creation.
+//            createFrames(editor);
+//            getFrames(editor, list);
+//        }
+//        return list;
+//    }
 
     /**
      * Adds all {@code JEditorPanes} under {@code container} tagged by {@code
@@ -215,51 +215,51 @@
      * @param c the container to find all frames under
      * @param list {@code List} to append the results too
      */
-    private static void getFrames(final Container container, List<JEditorPane> list) {
-        for (Component c : container.getComponents()) {
-            if (c instanceof FrameEditorPaneTag
-                && c instanceof JEditorPane ) { //it should be always JEditorPane
-                list.add((JEditorPane) c);
-            } else {
-                if (c instanceof Container) {
-                    getFrames((Container) c, list);
-                }
-            }
-        }
-    }
+    private static void getFrames(final Container container, List<JEditorPane> list) {throw new RuntimeException("cf-bug");} //{
+//        for (Component c : container.getComponents()) {
+//            if (c instanceof FrameEditorPaneTag
+//                && c instanceof JEditorPane ) { //it should be always JEditorPane
+//                list.add((JEditorPane) c);
+//            } else {
+//                if (c instanceof Container) {
+//                    getFrames((Container) c, list);
+//                }
+//            }
+//        }
+//    }
 
     /**
      * Triggers the frames creation for {@code JEditorPane}
      *
      * @param editor the {@code JEditorPane} to create frames for
      */
-    private static void createFrames(final JEditorPane editor) {
-        Runnable doCreateFrames =
-            new Runnable() {
-                public void run() {
-                    final int WIDTH = 500;
-                    final int HEIGHT = 500;
-                    CellRendererPane rendererPane = new CellRendererPane();
-                    rendererPane.add(editor);
-                    //the values do not matter
-                    //we only need to get frames created
-                    rendererPane.setSize(WIDTH, HEIGHT);
-                };
-            };
-        if (SwingUtilities.isEventDispatchThread()) {
-            doCreateFrames.run();
-        } else {
-            try {
-                SwingUtilities.invokeAndWait(doCreateFrames);
-            } catch (Exception e) {
-                if (e instanceof RuntimeException) {
-                    throw (RuntimeException) e;
-                } else {
-                    throw new RuntimeException(e);
-                }
-            }
-        }
-    }
+    private static void createFrames(final JEditorPane editor) {throw new RuntimeException("cf-bug");} //{
+//        Runnable doCreateFrames =
+//            new Runnable() {
+//                public void run() {
+//                    final int WIDTH = 500;
+//                    final int HEIGHT = 500;
+//                    CellRendererPane rendererPane = new CellRendererPane();
+//                    rendererPane.add(editor);
+//                    //the values do not matter
+//                    //we only need to get frames created
+//                    rendererPane.setSize(WIDTH, HEIGHT);
+//                };
+//            };
+//        if (SwingUtilities.isEventDispatchThread()) {
+//            doCreateFrames.run();
+//        } else {
+//            try {
+//                SwingUtilities.invokeAndWait(doCreateFrames);
+//            } catch (Exception e) {
+//                if (e instanceof RuntimeException) {
+//                    throw (RuntimeException) e;
+//                } else {
+//                    throw new RuntimeException(e);
+//                }
+//            }
+//        }
+//    }
 
     /**
      * Constructs  {@code TextComponentPrintable} to print {@code JTextComponent}
@@ -271,19 +271,19 @@
      */
     private TextComponentPrintable(JTextComponent textComponent,
             MessageFormat headerFormat,
-            MessageFormat footerFormat) {
-        this.textComponentToPrint = textComponent;
-        this.headerFormat = headerFormat;
-        this.footerFormat = footerFormat;
-        headerFont = textComponent.getFont().deriveFont(Font.BOLD,
-            HEADER_FONT_SIZE);
-        footerFont = textComponent.getFont().deriveFont(Font.PLAIN,
-            FOOTER_FONT_SIZE);
-        this.pagesMetrics =
-            Collections.synchronizedList(new ArrayList<IntegerSegment>());
-        this.rowsMetrics = new ArrayList<IntegerSegment>(LIST_SIZE);
-        this.printShell = createPrintShell(textComponent);
-    }
+            MessageFormat footerFormat) {throw new RuntimeException("cf-bug");} //{
+//        this.textComponentToPrint = textComponent;
+//        this.headerFormat = headerFormat;
+//        this.footerFormat = footerFormat;
+//        headerFont = textComponent.getFont().deriveFont(Font.BOLD,
+//            HEADER_FONT_SIZE);
+//        footerFont = textComponent.getFont().deriveFont(Font.PLAIN,
+//            FOOTER_FONT_SIZE);
+//        this.pagesMetrics =
+//            Collections.synchronizedList(new ArrayList<IntegerSegment>());
+//        this.rowsMetrics = new ArrayList<IntegerSegment>(LIST_SIZE);
+//        this.printShell = createPrintShell(textComponent);
+//    }
 
 
     /**
@@ -296,145 +296,145 @@
      *        printShell for
      * @return the print shell
      */
-    private JTextComponent createPrintShell(final JTextComponent textComponent) {
-        if (SwingUtilities.isEventDispatchThread()) {
-            return createPrintShellOnEDT(textComponent);
-        } else {
-            FutureTask<JTextComponent> futureCreateShell =
-                new FutureTask<JTextComponent>(
-                    new Callable<JTextComponent>() {
-                        public JTextComponent call() throws Exception {
-                            return createPrintShellOnEDT(textComponent);
-                        }
-                    });
-            SwingUtilities.invokeLater(futureCreateShell);
-            try {
-                return futureCreateShell.get();
-            } catch (InterruptedException e) {
-                throw new RuntimeException(e);
-            } catch (ExecutionException e) {
-                Throwable cause = e.getCause();
-                if (cause instanceof Error) {
-                    throw (Error) cause;
-                }
-                if (cause instanceof RuntimeException) {
-                    throw (RuntimeException) cause;
-                }
-                throw new AssertionError(cause);
-            }
-        }
-    }
-    private JTextComponent createPrintShellOnEDT(final JTextComponent textComponent) {
-        assert SwingUtilities.isEventDispatchThread();
-
-        JTextComponent ret = null;
-        if (textComponent instanceof JPasswordField) {
-            ret =
-                new JPasswordField() {
-                    {
-                        setEchoChar(((JPasswordField) textComponent).getEchoChar());
-                        setHorizontalAlignment(
-                            ((JTextField) textComponent).getHorizontalAlignment());
-                    }
-                    @Override
-                    public FontMetrics getFontMetrics(Font font) {
-                        return (frc.get() == null)
-                            ? super.getFontMetrics(font)
-                            : FontDesignMetrics.getMetrics(font, frc.get());
-                    }
-                };
-        } else if (textComponent instanceof JTextField) {
-            ret =
-                new JTextField() {
-                    {
-                        setHorizontalAlignment(
-                            ((JTextField) textComponent).getHorizontalAlignment());
-                    }
-                    @Override
-                    public FontMetrics getFontMetrics(Font font) {
-                        return (frc.get() == null)
-                            ? super.getFontMetrics(font)
-                            : FontDesignMetrics.getMetrics(font, frc.get());
-                    }
-                };
-        } else if (textComponent instanceof JTextArea) {
-            ret =
-                new JTextArea() {
-                    {
-                        JTextArea textArea = (JTextArea) textComponent;
-                        setLineWrap(textArea.getLineWrap());
-                        setWrapStyleWord(textArea.getWrapStyleWord());
-                        setTabSize(textArea.getTabSize());
-                    }
-                    @Override
-                    public FontMetrics getFontMetrics(Font font) {
-                        return (frc.get() == null)
-                            ? super.getFontMetrics(font)
-                            : FontDesignMetrics.getMetrics(font, frc.get());
-                    }
-                };
-        } else if (textComponent instanceof JTextPane) {
-            ret =
-                new JTextPane() {
-                    @Override
-                    public FontMetrics getFontMetrics(Font font) {
-                        return (frc.get() == null)
-                            ? super.getFontMetrics(font)
-                            : FontDesignMetrics.getMetrics(font, frc.get());
-                    }
-                    @Override
-                    public EditorKit getEditorKit() {
-                        if (getDocument() == textComponent.getDocument()) {
-                            return ((JTextPane) textComponent).getEditorKit();
-                        } else {
-                            return super.getEditorKit();
-                        }
-                    }
-                };
-        } else if (textComponent instanceof JEditorPane) {
-            ret =
-                new JEditorPane() {
-                    @Override
-                    public FontMetrics getFontMetrics(Font font) {
-                        return (frc.get() == null)
-                            ? super.getFontMetrics(font)
-                            : FontDesignMetrics.getMetrics(font, frc.get());
-                    }
-                    @Override
-                    public EditorKit getEditorKit() {
-                        if (getDocument() == textComponent.getDocument()) {
-                            return ((JEditorPane) textComponent).getEditorKit();
-                        } else {
-                            return super.getEditorKit();
-                        }
-                    }
-                };
-        }
-        //want to occupy the whole width and height by text
-        ret.setBorder(null);
-
-        //set properties from the component to print
-        ret.setOpaque(textComponent.isOpaque());
-        ret.setEditable(textComponent.isEditable());
-        ret.setEnabled(textComponent.isEnabled());
-        ret.setFont(textComponent.getFont());
-        ret.setBackground(textComponent.getBackground());
-        ret.setForeground(textComponent.getForeground());
-        ret.setComponentOrientation(
-            textComponent.getComponentOrientation());
-
-        if (ret instanceof JEditorPane) {
-            ret.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES,
-                textComponent.getClientProperty(
-                JEditorPane.HONOR_DISPLAY_PROPERTIES));
-            ret.putClientProperty(JEditorPane.W3C_LENGTH_UNITS,
-                textComponent.getClientProperty(JEditorPane.W3C_LENGTH_UNITS));
-            ret.putClientProperty("charset",
-                textComponent.getClientProperty("charset"));
-        }
-        ret.setDocument(textComponent.getDocument());
-        return ret;
-    }
+    private JTextComponent createPrintShell(final JTextComponent textComponent) {throw new RuntimeException("cf-bug");} //{
+//        if (SwingUtilities.isEventDispatchThread()) {
+//            return createPrintShellOnEDT(textComponent);
+//        } else {
+//            FutureTask<JTextComponent> futureCreateShell =
+//                new FutureTask<JTextComponent>(
+//                    new Callable<JTextComponent>() {
+//                        public JTextComponent call() throws Exception {
+//                            return createPrintShellOnEDT(textComponent);
+//                        }
+//                    });
+//            SwingUtilities.invokeLater(futureCreateShell);
+//            try {
+//                return futureCreateShell.get();
+//            } catch (InterruptedException e) {
+//                throw new RuntimeException(e);
+//            } catch (ExecutionException e) {
+//                Throwable cause = e.getCause();
+//                if (cause instanceof Error) {
+//                    throw (Error) cause;
+//                }
+//                if (cause instanceof RuntimeException) {
+//                    throw (RuntimeException) cause;
+//                }
+//                throw new AssertionError(cause);
+//            }
+//        }
+//    }
+    private JTextComponent createPrintShellOnEDT(final JTextComponent textComponent) {throw new RuntimeException("cf-bug");} //{
+//        assert SwingUtilities.isEventDispatchThread();
+//
+//        JTextComponent ret = null;
+//        if (textComponent instanceof JPasswordField) {
+//            ret =
+//                new JPasswordField() {
+//                    {
+//                        setEchoChar(((JPasswordField) textComponent).getEchoChar());
+//                        setHorizontalAlignment(
+//                            ((JTextField) textComponent).getHorizontalAlignment());
+//                    }
+//                    @Override
+//                    public FontMetrics getFontMetrics(Font font) {
+//                        return (frc.get() == null)
+//                            ? super.getFontMetrics(font)
+//                            : FontDesignMetrics.getMetrics(font, frc.get());
+//                    }
+//                };
+//        } else if (textComponent instanceof JTextField) {
+//            ret =
+//                new JTextField() {
+//                    {
+//                        setHorizontalAlignment(
+//                            ((JTextField) textComponent).getHorizontalAlignment());
+//                    }
+//                    @Override
+//                    public FontMetrics getFontMetrics(Font font) {
+//                        return (frc.get() == null)
+//                            ? super.getFontMetrics(font)
+//                            : FontDesignMetrics.getMetrics(font, frc.get());
+//                    }
+//                };
+//        } else if (textComponent instanceof JTextArea) {
+//            ret =
+//                new JTextArea() {
+//                    {
+//                        JTextArea textArea = (JTextArea) textComponent;
+//                        setLineWrap(textArea.getLineWrap());
+//                        setWrapStyleWord(textArea.getWrapStyleWord());
+//                        setTabSize(textArea.getTabSize());
+//                    }
+//                    @Override
+//                    public FontMetrics getFontMetrics(Font font) {
+//                        return (frc.get() == null)
+//                            ? super.getFontMetrics(font)
+//                            : FontDesignMetrics.getMetrics(font, frc.get());
+//                    }
+//                };
+//        } else if (textComponent instanceof JTextPane) {
+//            ret =
+//                new JTextPane() {
+//                    @Override
+//                    public FontMetrics getFontMetrics(Font font) {
+//                        return (frc.get() == null)
+//                            ? super.getFontMetrics(font)
+//                            : FontDesignMetrics.getMetrics(font, frc.get());
+//                    }
+//                    @Override
+//                    public EditorKit getEditorKit() {
+//                        if (getDocument() == textComponent.getDocument()) {
+//                            return ((JTextPane) textComponent).getEditorKit();
+//                        } else {
+//                            return super.getEditorKit();
+//                        }
+//                    }
+//                };
+//        } else if (textComponent instanceof JEditorPane) {
+//            ret =
+//                new JEditorPane() {
+//                    @Override
+//                    public FontMetrics getFontMetrics(Font font) {
+//                        return (frc.get() == null)
+//                            ? super.getFontMetrics(font)
+//                            : FontDesignMetrics.getMetrics(font, frc.get());
+//                    }
+//                    @Override
+//                    public EditorKit getEditorKit() {
+//                        if (getDocument() == textComponent.getDocument()) {
+//                            return ((JEditorPane) textComponent).getEditorKit();
+//                        } else {
+//                            return super.getEditorKit();
+//                        }
+//                    }
+//                };
+//        }
+//        //want to occupy the whole width and height by text
+//        ret.setBorder(null);
+//
+//        //set properties from the component to print
+//        ret.setOpaque(textComponent.isOpaque());
+//        ret.setEditable(textComponent.isEditable());
+//        ret.setEnabled(textComponent.isEnabled());
+//        ret.setFont(textComponent.getFont());
+//        ret.setBackground(textComponent.getBackground());
+//        ret.setForeground(textComponent.getForeground());
+//        ret.setComponentOrientation(
+//            textComponent.getComponentOrientation());
+//
+//        if (ret instanceof JEditorPane) {
+//            ret.putClientProperty(JEditorPane.HONOR_DISPLAY_PROPERTIES,
+//                textComponent.getClientProperty(
+//                JEditorPane.HONOR_DISPLAY_PROPERTIES));
+//            ret.putClientProperty(JEditorPane.W3C_LENGTH_UNITS,
+//                textComponent.getClientProperty(JEditorPane.W3C_LENGTH_UNITS));
+//            ret.putClientProperty("charset",
+//                textComponent.getClientProperty("charset"));
+//        }
+//        ret.setDocument(textComponent.getDocument());
+//        return ret;
+//    }
 
 
 
@@ -446,9 +446,9 @@
      *
      * @return the number of pages.
      */
-    public int getNumberOfPages() {
-        return pagesMetrics.size();
-    }
+    public int getNumberOfPages() {throw new RuntimeException("cf-bug");} //{
+//        return pagesMetrics.size();
+//    }
 
     /**
      * See Printable.print for the API description.
@@ -461,45 +461,45 @@
      */
     public int print(final Graphics graphics,
             final PageFormat pf,
-            final int pageIndex) throws PrinterException {
-        if (!isLayouted) {
-            if (graphics instanceof Graphics2D) {
-                frc.set(((Graphics2D)graphics).getFontRenderContext());
-            }
-            layout((int)Math.floor(pf.getImageableWidth()));
-            calculateRowsMetrics();
-        }
-        int ret;
-        if (!SwingUtilities.isEventDispatchThread()) {
-            Callable<Integer> doPrintOnEDT = new Callable<Integer>() {
-                public Integer call() throws Exception {
-                    return printOnEDT(graphics, pf, pageIndex);
-                }
-            };
-            FutureTask<Integer> futurePrintOnEDT =
-                new FutureTask<Integer>(doPrintOnEDT);
-            SwingUtilities.invokeLater(futurePrintOnEDT);
-            try {
-                ret = futurePrintOnEDT.get();
-            } catch (InterruptedException e) {
-                throw new RuntimeException(e);
-            } catch (ExecutionException e) {
-                Throwable cause = e.getCause();
-                if (cause instanceof PrinterException) {
-                    throw (PrinterException)cause;
-                } else if (cause instanceof RuntimeException) {
-                    throw (RuntimeException) cause;
-                } else if (cause instanceof Error) {
-                    throw (Error) cause;
-                } else {
-                    throw new RuntimeException(cause);
-                }
-            }
-        } else {
-            ret = printOnEDT(graphics, pf, pageIndex);
-        }
-        return ret;
-    }
+            final int pageIndex) throws PrinterException {throw new RuntimeException("cf-bug");} //{
+//        if (!isLayouted) {
+//            if (graphics instanceof Graphics2D) {
+//                frc.set(((Graphics2D)graphics).getFontRenderContext());
+//            }
+//            layout((int)Math.floor(pf.getImageableWidth()));
+//            calculateRowsMetrics();
+//        }
+//        int ret;
+//        if (!SwingUtilities.isEventDispatchThread()) {
+//            Callable<Integer> doPrintOnEDT = new Callable<Integer>() {
+//                public Integer call() throws Exception {
+//                    return printOnEDT(graphics, pf, pageIndex);
+//                }
+//            };
+//            FutureTask<Integer> futurePrintOnEDT =
+//                new FutureTask<Integer>(doPrintOnEDT);
+//            SwingUtilities.invokeLater(futurePrintOnEDT);
+//            try {
+//                ret = futurePrintOnEDT.get();
+//            } catch (InterruptedException e) {
+//                throw new RuntimeException(e);
+//            } catch (ExecutionException e) {
+//                Throwable cause = e.getCause();
+//                if (cause instanceof PrinterException) {
+//                    throw (PrinterException)cause;
+//                } else if (cause instanceof RuntimeException) {
+//                    throw (RuntimeException) cause;
+//                } else if (cause instanceof Error) {
+//                    throw (Error) cause;
+//                } else {
+//                    throw new RuntimeException(cause);
+//                }
+//            }
+//        } else {
+//            ret = printOnEDT(graphics, pf, pageIndex);
+//        }
+//        return ret;
+//    }
 
 
     /**
@@ -510,62 +510,62 @@
      */
     private int printOnEDT(final Graphics graphics,
             final PageFormat pf,
-            final int pageIndex) throws PrinterException {
-        assert SwingUtilities.isEventDispatchThread();
-        Border border = BorderFactory.createEmptyBorder();
-        //handle header and footer
-        if (headerFormat != null || footerFormat != null) {
-            //Printable page enumeration is 0 base. We need 1 based.
-            Object[] formatArg = new Object[]{Integer.valueOf(pageIndex + 1)};
-            if (headerFormat != null) {
-                border = new TitledBorder(border,
-                    headerFormat.format(formatArg),
-                    TitledBorder.CENTER, TitledBorder.ABOVE_TOP,
-                    headerFont, printShell.getForeground());
-            }
-            if (footerFormat != null) {
-                border = new TitledBorder(border,
-                    footerFormat.format(formatArg),
-                    TitledBorder.CENTER, TitledBorder.BELOW_BOTTOM,
-                    footerFont, printShell.getForeground());
-            }
-        }
-        Insets borderInsets = border.getBorderInsets(printShell);
-        updatePagesMetrics(pageIndex,
-            (int)Math.floor(pf.getImageableHeight()) - borderInsets.top
-                           - borderInsets.bottom);
-
-        if (pagesMetrics.size() <= pageIndex) {
-            return NO_SUCH_PAGE;
-        }
-
-        Graphics2D g2d = (Graphics2D)graphics.create();
-
-        g2d.translate(pf.getImageableX(), pf.getImageableY());
-        border.paintBorder(printShell, g2d, 0, 0,
-            (int)Math.floor(pf.getImageableWidth()),
-            (int)Math.floor(pf.getImageableHeight()));
-
-        g2d.translate(0, borderInsets.top);
-        //want to clip only vertically
-        Rectangle clip = new Rectangle(0, 0,
-            (int) pf.getWidth(),
-            pagesMetrics.get(pageIndex).end
-                - pagesMetrics.get(pageIndex).start + 1);
-
-        g2d.clip(clip);
-        int xStart = 0;
-        if (ComponentOrientation.RIGHT_TO_LEFT ==
-                printShell.getComponentOrientation()) {
-            xStart = (int) pf.getImageableWidth() - printShell.getWidth();
-        }
-        g2d.translate(xStart, - pagesMetrics.get(pageIndex).start);
-        printShell.print(g2d);
-
-        g2d.dispose();
-
-        return Printable.PAGE_EXISTS;
-    }
+            final int pageIndex) throws PrinterException {throw new RuntimeException("cf-bug");} //{
+//        assert SwingUtilities.isEventDispatchThread();
+//        Border border = BorderFactory.createEmptyBorder();
+//        //handle header and footer
+//        if (headerFormat != null || footerFormat != null) {
+//            //Printable page enumeration is 0 base. We need 1 based.
+//            Object[] formatArg = new Object[]{Integer.valueOf(pageIndex + 1)};
+//            if (headerFormat != null) {
+//                border = new TitledBorder(border,
+//                    headerFormat.format(formatArg),
+//                    TitledBorder.CENTER, TitledBorder.ABOVE_TOP,
+//                    headerFont, printShell.getForeground());
+//            }
+//            if (footerFormat != null) {
+//                border = new TitledBorder(border,
+//                    footerFormat.format(formatArg),
+//                    TitledBorder.CENTER, TitledBorder.BELOW_BOTTOM,
+//                    footerFont, printShell.getForeground());
+//            }
+//        }
+//        Insets borderInsets = border.getBorderInsets(printShell);
+//        updatePagesMetrics(pageIndex,
+//            (int)Math.floor(pf.getImageableHeight()) - borderInsets.top
+//                           - borderInsets.bottom);
+//
+//        if (pagesMetrics.size() <= pageIndex) {
+//            return NO_SUCH_PAGE;
+//        }
+//
+//        Graphics2D g2d = (Graphics2D)graphics.create();
+//
+//        g2d.translate(pf.getImageableX(), pf.getImageableY());
+//        border.paintBorder(printShell, g2d, 0, 0,
+//            (int)Math.floor(pf.getImageableWidth()),
+//            (int)Math.floor(pf.getImageableHeight()));
+//
+//        g2d.translate(0, borderInsets.top);
+//        //want to clip only vertically
+//        Rectangle clip = new Rectangle(0, 0,
+//            (int) pf.getWidth(),
+//            pagesMetrics.get(pageIndex).end
+//                - pagesMetrics.get(pageIndex).start + 1);
+//
+//        g2d.clip(clip);
+//        int xStart = 0;
+//        if (ComponentOrientation.RIGHT_TO_LEFT ==
+//                printShell.getComponentOrientation()) {
+//            xStart = (int) pf.getImageableWidth() - printShell.getWidth();
+//        }
+//        g2d.translate(xStart, - pagesMetrics.get(pageIndex).start);
+//        printShell.print(g2d);
+//
+//        g2d.dispose();
+//
+//        return Printable.PAGE_EXISTS;
+//    }
 
 
     private boolean needReadLock = false;
@@ -575,18 +575,18 @@
      *
      * Note: Not to be called on the EDT.
      */
-    private void releaseReadLock() {
-        assert ! SwingUtilities.isEventDispatchThread();
-        Document document = textComponentToPrint.getDocument();
-        if (document instanceof AbstractDocument) {
-            try {
-                ((AbstractDocument) document).readUnlock();
-                needReadLock = true;
-            } catch (Error ignore) {
-                // readUnlock() might throw StateInvariantError
-            }
-        }
-    }
+    private void releaseReadLock() {throw new RuntimeException("cf-bug");} //{
+//        assert ! SwingUtilities.isEventDispatchThread();
+//        Document document = textComponentToPrint.getDocument();
+//        if (document instanceof AbstractDocument) {
+//            try {
+//                ((AbstractDocument) document).readUnlock();
+//                needReadLock = true;
+//            } catch (Error ignore) {
+//                // readUnlock() might throw StateInvariantError
+//            }
+//        }
+//    }
 
 
     /**
@@ -595,28 +595,28 @@
      *
      * Note: Not to be called on the EDT.
      */
-    private void acquireReadLock() {
-        assert ! SwingUtilities.isEventDispatchThread();
-        if (needReadLock) {
-            try {
-                /*
-                 * wait until all the EDT events are processed
-                 * some of the document changes are asynchronous
-                 * we need to make sure we get the lock after those changes
-                 */
-                SwingUtilities.invokeAndWait(
-                    new Runnable() {
-                        public void run() {
-                        }
-                    });
-            } catch (InterruptedException ignore) {
-            } catch (java.lang.reflect.InvocationTargetException ignore) {
-            }
-            Document document = textComponentToPrint.getDocument();
-            ((AbstractDocument) document).readLock();
-            needReadLock = false;
-        }
-    }
+    private void acquireReadLock() {throw new RuntimeException("cf-bug");} //{
+//        assert ! SwingUtilities.isEventDispatchThread();
+//        if (needReadLock) {
+//            try {
+//                /*
+//                 * wait until all the EDT events are processed
+//                 * some of the document changes are asynchronous
+//                 * we need to make sure we get the lock after those changes
+//                 */
+//                SwingUtilities.invokeAndWait(
+//                    new Runnable() {
+//                        public void run() {
+//                        }
+//                    });
+//            } catch (InterruptedException ignore) {
+//            } catch (java.lang.reflect.InvocationTargetException ignore) {
+//            }
+//            Document document = textComponentToPrint.getDocument();
+//            ((AbstractDocument) document).readLock();
+//            needReadLock = false;
+//        }
+//    }
 
     /**
      * Prepares {@code printShell} for printing.
@@ -634,77 +634,77 @@
      *
      * @param width width to layout the text for
      */
-    private void layout(final int width) {
-        if (!SwingUtilities.isEventDispatchThread()) {
-            Callable<Object> doLayoutOnEDT = new Callable<Object>() {
-                public Object call() throws Exception {
-                    layoutOnEDT(width);
-                    return null;
-                }
-            };
-            FutureTask<Object> futureLayoutOnEDT = new FutureTask<Object>(
-                doLayoutOnEDT);
-
-            /*
-             * We need to release document's readlock while printShell is
-             * initializing
-             */
-            releaseReadLock();
-            SwingUtilities.invokeLater(futureLayoutOnEDT);
-            try {
-                futureLayoutOnEDT.get();
-            } catch (InterruptedException e) {
-                throw new RuntimeException(e);
-            } catch (ExecutionException e) {
-                Throwable cause = e.getCause();
-                if (cause instanceof RuntimeException) {
-                    throw (RuntimeException) cause;
-                } else if (cause instanceof Error) {
-                    throw (Error) cause;
-                } else {
-                    throw new RuntimeException(cause);
-                }
-            } finally {
-                acquireReadLock();
-            }
-        } else {
-            layoutOnEDT(width);
-        }
-
-        isLayouted = true;
-    }
+    private void layout(final int width) {throw new RuntimeException("cf-bug");} //{
+//        if (!SwingUtilities.isEventDispatchThread()) {
+//            Callable<Object> doLayoutOnEDT = new Callable<Object>() {
+//                public Object call() throws Exception {
+//                    layoutOnEDT(width);
+//                    return null;
+//                }
+//            };
+//            FutureTask<Object> futureLayoutOnEDT = new FutureTask<Object>(
+//                doLayoutOnEDT);
+//
+//            /*
+//             * We need to release document's readlock while printShell is
+//             * initializing
+//             */
+//            releaseReadLock();
+//            SwingUtilities.invokeLater(futureLayoutOnEDT);
+//            try {
+//                futureLayoutOnEDT.get();
+//            } catch (InterruptedException e) {
+//                throw new RuntimeException(e);
+//            } catch (ExecutionException e) {
+//                Throwable cause = e.getCause();
+//                if (cause instanceof RuntimeException) {
+//                    throw (RuntimeException) cause;
+//                } else if (cause instanceof Error) {
+//                    throw (Error) cause;
+//                } else {
+//                    throw new RuntimeException(cause);
+//                }
+//            } finally {
+//                acquireReadLock();
+//            }
+//        } else {
+//            layoutOnEDT(width);
+//        }
+//
+//        isLayouted = true;
+//    }
 
     /**
      * The EDT part of layout method.
      *
      * This method is to be called on the EDT only.
      */
-    private void layoutOnEDT(final int width) {
-        assert SwingUtilities.isEventDispatchThread();
-        //need to have big value but smaller than MAX_VALUE otherwise
-        //printing goes south due to overflow somewhere
-        final int HUGE_INTEGER = Integer.MAX_VALUE - 1000;
-
-        CellRendererPane rendererPane = new CellRendererPane();
-
-        //need to use JViewport since text is layouted to the viewPort width
-        //otherwise it will be layouted to the maximum text width
-        JViewport viewport = new JViewport();
-        viewport.setBorder(null);
-        Dimension size = new Dimension(width, HUGE_INTEGER);
-
-        //JTextField is a special case
-        //it layouts text in the middle by Y
-        if (printShell instanceof JTextField) {
-            size =
-                new Dimension(size.width, printShell.getPreferredSize().height);
-        }
-        printShell.setSize(size);
-        viewport.setComponentOrientation(printShell.getComponentOrientation());
-        viewport.setSize(size);
-        viewport.add(printShell);
-        rendererPane.add(viewport);
-    }
+    private void layoutOnEDT(final int width) {throw new RuntimeException("cf-bug");} //{
+//        assert SwingUtilities.isEventDispatchThread();
+//        //need to have big value but smaller than MAX_VALUE otherwise
+//        //printing goes south due to overflow somewhere
+//        final int HUGE_INTEGER = Integer.MAX_VALUE - 1000;
+//
+//        CellRendererPane rendererPane = new CellRendererPane();
+//
+//        //need to use JViewport since text is layouted to the viewPort width
+//        //otherwise it will be layouted to the maximum text width
+//        JViewport viewport = new JViewport();
+//        viewport.setBorder(null);
+//        Dimension size = new Dimension(width, HUGE_INTEGER);
+//
+//        //JTextField is a special case
+//        //it layouts text in the middle by Y
+//        if (printShell instanceof JTextField) {
+//            size =
+//                new Dimension(size.width, printShell.getPreferredSize().height);
+//        }
+//        printShell.setSize(size);
+//        viewport.setComponentOrientation(printShell.getComponentOrientation());
+//        viewport.setSize(size);
+//        viewport.add(printShell);
+//        rendererPane.add(viewport);
+//    }
 
     /**
      * Calculates pageMetrics for the pages up to the {@code pageIndex} using
@@ -714,35 +714,35 @@
      * @param pageIndex the page to update the metrics for
      * @param pageHeight the page height
      */
-    private void updatePagesMetrics(final int pageIndex, final int pageHeight) {
-        while (pageIndex >= pagesMetrics.size() && !rowsMetrics.isEmpty()) {
-            // add one page to the pageMetrics
-            int lastPage = pagesMetrics.size() - 1;
-            int pageStart = (lastPage >= 0)
-               ? pagesMetrics.get(lastPage).end + 1
-               : 0;
-            int rowIndex;
-            for (rowIndex = 0;
-                   rowIndex < rowsMetrics.size()
-                   && (rowsMetrics.get(rowIndex).end - pageStart + 1)
-                     <= pageHeight;
-                   rowIndex++) {
-            }
-            if (rowIndex == 0) {
-                // can not fit a single row
-                // need to split
-                pagesMetrics.add(
-                    new IntegerSegment(pageStart, pageStart + pageHeight - 1));
-            } else {
-                rowIndex--;
-                pagesMetrics.add(new IntegerSegment(pageStart,
-                    rowsMetrics.get(rowIndex).end));
-                for (int i = 0; i <= rowIndex; i++) {
-                    rowsMetrics.remove(0);
-                }
-            }
-        }
-    }
+    private void updatePagesMetrics(final int pageIndex, final int pageHeight) {throw new RuntimeException("cf-bug");} //{
+//        while (pageIndex >= pagesMetrics.size() && !rowsMetrics.isEmpty()) {
+//            // add one page to the pageMetrics
+//            int lastPage = pagesMetrics.size() - 1;
+//            int pageStart = (lastPage >= 0)
+//               ? pagesMetrics.get(lastPage).end + 1
+//               : 0;
+//            int rowIndex;
+//            for (rowIndex = 0;
+//                   rowIndex < rowsMetrics.size()
+//                   && (rowsMetrics.get(rowIndex).end - pageStart + 1)
+//                     <= pageHeight;
+//                   rowIndex++) {
+//            }
+//            if (rowIndex == 0) {
+//                // can not fit a single row
+//                // need to split
+//                pagesMetrics.add(
+//                    new IntegerSegment(pageStart, pageStart + pageHeight - 1));
+//            } else {
+//                rowIndex--;
+//                pagesMetrics.add(new IntegerSegment(pageStart,
+//                    rowsMetrics.get(rowIndex).end));
+//                for (int i = 0; i <= rowIndex; i++) {
+//                    rowsMetrics.remove(0);
+//                }
+//            }
+//        }
+//    }
 
     /**
      * Calculates rowsMetrics for the document. The result is stored
@@ -752,54 +752,54 @@
      * First step is to find yStart and yEnd for the every document position.
      * Second step is to merge all intersected segments ( [yStart, yEnd] ).
      */
-    private void calculateRowsMetrics() {
-        final int documentLength = printShell.getDocument().getLength();
-        List<IntegerSegment> documentMetrics = new ArrayList<IntegerSegment>(LIST_SIZE);
-        Rectangle rect;
-        for (int i = 0, previousY = -1, previousHeight = -1; i < documentLength;
-                 i++) {
-            try {
-                rect = printShell.modelToView(i);
-                if (rect != null) {
-                    int y = (int) rect.getY();
-                    int height = (int) rect.getHeight();
-                    if (height != 0
-                            && (y != previousY || height != previousHeight)) {
-                        /*
-                         * we do not store the same value as previous. in our
-                         * documents it is often for consequent positons to have
-                         * the same modelToView y and height.
-                         */
-                        previousY = y;
-                        previousHeight = height;
-                        documentMetrics.add(new IntegerSegment(y, y + height - 1));
-                    }
-                }
-            } catch (BadLocationException e) {
-                assert false;
-            }
-        }
-        /*
-         * Merge all intersected segments.
-         */
-        Collections.sort(documentMetrics);
-        int yStart = Integer.MIN_VALUE;
-        int yEnd = Integer.MIN_VALUE;
-        for (IntegerSegment segment : documentMetrics) {
-            if (yEnd < segment.start) {
-                if (yEnd != Integer.MIN_VALUE) {
-                    rowsMetrics.add(new IntegerSegment(yStart, yEnd));
-                }
-                yStart = segment.start;
-                yEnd = segment.end;
-            } else {
-                yEnd = segment.end;
-            }
-        }
-        if (yEnd != Integer.MIN_VALUE) {
-            rowsMetrics.add(new IntegerSegment(yStart, yEnd));
-        }
-    }
+    private void calculateRowsMetrics() {throw new RuntimeException("cf-bug");} //{
+//        final int documentLength = printShell.getDocument().getLength();
+//        List<IntegerSegment> documentMetrics = new ArrayList<IntegerSegment>(LIST_SIZE);
+//        Rectangle rect;
+//        for (int i = 0, previousY = -1, previousHeight = -1; i < documentLength;
+//                 i++) {
+//            try {
+//                rect = printShell.modelToView(i);
+//                if (rect != null) {
+//                    int y = (int) rect.getY();
+//                    int height = (int) rect.getHeight();
+//                    if (height != 0
+//                            && (y != previousY || height != previousHeight)) {
+//                        /*
+//                         * we do not store the same value as previous. in our
+//                         * documents it is often for consequent positons to have
+//                         * the same modelToView y and height.
+//                         */
+//                        previousY = y;
+//                        previousHeight = height;
+//                        documentMetrics.add(new IntegerSegment(y, y + height - 1));
+//                    }
+//                }
+//            } catch (BadLocationException e) {
+//                assert false;
+//            }
+//        }
+//        /*
+//         * Merge all intersected segments.
+//         */
+//        Collections.sort(documentMetrics);
+//        int yStart = Integer.MIN_VALUE;
+//        int yEnd = Integer.MIN_VALUE;
+//        for (IntegerSegment segment : documentMetrics) {
+//            if (yEnd < segment.start) {
+//                if (yEnd != Integer.MIN_VALUE) {
+//                    rowsMetrics.add(new IntegerSegment(yStart, yEnd));
+//                }
+//                yStart = segment.start;
+//                yEnd = segment.end;
+//            } else {
+//                yEnd = segment.end;
+//            }
+//        }
+//        if (yEnd != Integer.MIN_VALUE) {
+//            rowsMetrics.add(new IntegerSegment(yStart, yEnd));
+//        }
+//    }
 
     /**
      *  Class to represent segment of integers.
@@ -815,32 +815,32 @@
             this.end = end;
         }
 
-        public int compareTo(IntegerSegment object) {
-            int startsDelta = start - object.start;
-            return (startsDelta != 0) ? startsDelta : end - object.end;
-        }
+        public int compareTo(IntegerSegment object) {throw new RuntimeException("cf-bug");} //{
+//            int startsDelta = start - object.start;
+//            return (startsDelta != 0) ? startsDelta : end - object.end;
+//        }
 
         @Override
-        public boolean equals(Object obj) {
-            if (obj instanceof IntegerSegment) {
-                return compareTo((IntegerSegment) obj) == 0;
-            } else {
-                return false;
-            }
-        }
+        public boolean equals(Object obj) {throw new RuntimeException("cf-bug");} //{
+//            if (obj instanceof IntegerSegment) {
+//                return compareTo((IntegerSegment) obj) == 0;
+//            } else {
+//                return false;
+//            }
+//        }
 
         @Override
-        public int hashCode() {
-            // from the "Effective Java: Programming Language Guide"
-            int result = 17;
-            result = 37 * result + start;
-            result = 37 * result + end;
-            return result;
-        }
+        public int hashCode() {throw new RuntimeException("cf-bug");} //{
+//            // from the "Effective Java: Programming Language Guide"
+//            int result = 17;
+//            result = 37 * result + start;
+//            result = 37 * result + end;
+//            return result;
+//        }
 
         @Override
-        public String toString() {
-            return "IntegerSegment [" + start + ", " + end + "]";
-        }
+        public String toString() {throw new RuntimeException("cf-bug");} //{
+//            return "IntegerSegment [" + start + ", " + end + "]";
+//        }
     }
 }
--- a/sun/java2d/StateTrackableDelegate.java	2016-06-22 19:56:06.803122357 -0700
+++ b/sun/java2d/StateTrackableDelegate.java	2016-06-29 12:48:30.332877215 -0700
@@ -65,20 +65,20 @@
      * {@link #UNTRACKABLE_DELEGATE} or {@link #IMMUTABLE_DELEGATE}
      * is returned.
      */
-    public static StateTrackableDelegate createInstance(State state) {
-        switch (state) {
-        case UNTRACKABLE:
-            return UNTRACKABLE_DELEGATE;
-        case STABLE:
-            return new StateTrackableDelegate(STABLE);
-        case DYNAMIC:
-            return new StateTrackableDelegate(DYNAMIC);
-        case IMMUTABLE:
-            return IMMUTABLE_DELEGATE;
-        default:
-            throw new InternalError("unknown state");
-        }
-    }
+    public static StateTrackableDelegate createInstance(State state) {throw new RuntimeException("cf-bug");} //{
+//        switch (state) {
+//        case UNTRACKABLE:
+//            return UNTRACKABLE_DELEGATE;
+//        case STABLE:
+//            return new StateTrackableDelegate(STABLE);
+//        case DYNAMIC:
+//            return new StateTrackableDelegate(DYNAMIC);
+//        case IMMUTABLE:
+//            return IMMUTABLE_DELEGATE;
+//        default:
+//            throw new InternalError("unknown state");
+//        }
+//    }
 
     private State theState;
     StateTracker theTracker;   // package private for easy access from tracker
@@ -88,48 +88,48 @@
      * Constructs a StateTrackableDelegate object with the specified
      * initial State.
      */
-    private StateTrackableDelegate(State state) {
-        this.theState = state;
-    }
+    private StateTrackableDelegate(State state) {throw new RuntimeException("cf-bug");} //{
+//        this.theState = state;
+//    }
 
     /**
      * @inheritDoc
      * @since 1.7
      */
-    public State getState() {
-        return theState;
-    }
+    public State getState() {throw new RuntimeException("cf-bug");} //{
+//        return theState;
+//    }
 
     /**
      * @inheritDoc
      * @since 1.7
      */
-    public synchronized StateTracker getStateTracker() {
-        StateTracker st = theTracker;
-        if (st == null) {
-            switch (theState) {
-            case IMMUTABLE:
-                st = StateTracker.ALWAYS_CURRENT;
-                break;
-            case STABLE:
-                st = new StateTracker() {
-                    public boolean isCurrent() {
-                        return (theTracker == this);
-                    }
-                };
-                break;
-            case DYNAMIC:
-                // We return the NEVER_CURRENT tracker, but that is
-                // just temporary while we are in the DYNAMIC state.
-                // NO BREAK
-            case UNTRACKABLE:
-                st = StateTracker.NEVER_CURRENT;
-                break;
-            }
-            theTracker = st;
-        }
-        return st;
-    }
+    public synchronized StateTracker getStateTracker() {throw new RuntimeException("cf-bug");} //{
+//        StateTracker st = theTracker;
+//        if (st == null) {
+//            switch (theState) {
+//            case IMMUTABLE:
+//                st = StateTracker.ALWAYS_CURRENT;
+//                break;
+//            case STABLE:
+//                st = new StateTracker() {
+//                    public boolean isCurrent() {
+//                        return (theTracker == this);
+//                    }
+//                };
+//                break;
+//            case DYNAMIC:
+//                // We return the NEVER_CURRENT tracker, but that is
+//                // just temporary while we are in the DYNAMIC state.
+//                // NO BREAK
+//            case UNTRACKABLE:
+//                st = StateTracker.NEVER_CURRENT;
+//                break;
+//            }
+//            theTracker = st;
+//        }
+//        return st;
+//    }
 
     /**
      * This method provides an easy way for delegating classes to
@@ -140,14 +140,14 @@
      * @see #setUntrackable
      * @since 1.7
      */
-    public synchronized void setImmutable() {
-        if (theState == UNTRACKABLE || theState == DYNAMIC) {
-            throw new IllegalStateException("UNTRACKABLE or DYNAMIC "+
-                                            "objects cannot become IMMUTABLE");
-        }
-        theState = IMMUTABLE;
-        theTracker = null;
-    }
+    public synchronized void setImmutable() {throw new RuntimeException("cf-bug");} //{
+//        if (theState == UNTRACKABLE || theState == DYNAMIC) {
+//            throw new IllegalStateException("UNTRACKABLE or DYNAMIC "+
+//                                            "objects cannot become IMMUTABLE");
+//        }
+//        theState = IMMUTABLE;
+//        theTracker = null;
+//    }
 
     /**
      * This method provides an easy way for delegating classes to
@@ -160,14 +160,14 @@
      * @see #setImmutable
      * @since 1.7
      */
-    public synchronized void setUntrackable() {
-        if (theState == IMMUTABLE) {
-            throw new IllegalStateException("IMMUTABLE objects cannot "+
-                                            "become UNTRACKABLE");
-        }
-        theState = UNTRACKABLE;
-        theTracker = null;
-    }
+    public synchronized void setUntrackable() {throw new RuntimeException("cf-bug");} //{
+//        if (theState == IMMUTABLE) {
+//            throw new IllegalStateException("IMMUTABLE objects cannot "+
+//                                            "become UNTRACKABLE");
+//        }
+//        theState = UNTRACKABLE;
+//        theTracker = null;
+//    }
 
     /**
      * This method provides an easy way for delegating classes to
@@ -191,17 +191,17 @@
      *         {@link State#IMMUTABLE IMMUTABLE}
      * @since 1.7
      */
-    public synchronized void addDynamicAgent() {
-        if (theState == IMMUTABLE) {
-            throw new IllegalStateException("Cannot change state from "+
-                                            "IMMUTABLE");
-        }
-        ++numDynamicAgents;
-        if (theState == STABLE) {
-            theState = DYNAMIC;
-            theTracker = null;
-        }
-    }
+    public synchronized void addDynamicAgent() {throw new RuntimeException("cf-bug");} //{
+//        if (theState == IMMUTABLE) {
+//            throw new IllegalStateException("Cannot change state from "+
+//                                            "IMMUTABLE");
+//        }
+//        ++numDynamicAgents;
+//        if (theState == STABLE) {
+//            theState = DYNAMIC;
+//            theTracker = null;
+//        }
+//    }
 
     /**
      * This method provides an easy way for delegating classes to
@@ -226,12 +226,12 @@
      *
      * @since 1.7
      */
-    protected synchronized void removeDynamicAgent() {
-        if (--numDynamicAgents == 0 && theState == DYNAMIC) {
-            theState = STABLE;
-            theTracker = null;
-        }
-    }
+    protected synchronized void removeDynamicAgent() {throw new RuntimeException("cf-bug");} //{
+//        if (--numDynamicAgents == 0 && theState == DYNAMIC) {
+//            theState = STABLE;
+//            theTracker = null;
+//        }
+//    }
 
     /**
      * This method provides an easy way for delegating classes to
@@ -250,7 +250,7 @@
      * {@code IMMUTABLE} delegate is never modified.
      * @since 1.7
      */
-    public final void markDirty() {
-        theTracker = null;
-    }
+    public final void markDirty() {throw new RuntimeException("cf-bug");} //{
+//        theTracker = null;
+//    }
 }
--- a/java/net/InetAddress.java	2016-06-22 19:56:38.949280838 -0700
+++ b/java/net/InetAddress.java	2016-06-29 11:04:52.463155585 -0700
@@ -228,32 +228,32 @@
             this.family = family;
         }
 
-        void init(String hostName, int family) {
-            this.originalHostName = hostName;
-            this.hostName = hostName;
-            if (family != -1) {
-                this.family = family;
-            }
-        }
+        void init(String hostName, int family) {throw new RuntimeException("cf-bug");} //{
+//            this.originalHostName = hostName;
+//            this.hostName = hostName;
+//            if (family != -1) {
+//                this.family = family;
+//            }
+//        }
 
         String hostName;
 
-        String getHostName() {
-            return hostName;
-        }
-
-        String getOriginalHostName() {
-            return originalHostName;
-        }
+        String getHostName() {throw new RuntimeException("cf-bug");} //{
+//            return hostName;
+//        }
+
+        String getOriginalHostName() {throw new RuntimeException("cf-bug");} //{
+//            return originalHostName;
+//        }
 
         /**
          * Holds a 32-bit IPv4 address.
          */
         int address;
 
-        int getAddress() {
-            return address;
-        }
+        int getAddress() {throw new RuntimeException("cf-bug");} //{
+//            return address;
+//        }
 
         /**
          * Specifies the address family type, for instance, '1' for IPv4
@@ -261,17 +261,17 @@
          */
         int family;
 
-        int getFamily() {
-            return family;
-        }
+        int getFamily() {throw new RuntimeException("cf-bug");} //{
+//            return family;
+//        }
     }
 
     /* Used to store the serializable fields of InetAddress */
     final transient InetAddressHolder holder;
 
-    InetAddressHolder holder() {
-        return holder;
-    }
+    InetAddressHolder holder() {throw new RuntimeException("cf-bug");} //{
+//        return holder;
+//    }
 
     /* Used to store the name service provider */
     private static List<NameService> nameServices = null;
@@ -316,10 +316,10 @@
      * @throws ObjectStreamException if a new object replacing this
      * object could not be created
      */
-    private Object readResolve() throws ObjectStreamException {
-        // will replace the deserialized 'this' object
-        return new Inet4Address(holder().getHostName(), holder().getAddress());
-    }
+    private Object readResolve() throws ObjectStreamException {throw new RuntimeException("cf-bug");} //{
+//        // will replace the deserialized 'this' object
+//        return new Inet4Address(holder().getHostName(), holder().getAddress());
+//    }
 
     /**
      * Utility routine to check if the InetAddress is an
@@ -328,9 +328,9 @@
      * an IP multicast address
      * @since   JDK1.1
      */
-    public boolean isMulticastAddress() {
-        return false;
-    }
+    public boolean isMulticastAddress() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Utility routine to check if the InetAddress in a wildcard address.
@@ -338,9 +338,9 @@
      *         a wildcard address.
      * @since 1.4
      */
-    public boolean isAnyLocalAddress() {
-        return false;
-    }
+    public boolean isAnyLocalAddress() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Utility routine to check if the InetAddress is a loopback address.
@@ -349,9 +349,9 @@
      * a loopback address; or false otherwise.
      * @since 1.4
      */
-    public boolean isLoopbackAddress() {
-        return false;
-    }
+    public boolean isLoopbackAddress() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Utility routine to check if the InetAddress is an link local address.
@@ -360,9 +360,9 @@
      * a link local address; or false if address is not a link local unicast address.
      * @since 1.4
      */
-    public boolean isLinkLocalAddress() {
-        return false;
-    }
+    public boolean isLinkLocalAddress() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Utility routine to check if the InetAddress is a site local address.
@@ -371,9 +371,9 @@
      * a site local address; or false if address is not a site local unicast address.
      * @since 1.4
      */
-    public boolean isSiteLocalAddress() {
-        return false;
-    }
+    public boolean isSiteLocalAddress() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Utility routine to check if the multicast address has global scope.
@@ -383,9 +383,9 @@
      *         of global scope or it is not a multicast address
      * @since 1.4
      */
-    public boolean isMCGlobal() {
-        return false;
-    }
+    public boolean isMCGlobal() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Utility routine to check if the multicast address has node scope.
@@ -395,9 +395,9 @@
      *         of node-local scope or it is not a multicast address
      * @since 1.4
      */
-    public boolean isMCNodeLocal() {
-        return false;
-    }
+    public boolean isMCNodeLocal() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Utility routine to check if the multicast address has link scope.
@@ -407,9 +407,9 @@
      *         of link-local scope or it is not a multicast address
      * @since 1.4
      */
-    public boolean isMCLinkLocal() {
-        return false;
-    }
+    public boolean isMCLinkLocal() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Utility routine to check if the multicast address has site scope.
@@ -419,9 +419,9 @@
      *         of site-local scope or it is not a multicast address
      * @since 1.4
      */
-    public boolean isMCSiteLocal() {
-        return false;
-    }
+    public boolean isMCSiteLocal() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Utility routine to check if the multicast address has organization scope.
@@ -432,9 +432,9 @@
      *         or it is not a multicast address
      * @since 1.4
      */
-    public boolean isMCOrgLocal() {
-        return false;
-    }
+    public boolean isMCOrgLocal() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
 
     /**
@@ -457,9 +457,9 @@
      * @throws  IllegalArgumentException if {@code timeout} is negative.
      * @since 1.5
      */
-    public boolean isReachable(int timeout) throws IOException {
-        return isReachable(null, 0 , timeout);
-    }
+    public boolean isReachable(int timeout) throws IOException {throw new RuntimeException("cf-bug");} //{
+//        return isReachable(null, 0 , timeout);
+//    }
 
     /**
      * Test whether that address is reachable. Best effort is made by the
@@ -493,14 +493,14 @@
      * @since 1.5
      */
     public boolean isReachable(NetworkInterface netif, int ttl,
-                               int timeout) throws IOException {
-        if (ttl < 0)
-            throw new IllegalArgumentException("ttl can't be negative");
-        if (timeout < 0)
-            throw new IllegalArgumentException("timeout can't be negative");
-
-        return impl.isReachable(this, timeout, netif, ttl);
-    }
+                               int timeout) throws IOException {throw new RuntimeException("cf-bug");} //{
+//        if (ttl < 0)
+//            throw new IllegalArgumentException("ttl can't be negative");
+//        if (timeout < 0)
+//            throw new IllegalArgumentException("timeout can't be negative");
+//
+//        return impl.isReachable(this, timeout, netif, ttl);
+//    }
 
     /**
      * Gets the host name for this IP address.
@@ -527,9 +527,9 @@
      * @see InetAddress#getCanonicalHostName
      * @see SecurityManager#checkConnect
      */
-    public String getHostName() {
-        return getHostName(true);
-    }
+    public String getHostName() {throw new RuntimeException("cf-bug");} //{
+//        return getHostName(true);
+//    }
 
     /**
      * Returns the hostname for this address.
@@ -554,12 +554,12 @@
      *
      * @see SecurityManager#checkConnect
      */
-    String getHostName(boolean check) {
-        if (holder().getHostName() == null) {
-            holder().hostName = InetAddress.getHostFromNameService(this, check);
-        }
-        return holder().getHostName();
-    }
+    String getHostName(boolean check) {throw new RuntimeException("cf-bug");} //{
+//        if (holder().getHostName() == null) {
+//            holder().hostName = InetAddress.getHostFromNameService(this, check);
+//        }
+//        return holder().getHostName();
+//    }
 
     /**
      * Gets the fully qualified domain name for this IP address.
@@ -582,13 +582,13 @@
      *
      * @since 1.4
      */
-    public String getCanonicalHostName() {
-        if (canonicalHostName == null) {
-            canonicalHostName =
-                InetAddress.getHostFromNameService(this, true);
-        }
-        return canonicalHostName;
-    }
+    public String getCanonicalHostName() {throw new RuntimeException("cf-bug");} //{
+//        if (canonicalHostName == null) {
+//            canonicalHostName =
+//                InetAddress.getHostFromNameService(this, true);
+//        }
+//        return canonicalHostName;
+//    }
 
     /**
      * Returns the hostname for this address.
@@ -609,56 +609,56 @@
      *
      * @see SecurityManager#checkConnect
      */
-    private static String getHostFromNameService(InetAddress addr, boolean check) {
-        String host = null;
-        for (NameService nameService : nameServices) {
-            try {
-                // first lookup the hostname
-                host = nameService.getHostByAddr(addr.getAddress());
-
-                /* check to see if calling code is allowed to know
-                 * the hostname for this IP address, ie, connect to the host
-                 */
-                if (check) {
-                    SecurityManager sec = System.getSecurityManager();
-                    if (sec != null) {
-                        sec.checkConnect(host, -1);
-                    }
-                }
-
-                /* now get all the IP addresses for this hostname,
-                 * and make sure one of them matches the original IP
-                 * address. We do this to try and prevent spoofing.
-                 */
-
-                InetAddress[] arr = InetAddress.getAllByName0(host, check);
-                boolean ok = false;
-
-                if(arr != null) {
-                    for(int i = 0; !ok && i < arr.length; i++) {
-                        ok = addr.equals(arr[i]);
-                    }
-                }
-
-                //XXX: if it looks a spoof just return the address?
-                if (!ok) {
-                    host = addr.getHostAddress();
-                    return host;
-                }
-
-                break;
-
-            } catch (SecurityException e) {
-                host = addr.getHostAddress();
-                break;
-            } catch (UnknownHostException e) {
-                host = addr.getHostAddress();
-                // let next provider resolve the hostname
-            }
-        }
-
-        return host;
-    }
+    private static String getHostFromNameService(InetAddress addr, boolean check) {throw new RuntimeException("cf-bug");} //{
+//        String host = null;
+//        for (NameService nameService : nameServices) {
+//            try {
+//                // first lookup the hostname
+//                host = nameService.getHostByAddr(addr.getAddress());
+//
+//                /* check to see if calling code is allowed to know
+//                 * the hostname for this IP address, ie, connect to the host
+//                 */
+//                if (check) {
+//                    SecurityManager sec = System.getSecurityManager();
+//                    if (sec != null) {
+//                        sec.checkConnect(host, -1);
+//                    }
+//                }
+//
+//                /* now get all the IP addresses for this hostname,
+//                 * and make sure one of them matches the original IP
+//                 * address. We do this to try and prevent spoofing.
+//                 */
+//
+//                InetAddress[] arr = InetAddress.getAllByName0(host, check);
+//                boolean ok = false;
+//
+//                if(arr != null) {
+//                    for(int i = 0; !ok && i < arr.length; i++) {
+//                        ok = addr.equals(arr[i]);
+//                    }
+//                }
+//
+//                //XXX: if it looks a spoof just return the address?
+//                if (!ok) {
+//                    host = addr.getHostAddress();
+//                    return host;
+//                }
+//
+//                break;
+//
+//            } catch (SecurityException e) {
+//                host = addr.getHostAddress();
+//                break;
+//            } catch (UnknownHostException e) {
+//                host = addr.getHostAddress();
+//                // let next provider resolve the hostname
+//            }
+//        }
+//
+//        return host;
+//    }
 
     /**
      * Returns the raw IP address of this {@code InetAddress}
@@ -667,9 +667,9 @@
      *
      * @return  the raw IP address of this object.
      */
-    public byte[] getAddress() {
-        return null;
-    }
+    public byte[] getAddress() {throw new RuntimeException("cf-bug");} //{
+//        return null;
+//    }
 
     /**
      * Returns the IP address string in textual presentation.
@@ -677,18 +677,18 @@
      * @return  the raw IP address in a string format.
      * @since   JDK1.0.2
      */
-    public String getHostAddress() {
-        return null;
-     }
+    public String getHostAddress() {throw new RuntimeException("cf-bug");} //{
+//        return null;
+//     }
 
     /**
      * Returns a hashcode for this IP address.
      *
      * @return  a hash code value for this IP address.
      */
-    public int hashCode() {
-        return -1;
-    }
+    public int hashCode() {throw new RuntimeException("cf-bug");} //{
+//        return -1;
+//    }
 
     /**
      * Compares this object against the specified object.
@@ -706,9 +706,9 @@
      *          {@code false} otherwise.
      * @see     java.net.InetAddress#getAddress()
      */
-    public boolean equals(Object obj) {
-        return false;
-    }
+    public boolean equals(Object obj) {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Converts this IP address to a {@code String}. The
@@ -720,11 +720,11 @@
      *
      * @return  a string representation of this IP address.
      */
-    public String toString() {
-        String hostName = holder().getHostName();
-        return ((hostName != null) ? hostName : "")
-            + "/" + getHostAddress();
-    }
+    public String toString() {throw new RuntimeException("cf-bug");} //{
+//        String hostName = holder().getHostName();
+//        return ((hostName != null) ? hostName : "")
+//            + "/" + getHostAddress();
+//    }
 
     /*
      * Cached addresses - our own litle nis, not!
@@ -773,200 +773,200 @@
             cache = new LinkedHashMap<String, CacheEntry>();
         }
 
-        private int getPolicy() {
-            if (type == Type.Positive) {
-                return InetAddressCachePolicy.get();
-            } else {
-                return InetAddressCachePolicy.getNegative();
-            }
-        }
+        private int getPolicy() {throw new RuntimeException("cf-bug");} //{
+//            if (type == Type.Positive) {
+//                return InetAddressCachePolicy.get();
+//            } else {
+//                return InetAddressCachePolicy.getNegative();
+//            }
+//        }
 
         /**
          * Add an entry to the cache. If there's already an
          * entry then for this host then the entry will be
          * replaced.
          */
-        public Cache put(String host, InetAddress[] addresses) {
-            int policy = getPolicy();
-            if (policy == InetAddressCachePolicy.NEVER) {
-                return this;
-            }
-
-            // purge any expired entries
-
-            if (policy != InetAddressCachePolicy.FOREVER) {
-
-                // As we iterate in insertion order we can
-                // terminate when a non-expired entry is found.
-                LinkedList<String> expired = new LinkedList<>();
-                long now = System.currentTimeMillis();
-                for (String key : cache.keySet()) {
-                    CacheEntry entry = cache.get(key);
-
-                    if (entry.expiration >= 0 && entry.expiration < now) {
-                        expired.add(key);
-                    } else {
-                        break;
-                    }
-                }
-
-                for (String key : expired) {
-                    cache.remove(key);
-                }
-            }
-
-            // create new entry and add it to the cache
-            // -- as a HashMap replaces existing entries we
-            //    don't need to explicitly check if there is
-            //    already an entry for this host.
-            long expiration;
-            if (policy == InetAddressCachePolicy.FOREVER) {
-                expiration = -1;
-            } else {
-                expiration = System.currentTimeMillis() + (policy * 1000);
-            }
-            CacheEntry entry = new CacheEntry(addresses, expiration);
-            cache.put(host, entry);
-            return this;
-        }
+        public Cache put(String host, InetAddress[] addresses) {throw new RuntimeException("cf-bug");} //{
+//            int policy = getPolicy();
+//            if (policy == InetAddressCachePolicy.NEVER) {
+//                return this;
+//            }
+//
+//            // purge any expired entries
+//
+//            if (policy != InetAddressCachePolicy.FOREVER) {
+//
+//                // As we iterate in insertion order we can
+//                // terminate when a non-expired entry is found.
+//                LinkedList<String> expired = new LinkedList<>();
+//                long now = System.currentTimeMillis();
+//                for (String key : cache.keySet()) {
+//                    CacheEntry entry = cache.get(key);
+//
+//                    if (entry.expiration >= 0 && entry.expiration < now) {
+//                        expired.add(key);
+//                    } else {
+//                        break;
+//                    }
+//                }
+//
+//                for (String key : expired) {
+//                    cache.remove(key);
+//                }
+//            }
+//
+//            // create new entry and add it to the cache
+//            // -- as a HashMap replaces existing entries we
+//            //    don't need to explicitly check if there is
+//            //    already an entry for this host.
+//            long expiration;
+//            if (policy == InetAddressCachePolicy.FOREVER) {
+//                expiration = -1;
+//            } else {
+//                expiration = System.currentTimeMillis() + (policy * 1000);
+//            }
+//            CacheEntry entry = new CacheEntry(addresses, expiration);
+//            cache.put(host, entry);
+//            return this;
+//        }
 
         /**
          * Query the cache for the specific host. If found then
          * return its CacheEntry, or null if not found.
          */
-        public CacheEntry get(String host) {
-            int policy = getPolicy();
-            if (policy == InetAddressCachePolicy.NEVER) {
-                return null;
-            }
-            CacheEntry entry = cache.get(host);
-
-            // check if entry has expired
-            if (entry != null && policy != InetAddressCachePolicy.FOREVER) {
-                if (entry.expiration >= 0 &&
-                    entry.expiration < System.currentTimeMillis()) {
-                    cache.remove(host);
-                    entry = null;
-                }
-            }
-
-            return entry;
-        }
+        public CacheEntry get(String host) {throw new RuntimeException("cf-bug");} //{
+//            int policy = getPolicy();
+//            if (policy == InetAddressCachePolicy.NEVER) {
+//                return null;
+//            }
+//            CacheEntry entry = cache.get(host);
+//
+//            // check if entry has expired
+//            if (entry != null && policy != InetAddressCachePolicy.FOREVER) {
+//                if (entry.expiration >= 0 &&
+//                    entry.expiration < System.currentTimeMillis()) {
+//                    cache.remove(host);
+//                    entry = null;
+//                }
+//            }
+//
+//            return entry;
+//        }
     }
 
     /*
      * Initialize cache and insert anyLocalAddress into the
      * unknown array with no expiry.
      */
-    private static void cacheInitIfNeeded() {
-        assert Thread.holdsLock(addressCache);
-        if (addressCacheInit) {
-            return;
-        }
-        unknown_array = new InetAddress[1];
-        unknown_array[0] = impl.anyLocalAddress();
-
-        addressCache.put(impl.anyLocalAddress().getHostName(),
-                         unknown_array);
-
-        addressCacheInit = true;
-    }
+    private static void cacheInitIfNeeded() {throw new RuntimeException("cf-bug");} //{
+//        assert Thread.holdsLock(addressCache);
+//        if (addressCacheInit) {
+//            return;
+//        }
+//        unknown_array = new InetAddress[1];
+//        unknown_array[0] = impl.anyLocalAddress();
+//
+//        addressCache.put(impl.anyLocalAddress().getHostName(),
+//                         unknown_array);
+//
+//        addressCacheInit = true;
+//    }
 
     /*
      * Cache the given hostname and addresses.
      */
     private static void cacheAddresses(String hostname,
                                        InetAddress[] addresses,
-                                       boolean success) {
-        hostname = hostname.toLowerCase();
-        synchronized (addressCache) {
-            cacheInitIfNeeded();
-            if (success) {
-                addressCache.put(hostname, addresses);
-            } else {
-                negativeCache.put(hostname, addresses);
-            }
-        }
-    }
+                                       boolean success) {throw new RuntimeException("cf-bug");} //{
+//        hostname = hostname.toLowerCase();
+//        synchronized (addressCache) {
+//            cacheInitIfNeeded();
+//            if (success) {
+//                addressCache.put(hostname, addresses);
+//            } else {
+//                negativeCache.put(hostname, addresses);
+//            }
+//        }
+//    }
 
     /*
      * Lookup hostname in cache (positive & negative cache). If
      * found return addresses, null if not found.
      */
-    private static InetAddress[] getCachedAddresses(String hostname) {
-        hostname = hostname.toLowerCase();
-
-        // search both positive & negative caches
-
-        synchronized (addressCache) {
-            cacheInitIfNeeded();
-
-            CacheEntry entry = addressCache.get(hostname);
-            if (entry == null) {
-                entry = negativeCache.get(hostname);
-            }
-
-            if (entry != null) {
-                return entry.addresses;
-            }
-        }
-
-        // not found
-        return null;
-    }
-
-    private static NameService createNSProvider(String provider) {
-        if (provider == null)
-            return null;
-
-        NameService nameService = null;
-        if (provider.equals("default")) {
-            // initialize the default name service
-            nameService = new NameService() {
-                public InetAddress[] lookupAllHostAddr(String host)
-                    throws UnknownHostException {
-                    return impl.lookupAllHostAddr(host);
-                }
-                public String getHostByAddr(byte[] addr)
-                    throws UnknownHostException {
-                    return impl.getHostByAddr(addr);
-                }
-            };
-        } else {
-            final String providerName = provider;
-            try {
-                nameService = java.security.AccessController.doPrivileged(
-                    new java.security.PrivilegedExceptionAction<NameService>() {
-                        public NameService run() {
-                            Iterator<NameServiceDescriptor> itr =
-                                ServiceLoader.load(NameServiceDescriptor.class)
-                                    .iterator();
-                            while (itr.hasNext()) {
-                                NameServiceDescriptor nsd = itr.next();
-                                if (providerName.
-                                    equalsIgnoreCase(nsd.getType()+","
-                                        +nsd.getProviderName())) {
-                                    try {
-                                        return nsd.createNameService();
-                                    } catch (Exception e) {
-                                        e.printStackTrace();
-                                        System.err.println(
-                                            "Cannot create name service:"
-                                             +providerName+": " + e);
-                                    }
-                                }
-                            }
-
-                            return null;
-                        }
-                    }
-                );
-            } catch (java.security.PrivilegedActionException e) {
-            }
-        }
-
-        return nameService;
-    }
+    private static InetAddress[] getCachedAddresses(String hostname) {throw new RuntimeException("cf-bug");} //{
+//        hostname = hostname.toLowerCase();
+//
+//        // search both positive & negative caches
+//
+//        synchronized (addressCache) {
+//            cacheInitIfNeeded();
+//
+//            CacheEntry entry = addressCache.get(hostname);
+//            if (entry == null) {
+//                entry = negativeCache.get(hostname);
+//            }
+//
+//            if (entry != null) {
+//                return entry.addresses;
+//            }
+//        }
+//
+//        // not found
+//        return null;
+//    }
+
+    private static NameService createNSProvider(String provider) {throw new RuntimeException("cf-bug");} //{
+//        if (provider == null)
+//            return null;
+//
+//        NameService nameService = null;
+//        if (provider.equals("default")) {
+//            // initialize the default name service
+//            nameService = new NameService() {
+//                public InetAddress[] lookupAllHostAddr(String host)
+//                    throws UnknownHostException {
+//                    return impl.lookupAllHostAddr(host);
+//                }
+//                public String getHostByAddr(byte[] addr)
+//                    throws UnknownHostException {
+//                    return impl.getHostByAddr(addr);
+//                }
+//            };
+//        } else {
+//            final String providerName = provider;
+//            try {
+//                nameService = java.security.AccessController.doPrivileged(
+//                    new java.security.PrivilegedExceptionAction<NameService>() {
+//                        public NameService run() {
+//                            Iterator<NameServiceDescriptor> itr =
+//                                ServiceLoader.load(NameServiceDescriptor.class)
+//                                    .iterator();
+//                            while (itr.hasNext()) {
+//                                NameServiceDescriptor nsd = itr.next();
+//                                if (providerName.
+//                                    equalsIgnoreCase(nsd.getType()+","
+//                                        +nsd.getProviderName())) {
+//                                    try {
+//                                        return nsd.createNameService();
+//                                    } catch (Exception e) {
+//                                        e.printStackTrace();
+//                                        System.err.println(
+//                                            "Cannot create name service:"
+//                                             +providerName+": " + e);
+//                                    }
+//                                }
+//                            }
+//
+//                            return null;
+//                        }
+//                    }
+//                );
+//            } catch (java.security.PrivilegedActionException e) {
+//            }
+//        }
+//
+//        return nameService;
+//    }
 
     static {
         // create the impl
@@ -1020,27 +1020,27 @@
      * @since 1.4
      */
     public static InetAddress getByAddress(String host, byte[] addr)
-        throws UnknownHostException {
-        if (host != null && host.length() > 0 && host.charAt(0) == '[') {
-            if (host.charAt(host.length()-1) == ']') {
-                host = host.substring(1, host.length() -1);
-            }
-        }
-        if (addr != null) {
-            if (addr.length == Inet4Address.INADDRSZ) {
-                return new Inet4Address(host, addr);
-            } else if (addr.length == Inet6Address.INADDRSZ) {
-                byte[] newAddr
-                    = IPAddressUtil.convertFromIPv4MappedAddress(addr);
-                if (newAddr != null) {
-                    return new Inet4Address(host, newAddr);
-                } else {
-                    return new Inet6Address(host, addr);
-                }
-            }
-        }
-        throw new UnknownHostException("addr is of illegal length");
-    }
+        throws UnknownHostException {throw new RuntimeException("cf-bug");} //{
+//        if (host != null && host.length() > 0 && host.charAt(0) == '[') {
+//            if (host.charAt(host.length()-1) == ']') {
+//                host = host.substring(1, host.length() -1);
+//            }
+//        }
+//        if (addr != null) {
+//            if (addr.length == Inet4Address.INADDRSZ) {
+//                return new Inet4Address(host, addr);
+//            } else if (addr.length == Inet6Address.INADDRSZ) {
+//                byte[] newAddr
+//                    = IPAddressUtil.convertFromIPv4MappedAddress(addr);
+//                if (newAddr != null) {
+//                    return new Inet4Address(host, newAddr);
+//                } else {
+//                    return new Inet6Address(host, addr);
+//                }
+//            }
+//        }
+//        throw new UnknownHostException("addr is of illegal length");
+//    }
 
 
     /**
@@ -1072,15 +1072,15 @@
      *             and its checkConnect method doesn't allow the operation
      */
     public static InetAddress getByName(String host)
-        throws UnknownHostException {
-        return InetAddress.getAllByName(host)[0];
-    }
+        throws UnknownHostException {throw new RuntimeException("cf-bug");} //{
+//        return InetAddress.getAllByName(host)[0];
+//    }
 
     // called from deployment cache manager
     private static InetAddress getByName(String host, InetAddress reqAddr)
-        throws UnknownHostException {
-        return InetAddress.getAllByName(host, reqAddr)[0];
-    }
+        throws UnknownHostException {throw new RuntimeException("cf-bug");} //{
+//        return InetAddress.getAllByName(host, reqAddr)[0];
+//    }
 
     /**
      * Given the name of a host, returns an array of its IP addresses,
@@ -1122,75 +1122,75 @@
      * @see SecurityManager#checkConnect
      */
     public static InetAddress[] getAllByName(String host)
-        throws UnknownHostException {
-        return getAllByName(host, null);
-    }
+        throws UnknownHostException {throw new RuntimeException("cf-bug");} //{
+//        return getAllByName(host, null);
+//    }
 
     private static InetAddress[] getAllByName(String host, InetAddress reqAddr)
-        throws UnknownHostException {
-
-        if (host == null || host.length() == 0) {
-            InetAddress[] ret = new InetAddress[1];
-            ret[0] = impl.loopbackAddress();
-            return ret;
-        }
-
-        boolean ipv6Expected = false;
-        if (host.charAt(0) == '[') {
-            // This is supposed to be an IPv6 literal
-            if (host.length() > 2 && host.charAt(host.length()-1) == ']') {
-                host = host.substring(1, host.length() -1);
-                ipv6Expected = true;
-            } else {
-                // This was supposed to be a IPv6 address, but it's not!
-                throw new UnknownHostException(host + ": invalid IPv6 address");
-            }
-        }
-
-        // if host is an IP address, we won't do further lookup
-        if (Character.digit(host.charAt(0), 16) != -1
-            || (host.charAt(0) == ':')) {
-            byte[] addr = null;
-            int numericZone = -1;
-            String ifname = null;
-            // see if it is IPv4 address
-            addr = IPAddressUtil.textToNumericFormatV4(host);
-            if (addr == null) {
-                // This is supposed to be an IPv6 literal
-                // Check if a numeric or string zone id is present
-                int pos;
-                if ((pos=host.indexOf ("%")) != -1) {
-                    numericZone = checkNumericZone (host);
-                    if (numericZone == -1) { /* remainder of string must be an ifname */
-                        ifname = host.substring (pos+1);
-                    }
-                }
-                if ((addr = IPAddressUtil.textToNumericFormatV6(host)) == null && host.contains(":")) {
-                    throw new UnknownHostException(host + ": invalid IPv6 address");
-                }
-            } else if (ipv6Expected) {
-                // Means an IPv4 litteral between brackets!
-                throw new UnknownHostException("["+host+"]");
-            }
-            InetAddress[] ret = new InetAddress[1];
-            if(addr != null) {
-                if (addr.length == Inet4Address.INADDRSZ) {
-                    ret[0] = new Inet4Address(null, addr);
-                } else {
-                    if (ifname != null) {
-                        ret[0] = new Inet6Address(null, addr, ifname);
-                    } else {
-                        ret[0] = new Inet6Address(null, addr, numericZone);
-                    }
-                }
-                return ret;
-            }
-        } else if (ipv6Expected) {
-            // We were expecting an IPv6 Litteral, but got something else
-            throw new UnknownHostException("["+host+"]");
-        }
-        return getAllByName0(host, reqAddr, true);
-    }
+        throws UnknownHostException {throw new RuntimeException("cf-bug");} //{
+//
+//        if (host == null || host.length() == 0) {
+//            InetAddress[] ret = new InetAddress[1];
+//            ret[0] = impl.loopbackAddress();
+//            return ret;
+//        }
+//
+//        boolean ipv6Expected = false;
+//        if (host.charAt(0) == '[') {
+//            // This is supposed to be an IPv6 literal
+//            if (host.length() > 2 && host.charAt(host.length()-1) == ']') {
+//                host = host.substring(1, host.length() -1);
+//                ipv6Expected = true;
+//            } else {
+//                // This was supposed to be a IPv6 address, but it's not!
+//                throw new UnknownHostException(host + ": invalid IPv6 address");
+//            }
+//        }
+//
+//        // if host is an IP address, we won't do further lookup
+//        if (Character.digit(host.charAt(0), 16) != -1
+//            || (host.charAt(0) == ':')) {
+//            byte[] addr = null;
+//            int numericZone = -1;
+//            String ifname = null;
+//            // see if it is IPv4 address
+//            addr = IPAddressUtil.textToNumericFormatV4(host);
+//            if (addr == null) {
+//                // This is supposed to be an IPv6 literal
+//                // Check if a numeric or string zone id is present
+//                int pos;
+//                if ((pos=host.indexOf ("%")) != -1) {
+//                    numericZone = checkNumericZone (host);
+//                    if (numericZone == -1) { /* remainder of string must be an ifname */
+//                        ifname = host.substring (pos+1);
+//                    }
+//                }
+//                if ((addr = IPAddressUtil.textToNumericFormatV6(host)) == null && host.contains(":")) {
+//                    throw new UnknownHostException(host + ": invalid IPv6 address");
+//                }
+//            } else if (ipv6Expected) {
+//                // Means an IPv4 litteral between brackets!
+//                throw new UnknownHostException("["+host+"]");
+//            }
+//            InetAddress[] ret = new InetAddress[1];
+//            if(addr != null) {
+//                if (addr.length == Inet4Address.INADDRSZ) {
+//                    ret[0] = new Inet4Address(null, addr);
+//                } else {
+//                    if (ifname != null) {
+//                        ret[0] = new Inet6Address(null, addr, ifname);
+//                    } else {
+//                        ret[0] = new Inet6Address(null, addr, numericZone);
+//                    }
+//                }
+//                return ret;
+//            }
+//        } else if (ipv6Expected) {
+//            // We were expecting an IPv6 Litteral, but got something else
+//            throw new UnknownHostException("["+host+"]");
+//        }
+//        return getAllByName0(host, reqAddr, true);
+//    }
 
     /**
      * Returns the loopback address.
@@ -1203,9 +1203,9 @@
      * @return  the InetAddress loopback instance.
      * @since 1.7
      */
-    public static InetAddress getLoopbackAddress() {
-        return impl.loopbackAddress();
-    }
+    public static InetAddress getLoopbackAddress() {throw new RuntimeException("cf-bug");} //{
+//        return impl.loopbackAddress();
+//    }
 
 
     /**
@@ -1215,208 +1215,208 @@
      * %nn may also be a string that represents the displayName of
      * a currently available NetworkInterface.
      */
-    private static int checkNumericZone (String s) throws UnknownHostException {
-        int percent = s.indexOf ('%');
-        int slen = s.length();
-        int digit, zone=0;
-        if (percent == -1) {
-            return -1;
-        }
-        for (int i=percent+1; i<slen; i++) {
-            char c = s.charAt(i);
-            if (c == ']') {
-                if (i == percent+1) {
-                    /* empty per-cent field */
-                    return -1;
-                }
-                break;
-            }
-            if ((digit = Character.digit (c, 10)) < 0) {
-                return -1;
-            }
-            zone = (zone * 10) + digit;
-        }
-        return zone;
-    }
+    private static int checkNumericZone (String s) throws UnknownHostException {throw new RuntimeException("cf-bug");} //{
+//        int percent = s.indexOf ('%');
+//        int slen = s.length();
+//        int digit, zone=0;
+//        if (percent == -1) {
+//            return -1;
+//        }
+//        for (int i=percent+1; i<slen; i++) {
+//            char c = s.charAt(i);
+//            if (c == ']') {
+//                if (i == percent+1) {
+//                    /* empty per-cent field */
+//                    return -1;
+//                }
+//                break;
+//            }
+//            if ((digit = Character.digit (c, 10)) < 0) {
+//                return -1;
+//            }
+//            zone = (zone * 10) + digit;
+//        }
+//        return zone;
+//    }
 
     private static InetAddress[] getAllByName0 (String host)
         throws UnknownHostException
-    {
-        return getAllByName0(host, true);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        return getAllByName0(host, true);
+//    }
 
     /**
      * package private so SocketPermission can call it
      */
     static InetAddress[] getAllByName0 (String host, boolean check)
-        throws UnknownHostException  {
-        return getAllByName0 (host, null, check);
-    }
+        throws UnknownHostException  {throw new RuntimeException("cf-bug");} //{
+//        return getAllByName0 (host, null, check);
+//    }
 
     private static InetAddress[] getAllByName0 (String host, InetAddress reqAddr, boolean check)
-        throws UnknownHostException  {
-
-        /* If it gets here it is presumed to be a hostname */
-        /* Cache.get can return: null, unknownAddress, or InetAddress[] */
-
-        /* make sure the connection to the host is allowed, before we
-         * give out a hostname
-         */
-        if (check) {
-            SecurityManager security = System.getSecurityManager();
-            if (security != null) {
-                security.checkConnect(host, -1);
-            }
-        }
-
-        InetAddress[] addresses = getCachedAddresses(host);
-
-        /* If no entry in cache, then do the host lookup */
-        if (addresses == null) {
-            addresses = getAddressesFromNameService(host, reqAddr);
-        }
-
-        if (addresses == unknown_array)
-            throw new UnknownHostException(host);
-
-        return addresses.clone();
-    }
+        throws UnknownHostException  {throw new RuntimeException("cf-bug");} //{
+//
+//        /* If it gets here it is presumed to be a hostname */
+//        /* Cache.get can return: null, unknownAddress, or InetAddress[] */
+//
+//        /* make sure the connection to the host is allowed, before we
+//         * give out a hostname
+//         */
+//        if (check) {
+//            SecurityManager security = System.getSecurityManager();
+//            if (security != null) {
+//                security.checkConnect(host, -1);
+//            }
+//        }
+//
+//        InetAddress[] addresses = getCachedAddresses(host);
+//
+//        /* If no entry in cache, then do the host lookup */
+//        if (addresses == null) {
+//            addresses = getAddressesFromNameService(host, reqAddr);
+//        }
+//
+//        if (addresses == unknown_array)
+//            throw new UnknownHostException(host);
+//
+//        return addresses.clone();
+//    }
 
     private static InetAddress[] getAddressesFromNameService(String host, InetAddress reqAddr)
         throws UnknownHostException
-    {
-        InetAddress[] addresses = null;
-        boolean success = false;
-        UnknownHostException ex = null;
-
-        // Check whether the host is in the lookupTable.
-        // 1) If the host isn't in the lookupTable when
-        //    checkLookupTable() is called, checkLookupTable()
-        //    would add the host in the lookupTable and
-        //    return null. So we will do the lookup.
-        // 2) If the host is in the lookupTable when
-        //    checkLookupTable() is called, the current thread
-        //    would be blocked until the host is removed
-        //    from the lookupTable. Then this thread
-        //    should try to look up the addressCache.
-        //     i) if it found the addresses in the
-        //        addressCache, checkLookupTable()  would
-        //        return the addresses.
-        //     ii) if it didn't find the addresses in the
-        //         addressCache for any reason,
-        //         it should add the host in the
-        //         lookupTable and return null so the
-        //         following code would do  a lookup itself.
-        if ((addresses = checkLookupTable(host)) == null) {
-            try {
-                // This is the first thread which looks up the addresses
-                // this host or the cache entry for this host has been
-                // expired so this thread should do the lookup.
-                for (NameService nameService : nameServices) {
-                    try {
-                        /*
-                         * Do not put the call to lookup() inside the
-                         * constructor.  if you do you will still be
-                         * allocating space when the lookup fails.
-                         */
-
-                        addresses = nameService.lookupAllHostAddr(host);
-                        success = true;
-                        break;
-                    } catch (UnknownHostException uhe) {
-                        if (host.equalsIgnoreCase("localhost")) {
-                            InetAddress[] local = new InetAddress[] { impl.loopbackAddress() };
-                            addresses = local;
-                            success = true;
-                            break;
-                        }
-                        else {
-                            addresses = unknown_array;
-                            success = false;
-                            ex = uhe;
-                        }
-                    }
-                }
-
-                // More to do?
-                if (reqAddr != null && addresses.length > 1 && !addresses[0].equals(reqAddr)) {
-                    // Find it?
-                    int i = 1;
-                    for (; i < addresses.length; i++) {
-                        if (addresses[i].equals(reqAddr)) {
-                            break;
-                        }
-                    }
-                    // Rotate
-                    if (i < addresses.length) {
-                        InetAddress tmp, tmp2 = reqAddr;
-                        for (int j = 0; j < i; j++) {
-                            tmp = addresses[j];
-                            addresses[j] = tmp2;
-                            tmp2 = tmp;
-                        }
-                        addresses[i] = tmp2;
-                    }
-                }
-                // Cache the address.
-                cacheAddresses(host, addresses, success);
-
-                if (!success && ex != null)
-                    throw ex;
-
-            } finally {
-                // Delete host from the lookupTable and notify
-                // all threads waiting on the lookupTable monitor.
-                updateLookupTable(host);
-            }
-        }
-
-        return addresses;
-    }
-
-
-    private static InetAddress[] checkLookupTable(String host) {
-        synchronized (lookupTable) {
-            // If the host isn't in the lookupTable, add it in the
-            // lookuptable and return null. The caller should do
-            // the lookup.
-            if (lookupTable.containsKey(host) == false) {
-                lookupTable.put(host, null);
-                return null;
-            }
-
-            // If the host is in the lookupTable, it means that another
-            // thread is trying to look up the addresses of this host.
-            // This thread should wait.
-            while (lookupTable.containsKey(host)) {
-                try {
-                    lookupTable.wait();
-                } catch (InterruptedException e) {
-                }
-            }
-        }
-
-        // The other thread has finished looking up the addresses of
-        // the host. This thread should retry to get the addresses
-        // from the addressCache. If it doesn't get the addresses from
-        // the cache, it will try to look up the addresses itself.
-        InetAddress[] addresses = getCachedAddresses(host);
-        if (addresses == null) {
-            synchronized (lookupTable) {
-                lookupTable.put(host, null);
-                return null;
-            }
-        }
-
-        return addresses;
-    }
-
-    private static void updateLookupTable(String host) {
-        synchronized (lookupTable) {
-            lookupTable.remove(host);
-            lookupTable.notifyAll();
-        }
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        InetAddress[] addresses = null;
+//        boolean success = false;
+//        UnknownHostException ex = null;
+//
+//        // Check whether the host is in the lookupTable.
+//        // 1) If the host isn't in the lookupTable when
+//        //    checkLookupTable() is called, checkLookupTable()
+//        //    would add the host in the lookupTable and
+//        //    return null. So we will do the lookup.
+//        // 2) If the host is in the lookupTable when
+//        //    checkLookupTable() is called, the current thread
+//        //    would be blocked until the host is removed
+//        //    from the lookupTable. Then this thread
+//        //    should try to look up the addressCache.
+//        //     i) if it found the addresses in the
+//        //        addressCache, checkLookupTable()  would
+//        //        return the addresses.
+//        //     ii) if it didn't find the addresses in the
+//        //         addressCache for any reason,
+//        //         it should add the host in the
+//        //         lookupTable and return null so the
+//        //         following code would do  a lookup itself.
+//        if ((addresses = checkLookupTable(host)) == null) {
+//            try {
+//                // This is the first thread which looks up the addresses
+//                // this host or the cache entry for this host has been
+//                // expired so this thread should do the lookup.
+//                for (NameService nameService : nameServices) {
+//                    try {
+//                        /*
+//                         * Do not put the call to lookup() inside the
+//                         * constructor.  if you do you will still be
+//                         * allocating space when the lookup fails.
+//                         */
+//
+//                        addresses = nameService.lookupAllHostAddr(host);
+//                        success = true;
+//                        break;
+//                    } catch (UnknownHostException uhe) {
+//                        if (host.equalsIgnoreCase("localhost")) {
+//                            InetAddress[] local = new InetAddress[] { impl.loopbackAddress() };
+//                            addresses = local;
+//                            success = true;
+//                            break;
+//                        }
+//                        else {
+//                            addresses = unknown_array;
+//                            success = false;
+//                            ex = uhe;
+//                        }
+//                    }
+//                }
+//
+//                // More to do?
+//                if (reqAddr != null && addresses.length > 1 && !addresses[0].equals(reqAddr)) {
+//                    // Find it?
+//                    int i = 1;
+//                    for (; i < addresses.length; i++) {
+//                        if (addresses[i].equals(reqAddr)) {
+//                            break;
+//                        }
+//                    }
+//                    // Rotate
+//                    if (i < addresses.length) {
+//                        InetAddress tmp, tmp2 = reqAddr;
+//                        for (int j = 0; j < i; j++) {
+//                            tmp = addresses[j];
+//                            addresses[j] = tmp2;
+//                            tmp2 = tmp;
+//                        }
+//                        addresses[i] = tmp2;
+//                    }
+//                }
+//                // Cache the address.
+//                cacheAddresses(host, addresses, success);
+//
+//                if (!success && ex != null)
+//                    throw ex;
+//
+//            } finally {
+//                // Delete host from the lookupTable and notify
+//                // all threads waiting on the lookupTable monitor.
+//                updateLookupTable(host);
+//            }
+//        }
+//
+//        return addresses;
+//    }
+
+
+    private static InetAddress[] checkLookupTable(String host) {throw new RuntimeException("cf-bug");} //{
+//        synchronized (lookupTable) {
+//            // If the host isn't in the lookupTable, add it in the
+//            // lookuptable and return null. The caller should do
+//            // the lookup.
+//            if (lookupTable.containsKey(host) == false) {
+//                lookupTable.put(host, null);
+//                return null;
+//            }
+//
+//            // If the host is in the lookupTable, it means that another
+//            // thread is trying to look up the addresses of this host.
+//            // This thread should wait.
+//            while (lookupTable.containsKey(host)) {
+//                try {
+//                    lookupTable.wait();
+//                } catch (InterruptedException e) {
+//                }
+//            }
+//        }
+//
+//        // The other thread has finished looking up the addresses of
+//        // the host. This thread should retry to get the addresses
+//        // from the addressCache. If it doesn't get the addresses from
+//        // the cache, it will try to look up the addresses itself.
+//        InetAddress[] addresses = getCachedAddresses(host);
+//        if (addresses == null) {
+//            synchronized (lookupTable) {
+//                lookupTable.put(host, null);
+//                return null;
+//            }
+//        }
+//
+//        return addresses;
+//    }
+
+    private static void updateLookupTable(String host) {throw new RuntimeException("cf-bug");} //{
+//        synchronized (lookupTable) {
+//            lookupTable.remove(host);
+//            lookupTable.notifyAll();
+//        }
+//    }
 
     /**
      * Returns an {@code InetAddress} object given the raw IP address .
@@ -1435,9 +1435,9 @@
      * @since 1.4
      */
     public static InetAddress getByAddress(byte[] addr)
-        throws UnknownHostException {
-        return getByAddress(null, addr);
-    }
+        throws UnknownHostException {throw new RuntimeException("cf-bug");} //{
+//        return getByAddress(null, addr);
+//    }
 
     private static InetAddress cachedLocalHost = null;
     private static long cacheTime = 0;
@@ -1467,55 +1467,55 @@
      * @see SecurityManager#checkConnect
      * @see java.net.InetAddress#getByName(java.lang.String)
      */
-    public static InetAddress getLocalHost() throws UnknownHostException {
-
-        SecurityManager security = System.getSecurityManager();
-        try {
-            String local = impl.getLocalHostName();
-
-            if (security != null) {
-                security.checkConnect(local, -1);
-            }
-
-            if (local.equals("localhost")) {
-                return impl.loopbackAddress();
-            }
-
-            InetAddress ret = null;
-            synchronized (cacheLock) {
-                long now = System.currentTimeMillis();
-                if (cachedLocalHost != null) {
-                    if ((now - cacheTime) < maxCacheTime) // Less than 5s old?
-                        ret = cachedLocalHost;
-                    else
-                        cachedLocalHost = null;
-                }
-
-                // we are calling getAddressesFromNameService directly
-                // to avoid getting localHost from cache
-                if (ret == null) {
-                    InetAddress[] localAddrs;
-                    try {
-                        localAddrs =
-                            InetAddress.getAddressesFromNameService(local, null);
-                    } catch (UnknownHostException uhe) {
-                        // Rethrow with a more informative error message.
-                        UnknownHostException uhe2 =
-                            new UnknownHostException(local + ": " +
-                                                     uhe.getMessage());
-                        uhe2.initCause(uhe);
-                        throw uhe2;
-                    }
-                    cachedLocalHost = localAddrs[0];
-                    cacheTime = now;
-                    ret = localAddrs[0];
-                }
-            }
-            return ret;
-        } catch (java.lang.SecurityException e) {
-            return impl.loopbackAddress();
-        }
-    }
+    public static InetAddress getLocalHost() throws UnknownHostException {throw new RuntimeException("cf-bug");} //{
+//
+//        SecurityManager security = System.getSecurityManager();
+//        try {
+//            String local = impl.getLocalHostName();
+//
+//            if (security != null) {
+//                security.checkConnect(local, -1);
+//            }
+//
+//            if (local.equals("localhost")) {
+//                return impl.loopbackAddress();
+//            }
+//
+//            InetAddress ret = null;
+//            synchronized (cacheLock) {
+//                long now = System.currentTimeMillis();
+//                if (cachedLocalHost != null) {
+//                    if ((now - cacheTime) < maxCacheTime) // Less than 5s old?
+//                        ret = cachedLocalHost;
+//                    else
+//                        cachedLocalHost = null;
+//                }
+//
+//                // we are calling getAddressesFromNameService directly
+//                // to avoid getting localHost from cache
+//                if (ret == null) {
+//                    InetAddress[] localAddrs;
+//                    try {
+//                        localAddrs =
+//                            InetAddress.getAddressesFromNameService(local, null);
+//                    } catch (UnknownHostException uhe) {
+//                        // Rethrow with a more informative error message.
+//                        UnknownHostException uhe2 =
+//                            new UnknownHostException(local + ": " +
+//                                                     uhe.getMessage());
+//                        uhe2.initCause(uhe);
+//                        throw uhe2;
+//                    }
+//                    cachedLocalHost = localAddrs[0];
+//                    cacheTime = now;
+//                    ret = localAddrs[0];
+//                }
+//            }
+//            return ret;
+//        } catch (java.lang.SecurityException e) {
+//            return impl.loopbackAddress();
+//        }
+//    }
 
     /**
      * Perform class load-time initializations.
@@ -1527,58 +1527,58 @@
      * Returns the InetAddress representing anyLocalAddress
      * (typically 0.0.0.0 or ::0)
      */
-    static InetAddress anyLocalAddress() {
-        return impl.anyLocalAddress();
-    }
+    static InetAddress anyLocalAddress() {throw new RuntimeException("cf-bug");} //{
+//        return impl.anyLocalAddress();
+//    }
 
     /*
      * Load and instantiate an underlying impl class
      */
-    static InetAddressImpl loadImpl(String implName) {
-        Object impl = null;
-
-        /*
-         * Property "impl.prefix" will be prepended to the classname
-         * of the implementation object we instantiate, to which we
-         * delegate the real work (like native methods).  This
-         * property can vary across implementations of the java.
-         * classes.  The default is an empty String "".
-         */
-        String prefix = AccessController.doPrivileged(
-                      new GetPropertyAction("impl.prefix", ""));
-        try {
-            impl = Class.forName("java.net." + prefix + implName).newInstance();
-        } catch (ClassNotFoundException e) {
-            System.err.println("Class not found: java.net." + prefix +
-                               implName + ":\ncheck impl.prefix property " +
-                               "in your properties file.");
-        } catch (InstantiationException e) {
-            System.err.println("Could not instantiate: java.net." + prefix +
-                               implName + ":\ncheck impl.prefix property " +
-                               "in your properties file.");
-        } catch (IllegalAccessException e) {
-            System.err.println("Cannot access class: java.net." + prefix +
-                               implName + ":\ncheck impl.prefix property " +
-                               "in your properties file.");
-        }
-
-        if (impl == null) {
-            try {
-                impl = Class.forName(implName).newInstance();
-            } catch (Exception e) {
-                throw new Error("System property impl.prefix incorrect");
-            }
-        }
-
-        return (InetAddressImpl) impl;
-    }
+    static InetAddressImpl loadImpl(String implName) {throw new RuntimeException("cf-bug");} //{
+//        Object impl = null;
+//
+//        /*
+//         * Property "impl.prefix" will be prepended to the classname
+//         * of the implementation object we instantiate, to which we
+//         * delegate the real work (like native methods).  This
+//         * property can vary across implementations of the java.
+//         * classes.  The default is an empty String "".
+//         */
+//        String prefix = AccessController.doPrivileged(
+//                      new GetPropertyAction("impl.prefix", ""));
+//        try {
+//            impl = Class.forName("java.net." + prefix + implName).newInstance();
+//        } catch (ClassNotFoundException e) {
+//            System.err.println("Class not found: java.net." + prefix +
+//                               implName + ":\ncheck impl.prefix property " +
+//                               "in your properties file.");
+//        } catch (InstantiationException e) {
+//            System.err.println("Could not instantiate: java.net." + prefix +
+//                               implName + ":\ncheck impl.prefix property " +
+//                               "in your properties file.");
+//        } catch (IllegalAccessException e) {
+//            System.err.println("Cannot access class: java.net." + prefix +
+//                               implName + ":\ncheck impl.prefix property " +
+//                               "in your properties file.");
+//        }
+//
+//        if (impl == null) {
+//            try {
+//                impl = Class.forName(implName).newInstance();
+//            } catch (Exception e) {
+//                throw new Error("System property impl.prefix incorrect");
+//            }
+//        }
+//
+//        return (InetAddressImpl) impl;
+//    }
 
     private void readObjectNoData (ObjectInputStream s) throws
-                         IOException, ClassNotFoundException {
-        if (getClass().getClassLoader() != null) {
-            throw new SecurityException ("invalid address type");
-        }
-    }
+                         IOException, ClassNotFoundException {throw new RuntimeException("cf-bug");} //{
+//        if (getClass().getClassLoader() != null) {
+//            throw new SecurityException ("invalid address type");
+//        }
+//    }
 
     private static final long FIELDS_OFFSET;
     private static final sun.misc.Unsafe UNSAFE;
@@ -1596,17 +1596,17 @@
     }
 
     private void readObject (ObjectInputStream s) throws
-                         IOException, ClassNotFoundException {
-        if (getClass().getClassLoader() != null) {
-            throw new SecurityException ("invalid address type");
-        }
-        GetField gf = s.readFields();
-        String host = (String)gf.get("hostName", null);
-        int address= gf.get("address", 0);
-        int family= gf.get("family", 0);
-        InetAddressHolder h = new InetAddressHolder(host, address, family);
-        UNSAFE.putObject(this, FIELDS_OFFSET, h);
-    }
+                         IOException, ClassNotFoundException {throw new RuntimeException("cf-bug");} //{
+//        if (getClass().getClassLoader() != null) {
+//            throw new SecurityException ("invalid address type");
+//        }
+//        GetField gf = s.readFields();
+//        String host = (String)gf.get("hostName", null);
+//        int address= gf.get("address", 0);
+//        int family= gf.get("family", 0);
+//        InetAddressHolder h = new InetAddressHolder(host, address, family);
+//        UNSAFE.putObject(this, FIELDS_OFFSET, h);
+//    }
 
     /* needed because the serializable fields no longer exist */
 
@@ -1622,16 +1622,16 @@
     };
 
     private void writeObject (ObjectOutputStream s) throws
-                        IOException {
-        if (getClass().getClassLoader() != null) {
-            throw new SecurityException ("invalid address type");
-        }
-        PutField pf = s.putFields();
-        pf.put("hostName", holder().getHostName());
-        pf.put("address", holder().getAddress());
-        pf.put("family", holder().getFamily());
-        s.writeFields();
-    }
+                        IOException {throw new RuntimeException("cf-bug");} //{
+//        if (getClass().getClassLoader() != null) {
+//            throw new SecurityException ("invalid address type");
+//        }
+//        PutField pf = s.putFields();
+//        pf.put("hostName", holder().getHostName());
+//        pf.put("address", holder().getAddress());
+//        pf.put("family", holder().getFamily());
+//        s.writeFields();
+//    }
 }
 
 /*
@@ -1639,10 +1639,10 @@
  */
 class InetAddressImplFactory {
 
-    static InetAddressImpl create() {
-        return InetAddress.loadImpl(isIPv6Supported() ?
-                                    "Inet6AddressImpl" : "Inet4AddressImpl");
-    }
+    static InetAddressImpl create() {throw new RuntimeException("cf-bug");} //{
+//        return InetAddress.loadImpl(isIPv6Supported() ?
+//                                    "Inet6AddressImpl" : "Inet4AddressImpl");
+//    }
 
     static native boolean isIPv6Supported();
 }
--- a/java/nio/channels/spi/AbstractSelector.java	2016-06-22 19:56:40.563288795 -0700
+++ b/java/nio/channels/spi/AbstractSelector.java	2016-06-29 11:07:28.257888879 -0700
@@ -87,11 +87,11 @@
 
     private final Set<SelectionKey> cancelledKeys = new HashSet<SelectionKey>();
 
-    void cancel(SelectionKey k) {                       // package-private
-        synchronized (cancelledKeys) {
-            cancelledKeys.add(k);
-        }
-    }
+    void cancel(SelectionKey k) {throw new RuntimeException("cf-bug");} //{                       // package-private
+//        synchronized (cancelledKeys) {
+//            cancelledKeys.add(k);
+//        }
+//    }
 
     /**
      * Closes this selector.
@@ -104,12 +104,12 @@
      * @throws  IOException
      *          If an I/O error occurs
      */
-    public final void close() throws IOException {
-        boolean open = selectorOpen.getAndSet(false);
-        if (!open)
-            return;
-        implCloseSelector();
-    }
+    public final void close() throws IOException {throw new RuntimeException("cf-bug");} //{
+//        boolean open = selectorOpen.getAndSet(false);
+//        if (!open)
+//            return;
+//        implCloseSelector();
+//    }
 
     /**
      * Closes this selector.
@@ -129,18 +129,18 @@
      */
     protected abstract void implCloseSelector() throws IOException;
 
-    public final boolean isOpen() {
-        return selectorOpen.get();
-    }
+    public final boolean isOpen() {throw new RuntimeException("cf-bug");} //{
+//        return selectorOpen.get();
+//    }
 
     /**
      * Returns the provider that created this channel.
      *
      * @return  The provider that created this channel
      */
-    public final SelectorProvider provider() {
-        return provider;
-    }
+    public final SelectorProvider provider() {throw new RuntimeException("cf-bug");} //{
+//        return provider;
+//    }
 
     /**
      * Retrieves this selector's cancelled-key set.
@@ -149,9 +149,9 @@
      *
      * @return  The cancelled-key set
      */
-    protected final Set<SelectionKey> cancelledKeys() {
-        return cancelledKeys;
-    }
+    protected final Set<SelectionKey> cancelledKeys() {throw new RuntimeException("cf-bug");} //{
+//        return cancelledKeys;
+//    }
 
     /**
      * Registers the given channel with this selector.
@@ -184,9 +184,9 @@
      * @param  key
      *         The selection key to be removed
      */
-    protected final void deregister(AbstractSelectionKey key) {
-        ((AbstractSelectableChannel)key.channel()).removeKey(key);
-    }
+    protected final void deregister(AbstractSelectionKey key) {throw new RuntimeException("cf-bug");} //{
+//        ((AbstractSelectableChannel)key.channel()).removeKey(key);
+//    }
 
 
     // -- Interruption machinery --
@@ -206,18 +206,18 @@
      * Thread#interrupt interrupt} method is invoked while the thread is
      * blocked in an I/O operation upon the selector.  </p>
      */
-    protected final void begin() {
-        if (interruptor == null) {
-            interruptor = new Interruptible() {
-                    public void interrupt(Thread ignore) {
-                        AbstractSelector.this.wakeup();
-                    }};
-        }
-        AbstractInterruptibleChannel.blockedOn(interruptor);
-        Thread me = Thread.currentThread();
-        if (me.isInterrupted())
-            interruptor.interrupt(me);
-    }
+    protected final void begin() {throw new RuntimeException("cf-bug");} //{
+//        if (interruptor == null) {
+//            interruptor = new Interruptible() {
+//                    public void interrupt(Thread ignore) {
+//                        AbstractSelector.this.wakeup();
+//                    }};
+//        }
+//        AbstractInterruptibleChannel.blockedOn(interruptor);
+//        Thread me = Thread.currentThread();
+//        if (me.isInterrupted())
+//            interruptor.interrupt(me);
+//    }
 
     /**
      * Marks the end of an I/O operation that might block indefinitely.
@@ -227,8 +227,8 @@
      * shown <a href="#be">above</a>, in order to implement interruption for
      * this selector.  </p>
      */
-    protected final void end() {
-        AbstractInterruptibleChannel.blockedOn(null);
-    }
+    protected final void end() {throw new RuntimeException("cf-bug");} //{
+//        AbstractInterruptibleChannel.blockedOn(null);
+//    }
 
 }
--- a/java/nio/channels/spi/AbstractInterruptibleChannel.java	2016-06-27 17:06:33.025074710 -0700
+++ b/java/nio/channels/spi/AbstractInterruptibleChannel.java	2016-06-29 11:06:38.804655926 -0700
@@ -111,14 +111,14 @@
      * @throws  IOException
      *          If an I/O error occurs
      */
-    public final void close() throws IOException {
-        synchronized (closeLock) {
-            if (!open)
-                return;
-            open = false;
-            implCloseChannel();
-        }
-    }
+    public final void close() throws IOException {throw new RuntimeException("cf-bug");} //{
+//        synchronized (closeLock) {
+//            if (!open)
+//                return;
+//            open = false;
+//            implCloseChannel();
+//        }
+//    }
 
     /**
      * Closes this channel.
@@ -138,9 +138,9 @@
      */
     protected abstract void implCloseChannel() throws IOException;
 
-    public final boolean isOpen() {
-        return open;
-    }
+    public final boolean isOpen() {throw new RuntimeException("cf-bug");} //{
+//        return open;
+//    }
 
 
     // -- Interruption machinery --
@@ -156,26 +156,26 @@
      * shown <a href="#be">above</a>, in order to implement asynchronous
      * closing and interruption for this channel.  </p>
      */
-    protected final void begin() {
-        if (interruptor == null) {
-            interruptor = new Interruptible() {
-                    public void interrupt(Thread target) {
-                        synchronized (closeLock) {
-                            if (!open)
-                                return;
-                            open = false;
-                            interrupted = target;
-                            try {
-                                AbstractInterruptibleChannel.this.implCloseChannel();
-                            } catch (IOException x) { }
-                        }
-                    }};
-        }
-        blockedOn(interruptor);
-        Thread me = Thread.currentThread();
-        if (me.isInterrupted())
-            interruptor.interrupt(me);
-    }
+    protected final void begin() {throw new RuntimeException("cf-bug");} //{
+//        if (interruptor == null) {
+//            interruptor = new Interruptible() {
+//                    public void interrupt(Thread target) {
+//                        synchronized (closeLock) {
+//                            if (!open)
+//                                return;
+//                            open = false;
+//                            interrupted = target;
+//                            try {
+//                                AbstractInterruptibleChannel.this.implCloseChannel();
+//                            } catch (IOException x) { }
+//                        }
+//                    }};
+//        }
+//        blockedOn(interruptor);
+//        Thread me = Thread.currentThread();
+//        if (me.isInterrupted())
+//            interruptor.interrupt(me);
+//    }
 
     /**
      * Marks the end of an I/O operation that might block indefinitely.
@@ -198,21 +198,21 @@
      */
     protected final void end(boolean completed)
         throws AsynchronousCloseException
-    {
-        blockedOn(null);
-        Thread interrupted = this.interrupted;
-        if (interrupted != null && interrupted == Thread.currentThread()) {
-            interrupted = null;
-            throw new ClosedByInterruptException();
-        }
-        if (!completed && !open)
-            throw new AsynchronousCloseException();
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        blockedOn(null);
+//        Thread interrupted = this.interrupted;
+//        if (interrupted != null && interrupted == Thread.currentThread()) {
+//            interrupted = null;
+//            throw new ClosedByInterruptException();
+//        }
+//        if (!completed && !open)
+//            throw new AsynchronousCloseException();
+//    }
 
 
     // -- sun.misc.SharedSecrets --
-    static void blockedOn(Interruptible intr) {         // package-private
-        sun.misc.SharedSecrets.getJavaLangAccess().blockedOn(Thread.currentThread(),
-                                                             intr);
-    }
+    static void blockedOn(Interruptible intr) {throw new RuntimeException("cf-bug");} //{         // package-private
+//        sun.misc.SharedSecrets.getJavaLangAccess().blockedOn(Thread.currentThread(),
+//                                                             intr);
+//    }
 }
--- a/java/awt/dnd/DragSourceContext.java	2016-06-27 18:24:14.818828768 -0700
+++ b/java/awt/dnd/DragSourceContext.java	2016-06-29 11:11:09.658933865 -0700
@@ -241,7 +241,7 @@
      *   instantiated this <code>DragSourceContext</code>
      */
 
-    public DragSource   getDragSource() { return trigger.getDragSource(); }
+    public DragSource   getDragSource() {throw new RuntimeException("cf-bug");} //{ return trigger.getDragSource(); }
 
     /**
      * Returns the <code>Component</code> associated with this
@@ -250,7 +250,7 @@
      * @return the <code>Component</code> that started the drag
      */
 
-    public Component    getComponent() { return trigger.getComponent(); }
+    public Component    getComponent() {throw new RuntimeException("cf-bug");} //{ return trigger.getComponent(); }
 
     /**
      * Returns the <code>DragGestureEvent</code>
@@ -259,7 +259,7 @@
      * @return the Event that triggered the drag
      */
 
-    public DragGestureEvent getTrigger() { return trigger; }
+    public DragGestureEvent getTrigger() {throw new RuntimeException("cf-bug");} //{ return trigger; }
 
     /**
      * Returns a bitwise mask of <code>DnDConstants</code> that
@@ -268,9 +268,9 @@
      *
      * @return the drop actions supported by the drag source
      */
-    public int  getSourceActions() {
-        return sourceActions;
-    }
+    public int  getSourceActions() {throw new RuntimeException("cf-bug");} //{
+//        return sourceActions;
+//    }
 
     /**
      * Sets the cursor for this drag operation to the specified
@@ -286,10 +286,10 @@
      *
      */
 
-    public synchronized void setCursor(Cursor c) {
-        useCustomCursor = (c != null);
-        setCursorImpl(c);
-    }
+    public synchronized void setCursor(Cursor c) {throw new RuntimeException("cf-bug");} //{
+//        useCustomCursor = (c != null);
+//        setCursorImpl(c);
+//    }
 
     /**
      * Returns the current drag <code>Cursor</code>.
@@ -297,7 +297,7 @@
      * @return the current drag <code>Cursor</code>
      */
 
-    public Cursor getCursor() { return cursor; }
+    public Cursor getCursor() {throw new RuntimeException("cf-bug");} //{ return cursor; }
 
     /**
      * Add a <code>DragSourceListener</code> to this
@@ -313,16 +313,16 @@
      * a <code>DragSourceListener</code> has already been added
      */
 
-    public synchronized void addDragSourceListener(DragSourceListener dsl) throws TooManyListenersException {
-        if (dsl == null) return;
-
-        if (equals(dsl)) throw new IllegalArgumentException("DragSourceContext may not be its own listener");
-
-        if (listener != null)
-            throw new TooManyListenersException();
-        else
-            listener = dsl;
-    }
+    public synchronized void addDragSourceListener(DragSourceListener dsl) throws TooManyListenersException {throw new RuntimeException("cf-bug");} //{
+//        if (dsl == null) return;
+//
+//        if (equals(dsl)) throw new IllegalArgumentException("DragSourceContext may not be its own listener");
+//
+//        if (listener != null)
+//            throw new TooManyListenersException();
+//        else
+//            listener = dsl;
+//    }
 
     /**
      * Removes the specified <code>DragSourceListener</code>
@@ -333,21 +333,21 @@
      *     it is not acceptable as a parameter
      */
 
-    public synchronized void removeDragSourceListener(DragSourceListener dsl) {
-        if (listener != null && listener.equals(dsl)) {
-            listener = null;
-        } else
-            throw new IllegalArgumentException();
-    }
+    public synchronized void removeDragSourceListener(DragSourceListener dsl) {throw new RuntimeException("cf-bug");} //{
+//        if (listener != null && listener.equals(dsl)) {
+//            listener = null;
+//        } else
+//            throw new IllegalArgumentException();
+//    }
 
     /**
      * Notifies the peer that the <code>Transferable</code>'s
      * <code>DataFlavor</code>s have changed.
      */
 
-    public void transferablesFlavorsChanged() {
-        if (peer != null) peer.transferablesFlavorsChanged();
-    }
+    public void transferablesFlavorsChanged() {throw new RuntimeException("cf-bug");} //{
+//        if (peer != null) peer.transferablesFlavorsChanged();
+//    }
 
     /**
      * Calls <code>dragEnter</code> on the
@@ -358,15 +358,15 @@
      *
      * @param dsde the <code>DragSourceDragEvent</code>
      */
-    public void dragEnter(DragSourceDragEvent dsde) {
-        DragSourceListener dsl = listener;
-        if (dsl != null) {
-            dsl.dragEnter(dsde);
-        }
-        getDragSource().processDragEnter(dsde);
-
-        updateCurrentCursor(getSourceActions(), dsde.getTargetActions(), ENTER);
-    }
+    public void dragEnter(DragSourceDragEvent dsde) {throw new RuntimeException("cf-bug");} //{
+//        DragSourceListener dsl = listener;
+//        if (dsl != null) {
+//            dsl.dragEnter(dsde);
+//        }
+//        getDragSource().processDragEnter(dsde);
+//
+//        updateCurrentCursor(getSourceActions(), dsde.getTargetActions(), ENTER);
+//    }
 
     /**
      * Calls <code>dragOver</code> on the
@@ -377,15 +377,15 @@
      *
      * @param dsde the <code>DragSourceDragEvent</code>
      */
-    public void dragOver(DragSourceDragEvent dsde) {
-        DragSourceListener dsl = listener;
-        if (dsl != null) {
-            dsl.dragOver(dsde);
-        }
-        getDragSource().processDragOver(dsde);
-
-        updateCurrentCursor(getSourceActions(), dsde.getTargetActions(), OVER);
-    }
+    public void dragOver(DragSourceDragEvent dsde) {throw new RuntimeException("cf-bug");} //{
+//        DragSourceListener dsl = listener;
+//        if (dsl != null) {
+//            dsl.dragOver(dsde);
+//        }
+//        getDragSource().processDragOver(dsde);
+//
+//        updateCurrentCursor(getSourceActions(), dsde.getTargetActions(), OVER);
+//    }
 
     /**
      * Calls <code>dragExit</code> on the
@@ -396,15 +396,15 @@
      *
      * @param dse the <code>DragSourceEvent</code>
      */
-    public void dragExit(DragSourceEvent dse) {
-        DragSourceListener dsl = listener;
-        if (dsl != null) {
-            dsl.dragExit(dse);
-        }
-        getDragSource().processDragExit(dse);
-
-        updateCurrentCursor(DnDConstants.ACTION_NONE, DnDConstants.ACTION_NONE, DEFAULT);
-    }
+    public void dragExit(DragSourceEvent dse) {throw new RuntimeException("cf-bug");} //{
+//        DragSourceListener dsl = listener;
+//        if (dsl != null) {
+//            dsl.dragExit(dse);
+//        }
+//        getDragSource().processDragExit(dse);
+//
+//        updateCurrentCursor(DnDConstants.ACTION_NONE, DnDConstants.ACTION_NONE, DEFAULT);
+//    }
 
     /**
      * Calls <code>dropActionChanged</code> on the
@@ -415,15 +415,15 @@
      *
      * @param dsde the <code>DragSourceDragEvent</code>
      */
-    public void dropActionChanged(DragSourceDragEvent dsde) {
-        DragSourceListener dsl = listener;
-        if (dsl != null) {
-            dsl.dropActionChanged(dsde);
-        }
-        getDragSource().processDropActionChanged(dsde);
-
-        updateCurrentCursor(getSourceActions(), dsde.getTargetActions(), CHANGED);
-    }
+    public void dropActionChanged(DragSourceDragEvent dsde) {throw new RuntimeException("cf-bug");} //{
+//        DragSourceListener dsl = listener;
+//        if (dsl != null) {
+//            dsl.dropActionChanged(dsde);
+//        }
+//        getDragSource().processDropActionChanged(dsde);
+//
+//        updateCurrentCursor(getSourceActions(), dsde.getTargetActions(), CHANGED);
+//    }
 
     /**
      * Calls <code>dragDropEnd</code> on the
@@ -434,13 +434,13 @@
      *
      * @param dsde the <code>DragSourceDropEvent</code>
      */
-    public void dragDropEnd(DragSourceDropEvent dsde) {
-        DragSourceListener dsl = listener;
-        if (dsl != null) {
-            dsl.dragDropEnd(dsde);
-        }
-        getDragSource().processDragDropEnd(dsde);
-    }
+    public void dragDropEnd(DragSourceDropEvent dsde) {throw new RuntimeException("cf-bug");} //{
+//        DragSourceListener dsl = listener;
+//        if (dsl != null) {
+//            dsl.dragDropEnd(dsde);
+//        }
+//        getDragSource().processDragDropEnd(dsde);
+//    }
 
     /**
      * Calls <code>dragMouseMoved</code> on the
@@ -452,9 +452,9 @@
      * @param dsde the <code>DragSourceDragEvent</code>
      * @since 1.4
      */
-    public void dragMouseMoved(DragSourceDragEvent dsde) {
-        getDragSource().processDragMouseMoved(dsde);
-    }
+    public void dragMouseMoved(DragSourceDragEvent dsde) {throw new RuntimeException("cf-bug");} //{
+//        getDragSource().processDragMouseMoved(dsde);
+//    }
 
     /**
      * Returns the <code>Transferable</code> associated with
@@ -462,7 +462,7 @@
      *
      * @return the <code>Transferable</code>
      */
-    public Transferable getTransferable() { return transferable; }
+    public Transferable getTransferable() {throw new RuntimeException("cf-bug");} //{ return transferable; }
 
     /**
      * If the default drag cursor behavior is active, this method
@@ -477,53 +477,53 @@
      *               <code>CHANGED</code>
      */
 
-    protected synchronized void updateCurrentCursor(int sourceAct, int targetAct, int status) {
-
-        // if the cursor has been previously set then don't do any defaults
-        // processing.
-
-        if (useCustomCursor) {
-            return;
-        }
-
-        // do defaults processing
-
-        Cursor c = null;
-
-        switch (status) {
-            default:
-                targetAct = DnDConstants.ACTION_NONE;
-            case ENTER:
-            case OVER:
-            case CHANGED:
-                int    ra = sourceAct & targetAct;
-
-                if (ra == DnDConstants.ACTION_NONE) { // no drop possible
-                    if ((sourceAct & DnDConstants.ACTION_LINK) == DnDConstants.ACTION_LINK)
-                        c = DragSource.DefaultLinkNoDrop;
-                    else if ((sourceAct & DnDConstants.ACTION_MOVE) == DnDConstants.ACTION_MOVE)
-                        c = DragSource.DefaultMoveNoDrop;
-                    else
-                        c = DragSource.DefaultCopyNoDrop;
-                } else { // drop possible
-                    if ((ra & DnDConstants.ACTION_LINK) == DnDConstants.ACTION_LINK)
-                        c = DragSource.DefaultLinkDrop;
-                    else if ((ra & DnDConstants.ACTION_MOVE) == DnDConstants.ACTION_MOVE)
-                        c = DragSource.DefaultMoveDrop;
-                    else
-                        c = DragSource.DefaultCopyDrop;
-                }
-        }
-
-        setCursorImpl(c);
-    }
-
-    private void setCursorImpl(Cursor c) {
-        if (cursor == null || !cursor.equals(c)) {
-            cursor = c;
-            if (peer != null) peer.setCursor(cursor);
-        }
-    }
+    protected synchronized void updateCurrentCursor(int sourceAct, int targetAct, int status) {throw new RuntimeException("cf-bug");} //{
+//
+//        // if the cursor has been previously set then don't do any defaults
+//        // processing.
+//
+//        if (useCustomCursor) {
+//            return;
+//        }
+//
+//        // do defaults processing
+//
+//        Cursor c = null;
+//
+//        switch (status) {
+//            default:
+//                targetAct = DnDConstants.ACTION_NONE;
+//            case ENTER:
+//            case OVER:
+//            case CHANGED:
+//                int    ra = sourceAct & targetAct;
+//
+//                if (ra == DnDConstants.ACTION_NONE) { // no drop possible
+//                    if ((sourceAct & DnDConstants.ACTION_LINK) == DnDConstants.ACTION_LINK)
+//                        c = DragSource.DefaultLinkNoDrop;
+//                    else if ((sourceAct & DnDConstants.ACTION_MOVE) == DnDConstants.ACTION_MOVE)
+//                        c = DragSource.DefaultMoveNoDrop;
+//                    else
+//                        c = DragSource.DefaultCopyNoDrop;
+//                } else { // drop possible
+//                    if ((ra & DnDConstants.ACTION_LINK) == DnDConstants.ACTION_LINK)
+//                        c = DragSource.DefaultLinkDrop;
+//                    else if ((ra & DnDConstants.ACTION_MOVE) == DnDConstants.ACTION_MOVE)
+//                        c = DragSource.DefaultMoveDrop;
+//                    else
+//                        c = DragSource.DefaultCopyDrop;
+//                }
+//        }
+//
+//        setCursorImpl(c);
+//    }
+
+    private void setCursorImpl(Cursor c) {throw new RuntimeException("cf-bug");} //{
+//        if (cursor == null || !cursor.equals(c)) {
+//            cursor = c;
+//            if (peer != null) peer.setCursor(cursor);
+//        }
+//    }
 
     /**
      * Serializes this <code>DragSourceContext</code>. This method first
@@ -543,14 +543,14 @@
      *             <code>null</code>.
      * @since 1.4
      */
-    private void writeObject(ObjectOutputStream s) throws IOException {
-        s.defaultWriteObject();
-
-        s.writeObject(SerializationTester.test(transferable)
-                      ? transferable : null);
-        s.writeObject(SerializationTester.test(listener)
-                      ? listener : null);
-    }
+    private void writeObject(ObjectOutputStream s) throws IOException {throw new RuntimeException("cf-bug");} //{
+//        s.defaultWriteObject();
+//
+//        s.writeObject(SerializationTester.test(transferable)
+//                      ? transferable : null);
+//        s.writeObject(SerializationTester.test(listener)
+//                      ? listener : null);
+//    }
 
     /**
      * Deserializes this <code>DragSourceContext</code>. This method first
@@ -566,61 +566,61 @@
      */
     private void readObject(ObjectInputStream s)
         throws ClassNotFoundException, IOException
-    {
-        ObjectInputStream.GetField f = s.readFields();
-
-        DragGestureEvent newTrigger = (DragGestureEvent)f.get("trigger", null);
-        if (newTrigger == null) {
-            throw new InvalidObjectException("Null trigger");
-        }
-        if (newTrigger.getDragSource() == null) {
-            throw new InvalidObjectException("Null DragSource");
-        }
-        if (newTrigger.getComponent() == null) {
-            throw new InvalidObjectException("Null trigger component");
-        }
-
-        int newSourceActions = f.get("sourceActions", 0)
-                & (DnDConstants.ACTION_COPY_OR_MOVE | DnDConstants.ACTION_LINK);
-        if (newSourceActions == DnDConstants.ACTION_NONE) {
-            throw new InvalidObjectException("Invalid source actions");
-        }
-        int triggerActions = newTrigger.getDragAction();
-        if (triggerActions != DnDConstants.ACTION_COPY &&
-                triggerActions != DnDConstants.ACTION_MOVE &&
-                triggerActions != DnDConstants.ACTION_LINK) {
-            throw new InvalidObjectException("No drag action");
-        }
-        trigger = newTrigger;
-
-        cursor = (Cursor)f.get("cursor", null);
-        useCustomCursor = f.get("useCustomCursor", false);
-        sourceActions = newSourceActions;
-
-        transferable = (Transferable)s.readObject();
-        listener = (DragSourceListener)s.readObject();
-
-        // Implementation assumes 'transferable' is never null.
-        if (transferable == null) {
-            if (emptyTransferable == null) {
-                emptyTransferable = new Transferable() {
-                        public DataFlavor[] getTransferDataFlavors() {
-                            return new DataFlavor[0];
-                        }
-                        public boolean isDataFlavorSupported(DataFlavor flavor)
-                        {
-                            return false;
-                        }
-                        public Object getTransferData(DataFlavor flavor)
-                            throws UnsupportedFlavorException
-                        {
-                            throw new UnsupportedFlavorException(flavor);
-                        }
-                    };
-            }
-            transferable = emptyTransferable;
-        }
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        ObjectInputStream.GetField f = s.readFields();
+//
+//        DragGestureEvent newTrigger = (DragGestureEvent)f.get("trigger", null);
+//        if (newTrigger == null) {
+//            throw new InvalidObjectException("Null trigger");
+//        }
+//        if (newTrigger.getDragSource() == null) {
+//            throw new InvalidObjectException("Null DragSource");
+//        }
+//        if (newTrigger.getComponent() == null) {
+//            throw new InvalidObjectException("Null trigger component");
+//        }
+//
+//        int newSourceActions = f.get("sourceActions", 0)
+//                & (DnDConstants.ACTION_COPY_OR_MOVE | DnDConstants.ACTION_LINK);
+//        if (newSourceActions == DnDConstants.ACTION_NONE) {
+//            throw new InvalidObjectException("Invalid source actions");
+//        }
+//        int triggerActions = newTrigger.getDragAction();
+//        if (triggerActions != DnDConstants.ACTION_COPY &&
+//                triggerActions != DnDConstants.ACTION_MOVE &&
+//                triggerActions != DnDConstants.ACTION_LINK) {
+//            throw new InvalidObjectException("No drag action");
+//        }
+//        trigger = newTrigger;
+//
+//        cursor = (Cursor)f.get("cursor", null);
+//        useCustomCursor = f.get("useCustomCursor", false);
+//        sourceActions = newSourceActions;
+//
+//        transferable = (Transferable)s.readObject();
+//        listener = (DragSourceListener)s.readObject();
+//
+//        // Implementation assumes 'transferable' is never null.
+//        if (transferable == null) {
+//            if (emptyTransferable == null) {
+//                emptyTransferable = new Transferable() {
+//                        public DataFlavor[] getTransferDataFlavors() {
+//                            return new DataFlavor[0];
+//                        }
+//                        public boolean isDataFlavorSupported(DataFlavor flavor)
+//                        {
+//                            return false;
+//                        }
+//                        public Object getTransferData(DataFlavor flavor)
+//                            throws UnsupportedFlavorException
+//                        {
+//                            throw new UnsupportedFlavorException(flavor);
+//                        }
+//                    };
+//            }
+//            transferable = emptyTransferable;
+//        }
+//    }
 
     private static Transferable emptyTransferable;
 
--- a/java/awt/MultipleGradientPaintContext.java	2016-06-27 18:46:48.552553499 -0700
+++ b/java/awt/MultipleGradientPaintContext.java	2016-06-29 11:08:53.128289063 -0700
@@ -161,160 +161,160 @@
                                            Color[] colors,
                                            CycleMethod cycleMethod,
                                            ColorSpaceType colorSpace)
-    {
-        if (deviceBounds == null) {
-            throw new NullPointerException("Device bounds cannot be null");
-        }
-
-        if (userBounds == null) {
-            throw new NullPointerException("User bounds cannot be null");
-        }
-
-        if (t == null) {
-            throw new NullPointerException("Transform cannot be null");
-        }
-
-        if (hints == null) {
-            throw new NullPointerException("RenderingHints cannot be null");
-        }
-
-        // The inverse transform is needed to go from device to user space.
-        // Get all the components of the inverse transform matrix.
-        AffineTransform tInv;
-        try {
-            // the following assumes that the caller has copied the incoming
-            // transform and is not concerned about it being modified
-            t.invert();
-            tInv = t;
-        } catch (NoninvertibleTransformException e) {
-            // just use identity transform in this case; better to show
-            // (incorrect) results than to throw an exception and/or no-op
-            tInv = new AffineTransform();
-        }
-        double m[] = new double[6];
-        tInv.getMatrix(m);
-        a00 = (float)m[0];
-        a10 = (float)m[1];
-        a01 = (float)m[2];
-        a11 = (float)m[3];
-        a02 = (float)m[4];
-        a12 = (float)m[5];
-
-        // copy some flags
-        this.cycleMethod = cycleMethod;
-        this.colorSpace = colorSpace;
-
-        // we can avoid copying this array since we do not modify its values
-        this.fractions = fractions;
-
-        // note that only one of these values can ever be non-null (we either
-        // store the fast gradient array or the slow one, but never both
-        // at the same time)
-        int[] gradient =
-            (mgp.gradient != null) ? mgp.gradient.get() : null;
-        int[][] gradients =
-            (mgp.gradients != null) ? mgp.gradients.get() : null;
-
-        if (gradient == null && gradients == null) {
-            // we need to (re)create the appropriate values
-            calculateLookupData(colors);
-
-            // now cache the calculated values in the
-            // MultipleGradientPaint instance for future use
-            mgp.model               = this.model;
-            mgp.normalizedIntervals = this.normalizedIntervals;
-            mgp.isSimpleLookup      = this.isSimpleLookup;
-            if (isSimpleLookup) {
-                // only cache the fast array
-                mgp.fastGradientArraySize = this.fastGradientArraySize;
-                mgp.gradient = new SoftReference<int[]>(this.gradient);
-            } else {
-                // only cache the slow array
-                mgp.gradients = new SoftReference<int[][]>(this.gradients);
-            }
-        } else {
-            // use the values cached in the MultipleGradientPaint instance
-            this.model                 = mgp.model;
-            this.normalizedIntervals   = mgp.normalizedIntervals;
-            this.isSimpleLookup        = mgp.isSimpleLookup;
-            this.gradient              = gradient;
-            this.fastGradientArraySize = mgp.fastGradientArraySize;
-            this.gradients             = gradients;
-        }
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        if (deviceBounds == null) {
+//            throw new NullPointerException("Device bounds cannot be null");
+//        }
+//
+//        if (userBounds == null) {
+//            throw new NullPointerException("User bounds cannot be null");
+//        }
+//
+//        if (t == null) {
+//            throw new NullPointerException("Transform cannot be null");
+//        }
+//
+//        if (hints == null) {
+//            throw new NullPointerException("RenderingHints cannot be null");
+//        }
+//
+//        // The inverse transform is needed to go from device to user space.
+//        // Get all the components of the inverse transform matrix.
+//        AffineTransform tInv;
+//        try {
+//            // the following assumes that the caller has copied the incoming
+//            // transform and is not concerned about it being modified
+//            t.invert();
+//            tInv = t;
+//        } catch (NoninvertibleTransformException e) {
+//            // just use identity transform in this case; better to show
+//            // (incorrect) results than to throw an exception and/or no-op
+//            tInv = new AffineTransform();
+//        }
+//        double m[] = new double[6];
+//        tInv.getMatrix(m);
+//        a00 = (float)m[0];
+//        a10 = (float)m[1];
+//        a01 = (float)m[2];
+//        a11 = (float)m[3];
+//        a02 = (float)m[4];
+//        a12 = (float)m[5];
+//
+//        // copy some flags
+//        this.cycleMethod = cycleMethod;
+//        this.colorSpace = colorSpace;
+//
+//        // we can avoid copying this array since we do not modify its values
+//        this.fractions = fractions;
+//
+//        // note that only one of these values can ever be non-null (we either
+//        // store the fast gradient array or the slow one, but never both
+//        // at the same time)
+//        int[] gradient =
+//            (mgp.gradient != null) ? mgp.gradient.get() : null;
+//        int[][] gradients =
+//            (mgp.gradients != null) ? mgp.gradients.get() : null;
+//
+//        if (gradient == null && gradients == null) {
+//            // we need to (re)create the appropriate values
+//            calculateLookupData(colors);
+//
+//            // now cache the calculated values in the
+//            // MultipleGradientPaint instance for future use
+//            mgp.model               = this.model;
+//            mgp.normalizedIntervals = this.normalizedIntervals;
+//            mgp.isSimpleLookup      = this.isSimpleLookup;
+//            if (isSimpleLookup) {
+//                // only cache the fast array
+//                mgp.fastGradientArraySize = this.fastGradientArraySize;
+//                mgp.gradient = new SoftReference<int[]>(this.gradient);
+//            } else {
+//                // only cache the slow array
+//                mgp.gradients = new SoftReference<int[][]>(this.gradients);
+//            }
+//        } else {
+//            // use the values cached in the MultipleGradientPaint instance
+//            this.model                 = mgp.model;
+//            this.normalizedIntervals   = mgp.normalizedIntervals;
+//            this.isSimpleLookup        = mgp.isSimpleLookup;
+//            this.gradient              = gradient;
+//            this.fastGradientArraySize = mgp.fastGradientArraySize;
+//            this.gradients             = gradients;
+//        }
+//    }
 
     /**
      * This function is the meat of this class.  It calculates an array of
      * gradient colors based on an array of fractions and color values at
      * those fractions.
      */
-    private void calculateLookupData(Color[] colors) {
-        Color[] normalizedColors;
-        if (colorSpace == ColorSpaceType.LINEAR_RGB) {
-            // create a new colors array
-            normalizedColors = new Color[colors.length];
-            // convert the colors using the lookup table
-            for (int i = 0; i < colors.length; i++) {
-                int argb = colors[i].getRGB();
-                int a = argb >>> 24;
-                int r = SRGBtoLinearRGB[(argb >> 16) & 0xff];
-                int g = SRGBtoLinearRGB[(argb >>  8) & 0xff];
-                int b = SRGBtoLinearRGB[(argb      ) & 0xff];
-                normalizedColors[i] = new Color(r, g, b, a);
-            }
-        } else {
-            // we can just use this array by reference since we do not
-            // modify its values in the case of SRGB
-            normalizedColors = colors;
-        }
-
-        // this will store the intervals (distances) between gradient stops
-        normalizedIntervals = new float[fractions.length-1];
-
-        // convert from fractions into intervals
-        for (int i = 0; i < normalizedIntervals.length; i++) {
-            // interval distance is equal to the difference in positions
-            normalizedIntervals[i] = this.fractions[i+1] - this.fractions[i];
-        }
-
-        // initialize to be fully opaque for ANDing with colors
-        transparencyTest = 0xff000000;
-
-        // array of interpolation arrays
-        gradients = new int[normalizedIntervals.length][];
-
-        // find smallest interval
-        float Imin = 1;
-        for (int i = 0; i < normalizedIntervals.length; i++) {
-            Imin = (Imin > normalizedIntervals[i]) ?
-                normalizedIntervals[i] : Imin;
-        }
-
-        // Estimate the size of the entire gradients array.
-        // This is to prevent a tiny interval from causing the size of array
-        // to explode.  If the estimated size is too large, break to using
-        // separate arrays for each interval, and using an indexing scheme at
-        // look-up time.
-        int estimatedSize = 0;
-        for (int i = 0; i < normalizedIntervals.length; i++) {
-            estimatedSize += (normalizedIntervals[i]/Imin) * GRADIENT_SIZE;
-        }
-
-        if (estimatedSize > MAX_GRADIENT_ARRAY_SIZE) {
-            // slow method
-            calculateMultipleArrayGradient(normalizedColors);
-        } else {
-            // fast method
-            calculateSingleArrayGradient(normalizedColors, Imin);
-        }
-
-        // use the most "economical" model
-        if ((transparencyTest >>> 24) == 0xff) {
-            model = xrgbmodel;
-        } else {
-            model = ColorModel.getRGBdefault();
-        }
-    }
+    private void calculateLookupData(Color[] colors) {throw new RuntimeException("cf-bug");} //{
+//        Color[] normalizedColors;
+//        if (colorSpace == ColorSpaceType.LINEAR_RGB) {
+//            // create a new colors array
+//            normalizedColors = new Color[colors.length];
+//            // convert the colors using the lookup table
+//            for (int i = 0; i < colors.length; i++) {
+//                int argb = colors[i].getRGB();
+//                int a = argb >>> 24;
+//                int r = SRGBtoLinearRGB[(argb >> 16) & 0xff];
+//                int g = SRGBtoLinearRGB[(argb >>  8) & 0xff];
+//                int b = SRGBtoLinearRGB[(argb      ) & 0xff];
+//                normalizedColors[i] = new Color(r, g, b, a);
+//            }
+//        } else {
+//            // we can just use this array by reference since we do not
+//            // modify its values in the case of SRGB
+//            normalizedColors = colors;
+//        }
+//
+//        // this will store the intervals (distances) between gradient stops
+//        normalizedIntervals = new float[fractions.length-1];
+//
+//        // convert from fractions into intervals
+//        for (int i = 0; i < normalizedIntervals.length; i++) {
+//            // interval distance is equal to the difference in positions
+//            normalizedIntervals[i] = this.fractions[i+1] - this.fractions[i];
+//        }
+//
+//        // initialize to be fully opaque for ANDing with colors
+//        transparencyTest = 0xff000000;
+//
+//        // array of interpolation arrays
+//        gradients = new int[normalizedIntervals.length][];
+//
+//        // find smallest interval
+//        float Imin = 1;
+//        for (int i = 0; i < normalizedIntervals.length; i++) {
+//            Imin = (Imin > normalizedIntervals[i]) ?
+//                normalizedIntervals[i] : Imin;
+//        }
+//
+//        // Estimate the size of the entire gradients array.
+//        // This is to prevent a tiny interval from causing the size of array
+//        // to explode.  If the estimated size is too large, break to using
+//        // separate arrays for each interval, and using an indexing scheme at
+//        // look-up time.
+//        int estimatedSize = 0;
+//        for (int i = 0; i < normalizedIntervals.length; i++) {
+//            estimatedSize += (normalizedIntervals[i]/Imin) * GRADIENT_SIZE;
+//        }
+//
+//        if (estimatedSize > MAX_GRADIENT_ARRAY_SIZE) {
+//            // slow method
+//            calculateMultipleArrayGradient(normalizedColors);
+//        } else {
+//            // fast method
+//            calculateSingleArrayGradient(normalizedColors, Imin);
+//        }
+//
+//        // use the most "economical" model
+//        if ((transparencyTest >>> 24) == 0xff) {
+//            model = xrgbmodel;
+//        } else {
+//            model = ColorModel.getRGBdefault();
+//        }
+//    }
 
     /**
      * FAST LOOKUP METHOD
@@ -339,57 +339,57 @@
      *
      * @param Imin the size of the smallest interval
      */
-    private void calculateSingleArrayGradient(Color[] colors, float Imin) {
-        // set the flag so we know later it is a simple (fast) lookup
-        isSimpleLookup = true;
-
-        // 2 colors to interpolate
-        int rgb1, rgb2;
-
-        //the eventual size of the single array
-        int gradientsTot = 1;
-
-        // for every interval (transition between 2 colors)
-        for (int i = 0; i < gradients.length; i++) {
-            // create an array whose size is based on the ratio to the
-            // smallest interval
-            int nGradients = (int)((normalizedIntervals[i]/Imin)*255f);
-            gradientsTot += nGradients;
-            gradients[i] = new int[nGradients];
-
-            // the 2 colors (keyframes) to interpolate between
-            rgb1 = colors[i].getRGB();
-            rgb2 = colors[i+1].getRGB();
-
-            // fill this array with the colors in between rgb1 and rgb2
-            interpolate(rgb1, rgb2, gradients[i]);
-
-            // if the colors are opaque, transparency should still
-            // be 0xff000000
-            transparencyTest &= rgb1;
-            transparencyTest &= rgb2;
-        }
-
-        // put all gradients in a single array
-        gradient = new int[gradientsTot];
-        int curOffset = 0;
-        for (int i = 0; i < gradients.length; i++){
-            System.arraycopy(gradients[i], 0, gradient,
-                             curOffset, gradients[i].length);
-            curOffset += gradients[i].length;
-        }
-        gradient[gradient.length-1] = colors[colors.length-1].getRGB();
-
-        // if interpolation occurred in Linear RGB space, convert the
-        // gradients back to sRGB using the lookup table
-        if (colorSpace == ColorSpaceType.LINEAR_RGB) {
-            for (int i = 0; i < gradient.length; i++) {
-                gradient[i] = convertEntireColorLinearRGBtoSRGB(gradient[i]);
-            }
-        }
-
-        fastGradientArraySize = gradient.length - 1;
-    }
+    private void calculateSingleArrayGradient(Color[] colors, float Imin) {throw new RuntimeException("cf-bug");} //{
+//        // set the flag so we know later it is a simple (fast) lookup
+//        isSimpleLookup = true;
+//
+//        // 2 colors to interpolate
+//        int rgb1, rgb2;
+//
+//        //the eventual size of the single array
+//        int gradientsTot = 1;
+//
+//        // for every interval (transition between 2 colors)
+//        for (int i = 0; i < gradients.length; i++) {
+//            // create an array whose size is based on the ratio to the
+//            // smallest interval
+//            int nGradients = (int)((normalizedIntervals[i]/Imin)*255f);
+//            gradientsTot += nGradients;
+//            gradients[i] = new int[nGradients];
+//
+//            // the 2 colors (keyframes) to interpolate between
+//            rgb1 = colors[i].getRGB();
+//            rgb2 = colors[i+1].getRGB();
+//
+//            // fill this array with the colors in between rgb1 and rgb2
+//            interpolate(rgb1, rgb2, gradients[i]);
+//
+//            // if the colors are opaque, transparency should still
+//            // be 0xff000000
+//            transparencyTest &= rgb1;
+//            transparencyTest &= rgb2;
+//        }
+//
+//        // put all gradients in a single array
+//        gradient = new int[gradientsTot];
+//        int curOffset = 0;
+//        for (int i = 0; i < gradients.length; i++){
+//            System.arraycopy(gradients[i], 0, gradient,
+//                             curOffset, gradients[i].length);
+//            curOffset += gradients[i].length;
+//        }
+//        gradient[gradient.length-1] = colors[colors.length-1].getRGB();
+//
+//        // if interpolation occurred in Linear RGB space, convert the
+//        // gradients back to sRGB using the lookup table
+//        if (colorSpace == ColorSpaceType.LINEAR_RGB) {
+//            for (int i = 0; i < gradient.length; i++) {
+//                gradient[i] = convertEntireColorLinearRGBtoSRGB(gradient[i]);
+//            }
+//        }
+//
+//        fastGradientArraySize = gradient.length - 1;
+//    }
 
     /**
      * SLOW LOOKUP METHOD
@@ -409,43 +409,43 @@
      * For those of you who are interested, this is a classic example of the
      * time-space tradeoff.
      */
-    private void calculateMultipleArrayGradient(Color[] colors) {
-        // set the flag so we know later it is a non-simple lookup
-        isSimpleLookup = false;
-
-        // 2 colors to interpolate
-        int rgb1, rgb2;
-
-        // for every interval (transition between 2 colors)
-        for (int i = 0; i < gradients.length; i++){
-            // create an array of the maximum theoretical size for
-            // each interval
-            gradients[i] = new int[GRADIENT_SIZE];
-
-            // get the the 2 colors
-            rgb1 = colors[i].getRGB();
-            rgb2 = colors[i+1].getRGB();
-
-            // fill this array with the colors in between rgb1 and rgb2
-            interpolate(rgb1, rgb2, gradients[i]);
-
-            // if the colors are opaque, transparency should still
-            // be 0xff000000
-            transparencyTest &= rgb1;
-            transparencyTest &= rgb2;
-        }
-
-        // if interpolation occurred in Linear RGB space, convert the
-        // gradients back to SRGB using the lookup table
-        if (colorSpace == ColorSpaceType.LINEAR_RGB) {
-            for (int j = 0; j < gradients.length; j++) {
-                for (int i = 0; i < gradients[j].length; i++) {
-                    gradients[j][i] =
-                        convertEntireColorLinearRGBtoSRGB(gradients[j][i]);
-                }
-            }
-        }
-    }
+    private void calculateMultipleArrayGradient(Color[] colors) {throw new RuntimeException("cf-bug");} //{
+//        // set the flag so we know later it is a non-simple lookup
+//        isSimpleLookup = false;
+//
+//        // 2 colors to interpolate
+//        int rgb1, rgb2;
+//
+//        // for every interval (transition between 2 colors)
+//        for (int i = 0; i < gradients.length; i++){
+//            // create an array of the maximum theoretical size for
+//            // each interval
+//            gradients[i] = new int[GRADIENT_SIZE];
+//
+//            // get the the 2 colors
+//            rgb1 = colors[i].getRGB();
+//            rgb2 = colors[i+1].getRGB();
+//
+//            // fill this array with the colors in between rgb1 and rgb2
+//            interpolate(rgb1, rgb2, gradients[i]);
+//
+//            // if the colors are opaque, transparency should still
+//            // be 0xff000000
+//            transparencyTest &= rgb1;
+//            transparencyTest &= rgb2;
+//        }
+//
+//        // if interpolation occurred in Linear RGB space, convert the
+//        // gradients back to SRGB using the lookup table
+//        if (colorSpace == ColorSpaceType.LINEAR_RGB) {
+//            for (int j = 0; j < gradients.length; j++) {
+//                for (int i = 0; i < gradients[j].length; i++) {
+//                    gradients[j][i] =
+//                        convertEntireColorLinearRGBtoSRGB(gradients[j][i]);
+//                }
+//            }
+//        }
+//    }
 
     /**
      * Yet another helper function.  This one linearly interpolates between
@@ -455,63 +455,63 @@
      * @param rgb2 the end color
      * @param output the output array of colors; must not be null
      */
-    private void interpolate(int rgb1, int rgb2, int[] output) {
-        // color components
-        int a1, r1, g1, b1, da, dr, dg, db;
-
-        // step between interpolated values
-        float stepSize = 1.0f / output.length;
-
-        // extract color components from packed integer
-        a1 = (rgb1 >> 24) & 0xff;
-        r1 = (rgb1 >> 16) & 0xff;
-        g1 = (rgb1 >>  8) & 0xff;
-        b1 = (rgb1      ) & 0xff;
-
-        // calculate the total change in alpha, red, green, blue
-        da = ((rgb2 >> 24) & 0xff) - a1;
-        dr = ((rgb2 >> 16) & 0xff) - r1;
-        dg = ((rgb2 >>  8) & 0xff) - g1;
-        db = ((rgb2      ) & 0xff) - b1;
-
-        // for each step in the interval calculate the in-between color by
-        // multiplying the normalized current position by the total color
-        // change (0.5 is added to prevent truncation round-off error)
-        for (int i = 0; i < output.length; i++) {
-            output[i] =
-                (((int) ((a1 + i * da * stepSize) + 0.5) << 24)) |
-                (((int) ((r1 + i * dr * stepSize) + 0.5) << 16)) |
-                (((int) ((g1 + i * dg * stepSize) + 0.5) <<  8)) |
-                (((int) ((b1 + i * db * stepSize) + 0.5)      ));
-        }
-    }
+    private void interpolate(int rgb1, int rgb2, int[] output) {throw new RuntimeException("cf-bug");} //{
+//        // color components
+//        int a1, r1, g1, b1, da, dr, dg, db;
+//
+//        // step between interpolated values
+//        float stepSize = 1.0f / output.length;
+//
+//        // extract color components from packed integer
+//        a1 = (rgb1 >> 24) & 0xff;
+//        r1 = (rgb1 >> 16) & 0xff;
+//        g1 = (rgb1 >>  8) & 0xff;
+//        b1 = (rgb1      ) & 0xff;
+//
+//        // calculate the total change in alpha, red, green, blue
+//        da = ((rgb2 >> 24) & 0xff) - a1;
+//        dr = ((rgb2 >> 16) & 0xff) - r1;
+//        dg = ((rgb2 >>  8) & 0xff) - g1;
+//        db = ((rgb2      ) & 0xff) - b1;
+//
+//        // for each step in the interval calculate the in-between color by
+//        // multiplying the normalized current position by the total color
+//        // change (0.5 is added to prevent truncation round-off error)
+//        for (int i = 0; i < output.length; i++) {
+//            output[i] =
+//                (((int) ((a1 + i * da * stepSize) + 0.5) << 24)) |
+//                (((int) ((r1 + i * dr * stepSize) + 0.5) << 16)) |
+//                (((int) ((g1 + i * dg * stepSize) + 0.5) <<  8)) |
+//                (((int) ((b1 + i * db * stepSize) + 0.5)      ));
+//        }
+//    }
 
     /**
      * Yet another helper function.  This one extracts the color components
      * of an integer RGB triple, converts them from LinearRGB to SRGB, then
      * recompacts them into an int.
      */
-    private int convertEntireColorLinearRGBtoSRGB(int rgb) {
-        // color components
-        int a1, r1, g1, b1;
-
-        // extract red, green, blue components
-        a1 = (rgb >> 24) & 0xff;
-        r1 = (rgb >> 16) & 0xff;
-        g1 = (rgb >>  8) & 0xff;
-        b1 = (rgb      ) & 0xff;
-
-        // use the lookup table
-        r1 = LinearRGBtoSRGB[r1];
-        g1 = LinearRGBtoSRGB[g1];
-        b1 = LinearRGBtoSRGB[b1];
-
-        // re-compact the components
-        return ((a1 << 24) |
-                (r1 << 16) |
-                (g1 <<  8) |
-                (b1      ));
-    }
+    private int convertEntireColorLinearRGBtoSRGB(int rgb) {throw new RuntimeException("cf-bug");} //{
+//        // color components
+//        int a1, r1, g1, b1;
+//
+//        // extract red, green, blue components
+//        a1 = (rgb >> 24) & 0xff;
+//        r1 = (rgb >> 16) & 0xff;
+//        g1 = (rgb >>  8) & 0xff;
+//        b1 = (rgb      ) & 0xff;
+//
+//        // use the lookup table
+//        r1 = LinearRGBtoSRGB[r1];
+//        g1 = LinearRGBtoSRGB[g1];
+//        b1 = LinearRGBtoSRGB[b1];
+//
+//        // re-compact the components
+//        return ((a1 << 24) |
+//                (r1 << 16) |
+//                (g1 <<  8) |
+//                (b1      ));
+//    }
 
     /**
      * Helper function to index into the gradients array.  This is necessary
@@ -523,137 +523,137 @@
      *                 into the range 0 to 1
      * @returns integer color to display
      */
-    protected final int indexIntoGradientsArrays(float position) {
-        // first, manipulate position value depending on the cycle method
-        if (cycleMethod == CycleMethod.NO_CYCLE) {
-            if (position > 1) {
-                // upper bound is 1
-                position = 1;
-            } else if (position < 0) {
-                // lower bound is 0
-                position = 0;
-            }
-        } else if (cycleMethod == CycleMethod.REPEAT) {
-            // get the fractional part
-            // (modulo behavior discards integer component)
-            position = position - (int)position;
-
-            //position should now be between -1 and 1
-            if (position < 0) {
-                // force it to be in the range 0-1
-                position = position + 1;
-            }
-        } else { // cycleMethod == CycleMethod.REFLECT
-            if (position < 0) {
-                // take absolute value
-                position = -position;
-            }
-
-            // get the integer part
-            int part = (int)position;
-
-            // get the fractional part
-            position = position - part;
-
-            if ((part & 1) == 1) {
-                // integer part is odd, get reflected color instead
-                position = 1 - position;
-            }
-        }
-
-        // now, get the color based on this 0-1 position...
-
-        if (isSimpleLookup) {
-            // easy to compute: just scale index by array size
-            return gradient[(int)(position * fastGradientArraySize)];
-        } else {
-            // more complicated computation, to save space
-
-            // for all the gradient interval arrays
-            for (int i = 0; i < gradients.length; i++) {
-                if (position < fractions[i+1]) {
-                    // this is the array we want
-                    float delta = position - fractions[i];
-
-                    // this is the interval we want
-                    int index = (int)((delta / normalizedIntervals[i])
-                                      * (GRADIENT_SIZE_INDEX));
-
-                    return gradients[i][index];
-                }
-            }
-        }
-
-        return gradients[gradients.length - 1][GRADIENT_SIZE_INDEX];
-    }
+    protected final int indexIntoGradientsArrays(float position) {throw new RuntimeException("cf-bug");} //{
+//        // first, manipulate position value depending on the cycle method
+//        if (cycleMethod == CycleMethod.NO_CYCLE) {
+//            if (position > 1) {
+//                // upper bound is 1
+//                position = 1;
+//            } else if (position < 0) {
+//                // lower bound is 0
+//                position = 0;
+//            }
+//        } else if (cycleMethod == CycleMethod.REPEAT) {
+//            // get the fractional part
+//            // (modulo behavior discards integer component)
+//            position = position - (int)position;
+//
+//            //position should now be between -1 and 1
+//            if (position < 0) {
+//                // force it to be in the range 0-1
+//                position = position + 1;
+//            }
+//        } else { // cycleMethod == CycleMethod.REFLECT
+//            if (position < 0) {
+//                // take absolute value
+//                position = -position;
+//            }
+//
+//            // get the integer part
+//            int part = (int)position;
+//
+//            // get the fractional part
+//            position = position - part;
+//
+//            if ((part & 1) == 1) {
+//                // integer part is odd, get reflected color instead
+//                position = 1 - position;
+//            }
+//        }
+//
+//        // now, get the color based on this 0-1 position...
+//
+//        if (isSimpleLookup) {
+//            // easy to compute: just scale index by array size
+//            return gradient[(int)(position * fastGradientArraySize)];
+//        } else {
+//            // more complicated computation, to save space
+//
+//            // for all the gradient interval arrays
+//            for (int i = 0; i < gradients.length; i++) {
+//                if (position < fractions[i+1]) {
+//                    // this is the array we want
+//                    float delta = position - fractions[i];
+//
+//                    // this is the interval we want
+//                    int index = (int)((delta / normalizedIntervals[i])
+//                                      * (GRADIENT_SIZE_INDEX));
+//
+//                    return gradients[i][index];
+//                }
+//            }
+//        }
+//
+//        return gradients[gradients.length - 1][GRADIENT_SIZE_INDEX];
+//    }
 
     /**
      * Helper function to convert a color component in sRGB space to linear
      * RGB space.  Used to build a static lookup table.
      */
-    private static int convertSRGBtoLinearRGB(int color) {
-        float input, output;
-
-        input = color / 255.0f;
-        if (input <= 0.04045f) {
-            output = input / 12.92f;
-        } else {
-            output = (float)Math.pow((input + 0.055) / 1.055, 2.4);
-        }
-
-        return Math.round(output * 255.0f);
-    }
+    private static int convertSRGBtoLinearRGB(int color) {throw new RuntimeException("cf-bug");} //{
+//        float input, output;
+//
+//        input = color / 255.0f;
+//        if (input <= 0.04045f) {
+//            output = input / 12.92f;
+//        } else {
+//            output = (float)Math.pow((input + 0.055) / 1.055, 2.4);
+//        }
+//
+//        return Math.round(output * 255.0f);
+//    }
 
     /**
      * Helper function to convert a color component in linear RGB space to
      * SRGB space.  Used to build a static lookup table.
      */
-    private static int convertLinearRGBtoSRGB(int color) {
-        float input, output;
-
-        input = color/255.0f;
-        if (input <= 0.0031308) {
-            output = input * 12.92f;
-        } else {
-            output = (1.055f *
-                ((float) Math.pow(input, (1.0 / 2.4)))) - 0.055f;
-        }
-
-        return Math.round(output * 255.0f);
-    }
+    private static int convertLinearRGBtoSRGB(int color) {throw new RuntimeException("cf-bug");} //{
+//        float input, output;
+//
+//        input = color/255.0f;
+//        if (input <= 0.0031308) {
+//            output = input * 12.92f;
+//        } else {
+//            output = (1.055f *
+//                ((float) Math.pow(input, (1.0 / 2.4)))) - 0.055f;
+//        }
+//
+//        return Math.round(output * 255.0f);
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public final Raster getRaster(int x, int y, int w, int h) {
-        // If working raster is big enough, reuse it. Otherwise,
-        // build a large enough new one.
-        Raster raster = saved;
-        if (raster == null ||
-            raster.getWidth() < w || raster.getHeight() < h)
-        {
-            raster = getCachedRaster(model, w, h);
-            saved = raster;
-        }
-
-        // Access raster internal int array. Because we use a DirectColorModel,
-        // we know the DataBuffer is of type DataBufferInt and the SampleModel
-        // is SinglePixelPackedSampleModel.
-        // Adjust for initial offset in DataBuffer and also for the scanline
-        // stride.
-        // These calls make the DataBuffer non-acceleratable, but the
-        // Raster is never Stable long enough to accelerate anyway...
-        DataBufferInt rasterDB = (DataBufferInt)raster.getDataBuffer();
-        int[] pixels = rasterDB.getData(0);
-        int off = rasterDB.getOffset();
-        int scanlineStride = ((SinglePixelPackedSampleModel)
-                              raster.getSampleModel()).getScanlineStride();
-        int adjust = scanlineStride - w;
-
-        fillRaster(pixels, off, adjust, x, y, w, h); // delegate to subclass
-
-        return raster;
-    }
+    public final Raster getRaster(int x, int y, int w, int h) {throw new RuntimeException("cf-bug");} //{
+//        // If working raster is big enough, reuse it. Otherwise,
+//        // build a large enough new one.
+//        Raster raster = saved;
+//        if (raster == null ||
+//            raster.getWidth() < w || raster.getHeight() < h)
+//        {
+//            raster = getCachedRaster(model, w, h);
+//            saved = raster;
+//        }
+//
+//        // Access raster internal int array. Because we use a DirectColorModel,
+//        // we know the DataBuffer is of type DataBufferInt and the SampleModel
+//        // is SinglePixelPackedSampleModel.
+//        // Adjust for initial offset in DataBuffer and also for the scanline
+//        // stride.
+//        // These calls make the DataBuffer non-acceleratable, but the
+//        // Raster is never Stable long enough to accelerate anyway...
+//        DataBufferInt rasterDB = (DataBufferInt)raster.getDataBuffer();
+//        int[] pixels = rasterDB.getData(0);
+//        int off = rasterDB.getOffset();
+//        int scanlineStride = ((SinglePixelPackedSampleModel)
+//                              raster.getSampleModel()).getScanlineStride();
+//        int adjust = scanlineStride - w;
+//
+//        fillRaster(pixels, off, adjust, x, y, w, h); // delegate to subclass
+//
+//        return raster;
+//    }
 
     protected abstract void fillRaster(int pixels[], int off, int adjust,
                                        int x, int y, int w, int h);
@@ -666,21 +666,21 @@
      */
     private static synchronized Raster getCachedRaster(ColorModel cm,
                                                        int w, int h)
-    {
-        if (cm == cachedModel) {
-            if (cached != null) {
-                Raster ras = (Raster) cached.get();
-                if (ras != null &&
-                    ras.getWidth() >= w &&
-                    ras.getHeight() >= h)
-                {
-                    cached = null;
-                    return ras;
-                }
-            }
-        }
-        return cm.createCompatibleWritableRaster(w, h);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        if (cm == cachedModel) {
+//            if (cached != null) {
+//                Raster ras = (Raster) cached.get();
+//                if (ras != null &&
+//                    ras.getWidth() >= w &&
+//                    ras.getHeight() >= h)
+//                {
+//                    cached = null;
+//                    return ras;
+//                }
+//            }
+//        }
+//        return cm.createCompatibleWritableRaster(w, h);
+//    }
 
     /**
      * Took this cacheRaster code from GradientPaint. It appears to recycle
@@ -689,40 +689,40 @@
      */
     private static synchronized void putCachedRaster(ColorModel cm,
                                                      Raster ras)
-    {
-        if (cached != null) {
-            Raster cras = (Raster) cached.get();
-            if (cras != null) {
-                int cw = cras.getWidth();
-                int ch = cras.getHeight();
-                int iw = ras.getWidth();
-                int ih = ras.getHeight();
-                if (cw >= iw && ch >= ih) {
-                    return;
-                }
-                if (cw * ch >= iw * ih) {
-                    return;
-                }
-            }
-        }
-        cachedModel = cm;
-        cached = new WeakReference<Raster>(ras);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        if (cached != null) {
+//            Raster cras = (Raster) cached.get();
+//            if (cras != null) {
+//                int cw = cras.getWidth();
+//                int ch = cras.getHeight();
+//                int iw = ras.getWidth();
+//                int ih = ras.getHeight();
+//                if (cw >= iw && ch >= ih) {
+//                    return;
+//                }
+//                if (cw * ch >= iw * ih) {
+//                    return;
+//                }
+//            }
+//        }
+//        cachedModel = cm;
+//        cached = new WeakReference<Raster>(ras);
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public final void dispose() {
-        if (saved != null) {
-            putCachedRaster(model, saved);
-            saved = null;
-        }
-    }
+    public final void dispose() {throw new RuntimeException("cf-bug");} //{
+//        if (saved != null) {
+//            putCachedRaster(model, saved);
+//            saved = null;
+//        }
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public final ColorModel getColorModel() {
-        return model;
-    }
+    public final ColorModel getColorModel() {throw new RuntimeException("cf-bug");} //{
+//        return model;
+//    }
 }
--- a/java/util/EnumSet.java	2016-06-22 19:56:54.255356296 -0700
+++ b/java/util/EnumSet.java	2016-06-29 11:16:05.906337152 -0700
@@ -106,16 +106,16 @@
      * @return An empty enum set of the specified type.
      * @throws NullPointerException if <tt>elementType</tt> is null
      */
-    public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
-        Enum<?>[] universe = getUniverse(elementType);
-        if (universe == null)
-            throw new ClassCastException(elementType + " not an enum");
-
-        if (universe.length <= 64)
-            return new RegularEnumSet<>(elementType, universe);
-        else
-            return new JumboEnumSet<>(elementType, universe);
-    }
+    public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {throw new RuntimeException("cf-bug");} //{
+//        Enum<?>[] universe = getUniverse(elementType);
+//        if (universe == null)
+//            throw new ClassCastException(elementType + " not an enum");
+//
+//        if (universe.length <= 64)
+//            return new RegularEnumSet<>(elementType, universe);
+//        else
+//            return new JumboEnumSet<>(elementType, universe);
+//    }
 
     /**
      * Creates an enum set containing all of the elements in the specified
@@ -127,11 +127,11 @@
      * @return An enum set containing all the elements in the specified type.
      * @throws NullPointerException if <tt>elementType</tt> is null
      */
-    public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType) {
-        EnumSet<E> result = noneOf(elementType);
-        result.addAll();
-        return result;
-    }
+    public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType) {throw new RuntimeException("cf-bug");} //{
+//        EnumSet<E> result = noneOf(elementType);
+//        result.addAll();
+//        return result;
+//    }
 
     /**
      * Adds all of the elements from the appropriate enum type to this enum
@@ -148,9 +148,9 @@
      * @return A copy of the specified enum set.
      * @throws NullPointerException if <tt>s</tt> is null
      */
-    public static <E extends Enum<E>> EnumSet<E> copyOf(EnumSet<E> s) {
-        return s.clone();
-    }
+    public static <E extends Enum<E>> EnumSet<E> copyOf(EnumSet<E> s) {throw new RuntimeException("cf-bug");} //{
+//        return s.clone();
+//    }
 
     /**
      * Creates an enum set initialized from the specified collection.  If
@@ -166,20 +166,20 @@
      *     <tt>EnumSet</tt> instance and contains no elements
      * @throws NullPointerException if <tt>c</tt> is null
      */
-    public static <E extends Enum<E>> EnumSet<E> copyOf(Collection<E> c) {
-        if (c instanceof EnumSet) {
-            return ((EnumSet<E>)c).clone();
-        } else {
-            if (c.isEmpty())
-                throw new IllegalArgumentException("Collection is empty");
-            Iterator<E> i = c.iterator();
-            E first = i.next();
-            EnumSet<E> result = EnumSet.of(first);
-            while (i.hasNext())
-                result.add(i.next());
-            return result;
-        }
-    }
+    public static <E extends Enum<E>> EnumSet<E> copyOf(Collection<E> c) {throw new RuntimeException("cf-bug");} //{
+//        if (c instanceof EnumSet) {
+//            return ((EnumSet<E>)c).clone();
+//        } else {
+//            if (c.isEmpty())
+//                throw new IllegalArgumentException("Collection is empty");
+//            Iterator<E> i = c.iterator();
+//            E first = i.next();
+//            EnumSet<E> result = EnumSet.of(first);
+//            while (i.hasNext())
+//                result.add(i.next());
+//            return result;
+//        }
+//    }
 
     /**
      * Creates an enum set with the same element type as the specified enum
@@ -191,11 +191,11 @@
      * @return The complement of the specified set in this set
      * @throws NullPointerException if <tt>s</tt> is null
      */
-    public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> s) {
-        EnumSet<E> result = copyOf(s);
-        result.complement();
-        return result;
-    }
+    public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> s) {throw new RuntimeException("cf-bug");} //{
+//        EnumSet<E> result = copyOf(s);
+//        result.complement();
+//        return result;
+//    }
 
     /**
      * Creates an enum set initially containing the specified element.
@@ -211,11 +211,11 @@
      * @throws NullPointerException if <tt>e</tt> is null
      * @return an enum set initially containing the specified element
      */
-    public static <E extends Enum<E>> EnumSet<E> of(E e) {
-        EnumSet<E> result = noneOf(e.getDeclaringClass());
-        result.add(e);
-        return result;
-    }
+    public static <E extends Enum<E>> EnumSet<E> of(E e) {throw new RuntimeException("cf-bug");} //{
+//        EnumSet<E> result = noneOf(e.getDeclaringClass());
+//        result.add(e);
+//        return result;
+//    }
 
     /**
      * Creates an enum set initially containing the specified elements.
@@ -232,12 +232,12 @@
      * @throws NullPointerException if any parameters are null
      * @return an enum set initially containing the specified elements
      */
-    public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2) {
-        EnumSet<E> result = noneOf(e1.getDeclaringClass());
-        result.add(e1);
-        result.add(e2);
-        return result;
-    }
+    public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2) {throw new RuntimeException("cf-bug");} //{
+//        EnumSet<E> result = noneOf(e1.getDeclaringClass());
+//        result.add(e1);
+//        result.add(e2);
+//        return result;
+//    }
 
     /**
      * Creates an enum set initially containing the specified elements.
@@ -255,13 +255,13 @@
      * @throws NullPointerException if any parameters are null
      * @return an enum set initially containing the specified elements
      */
-    public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3) {
-        EnumSet<E> result = noneOf(e1.getDeclaringClass());
-        result.add(e1);
-        result.add(e2);
-        result.add(e3);
-        return result;
-    }
+    public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3) {throw new RuntimeException("cf-bug");} //{
+//        EnumSet<E> result = noneOf(e1.getDeclaringClass());
+//        result.add(e1);
+//        result.add(e2);
+//        result.add(e3);
+//        return result;
+//    }
 
     /**
      * Creates an enum set initially containing the specified elements.
@@ -280,14 +280,14 @@
      * @throws NullPointerException if any parameters are null
      * @return an enum set initially containing the specified elements
      */
-    public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4) {
-        EnumSet<E> result = noneOf(e1.getDeclaringClass());
-        result.add(e1);
-        result.add(e2);
-        result.add(e3);
-        result.add(e4);
-        return result;
-    }
+    public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4) {throw new RuntimeException("cf-bug");} //{
+//        EnumSet<E> result = noneOf(e1.getDeclaringClass());
+//        result.add(e1);
+//        result.add(e2);
+//        result.add(e3);
+//        result.add(e4);
+//        return result;
+//    }
 
     /**
      * Creates an enum set initially containing the specified elements.
@@ -309,15 +309,15 @@
      */
     public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4,
                                                     E e5)
-    {
-        EnumSet<E> result = noneOf(e1.getDeclaringClass());
-        result.add(e1);
-        result.add(e2);
-        result.add(e3);
-        result.add(e4);
-        result.add(e5);
-        return result;
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        EnumSet<E> result = noneOf(e1.getDeclaringClass());
+//        result.add(e1);
+//        result.add(e2);
+//        result.add(e3);
+//        result.add(e4);
+//        result.add(e5);
+//        return result;
+//    }
 
     /**
      * Creates an enum set initially containing the specified elements.
@@ -334,13 +334,13 @@
      * @return an enum set initially containing the specified elements
      */
     @SafeVarargs
-    public static <E extends Enum<E>> EnumSet<E> of(E first, E... rest) {
-        EnumSet<E> result = noneOf(first.getDeclaringClass());
-        result.add(first);
-        for (E e : rest)
-            result.add(e);
-        return result;
-    }
+    public static <E extends Enum<E>> EnumSet<E> of(E first, E... rest) {throw new RuntimeException("cf-bug");} //{
+//        EnumSet<E> result = noneOf(first.getDeclaringClass());
+//        result.add(first);
+//        for (E e : rest)
+//            result.add(e);
+//        return result;
+//    }
 
     /**
      * Creates an enum set initially containing all of the elements in the
@@ -356,13 +356,13 @@
      * @return an enum set initially containing all of the elements in the
      *         range defined by the two specified endpoints
      */
-    public static <E extends Enum<E>> EnumSet<E> range(E from, E to) {
-        if (from.compareTo(to) > 0)
-            throw new IllegalArgumentException(from + " > " + to);
-        EnumSet<E> result = noneOf(from.getDeclaringClass());
-        result.addRange(from, to);
-        return result;
-    }
+    public static <E extends Enum<E>> EnumSet<E> range(E from, E to) {throw new RuntimeException("cf-bug");} //{
+//        if (from.compareTo(to) > 0)
+//            throw new IllegalArgumentException(from + " > " + to);
+//        EnumSet<E> result = noneOf(from.getDeclaringClass());
+//        result.addRange(from, to);
+//        return result;
+//    }
 
     /**
      * Adds the specified range to this enum set, which is empty prior
@@ -376,13 +376,13 @@
      * @return a copy of this set
      */
     @SuppressWarnings("unchecked")
-    public EnumSet<E> clone() {
-        try {
-            return (EnumSet<E>) super.clone();
-        } catch(CloneNotSupportedException e) {
-            throw new AssertionError(e);
-        }
-    }
+    public EnumSet<E> clone() {throw new RuntimeException("cf-bug");} //{
+//        try {
+//            return (EnumSet<E>) super.clone();
+//        } catch(CloneNotSupportedException e) {
+//            throw new AssertionError(e);
+//        }
+//    }
 
     /**
      * Complements the contents of this enum set.
@@ -392,20 +392,20 @@
     /**
      * Throws an exception if e is not of the correct type for this enum set.
      */
-    final void typeCheck(E e) {
-        Class<?> eClass = e.getClass();
-        if (eClass != elementType && eClass.getSuperclass() != elementType)
-            throw new ClassCastException(eClass + " != " + elementType);
-    }
+    final void typeCheck(E e) {throw new RuntimeException("cf-bug");} //{
+//        Class<?> eClass = e.getClass();
+//        if (eClass != elementType && eClass.getSuperclass() != elementType)
+//            throw new ClassCastException(eClass + " != " + elementType);
+//    }
 
     /**
      * Returns all of the values comprising E.
      * The result is uncloned, cached, and shared by all callers.
      */
-    private static <E extends Enum<E>> E[] getUniverse(Class<E> elementType) {
-        return SharedSecrets.getJavaLangAccess()
-                                        .getEnumConstantsShared(elementType);
-    }
+    private static <E extends Enum<E>> E[] getUniverse(Class<E> elementType) {throw new RuntimeException("cf-bug");} //{
+//        return SharedSecrets.getJavaLangAccess()
+//                                        .getEnumConstantsShared(elementType);
+//    }
 
     /**
      * This class is used to serialize all EnumSet instances, regardless of
@@ -441,24 +441,24 @@
         // instead of cast to E, we should perhaps use elementType.cast()
         // to avoid injection of forged stream, but it will slow the implementation
         @SuppressWarnings("unchecked")
-        private Object readResolve() {
-            EnumSet<E> result = EnumSet.noneOf(elementType);
-            for (Enum<?> e : elements)
-                result.add((E)e);
-            return result;
-        }
+        private Object readResolve() {throw new RuntimeException("cf-bug");} //{
+//            EnumSet<E> result = EnumSet.noneOf(elementType);
+//            for (Enum<?> e : elements)
+//                result.add((E)e);
+//            return result;
+//        }
 
         private static final long serialVersionUID = 362491234563181265L;
     }
 
-    Object writeReplace() {
-        return new SerializationProxy<>(this);
-    }
+    Object writeReplace() {throw new RuntimeException("cf-bug");} //{
+//        return new SerializationProxy<>(this);
+//    }
 
     // readObject method for the serialization proxy pattern
     // See Effective Java, Second Ed., Item 78.
     private void readObject(java.io.ObjectInputStream stream)
-        throws java.io.InvalidObjectException {
-        throw new java.io.InvalidObjectException("Proxy required");
-    }
+        throws java.io.InvalidObjectException {throw new RuntimeException("cf-bug");} //{
+//        throw new java.io.InvalidObjectException("Proxy required");
+//    }
 }
--- a/java/util/stream/IntPipeline.java	2016-06-22 19:56:58.654377983 -0700
+++ b/java/util/stream/IntPipeline.java	2016-06-29 11:28:27.624873426 -0700
@@ -95,17 +95,17 @@
      * Adapt a {@code Sink<Integer> to an {@code IntConsumer}, ideally simply
      * by casting.
      */
-    private static IntConsumer adapt(Sink<Integer> sink) {
-        if (sink instanceof IntConsumer) {
-            return (IntConsumer) sink;
-        }
-        else {
-            if (Tripwire.ENABLED)
-                Tripwire.trip(AbstractPipeline.class,
-                              "using IntStream.adapt(Sink<Integer> s)");
-            return sink::accept;
-        }
-    }
+    private static IntConsumer adapt(Sink<Integer> sink) {throw new RuntimeException("cf-bug");} //{
+//        if (sink instanceof IntConsumer) {
+//            return (IntConsumer) sink;
+//        }
+//        else {
+//            if (Tripwire.ENABLED)
+//                Tripwire.trip(AbstractPipeline.class,
+//                              "using IntStream.adapt(Sink<Integer> s)");
+//            return sink::accept;
+//        }
+//    }
 
     /**
      * Adapt a {@code Spliterator<Integer>} to a {@code Spliterator.OfInt}.
@@ -114,394 +114,394 @@
      * The implementation attempts to cast to a Spliterator.OfInt, and throws an
      * exception if this cast is not possible.
      */
-    private static Spliterator.OfInt adapt(Spliterator<Integer> s) {
-        if (s instanceof Spliterator.OfInt) {
-            return (Spliterator.OfInt) s;
-        }
-        else {
-            if (Tripwire.ENABLED)
-                Tripwire.trip(AbstractPipeline.class,
-                              "using IntStream.adapt(Spliterator<Integer> s)");
-            throw new UnsupportedOperationException("IntStream.adapt(Spliterator<Integer> s)");
-        }
-    }
+    private static Spliterator.OfInt adapt(Spliterator<Integer> s) {throw new RuntimeException("cf-bug");} //{
+//        if (s instanceof Spliterator.OfInt) {
+//            return (Spliterator.OfInt) s;
+//        }
+//        else {
+//            if (Tripwire.ENABLED)
+//                Tripwire.trip(AbstractPipeline.class,
+//                              "using IntStream.adapt(Spliterator<Integer> s)");
+//            throw new UnsupportedOperationException("IntStream.adapt(Spliterator<Integer> s)");
+//        }
+//    }
 
 
     // Shape-specific methods
 
     @Override
-    final StreamShape getOutputShape() {
-        return StreamShape.INT_VALUE;
-    }
+    final StreamShape getOutputShape() {throw new RuntimeException("cf-bug");} //{
+//        return StreamShape.INT_VALUE;
+//    }
 
     @Override
     final <P_IN> Node<Integer> evaluateToNode(PipelineHelper<Integer> helper,
                                               Spliterator<P_IN> spliterator,
                                               boolean flattenTree,
-                                              IntFunction<Integer[]> generator) {
-        return Nodes.collectInt(helper, spliterator, flattenTree);
-    }
+                                              IntFunction<Integer[]> generator) {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.collectInt(helper, spliterator, flattenTree);
+//    }
 
     @Override
     final <P_IN> Spliterator<Integer> wrap(PipelineHelper<Integer> ph,
                                            Supplier<Spliterator<P_IN>> supplier,
-                                           boolean isParallel) {
-        return new StreamSpliterators.IntWrappingSpliterator<>(ph, supplier, isParallel);
-    }
+                                           boolean isParallel) {throw new RuntimeException("cf-bug");} //{
+//        return new StreamSpliterators.IntWrappingSpliterator<>(ph, supplier, isParallel);
+//    }
 
     @Override
     @SuppressWarnings("unchecked")
-    final Spliterator.OfInt lazySpliterator(Supplier<? extends Spliterator<Integer>> supplier) {
-        return new StreamSpliterators.DelegatingSpliterator.OfInt((Supplier<Spliterator.OfInt>) supplier);
-    }
+    final Spliterator.OfInt lazySpliterator(Supplier<? extends Spliterator<Integer>> supplier) {throw new RuntimeException("cf-bug");} //{
+//        return new StreamSpliterators.DelegatingSpliterator.OfInt((Supplier<Spliterator.OfInt>) supplier);
+//    }
 
     @Override
-    final void forEachWithCancel(Spliterator<Integer> spliterator, Sink<Integer> sink) {
-        Spliterator.OfInt spl = adapt(spliterator);
-        IntConsumer adaptedSink = adapt(sink);
-        do { } while (!sink.cancellationRequested() && spl.tryAdvance(adaptedSink));
-    }
+    final void forEachWithCancel(Spliterator<Integer> spliterator, Sink<Integer> sink) {throw new RuntimeException("cf-bug");} //{
+//        Spliterator.OfInt spl = adapt(spliterator);
+//        IntConsumer adaptedSink = adapt(sink);
+//        do { } while (!sink.cancellationRequested() && spl.tryAdvance(adaptedSink));
+//    }
 
     @Override
     final Node.Builder<Integer> makeNodeBuilder(long exactSizeIfKnown,
-                                                IntFunction<Integer[]> generator) {
-        return Nodes.intBuilder(exactSizeIfKnown);
-    }
+                                                IntFunction<Integer[]> generator) {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.intBuilder(exactSizeIfKnown);
+//    }
 
 
     // IntStream
 
     @Override
-    public final PrimitiveIterator.OfInt iterator() {
-        return Spliterators.iterator(spliterator());
-    }
+    public final PrimitiveIterator.OfInt iterator() {throw new RuntimeException("cf-bug");} //{
+//        return Spliterators.iterator(spliterator());
+//    }
 
     @Override
-    public final Spliterator.OfInt spliterator() {
-        return adapt(super.spliterator());
-    }
+    public final Spliterator.OfInt spliterator() {throw new RuntimeException("cf-bug");} //{
+//        return adapt(super.spliterator());
+//    }
 
     // Stateless intermediate ops from IntStream
 
     @Override
-    public final LongStream asLongStream() {
-        return new LongPipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Integer> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedInt<Long>(sink) {
-                    @Override
-                    public void accept(int t) {
-                        downstream.accept((long) t);
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final DoubleStream asDoubleStream() {
-        return new DoublePipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                                       StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Integer> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedInt<Double>(sink) {
-                    @Override
-                    public void accept(int t) {
-                        downstream.accept((double) t);
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final Stream<Integer> boxed() {
-        return mapToObj(Integer::valueOf);
-    }
-
-    @Override
-    public final IntStream map(IntUnaryOperator mapper) {
-        Objects.requireNonNull(mapper);
-        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedInt<Integer>(sink) {
-                    @Override
-                    public void accept(int t) {
-                        downstream.accept(mapper.applyAsInt(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final <U> Stream<U> mapToObj(IntFunction<? extends U> mapper) {
-        Objects.requireNonNull(mapper);
-        return new ReferencePipeline.StatelessOp<Integer, U>(this, StreamShape.INT_VALUE,
-                                                             StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Integer> opWrapSink(int flags, Sink<U> sink) {
-                return new Sink.ChainedInt<U>(sink) {
-                    @Override
-                    public void accept(int t) {
-                        downstream.accept(mapper.apply(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final LongStream mapToLong(IntToLongFunction mapper) {
-        Objects.requireNonNull(mapper);
-        return new LongPipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Integer> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedInt<Long>(sink) {
-                    @Override
-                    public void accept(int t) {
-                        downstream.accept(mapper.applyAsLong(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final DoubleStream mapToDouble(IntToDoubleFunction mapper) {
-        Objects.requireNonNull(mapper);
-        return new DoublePipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                                       StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Integer> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedInt<Double>(sink) {
-                    @Override
-                    public void accept(int t) {
-                        downstream.accept(mapper.applyAsDouble(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final IntStream flatMap(IntFunction<? extends IntStream> mapper) {
-        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedInt<Integer>(sink) {
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(int t) {
-                        try (IntStream result = mapper.apply(t)) {
-                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
-                            if (result != null)
-                                result.sequential().forEach(i -> downstream.accept(i));
-                        }
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public IntStream unordered() {
-        if (!isOrdered())
-            return this;
-        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE, StreamOpFlag.NOT_ORDERED) {
-            @Override
-            Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
-                return sink;
-            }
-        };
-    }
-
-    @Override
-    public final IntStream filter(IntPredicate predicate) {
-        Objects.requireNonNull(predicate);
-        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                        StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedInt<Integer>(sink) {
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(int t) {
-                        if (predicate.test(t))
-                            downstream.accept(t);
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final IntStream peek(IntConsumer action) {
-        Objects.requireNonNull(action);
-        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
-                                        0) {
-            @Override
-            Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedInt<Integer>(sink) {
-                    @Override
-                    public void accept(int t) {
-                        action.accept(t);
-                        downstream.accept(t);
-                    }
-                };
-            }
-        };
-    }
+    public final LongStream asLongStream() {throw new RuntimeException("cf-bug");} //{
+//        return new LongPipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE,
+//                                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Integer> opWrapSink(int flags, Sink<Long> sink) {
+//                return new Sink.ChainedInt<Long>(sink) {
+//                    @Override
+//                    public void accept(int t) {
+//                        downstream.accept((long) t);
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final DoubleStream asDoubleStream() {throw new RuntimeException("cf-bug");} //{
+//        return new DoublePipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE,
+//                                                       StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Integer> opWrapSink(int flags, Sink<Double> sink) {
+//                return new Sink.ChainedInt<Double>(sink) {
+//                    @Override
+//                    public void accept(int t) {
+//                        downstream.accept((double) t);
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final Stream<Integer> boxed() {throw new RuntimeException("cf-bug");} //{
+//        return mapToObj(Integer::valueOf);
+//    }
+
+    @Override
+    public final IntStream map(IntUnaryOperator mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
+//                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
+//                return new Sink.ChainedInt<Integer>(sink) {
+//                    @Override
+//                    public void accept(int t) {
+//                        downstream.accept(mapper.applyAsInt(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final <U> Stream<U> mapToObj(IntFunction<? extends U> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new ReferencePipeline.StatelessOp<Integer, U>(this, StreamShape.INT_VALUE,
+//                                                             StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Integer> opWrapSink(int flags, Sink<U> sink) {
+//                return new Sink.ChainedInt<U>(sink) {
+//                    @Override
+//                    public void accept(int t) {
+//                        downstream.accept(mapper.apply(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final LongStream mapToLong(IntToLongFunction mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new LongPipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE,
+//                                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Integer> opWrapSink(int flags, Sink<Long> sink) {
+//                return new Sink.ChainedInt<Long>(sink) {
+//                    @Override
+//                    public void accept(int t) {
+//                        downstream.accept(mapper.applyAsLong(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final DoubleStream mapToDouble(IntToDoubleFunction mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new DoublePipeline.StatelessOp<Integer>(this, StreamShape.INT_VALUE,
+//                                                       StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Integer> opWrapSink(int flags, Sink<Double> sink) {
+//                return new Sink.ChainedInt<Double>(sink) {
+//                    @Override
+//                    public void accept(int t) {
+//                        downstream.accept(mapper.applyAsDouble(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final IntStream flatMap(IntFunction<? extends IntStream> mapper) {throw new RuntimeException("cf-bug");} //{
+//        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
+//                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
+//                return new Sink.ChainedInt<Integer>(sink) {
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(int t) {
+//                        try (IntStream result = mapper.apply(t)) {
+//                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
+//                            if (result != null)
+//                                result.sequential().forEach(i -> downstream.accept(i));
+//                        }
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public IntStream unordered() {throw new RuntimeException("cf-bug");} //{
+//        if (!isOrdered())
+//            return this;
+//        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE, StreamOpFlag.NOT_ORDERED) {
+//            @Override
+//            Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
+//                return sink;
+//            }
+//        };
+//    }
+
+    @Override
+    public final IntStream filter(IntPredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(predicate);
+//        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
+//                                        StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
+//                return new Sink.ChainedInt<Integer>(sink) {
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(int t) {
+//                        if (predicate.test(t))
+//                            downstream.accept(t);
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final IntStream peek(IntConsumer action) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(action);
+//        return new StatelessOp<Integer>(this, StreamShape.INT_VALUE,
+//                                        0) {
+//            @Override
+//            Sink<Integer> opWrapSink(int flags, Sink<Integer> sink) {
+//                return new Sink.ChainedInt<Integer>(sink) {
+//                    @Override
+//                    public void accept(int t) {
+//                        action.accept(t);
+//                        downstream.accept(t);
+//                    }
+//                };
+//            }
+//        };
+//    }
 
     // Stateful intermediate ops from IntStream
 
     @Override
-    public final IntStream limit(long maxSize) {
-        if (maxSize < 0)
-            throw new IllegalArgumentException(Long.toString(maxSize));
-        return SliceOps.makeInt(this, 0, maxSize);
-    }
-
-    @Override
-    public final IntStream skip(long n) {
-        if (n < 0)
-            throw new IllegalArgumentException(Long.toString(n));
-        if (n == 0)
-            return this;
-        else
-            return SliceOps.makeInt(this, n, -1);
-    }
-
-    @Override
-    public final IntStream sorted() {
-        return SortedOps.makeInt(this);
-    }
-
-    @Override
-    public final IntStream distinct() {
-        // While functional and quick to implement, this approach is not very efficient.
-        // An efficient version requires an int-specific map/set implementation.
-        return boxed().distinct().mapToInt(i -> i);
-    }
+    public final IntStream limit(long maxSize) {throw new RuntimeException("cf-bug");} //{
+//        if (maxSize < 0)
+//            throw new IllegalArgumentException(Long.toString(maxSize));
+//        return SliceOps.makeInt(this, 0, maxSize);
+//    }
+
+    @Override
+    public final IntStream skip(long n) {throw new RuntimeException("cf-bug");} //{
+//        if (n < 0)
+//            throw new IllegalArgumentException(Long.toString(n));
+//        if (n == 0)
+//            return this;
+//        else
+//            return SliceOps.makeInt(this, n, -1);
+//    }
+
+    @Override
+    public final IntStream sorted() {throw new RuntimeException("cf-bug");} //{
+//        return SortedOps.makeInt(this);
+//    }
+
+    @Override
+    public final IntStream distinct() {throw new RuntimeException("cf-bug");} //{
+//        // While functional and quick to implement, this approach is not very efficient.
+//        // An efficient version requires an int-specific map/set implementation.
+//        return boxed().distinct().mapToInt(i -> i);
+//    }
 
     // Terminal ops from IntStream
 
     @Override
-    public void forEach(IntConsumer action) {
-        evaluate(ForEachOps.makeInt(action, false));
-    }
+    public void forEach(IntConsumer action) {throw new RuntimeException("cf-bug");} //{
+//        evaluate(ForEachOps.makeInt(action, false));
+//    }
 
     @Override
-    public void forEachOrdered(IntConsumer action) {
-        evaluate(ForEachOps.makeInt(action, true));
-    }
+    public void forEachOrdered(IntConsumer action) {throw new RuntimeException("cf-bug");} //{
+//        evaluate(ForEachOps.makeInt(action, true));
+//    }
 
     @Override
-    public final int sum() {
-        return reduce(0, Integer::sum);
-    }
+    public final int sum() {throw new RuntimeException("cf-bug");} //{
+//        return reduce(0, Integer::sum);
+//    }
 
     @Override
-    public final OptionalInt min() {
-        return reduce(Math::min);
-    }
+    public final OptionalInt min() {throw new RuntimeException("cf-bug");} //{
+//        return reduce(Math::min);
+//    }
 
     @Override
-    public final OptionalInt max() {
-        return reduce(Math::max);
-    }
+    public final OptionalInt max() {throw new RuntimeException("cf-bug");} //{
+//        return reduce(Math::max);
+//    }
 
     @Override
-    public final long count() {
-        return mapToLong(e -> 1L).sum();
-    }
+    public final long count() {throw new RuntimeException("cf-bug");} //{
+//        return mapToLong(e -> 1L).sum();
+//    }
 
     @Override
-    public final OptionalDouble average() {
-        long[] avg = collect(() -> new long[2],
-                             (ll, i) -> {
-                                 ll[0]++;
-                                 ll[1] += i;
-                             },
-                             (ll, rr) -> {
-                                 ll[0] += rr[0];
-                                 ll[1] += rr[1];
-                             });
-        return avg[0] > 0
-               ? OptionalDouble.of((double) avg[1] / avg[0])
-               : OptionalDouble.empty();
-    }
+    public final OptionalDouble average() {throw new RuntimeException("cf-bug");} //{
+//        long[] avg = collect(() -> new long[2],
+//                             (ll, i) -> {
+//                                 ll[0]++;
+//                                 ll[1] += i;
+//                             },
+//                             (ll, rr) -> {
+//                                 ll[0] += rr[0];
+//                                 ll[1] += rr[1];
+//                             });
+//        return avg[0] > 0
+//               ? OptionalDouble.of((double) avg[1] / avg[0])
+//               : OptionalDouble.empty();
+//    }
 
     @Override
-    public final IntSummaryStatistics summaryStatistics() {
-        return collect(IntSummaryStatistics::new, IntSummaryStatistics::accept,
-                       IntSummaryStatistics::combine);
-    }
+    public final IntSummaryStatistics summaryStatistics() {throw new RuntimeException("cf-bug");} //{
+//        return collect(IntSummaryStatistics::new, IntSummaryStatistics::accept,
+//                       IntSummaryStatistics::combine);
+//    }
 
     @Override
-    public final int reduce(int identity, IntBinaryOperator op) {
-        return evaluate(ReduceOps.makeInt(identity, op));
-    }
+    public final int reduce(int identity, IntBinaryOperator op) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(ReduceOps.makeInt(identity, op));
+//    }
 
     @Override
-    public final OptionalInt reduce(IntBinaryOperator op) {
-        return evaluate(ReduceOps.makeInt(op));
-    }
+    public final OptionalInt reduce(IntBinaryOperator op) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(ReduceOps.makeInt(op));
+//    }
 
     @Override
     public final <R> R collect(Supplier<R> supplier,
                                ObjIntConsumer<R> accumulator,
-                               BiConsumer<R, R> combiner) {
-        BinaryOperator<R> operator = (left, right) -> {
-            combiner.accept(left, right);
-            return left;
-        };
-        return evaluate(ReduceOps.makeInt(supplier, accumulator, operator));
-    }
+                               BiConsumer<R, R> combiner) {throw new RuntimeException("cf-bug");} //{
+//        BinaryOperator<R> operator = (left, right) -> {
+//            combiner.accept(left, right);
+//            return left;
+//        };
+//        return evaluate(ReduceOps.makeInt(supplier, accumulator, operator));
+//    }
 
     @Override
-    public final boolean anyMatch(IntPredicate predicate) {
-        return evaluate(MatchOps.makeInt(predicate, MatchOps.MatchKind.ANY));
-    }
+    public final boolean anyMatch(IntPredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeInt(predicate, MatchOps.MatchKind.ANY));
+//    }
 
     @Override
-    public final boolean allMatch(IntPredicate predicate) {
-        return evaluate(MatchOps.makeInt(predicate, MatchOps.MatchKind.ALL));
-    }
+    public final boolean allMatch(IntPredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeInt(predicate, MatchOps.MatchKind.ALL));
+//    }
 
     @Override
-    public final boolean noneMatch(IntPredicate predicate) {
-        return evaluate(MatchOps.makeInt(predicate, MatchOps.MatchKind.NONE));
-    }
+    public final boolean noneMatch(IntPredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeInt(predicate, MatchOps.MatchKind.NONE));
+//    }
 
     @Override
-    public final OptionalInt findFirst() {
-        return evaluate(FindOps.makeInt(true));
-    }
+    public final OptionalInt findFirst() {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(FindOps.makeInt(true));
+//    }
 
     @Override
-    public final OptionalInt findAny() {
-        return evaluate(FindOps.makeInt(false));
-    }
+    public final OptionalInt findAny() {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(FindOps.makeInt(false));
+//    }
 
     @Override
-    public final int[] toArray() {
-        return Nodes.flattenInt((Node.OfInt) evaluateToArrayNode(Integer[]::new))
-                        .asPrimitiveArray();
-    }
+    public final int[] toArray() {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.flattenInt((Node.OfInt) evaluateToArrayNode(Integer[]::new))
+//                        .asPrimitiveArray();
+//    }
 
     //
 
@@ -540,36 +540,36 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            throw new UnsupportedOperationException();
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            throw new UnsupportedOperationException();
+//        }
 
         @Override
-        final Sink<E_IN> opWrapSink(int flags, Sink<Integer> sink) {
-            throw new UnsupportedOperationException();
-        }
+        final Sink<E_IN> opWrapSink(int flags, Sink<Integer> sink) {throw new RuntimeException("cf-bug");} //{
+//            throw new UnsupportedOperationException();
+//        }
 
         // Optimized sequential terminal operations for the head of the pipeline
 
         @Override
-        public void forEach(IntConsumer action) {
-            if (!isParallel()) {
-                adapt(sourceStageSpliterator()).forEachRemaining(action);
-            }
-            else {
-                super.forEach(action);
-            }
-        }
+        public void forEach(IntConsumer action) {throw new RuntimeException("cf-bug");} //{
+//            if (!isParallel()) {
+//                adapt(sourceStageSpliterator()).forEachRemaining(action);
+//            }
+//            else {
+//                super.forEach(action);
+//            }
+//        }
 
         @Override
-        public void forEachOrdered(IntConsumer action) {
-            if (!isParallel()) {
-                adapt(sourceStageSpliterator()).forEachRemaining(action);
-            }
-            else {
-                super.forEachOrdered(action);
-            }
-        }
+        public void forEachOrdered(IntConsumer action) {throw new RuntimeException("cf-bug");} //{
+//            if (!isParallel()) {
+//                adapt(sourceStageSpliterator()).forEachRemaining(action);
+//            }
+//            else {
+//                super.forEachOrdered(action);
+//            }
+//        }
     }
 
     /**
@@ -594,9 +594,9 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            return false;
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            return false;
+//        }
     }
 
     /**
@@ -621,9 +621,9 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            return true;
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            return true;
+//        }
 
         @Override
         abstract <P_IN> Node<Integer> opEvaluateParallel(PipelineHelper<Integer> helper,
--- a/java/util/stream/ReferencePipeline.java	2016-06-22 19:56:58.804378722 -0700
+++ b/java/util/stream/ReferencePipeline.java	2016-06-29 11:26:08.726208894 -0700
@@ -97,47 +97,47 @@
     // Shape-specific methods
 
     @Override
-    final StreamShape getOutputShape() {
-        return StreamShape.REFERENCE;
-    }
+    final StreamShape getOutputShape() {throw new RuntimeException("cf-bug");} //{
+//        return StreamShape.REFERENCE;
+//    }
 
     @Override
     final <P_IN> Node<P_OUT> evaluateToNode(PipelineHelper<P_OUT> helper,
                                         Spliterator<P_IN> spliterator,
                                         boolean flattenTree,
-                                        IntFunction<P_OUT[]> generator) {
-        return Nodes.collect(helper, spliterator, flattenTree, generator);
-    }
+                                        IntFunction<P_OUT[]> generator) {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.collect(helper, spliterator, flattenTree, generator);
+//    }
 
     @Override
     final <P_IN> Spliterator<P_OUT> wrap(PipelineHelper<P_OUT> ph,
                                      Supplier<Spliterator<P_IN>> supplier,
-                                     boolean isParallel) {
-        return new StreamSpliterators.WrappingSpliterator<>(ph, supplier, isParallel);
-    }
+                                     boolean isParallel) {throw new RuntimeException("cf-bug");} //{
+//        return new StreamSpliterators.WrappingSpliterator<>(ph, supplier, isParallel);
+//    }
 
     @Override
-    final Spliterator<P_OUT> lazySpliterator(Supplier<? extends Spliterator<P_OUT>> supplier) {
-        return new StreamSpliterators.DelegatingSpliterator<>(supplier);
-    }
+    final Spliterator<P_OUT> lazySpliterator(Supplier<? extends Spliterator<P_OUT>> supplier) {throw new RuntimeException("cf-bug");} //{
+//        return new StreamSpliterators.DelegatingSpliterator<>(supplier);
+//    }
 
     @Override
-    final void forEachWithCancel(Spliterator<P_OUT> spliterator, Sink<P_OUT> sink) {
-        do { } while (!sink.cancellationRequested() && spliterator.tryAdvance(sink));
-    }
+    final void forEachWithCancel(Spliterator<P_OUT> spliterator, Sink<P_OUT> sink) {throw new RuntimeException("cf-bug");} //{
+//        do { } while (!sink.cancellationRequested() && spliterator.tryAdvance(sink));
+//    }
 
     @Override
-    final Node.Builder<P_OUT> makeNodeBuilder(long exactSizeIfKnown, IntFunction<P_OUT[]> generator) {
-        return Nodes.builder(exactSizeIfKnown, generator);
-    }
+    final Node.Builder<P_OUT> makeNodeBuilder(long exactSizeIfKnown, IntFunction<P_OUT[]> generator) {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.builder(exactSizeIfKnown, generator);
+//    }
 
 
     // BaseStream
 
     @Override
-    public final Iterator<P_OUT> iterator() {
-        return Spliterators.iterator(spliterator());
-    }
+    public final Iterator<P_OUT> iterator() {throw new RuntimeException("cf-bug");} //{
+//        return Spliterators.iterator(spliterator());
+//    }
 
 
     // Stream
@@ -145,386 +145,386 @@
     // Stateless intermediate operations from Stream
 
     @Override
-    public Stream<P_OUT> unordered() {
-        if (!isOrdered())
-            return this;
-        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE, StreamOpFlag.NOT_ORDERED) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
-                return sink;
-            }
-        };
-    }
-
-    @Override
-    public final Stream<P_OUT> filter(Predicate<? super P_OUT> predicate) {
-        Objects.requireNonNull(predicate);
-        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE,
-                                     StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
-                return new Sink.ChainedReference<P_OUT, P_OUT>(sink) {
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(P_OUT u) {
-                        if (predicate.test(u))
-                            downstream.accept(u);
-                    }
-                };
-            }
-        };
-    }
+    public Stream<P_OUT> unordered() {throw new RuntimeException("cf-bug");} //{
+//        if (!isOrdered())
+//            return this;
+//        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE, StreamOpFlag.NOT_ORDERED) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
+//                return sink;
+//            }
+//        };
+//    }
+
+    @Override
+    public final Stream<P_OUT> filter(Predicate<? super P_OUT> predicate) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(predicate);
+//        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE,
+//                                     StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
+//                return new Sink.ChainedReference<P_OUT, P_OUT>(sink) {
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(P_OUT u) {
+//                        if (predicate.test(u))
+//                            downstream.accept(u);
+//                    }
+//                };
+//            }
+//        };
+//    }
 
     @Override
     @SuppressWarnings("unchecked")
-    public final <R> Stream<R> map(Function<? super P_OUT, ? extends R> mapper) {
-        Objects.requireNonNull(mapper);
-        return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE,
-                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<R> sink) {
-                return new Sink.ChainedReference<P_OUT, R>(sink) {
-                    @Override
-                    public void accept(P_OUT u) {
-                        downstream.accept(mapper.apply(u));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final IntStream mapToInt(ToIntFunction<? super P_OUT> mapper) {
-        Objects.requireNonNull(mapper);
-        return new IntPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                              StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedReference<P_OUT, Integer>(sink) {
-                    @Override
-                    public void accept(P_OUT u) {
-                        downstream.accept(mapper.applyAsInt(u));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final LongStream mapToLong(ToLongFunction<? super P_OUT> mapper) {
-        Objects.requireNonNull(mapper);
-        return new LongPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                      StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedReference<P_OUT, Long>(sink) {
-                    @Override
-                    public void accept(P_OUT u) {
-                        downstream.accept(mapper.applyAsLong(u));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final DoubleStream mapToDouble(ToDoubleFunction<? super P_OUT> mapper) {
-        Objects.requireNonNull(mapper);
-        return new DoublePipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedReference<P_OUT, Double>(sink) {
-                    @Override
-                    public void accept(P_OUT u) {
-                        downstream.accept(mapper.applyAsDouble(u));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final <R> Stream<R> flatMap(Function<? super P_OUT, ? extends Stream<? extends R>> mapper) {
-        Objects.requireNonNull(mapper);
-        // We can do better than this, by polling cancellationRequested when stream is infinite
-        return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE,
-                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<R> sink) {
-                return new Sink.ChainedReference<P_OUT, R>(sink) {
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(P_OUT u) {
-                        try (Stream<? extends R> result = mapper.apply(u)) {
-                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
-                            if (result != null)
-                                result.sequential().forEach(downstream);
-                        }
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final IntStream flatMapToInt(Function<? super P_OUT, ? extends IntStream> mapper) {
-        Objects.requireNonNull(mapper);
-        // We can do better than this, by polling cancellationRequested when stream is infinite
-        return new IntPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                              StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedReference<P_OUT, Integer>(sink) {
-                    IntConsumer downstreamAsInt = downstream::accept;
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(P_OUT u) {
-                        try (IntStream result = mapper.apply(u)) {
-                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
-                            if (result != null)
-                                result.sequential().forEach(downstreamAsInt);
-                        }
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final DoubleStream flatMapToDouble(Function<? super P_OUT, ? extends DoubleStream> mapper) {
-        Objects.requireNonNull(mapper);
-        // We can do better than this, by polling cancellationRequested when stream is infinite
-        return new DoublePipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedReference<P_OUT, Double>(sink) {
-                    DoubleConsumer downstreamAsDouble = downstream::accept;
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(P_OUT u) {
-                        try (DoubleStream result = mapper.apply(u)) {
-                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
-                            if (result != null)
-                                result.sequential().forEach(downstreamAsDouble);
-                        }
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final LongStream flatMapToLong(Function<? super P_OUT, ? extends LongStream> mapper) {
-        Objects.requireNonNull(mapper);
-        // We can do better than this, by polling cancellationRequested when stream is infinite
-        return new LongPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
-                                                   StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedReference<P_OUT, Long>(sink) {
-                    LongConsumer downstreamAsLong = downstream::accept;
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(P_OUT u) {
-                        try (LongStream result = mapper.apply(u)) {
-                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
-                            if (result != null)
-                                result.sequential().forEach(downstreamAsLong);
-                        }
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final Stream<P_OUT> peek(Consumer<? super P_OUT> action) {
-        Objects.requireNonNull(action);
-        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE,
-                                     0) {
-            @Override
-            Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
-                return new Sink.ChainedReference<P_OUT, P_OUT>(sink) {
-                    @Override
-                    public void accept(P_OUT u) {
-                        action.accept(u);
-                        downstream.accept(u);
-                    }
-                };
-            }
-        };
-    }
+    public final <R> Stream<R> map(Function<? super P_OUT, ? extends R> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE,
+//                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<R> sink) {
+//                return new Sink.ChainedReference<P_OUT, R>(sink) {
+//                    @Override
+//                    public void accept(P_OUT u) {
+//                        downstream.accept(mapper.apply(u));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final IntStream mapToInt(ToIntFunction<? super P_OUT> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new IntPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
+//                                              StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<Integer> sink) {
+//                return new Sink.ChainedReference<P_OUT, Integer>(sink) {
+//                    @Override
+//                    public void accept(P_OUT u) {
+//                        downstream.accept(mapper.applyAsInt(u));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final LongStream mapToLong(ToLongFunction<? super P_OUT> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new LongPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
+//                                      StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<Long> sink) {
+//                return new Sink.ChainedReference<P_OUT, Long>(sink) {
+//                    @Override
+//                    public void accept(P_OUT u) {
+//                        downstream.accept(mapper.applyAsLong(u));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final DoubleStream mapToDouble(ToDoubleFunction<? super P_OUT> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new DoublePipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
+//                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<Double> sink) {
+//                return new Sink.ChainedReference<P_OUT, Double>(sink) {
+//                    @Override
+//                    public void accept(P_OUT u) {
+//                        downstream.accept(mapper.applyAsDouble(u));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final <R> Stream<R> flatMap(Function<? super P_OUT, ? extends Stream<? extends R>> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        // We can do better than this, by polling cancellationRequested when stream is infinite
+//        return new StatelessOp<P_OUT, R>(this, StreamShape.REFERENCE,
+//                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<R> sink) {
+//                return new Sink.ChainedReference<P_OUT, R>(sink) {
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(P_OUT u) {
+//                        try (Stream<? extends R> result = mapper.apply(u)) {
+//                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
+//                            if (result != null)
+//                                result.sequential().forEach(downstream);
+//                        }
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final IntStream flatMapToInt(Function<? super P_OUT, ? extends IntStream> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        // We can do better than this, by polling cancellationRequested when stream is infinite
+//        return new IntPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
+//                                              StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<Integer> sink) {
+//                return new Sink.ChainedReference<P_OUT, Integer>(sink) {
+//                    IntConsumer downstreamAsInt = downstream::accept;
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(P_OUT u) {
+//                        try (IntStream result = mapper.apply(u)) {
+//                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
+//                            if (result != null)
+//                                result.sequential().forEach(downstreamAsInt);
+//                        }
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final DoubleStream flatMapToDouble(Function<? super P_OUT, ? extends DoubleStream> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        // We can do better than this, by polling cancellationRequested when stream is infinite
+//        return new DoublePipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
+//                                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<Double> sink) {
+//                return new Sink.ChainedReference<P_OUT, Double>(sink) {
+//                    DoubleConsumer downstreamAsDouble = downstream::accept;
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(P_OUT u) {
+//                        try (DoubleStream result = mapper.apply(u)) {
+//                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
+//                            if (result != null)
+//                                result.sequential().forEach(downstreamAsDouble);
+//                        }
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final LongStream flatMapToLong(Function<? super P_OUT, ? extends LongStream> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        // We can do better than this, by polling cancellationRequested when stream is infinite
+//        return new LongPipeline.StatelessOp<P_OUT>(this, StreamShape.REFERENCE,
+//                                                   StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<Long> sink) {
+//                return new Sink.ChainedReference<P_OUT, Long>(sink) {
+//                    LongConsumer downstreamAsLong = downstream::accept;
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(P_OUT u) {
+//                        try (LongStream result = mapper.apply(u)) {
+//                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
+//                            if (result != null)
+//                                result.sequential().forEach(downstreamAsLong);
+//                        }
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final Stream<P_OUT> peek(Consumer<? super P_OUT> action) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(action);
+//        return new StatelessOp<P_OUT, P_OUT>(this, StreamShape.REFERENCE,
+//                                     0) {
+//            @Override
+//            Sink<P_OUT> opWrapSink(int flags, Sink<P_OUT> sink) {
+//                return new Sink.ChainedReference<P_OUT, P_OUT>(sink) {
+//                    @Override
+//                    public void accept(P_OUT u) {
+//                        action.accept(u);
+//                        downstream.accept(u);
+//                    }
+//                };
+//            }
+//        };
+//    }
 
     // Stateful intermediate operations from Stream
 
     @Override
-    public final Stream<P_OUT> distinct() {
-        return DistinctOps.makeRef(this);
-    }
+    public final Stream<P_OUT> distinct() {throw new RuntimeException("cf-bug");} //{
+//        return DistinctOps.makeRef(this);
+//    }
 
     @Override
-    public final Stream<P_OUT> sorted() {
-        return SortedOps.makeRef(this);
-    }
+    public final Stream<P_OUT> sorted() {throw new RuntimeException("cf-bug");} //{
+//        return SortedOps.makeRef(this);
+//    }
 
     @Override
-    public final Stream<P_OUT> sorted(Comparator<? super P_OUT> comparator) {
-        return SortedOps.makeRef(this, comparator);
-    }
+    public final Stream<P_OUT> sorted(Comparator<? super P_OUT> comparator) {throw new RuntimeException("cf-bug");} //{
+//        return SortedOps.makeRef(this, comparator);
+//    }
 
     @Override
-    public final Stream<P_OUT> limit(long maxSize) {
-        if (maxSize < 0)
-            throw new IllegalArgumentException(Long.toString(maxSize));
-        return SliceOps.makeRef(this, 0, maxSize);
-    }
+    public final Stream<P_OUT> limit(long maxSize) {throw new RuntimeException("cf-bug");} //{
+//        if (maxSize < 0)
+//            throw new IllegalArgumentException(Long.toString(maxSize));
+//        return SliceOps.makeRef(this, 0, maxSize);
+//    }
 
     @Override
-    public final Stream<P_OUT> skip(long n) {
-        if (n < 0)
-            throw new IllegalArgumentException(Long.toString(n));
-        if (n == 0)
-            return this;
-        else
-            return SliceOps.makeRef(this, n, -1);
-    }
+    public final Stream<P_OUT> skip(long n) {throw new RuntimeException("cf-bug");} //{
+//        if (n < 0)
+//            throw new IllegalArgumentException(Long.toString(n));
+//        if (n == 0)
+//            return this;
+//        else
+//            return SliceOps.makeRef(this, n, -1);
+//    }
 
     // Terminal operations from Stream
 
     @Override
-    public void forEach(Consumer<? super P_OUT> action) {
-        evaluate(ForEachOps.makeRef(action, false));
-    }
+    public void forEach(Consumer<? super P_OUT> action) {throw new RuntimeException("cf-bug");} //{
+//        evaluate(ForEachOps.makeRef(action, false));
+//    }
 
     @Override
-    public void forEachOrdered(Consumer<? super P_OUT> action) {
-        evaluate(ForEachOps.makeRef(action, true));
-    }
+    public void forEachOrdered(Consumer<? super P_OUT> action) {throw new RuntimeException("cf-bug");} //{
+//        evaluate(ForEachOps.makeRef(action, true));
+//    }
 
     @Override
     @SuppressWarnings("unchecked")
-    public final <A> A[] toArray(IntFunction<A[]> generator) {
-        // Since A has no relation to U (not possible to declare that A is an upper bound of U)
-        // there will be no static type checking.
-        // Therefore use a raw type and assume A == U rather than propagating the separation of A and U
-        // throughout the code-base.
-        // The runtime type of U is never checked for equality with the component type of the runtime type of A[].
-        // Runtime checking will be performed when an element is stored in A[], thus if A is not a
-        // super type of U an ArrayStoreException will be thrown.
-        @SuppressWarnings("rawtypes")
-        IntFunction rawGenerator = (IntFunction) generator;
-        return (A[]) Nodes.flatten(evaluateToArrayNode(rawGenerator), rawGenerator)
-                              .asArray(rawGenerator);
-    }
+    public final <A> A[] toArray(IntFunction<A[]> generator) {throw new RuntimeException("cf-bug");} //{
+//        // Since A has no relation to U (not possible to declare that A is an upper bound of U)
+//        // there will be no static type checking.
+//        // Therefore use a raw type and assume A == U rather than propagating the separation of A and U
+//        // throughout the code-base.
+//        // The runtime type of U is never checked for equality with the component type of the runtime type of A[].
+//        // Runtime checking will be performed when an element is stored in A[], thus if A is not a
+//        // super type of U an ArrayStoreException will be thrown.
+//        @SuppressWarnings("rawtypes")
+//        IntFunction rawGenerator = (IntFunction) generator;
+//        return (A[]) Nodes.flatten(evaluateToArrayNode(rawGenerator), rawGenerator)
+//                              .asArray(rawGenerator);
+//    }
 
     @Override
-    public final Object[] toArray() {
-        return toArray(Object[]::new);
-    }
+    public final Object[] toArray() {throw new RuntimeException("cf-bug");} //{
+//        return toArray(Object[]::new);
+//    }
 
     @Override
-    public final boolean anyMatch(Predicate<? super P_OUT> predicate) {
-        return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ANY));
-    }
+    public final boolean anyMatch(Predicate<? super P_OUT> predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ANY));
+//    }
 
     @Override
-    public final boolean allMatch(Predicate<? super P_OUT> predicate) {
-        return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ALL));
-    }
+    public final boolean allMatch(Predicate<? super P_OUT> predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.ALL));
+//    }
 
     @Override
-    public final boolean noneMatch(Predicate<? super P_OUT> predicate) {
-        return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.NONE));
-    }
+    public final boolean noneMatch(Predicate<? super P_OUT> predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeRef(predicate, MatchOps.MatchKind.NONE));
+//    }
 
     @Override
-    public final Optional<P_OUT> findFirst() {
-        return evaluate(FindOps.makeRef(true));
-    }
+    public final Optional<P_OUT> findFirst() {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(FindOps.makeRef(true));
+//    }
 
     @Override
-    public final Optional<P_OUT> findAny() {
-        return evaluate(FindOps.makeRef(false));
-    }
+    public final Optional<P_OUT> findAny() {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(FindOps.makeRef(false));
+//    }
 
     @Override
-    public final P_OUT reduce(final P_OUT identity, final BinaryOperator<P_OUT> accumulator) {
-        return evaluate(ReduceOps.makeRef(identity, accumulator, accumulator));
-    }
+    public final P_OUT reduce(final P_OUT identity, final BinaryOperator<P_OUT> accumulator) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(ReduceOps.makeRef(identity, accumulator, accumulator));
+//    }
 
     @Override
-    public final Optional<P_OUT> reduce(BinaryOperator<P_OUT> accumulator) {
-        return evaluate(ReduceOps.makeRef(accumulator));
-    }
+    public final Optional<P_OUT> reduce(BinaryOperator<P_OUT> accumulator) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(ReduceOps.makeRef(accumulator));
+//    }
 
     @Override
-    public final <R> R reduce(R identity, BiFunction<R, ? super P_OUT, R> accumulator, BinaryOperator<R> combiner) {
-        return evaluate(ReduceOps.makeRef(identity, accumulator, combiner));
-    }
+    public final <R> R reduce(R identity, BiFunction<R, ? super P_OUT, R> accumulator, BinaryOperator<R> combiner) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(ReduceOps.makeRef(identity, accumulator, combiner));
+//    }
 
     @Override
     @SuppressWarnings("unchecked")
-    public final <R, A> R collect(Collector<? super P_OUT, A, R> collector) {
-        A container;
-        if (isParallel()
-                && (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))
-                && (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) {
-            container = collector.supplier().get();
-            BiConsumer<A, ? super P_OUT> accumulator = collector.accumulator();
-            forEach(u -> accumulator.accept(container, u));
-        }
-        else {
-            container = evaluate(ReduceOps.makeRef(collector));
-        }
-        return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)
-               ? (R) container
-               : collector.finisher().apply(container);
-    }
+    public final <R, A> R collect(Collector<? super P_OUT, A, R> collector) {throw new RuntimeException("cf-bug");} //{
+//        A container;
+//        if (isParallel()
+//                && (collector.characteristics().contains(Collector.Characteristics.CONCURRENT))
+//                && (!isOrdered() || collector.characteristics().contains(Collector.Characteristics.UNORDERED))) {
+//            container = collector.supplier().get();
+//            BiConsumer<A, ? super P_OUT> accumulator = collector.accumulator();
+//            forEach(u -> accumulator.accept(container, u));
+//        }
+//        else {
+//            container = evaluate(ReduceOps.makeRef(collector));
+//        }
+//        return collector.characteristics().contains(Collector.Characteristics.IDENTITY_FINISH)
+//               ? (R) container
+//               : collector.finisher().apply(container);
+//    }
 
     @Override
     public final <R> R collect(Supplier<R> supplier,
                                BiConsumer<R, ? super P_OUT> accumulator,
-                               BiConsumer<R, R> combiner) {
-        return evaluate(ReduceOps.makeRef(supplier, accumulator, combiner));
-    }
+                               BiConsumer<R, R> combiner) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(ReduceOps.makeRef(supplier, accumulator, combiner));
+//    }
 
     @Override
-    public final Optional<P_OUT> max(Comparator<? super P_OUT> comparator) {
-        return reduce(BinaryOperator.maxBy(comparator));
-    }
+    public final Optional<P_OUT> max(Comparator<? super P_OUT> comparator) {throw new RuntimeException("cf-bug");} //{
+//        return reduce(BinaryOperator.maxBy(comparator));
+//    }
 
     @Override
-    public final Optional<P_OUT> min(Comparator<? super P_OUT> comparator) {
-        return reduce(BinaryOperator.minBy(comparator));
-
-    }
+    public final Optional<P_OUT> min(Comparator<? super P_OUT> comparator) {throw new RuntimeException("cf-bug");} //{
+//        return reduce(BinaryOperator.minBy(comparator));
+//
+//    }
 
     @Override
-    public final long count() {
-        return mapToLong(e -> 1L).sum();
-    }
+    public final long count() {throw new RuntimeException("cf-bug");} //{
+//        return mapToLong(e -> 1L).sum();
+//    }
 
 
     //
@@ -563,36 +563,36 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            throw new UnsupportedOperationException();
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            throw new UnsupportedOperationException();
+//        }
 
         @Override
-        final Sink<E_IN> opWrapSink(int flags, Sink<E_OUT> sink) {
-            throw new UnsupportedOperationException();
-        }
+        final Sink<E_IN> opWrapSink(int flags, Sink<E_OUT> sink) {throw new RuntimeException("cf-bug");} //{
+//            throw new UnsupportedOperationException();
+//        }
 
         // Optimized sequential terminal operations for the head of the pipeline
 
         @Override
-        public void forEach(Consumer<? super E_OUT> action) {
-            if (!isParallel()) {
-                sourceStageSpliterator().forEachRemaining(action);
-            }
-            else {
-                super.forEach(action);
-            }
-        }
+        public void forEach(Consumer<? super E_OUT> action) {throw new RuntimeException("cf-bug");} //{
+//            if (!isParallel()) {
+//                sourceStageSpliterator().forEachRemaining(action);
+//            }
+//            else {
+//                super.forEach(action);
+//            }
+//        }
 
         @Override
-        public void forEachOrdered(Consumer<? super E_OUT> action) {
-            if (!isParallel()) {
-                sourceStageSpliterator().forEachRemaining(action);
-            }
-            else {
-                super.forEachOrdered(action);
-            }
-        }
+        public void forEachOrdered(Consumer<? super E_OUT> action) {throw new RuntimeException("cf-bug");} //{
+//            if (!isParallel()) {
+//                sourceStageSpliterator().forEachRemaining(action);
+//            }
+//            else {
+//                super.forEachOrdered(action);
+//            }
+//        }
     }
 
     /**
@@ -620,9 +620,9 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            return false;
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            return false;
+//        }
     }
 
     /**
@@ -649,9 +649,9 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            return true;
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            return true;
+//        }
 
         @Override
         abstract <P_IN> Node<E_OUT> opEvaluateParallel(PipelineHelper<E_OUT> helper,
--- a/java/util/stream/DoublePipeline.java	2016-06-22 19:56:58.586377647 -0700
+++ b/java/util/stream/DoublePipeline.java	2016-06-29 11:33:10.947231954 -0700
@@ -94,16 +94,16 @@
      * Adapt a {@code Sink<Double> to a {@code DoubleConsumer}, ideally simply
      * by casting.
      */
-    private static DoubleConsumer adapt(Sink<Double> sink) {
-        if (sink instanceof DoubleConsumer) {
-            return (DoubleConsumer) sink;
-        } else {
-            if (Tripwire.ENABLED)
-                Tripwire.trip(AbstractPipeline.class,
-                              "using DoubleStream.adapt(Sink<Double> s)");
-            return sink::accept;
-        }
-    }
+    private static DoubleConsumer adapt(Sink<Double> sink) {throw new RuntimeException("cf-bug");} //{
+//        if (sink instanceof DoubleConsumer) {
+//            return (DoubleConsumer) sink;
+//        } else {
+//            if (Tripwire.ENABLED)
+//                Tripwire.trip(AbstractPipeline.class,
+//                              "using DoubleStream.adapt(Sink<Double> s)");
+//            return sink::accept;
+//        }
+//    }
 
     /**
      * Adapt a {@code Spliterator<Double>} to a {@code Spliterator.OfDouble}.
@@ -112,302 +112,302 @@
      * The implementation attempts to cast to a Spliterator.OfDouble, and throws
      * an exception if this cast is not possible.
      */
-    private static Spliterator.OfDouble adapt(Spliterator<Double> s) {
-        if (s instanceof Spliterator.OfDouble) {
-            return (Spliterator.OfDouble) s;
-        } else {
-            if (Tripwire.ENABLED)
-                Tripwire.trip(AbstractPipeline.class,
-                              "using DoubleStream.adapt(Spliterator<Double> s)");
-            throw new UnsupportedOperationException("DoubleStream.adapt(Spliterator<Double> s)");
-        }
-    }
+    private static Spliterator.OfDouble adapt(Spliterator<Double> s) {throw new RuntimeException("cf-bug");} //{
+//        if (s instanceof Spliterator.OfDouble) {
+//            return (Spliterator.OfDouble) s;
+//        } else {
+//            if (Tripwire.ENABLED)
+//                Tripwire.trip(AbstractPipeline.class,
+//                              "using DoubleStream.adapt(Spliterator<Double> s)");
+//            throw new UnsupportedOperationException("DoubleStream.adapt(Spliterator<Double> s)");
+//        }
+//    }
 
 
     // Shape-specific methods
 
     @Override
-    final StreamShape getOutputShape() {
-        return StreamShape.DOUBLE_VALUE;
-    }
+    final StreamShape getOutputShape() {throw new RuntimeException("cf-bug");} //{
+//        return StreamShape.DOUBLE_VALUE;
+//    }
 
     @Override
     final <P_IN> Node<Double> evaluateToNode(PipelineHelper<Double> helper,
                                              Spliterator<P_IN> spliterator,
                                              boolean flattenTree,
-                                             IntFunction<Double[]> generator) {
-        return Nodes.collectDouble(helper, spliterator, flattenTree);
-    }
+                                             IntFunction<Double[]> generator) {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.collectDouble(helper, spliterator, flattenTree);
+//    }
 
     @Override
     final <P_IN> Spliterator<Double> wrap(PipelineHelper<Double> ph,
                                           Supplier<Spliterator<P_IN>> supplier,
-                                          boolean isParallel) {
-        return new StreamSpliterators.DoubleWrappingSpliterator<>(ph, supplier, isParallel);
-    }
+                                          boolean isParallel) {throw new RuntimeException("cf-bug");} //{
+//        return new StreamSpliterators.DoubleWrappingSpliterator<>(ph, supplier, isParallel);
+//    }
 
     @Override
     @SuppressWarnings("unchecked")
-    final Spliterator.OfDouble lazySpliterator(Supplier<? extends Spliterator<Double>> supplier) {
-        return new StreamSpliterators.DelegatingSpliterator.OfDouble((Supplier<Spliterator.OfDouble>) supplier);
-    }
+    final Spliterator.OfDouble lazySpliterator(Supplier<? extends Spliterator<Double>> supplier) {throw new RuntimeException("cf-bug");} //{
+//        return new StreamSpliterators.DelegatingSpliterator.OfDouble((Supplier<Spliterator.OfDouble>) supplier);
+//    }
 
     @Override
-    final void forEachWithCancel(Spliterator<Double> spliterator, Sink<Double> sink) {
-        Spliterator.OfDouble spl = adapt(spliterator);
-        DoubleConsumer adaptedSink = adapt(sink);
-        do { } while (!sink.cancellationRequested() && spl.tryAdvance(adaptedSink));
-    }
+    final void forEachWithCancel(Spliterator<Double> spliterator, Sink<Double> sink) {throw new RuntimeException("cf-bug");} //{
+//        Spliterator.OfDouble spl = adapt(spliterator);
+//        DoubleConsumer adaptedSink = adapt(sink);
+//        do { } while (!sink.cancellationRequested() && spl.tryAdvance(adaptedSink));
+//    }
 
     @Override
-    final  Node.Builder<Double> makeNodeBuilder(long exactSizeIfKnown, IntFunction<Double[]> generator) {
-        return Nodes.doubleBuilder(exactSizeIfKnown);
-    }
+    final  Node.Builder<Double> makeNodeBuilder(long exactSizeIfKnown, IntFunction<Double[]> generator) {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.doubleBuilder(exactSizeIfKnown);
+//    }
 
 
     // DoubleStream
 
     @Override
-    public final PrimitiveIterator.OfDouble iterator() {
-        return Spliterators.iterator(spliterator());
-    }
+    public final PrimitiveIterator.OfDouble iterator() {throw new RuntimeException("cf-bug");} //{
+//        return Spliterators.iterator(spliterator());
+//    }
 
     @Override
-    public final Spliterator.OfDouble spliterator() {
-        return adapt(super.spliterator());
-    }
+    public final Spliterator.OfDouble spliterator() {throw new RuntimeException("cf-bug");} //{
+//        return adapt(super.spliterator());
+//    }
 
     // Stateless intermediate ops from DoubleStream
 
     @Override
-    public final Stream<Double> boxed() {
-        return mapToObj(Double::valueOf);
-    }
-
-    @Override
-    public final DoubleStream map(DoubleUnaryOperator mapper) {
-        Objects.requireNonNull(mapper);
-        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                       StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedDouble<Double>(sink) {
-                    @Override
-                    public void accept(double t) {
-                        downstream.accept(mapper.applyAsDouble(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final <U> Stream<U> mapToObj(DoubleFunction<? extends U> mapper) {
-        Objects.requireNonNull(mapper);
-        return new ReferencePipeline.StatelessOp<Double, U>(this, StreamShape.DOUBLE_VALUE,
-                                                            StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Double> opWrapSink(int flags, Sink<U> sink) {
-                return new Sink.ChainedDouble<U>(sink) {
-                    @Override
-                    public void accept(double t) {
-                        downstream.accept(mapper.apply(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final IntStream mapToInt(DoubleToIntFunction mapper) {
-        Objects.requireNonNull(mapper);
-        return new IntPipeline.StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                                   StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Double> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedDouble<Integer>(sink) {
-                    @Override
-                    public void accept(double t) {
-                        downstream.accept(mapper.applyAsInt(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final LongStream mapToLong(DoubleToLongFunction mapper) {
-        Objects.requireNonNull(mapper);
-        return new LongPipeline.StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Double> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedDouble<Long>(sink) {
-                    @Override
-                    public void accept(double t) {
-                        downstream.accept(mapper.applyAsLong(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final DoubleStream flatMap(DoubleFunction<? extends DoubleStream> mapper) {
-        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedDouble<Double>(sink) {
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(double t) {
-                        try (DoubleStream result = mapper.apply(t)) {
-                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
-                            if (result != null)
-                                result.sequential().forEach(i -> downstream.accept(i));
-                        }
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public DoubleStream unordered() {
-        if (!isOrdered())
-            return this;
-        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE, StreamOpFlag.NOT_ORDERED) {
-            @Override
-            Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
-                return sink;
-            }
-        };
-    }
-
-    @Override
-    public final DoubleStream filter(DoublePredicate predicate) {
-        Objects.requireNonNull(predicate);
-        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                       StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedDouble<Double>(sink) {
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(double t) {
-                        if (predicate.test(t))
-                            downstream.accept(t);
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final DoubleStream peek(DoubleConsumer action) {
-        Objects.requireNonNull(action);
-        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
-                                       0) {
-            @Override
-            Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedDouble<Double>(sink) {
-                    @Override
-                    public void accept(double t) {
-                        action.accept(t);
-                        downstream.accept(t);
-                    }
-                };
-            }
-        };
-    }
+    public final Stream<Double> boxed() {throw new RuntimeException("cf-bug");} //{
+//        return mapToObj(Double::valueOf);
+//    }
+
+    @Override
+    public final DoubleStream map(DoubleUnaryOperator mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
+//                                       StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
+//                return new Sink.ChainedDouble<Double>(sink) {
+//                    @Override
+//                    public void accept(double t) {
+//                        downstream.accept(mapper.applyAsDouble(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final <U> Stream<U> mapToObj(DoubleFunction<? extends U> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new ReferencePipeline.StatelessOp<Double, U>(this, StreamShape.DOUBLE_VALUE,
+//                                                            StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Double> opWrapSink(int flags, Sink<U> sink) {
+//                return new Sink.ChainedDouble<U>(sink) {
+//                    @Override
+//                    public void accept(double t) {
+//                        downstream.accept(mapper.apply(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final IntStream mapToInt(DoubleToIntFunction mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new IntPipeline.StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
+//                                                   StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Double> opWrapSink(int flags, Sink<Integer> sink) {
+//                return new Sink.ChainedDouble<Integer>(sink) {
+//                    @Override
+//                    public void accept(double t) {
+//                        downstream.accept(mapper.applyAsInt(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final LongStream mapToLong(DoubleToLongFunction mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new LongPipeline.StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
+//                                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Double> opWrapSink(int flags, Sink<Long> sink) {
+//                return new Sink.ChainedDouble<Long>(sink) {
+//                    @Override
+//                    public void accept(double t) {
+//                        downstream.accept(mapper.applyAsLong(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final DoubleStream flatMap(DoubleFunction<? extends DoubleStream> mapper) {throw new RuntimeException("cf-bug");} //{
+//        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
+//                                        StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
+//                return new Sink.ChainedDouble<Double>(sink) {
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(double t) {
+//                        try (DoubleStream result = mapper.apply(t)) {
+//                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
+//                            if (result != null)
+//                                result.sequential().forEach(i -> downstream.accept(i));
+//                        }
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public DoubleStream unordered() {throw new RuntimeException("cf-bug");} //{
+//        if (!isOrdered())
+//            return this;
+//        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE, StreamOpFlag.NOT_ORDERED) {
+//            @Override
+//            Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
+//                return sink;
+//            }
+//        };
+//    }
+
+    @Override
+    public final DoubleStream filter(DoublePredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(predicate);
+//        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
+//                                       StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
+//                return new Sink.ChainedDouble<Double>(sink) {
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(double t) {
+//                        if (predicate.test(t))
+//                            downstream.accept(t);
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final DoubleStream peek(DoubleConsumer action) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(action);
+//        return new StatelessOp<Double>(this, StreamShape.DOUBLE_VALUE,
+//                                       0) {
+//            @Override
+//            Sink<Double> opWrapSink(int flags, Sink<Double> sink) {
+//                return new Sink.ChainedDouble<Double>(sink) {
+//                    @Override
+//                    public void accept(double t) {
+//                        action.accept(t);
+//                        downstream.accept(t);
+//                    }
+//                };
+//            }
+//        };
+//    }
 
     // Stateful intermediate ops from DoubleStream
 
     @Override
-    public final DoubleStream limit(long maxSize) {
-        if (maxSize < 0)
-            throw new IllegalArgumentException(Long.toString(maxSize));
-        return SliceOps.makeDouble(this, (long) 0, maxSize);
-    }
-
-    @Override
-    public final DoubleStream skip(long n) {
-        if (n < 0)
-            throw new IllegalArgumentException(Long.toString(n));
-        if (n == 0)
-            return this;
-        else {
-            long limit = -1;
-            return SliceOps.makeDouble(this, n, limit);
-        }
-    }
-
-    @Override
-    public final DoubleStream sorted() {
-        return SortedOps.makeDouble(this);
-    }
-
-    @Override
-    public final DoubleStream distinct() {
-        // While functional and quick to implement, this approach is not very efficient.
-        // An efficient version requires a double-specific map/set implementation.
-        return boxed().distinct().mapToDouble(i -> (double) i);
-    }
+    public final DoubleStream limit(long maxSize) {throw new RuntimeException("cf-bug");} //{
+//        if (maxSize < 0)
+//            throw new IllegalArgumentException(Long.toString(maxSize));
+//        return SliceOps.makeDouble(this, (long) 0, maxSize);
+//    }
+
+    @Override
+    public final DoubleStream skip(long n) {throw new RuntimeException("cf-bug");} //{
+//        if (n < 0)
+//            throw new IllegalArgumentException(Long.toString(n));
+//        if (n == 0)
+//            return this;
+//        else {
+//            long limit = -1;
+//            return SliceOps.makeDouble(this, n, limit);
+//        }
+//    }
+
+    @Override
+    public final DoubleStream sorted() {throw new RuntimeException("cf-bug");} //{
+//        return SortedOps.makeDouble(this);
+//    }
+
+    @Override
+    public final DoubleStream distinct() {throw new RuntimeException("cf-bug");} //{
+//        // While functional and quick to implement, this approach is not very efficient.
+//        // An efficient version requires a double-specific map/set implementation.
+//        return boxed().distinct().mapToDouble(i -> (double) i);
+//    }
 
     // Terminal ops from DoubleStream
 
     @Override
-    public void forEach(DoubleConsumer consumer) {
-        evaluate(ForEachOps.makeDouble(consumer, false));
-    }
-
-    @Override
-    public void forEachOrdered(DoubleConsumer consumer) {
-        evaluate(ForEachOps.makeDouble(consumer, true));
-    }
-
-    @Override
-    public final double sum() {
-        /*
-         * In the arrays allocated for the collect operation, index 0
-         * holds the high-order bits of the running sum, index 1 holds
-         * the low-order bits of the sum computed via compensated
-         * summation, and index 2 holds the simple sum used to compute
-         * the proper result if the stream contains infinite values of
-         * the same sign.
-         */
-        double[] summation = collect(() -> new double[3],
-                               (ll, d) -> {
-                                   Collectors.sumWithCompensation(ll, d);
-                                   ll[2] += d;
-                               },
-                               (ll, rr) -> {
-                                   Collectors.sumWithCompensation(ll, rr[0]);
-                                   Collectors.sumWithCompensation(ll, rr[1]);
-                                   ll[2] += rr[2];
-                               });
-
-        return Collectors.computeFinalSum(summation);
-    }
-
-    @Override
-    public final OptionalDouble min() {
-        return reduce(Math::min);
-    }
-
-    @Override
-    public final OptionalDouble max() {
-        return reduce(Math::max);
-    }
+    public void forEach(DoubleConsumer consumer) {throw new RuntimeException("cf-bug");} //{
+//        evaluate(ForEachOps.makeDouble(consumer, false));
+//    }
+
+    @Override
+    public void forEachOrdered(DoubleConsumer consumer) {throw new RuntimeException("cf-bug");} //{
+//        evaluate(ForEachOps.makeDouble(consumer, true));
+//    }
+
+    @Override
+    public final double sum() {throw new RuntimeException("cf-bug");} //{
+//        /*
+//         * In the arrays allocated for the collect operation, index 0
+//         * holds the high-order bits of the running sum, index 1 holds
+//         * the low-order bits of the sum computed via compensated
+//         * summation, and index 2 holds the simple sum used to compute
+//         * the proper result if the stream contains infinite values of
+//         * the same sign.
+//         */
+//        double[] summation = collect(() -> new double[3],
+//                               (ll, d) -> {
+//                                   Collectors.sumWithCompensation(ll, d);
+//                                   ll[2] += d;
+//                               },
+//                               (ll, rr) -> {
+//                                   Collectors.sumWithCompensation(ll, rr[0]);
+//                                   Collectors.sumWithCompensation(ll, rr[1]);
+//                                   ll[2] += rr[2];
+//                               });
+//
+//        return Collectors.computeFinalSum(summation);
+//    }
+
+    @Override
+    public final OptionalDouble min() {throw new RuntimeException("cf-bug");} //{
+//        return reduce(Math::min);
+//    }
+
+    @Override
+    public final OptionalDouble max() {throw new RuntimeException("cf-bug");} //{
+//        return reduce(Math::max);
+//    }
 
     /**
      * {@inheritDoc}
@@ -419,93 +419,93 @@
      * 2<sup>53</sup>, leading to additional numerical errors.
      */
     @Override
-    public final OptionalDouble average() {
-        /*
-         * In the arrays allocated for the collect operation, index 0
-         * holds the high-order bits of the running sum, index 1 holds
-         * the low-order bits of the sum computed via compensated
-         * summation, index 2 holds the number of values seen, index 3
-         * holds the simple sum.
-         */
-        double[] avg = collect(() -> new double[4],
-                               (ll, d) -> {
-                                   ll[2]++;
-                                   Collectors.sumWithCompensation(ll, d);
-                                   ll[3] += d;
-                               },
-                               (ll, rr) -> {
-                                   Collectors.sumWithCompensation(ll, rr[0]);
-                                   Collectors.sumWithCompensation(ll, rr[1]);
-                                   ll[2] += rr[2];
-                                   ll[3] += rr[3];
-                               });
-        return avg[2] > 0
-            ? OptionalDouble.of(Collectors.computeFinalSum(avg) / avg[2])
-            : OptionalDouble.empty();
-    }
-
-    @Override
-    public final long count() {
-        return mapToLong(e -> 1L).sum();
-    }
-
-    @Override
-    public final DoubleSummaryStatistics summaryStatistics() {
-        return collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept,
-                       DoubleSummaryStatistics::combine);
-    }
-
-    @Override
-    public final double reduce(double identity, DoubleBinaryOperator op) {
-        return evaluate(ReduceOps.makeDouble(identity, op));
-    }
-
-    @Override
-    public final OptionalDouble reduce(DoubleBinaryOperator op) {
-        return evaluate(ReduceOps.makeDouble(op));
-    }
+    public final OptionalDouble average() {throw new RuntimeException("cf-bug");} //{
+//        /*
+//         * In the arrays allocated for the collect operation, index 0
+//         * holds the high-order bits of the running sum, index 1 holds
+//         * the low-order bits of the sum computed via compensated
+//         * summation, index 2 holds the number of values seen, index 3
+//         * holds the simple sum.
+//         */
+//        double[] avg = collect(() -> new double[4],
+//                               (ll, d) -> {
+//                                   ll[2]++;
+//                                   Collectors.sumWithCompensation(ll, d);
+//                                   ll[3] += d;
+//                               },
+//                               (ll, rr) -> {
+//                                   Collectors.sumWithCompensation(ll, rr[0]);
+//                                   Collectors.sumWithCompensation(ll, rr[1]);
+//                                   ll[2] += rr[2];
+//                                   ll[3] += rr[3];
+//                               });
+//        return avg[2] > 0
+//            ? OptionalDouble.of(Collectors.computeFinalSum(avg) / avg[2])
+//            : OptionalDouble.empty();
+//    }
+
+    @Override
+    public final long count() {throw new RuntimeException("cf-bug");} //{
+//        return mapToLong(e -> 1L).sum();
+//    }
+
+    @Override
+    public final DoubleSummaryStatistics summaryStatistics() {throw new RuntimeException("cf-bug");} //{
+//        return collect(DoubleSummaryStatistics::new, DoubleSummaryStatistics::accept,
+//                       DoubleSummaryStatistics::combine);
+//    }
+
+    @Override
+    public final double reduce(double identity, DoubleBinaryOperator op) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(ReduceOps.makeDouble(identity, op));
+//    }
+
+    @Override
+    public final OptionalDouble reduce(DoubleBinaryOperator op) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(ReduceOps.makeDouble(op));
+//    }
 
     @Override
     public final <R> R collect(Supplier<R> supplier,
                                ObjDoubleConsumer<R> accumulator,
-                               BiConsumer<R, R> combiner) {
-        BinaryOperator<R> operator = (left, right) -> {
-            combiner.accept(left, right);
-            return left;
-        };
-        return evaluate(ReduceOps.makeDouble(supplier, accumulator, operator));
-    }
+                               BiConsumer<R, R> combiner) {throw new RuntimeException("cf-bug");} //{
+//        BinaryOperator<R> operator = (left, right) -> {
+//            combiner.accept(left, right);
+//            return left;
+//        };
+//        return evaluate(ReduceOps.makeDouble(supplier, accumulator, operator));
+//    }
 
     @Override
-    public final boolean anyMatch(DoublePredicate predicate) {
-        return evaluate(MatchOps.makeDouble(predicate, MatchOps.MatchKind.ANY));
-    }
+    public final boolean anyMatch(DoublePredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeDouble(predicate, MatchOps.MatchKind.ANY));
+//    }
 
     @Override
-    public final boolean allMatch(DoublePredicate predicate) {
-        return evaluate(MatchOps.makeDouble(predicate, MatchOps.MatchKind.ALL));
-    }
+    public final boolean allMatch(DoublePredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeDouble(predicate, MatchOps.MatchKind.ALL));
+//    }
 
     @Override
-    public final boolean noneMatch(DoublePredicate predicate) {
-        return evaluate(MatchOps.makeDouble(predicate, MatchOps.MatchKind.NONE));
-    }
+    public final boolean noneMatch(DoublePredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeDouble(predicate, MatchOps.MatchKind.NONE));
+//    }
 
     @Override
-    public final OptionalDouble findFirst() {
-        return evaluate(FindOps.makeDouble(true));
-    }
+    public final OptionalDouble findFirst() {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(FindOps.makeDouble(true));
+//    }
 
     @Override
-    public final OptionalDouble findAny() {
-        return evaluate(FindOps.makeDouble(false));
-    }
+    public final OptionalDouble findAny() {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(FindOps.makeDouble(false));
+//    }
 
     @Override
-    public final double[] toArray() {
-        return Nodes.flattenDouble((Node.OfDouble) evaluateToArrayNode(Double[]::new))
-                        .asPrimitiveArray();
-    }
+    public final double[] toArray() {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.flattenDouble((Node.OfDouble) evaluateToArrayNode(Double[]::new))
+//                        .asPrimitiveArray();
+//    }
 
     //
 
@@ -543,36 +543,36 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            throw new UnsupportedOperationException();
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            throw new UnsupportedOperationException();
+//        }
 
         @Override
-        final Sink<E_IN> opWrapSink(int flags, Sink<Double> sink) {
-            throw new UnsupportedOperationException();
-        }
+        final Sink<E_IN> opWrapSink(int flags, Sink<Double> sink) {throw new RuntimeException("cf-bug");} //{
+//            throw new UnsupportedOperationException();
+//        }
 
         // Optimized sequential terminal operations for the head of the pipeline
 
         @Override
-        public void forEach(DoubleConsumer consumer) {
-            if (!isParallel()) {
-                adapt(sourceStageSpliterator()).forEachRemaining(consumer);
-            }
-            else {
-                super.forEach(consumer);
-            }
-        }
+        public void forEach(DoubleConsumer consumer) {throw new RuntimeException("cf-bug");} //{
+//            if (!isParallel()) {
+//                adapt(sourceStageSpliterator()).forEachRemaining(consumer);
+//            }
+//            else {
+//                super.forEach(consumer);
+//            }
+//        }
 
         @Override
-        public void forEachOrdered(DoubleConsumer consumer) {
-            if (!isParallel()) {
-                adapt(sourceStageSpliterator()).forEachRemaining(consumer);
-            }
-            else {
-                super.forEachOrdered(consumer);
-            }
-        }
+        public void forEachOrdered(DoubleConsumer consumer) {throw new RuntimeException("cf-bug");} //{
+//            if (!isParallel()) {
+//                adapt(sourceStageSpliterator()).forEachRemaining(consumer);
+//            }
+//            else {
+//                super.forEachOrdered(consumer);
+//            }
+//        }
 
     }
 
@@ -599,9 +599,9 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            return false;
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            return false;
+//        }
     }
 
     /**
@@ -627,9 +627,9 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            return true;
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            return true;
+//        }
 
         @Override
         abstract <P_IN> Node<Double> opEvaluateParallel(PipelineHelper<Double> helper,
--- a/java/util/stream/LongPipeline.java	2016-06-22 19:56:58.676378091 -0700
+++ b/java/util/stream/LongPipeline.java	2016-06-29 11:30:52.608568124 -0700
@@ -95,16 +95,16 @@
      * Adapt a {@code Sink<Long> to an {@code LongConsumer}, ideally simply
      * by casting.
      */
-    private static LongConsumer adapt(Sink<Long> sink) {
-        if (sink instanceof LongConsumer) {
-            return (LongConsumer) sink;
-        } else {
-            if (Tripwire.ENABLED)
-                Tripwire.trip(AbstractPipeline.class,
-                              "using LongStream.adapt(Sink<Long> s)");
-            return sink::accept;
-        }
-    }
+    private static LongConsumer adapt(Sink<Long> sink) {throw new RuntimeException("cf-bug");} //{
+//        if (sink instanceof LongConsumer) {
+//            return (LongConsumer) sink;
+//        } else {
+//            if (Tripwire.ENABLED)
+//                Tripwire.trip(AbstractPipeline.class,
+//                              "using LongStream.adapt(Sink<Long> s)");
+//            return sink::accept;
+//        }
+//    }
 
     /**
      * Adapt a {@code Spliterator<Long>} to a {@code Spliterator.OfLong}.
@@ -113,377 +113,377 @@
      * The implementation attempts to cast to a Spliterator.OfLong, and throws
      * an exception if this cast is not possible.
      */
-    private static Spliterator.OfLong adapt(Spliterator<Long> s) {
-        if (s instanceof Spliterator.OfLong) {
-            return (Spliterator.OfLong) s;
-        } else {
-            if (Tripwire.ENABLED)
-                Tripwire.trip(AbstractPipeline.class,
-                              "using LongStream.adapt(Spliterator<Long> s)");
-            throw new UnsupportedOperationException("LongStream.adapt(Spliterator<Long> s)");
-        }
-    }
+    private static Spliterator.OfLong adapt(Spliterator<Long> s) {throw new RuntimeException("cf-bug");} //{
+//        if (s instanceof Spliterator.OfLong) {
+//            return (Spliterator.OfLong) s;
+//        } else {
+//            if (Tripwire.ENABLED)
+//                Tripwire.trip(AbstractPipeline.class,
+//                              "using LongStream.adapt(Spliterator<Long> s)");
+//            throw new UnsupportedOperationException("LongStream.adapt(Spliterator<Long> s)");
+//        }
+//    }
 
 
     // Shape-specific methods
 
     @Override
-    final StreamShape getOutputShape() {
-        return StreamShape.LONG_VALUE;
-    }
+    final StreamShape getOutputShape() {throw new RuntimeException("cf-bug");} //{
+//        return StreamShape.LONG_VALUE;
+//    }
 
     @Override
     final <P_IN> Node<Long> evaluateToNode(PipelineHelper<Long> helper,
                                            Spliterator<P_IN> spliterator,
                                            boolean flattenTree,
-                                           IntFunction<Long[]> generator) {
-        return Nodes.collectLong(helper, spliterator, flattenTree);
-    }
+                                           IntFunction<Long[]> generator) {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.collectLong(helper, spliterator, flattenTree);
+//    }
 
     @Override
     final <P_IN> Spliterator<Long> wrap(PipelineHelper<Long> ph,
                                         Supplier<Spliterator<P_IN>> supplier,
-                                        boolean isParallel) {
-        return new StreamSpliterators.LongWrappingSpliterator<>(ph, supplier, isParallel);
-    }
+                                        boolean isParallel) {throw new RuntimeException("cf-bug");} //{
+//        return new StreamSpliterators.LongWrappingSpliterator<>(ph, supplier, isParallel);
+//    }
 
     @Override
     @SuppressWarnings("unchecked")
-    final Spliterator.OfLong lazySpliterator(Supplier<? extends Spliterator<Long>> supplier) {
-        return new StreamSpliterators.DelegatingSpliterator.OfLong((Supplier<Spliterator.OfLong>) supplier);
-    }
+    final Spliterator.OfLong lazySpliterator(Supplier<? extends Spliterator<Long>> supplier) {throw new RuntimeException("cf-bug");} //{
+//        return new StreamSpliterators.DelegatingSpliterator.OfLong((Supplier<Spliterator.OfLong>) supplier);
+//    }
 
     @Override
-    final void forEachWithCancel(Spliterator<Long> spliterator, Sink<Long> sink) {
-        Spliterator.OfLong spl = adapt(spliterator);
-        LongConsumer adaptedSink =  adapt(sink);
-        do { } while (!sink.cancellationRequested() && spl.tryAdvance(adaptedSink));
-    }
+    final void forEachWithCancel(Spliterator<Long> spliterator, Sink<Long> sink) {throw new RuntimeException("cf-bug");} //{
+//        Spliterator.OfLong spl = adapt(spliterator);
+//        LongConsumer adaptedSink =  adapt(sink);
+//        do { } while (!sink.cancellationRequested() && spl.tryAdvance(adaptedSink));
+//    }
 
     @Override
-    final Node.Builder<Long> makeNodeBuilder(long exactSizeIfKnown, IntFunction<Long[]> generator) {
-        return Nodes.longBuilder(exactSizeIfKnown);
-    }
+    final Node.Builder<Long> makeNodeBuilder(long exactSizeIfKnown, IntFunction<Long[]> generator) {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.longBuilder(exactSizeIfKnown);
+//    }
 
 
     // LongStream
 
     @Override
-    public final PrimitiveIterator.OfLong iterator() {
-        return Spliterators.iterator(spliterator());
-    }
+    public final PrimitiveIterator.OfLong iterator() {throw new RuntimeException("cf-bug");} //{
+//        return Spliterators.iterator(spliterator());
+//    }
 
     @Override
-    public final Spliterator.OfLong spliterator() {
-        return adapt(super.spliterator());
-    }
+    public final Spliterator.OfLong spliterator() {throw new RuntimeException("cf-bug");} //{
+//        return adapt(super.spliterator());
+//    }
 
     // Stateless intermediate ops from LongStream
 
     @Override
-    public final DoubleStream asDoubleStream() {
-        return new DoublePipeline.StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Long> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedLong<Double>(sink) {
-                    @Override
-                    public void accept(long t) {
-                        downstream.accept((double) t);
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final Stream<Long> boxed() {
-        return mapToObj(Long::valueOf);
-    }
-
-    @Override
-    public final LongStream map(LongUnaryOperator mapper) {
-        Objects.requireNonNull(mapper);
-        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedLong<Long>(sink) {
-                    @Override
-                    public void accept(long t) {
-                        downstream.accept(mapper.applyAsLong(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final <U> Stream<U> mapToObj(LongFunction<? extends U> mapper) {
-        Objects.requireNonNull(mapper);
-        return new ReferencePipeline.StatelessOp<Long, U>(this, StreamShape.LONG_VALUE,
-                                                          StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Long> opWrapSink(int flags, Sink<U> sink) {
-                return new Sink.ChainedLong<U>(sink) {
-                    @Override
-                    public void accept(long t) {
-                        downstream.accept(mapper.apply(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final IntStream mapToInt(LongToIntFunction mapper) {
-        Objects.requireNonNull(mapper);
-        return new IntPipeline.StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Long> opWrapSink(int flags, Sink<Integer> sink) {
-                return new Sink.ChainedLong<Integer>(sink) {
-                    @Override
-                    public void accept(long t) {
-                        downstream.accept(mapper.applyAsInt(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final DoubleStream mapToDouble(LongToDoubleFunction mapper) {
-        Objects.requireNonNull(mapper);
-        return new DoublePipeline.StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
-            @Override
-            Sink<Long> opWrapSink(int flags, Sink<Double> sink) {
-                return new Sink.ChainedLong<Double>(sink) {
-                    @Override
-                    public void accept(long t) {
-                        downstream.accept(mapper.applyAsDouble(t));
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final LongStream flatMap(LongFunction<? extends LongStream> mapper) {
-        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedLong<Long>(sink) {
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(long t) {
-                        try (LongStream result = mapper.apply(t)) {
-                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
-                            if (result != null)
-                                result.sequential().forEach(i -> downstream.accept(i));
-                        }
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public LongStream unordered() {
-        if (!isOrdered())
-            return this;
-        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE, StreamOpFlag.NOT_ORDERED) {
-            @Override
-            Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
-                return sink;
-            }
-        };
-    }
-
-    @Override
-    public final LongStream filter(LongPredicate predicate) {
-        Objects.requireNonNull(predicate);
-        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                     StreamOpFlag.NOT_SIZED) {
-            @Override
-            Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedLong<Long>(sink) {
-                    @Override
-                    public void begin(long size) {
-                        downstream.begin(-1);
-                    }
-
-                    @Override
-                    public void accept(long t) {
-                        if (predicate.test(t))
-                            downstream.accept(t);
-                    }
-                };
-            }
-        };
-    }
-
-    @Override
-    public final LongStream peek(LongConsumer action) {
-        Objects.requireNonNull(action);
-        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
-                                     0) {
-            @Override
-            Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
-                return new Sink.ChainedLong<Long>(sink) {
-                    @Override
-                    public void accept(long t) {
-                        action.accept(t);
-                        downstream.accept(t);
-                    }
-                };
-            }
-        };
-    }
+    public final DoubleStream asDoubleStream() {throw new RuntimeException("cf-bug");} //{
+//        return new DoublePipeline.StatelessOp<Long>(this, StreamShape.LONG_VALUE,
+//                                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Long> opWrapSink(int flags, Sink<Double> sink) {
+//                return new Sink.ChainedLong<Double>(sink) {
+//                    @Override
+//                    public void accept(long t) {
+//                        downstream.accept((double) t);
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final Stream<Long> boxed() {throw new RuntimeException("cf-bug");} //{
+//        return mapToObj(Long::valueOf);
+//    }
+
+    @Override
+    public final LongStream map(LongUnaryOperator mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
+//                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
+//                return new Sink.ChainedLong<Long>(sink) {
+//                    @Override
+//                    public void accept(long t) {
+//                        downstream.accept(mapper.applyAsLong(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final <U> Stream<U> mapToObj(LongFunction<? extends U> mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new ReferencePipeline.StatelessOp<Long, U>(this, StreamShape.LONG_VALUE,
+//                                                          StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Long> opWrapSink(int flags, Sink<U> sink) {
+//                return new Sink.ChainedLong<U>(sink) {
+//                    @Override
+//                    public void accept(long t) {
+//                        downstream.accept(mapper.apply(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final IntStream mapToInt(LongToIntFunction mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new IntPipeline.StatelessOp<Long>(this, StreamShape.LONG_VALUE,
+//                                                 StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Long> opWrapSink(int flags, Sink<Integer> sink) {
+//                return new Sink.ChainedLong<Integer>(sink) {
+//                    @Override
+//                    public void accept(long t) {
+//                        downstream.accept(mapper.applyAsInt(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final DoubleStream mapToDouble(LongToDoubleFunction mapper) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(mapper);
+//        return new DoublePipeline.StatelessOp<Long>(this, StreamShape.LONG_VALUE,
+//                                                    StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) {
+//            @Override
+//            Sink<Long> opWrapSink(int flags, Sink<Double> sink) {
+//                return new Sink.ChainedLong<Double>(sink) {
+//                    @Override
+//                    public void accept(long t) {
+//                        downstream.accept(mapper.applyAsDouble(t));
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final LongStream flatMap(LongFunction<? extends LongStream> mapper) {throw new RuntimeException("cf-bug");} //{
+//        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
+//                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT | StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
+//                return new Sink.ChainedLong<Long>(sink) {
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(long t) {
+//                        try (LongStream result = mapper.apply(t)) {
+//                            // We can do better that this too; optimize for depth=0 case and just grab spliterator and forEach it
+//                            if (result != null)
+//                                result.sequential().forEach(i -> downstream.accept(i));
+//                        }
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public LongStream unordered() {throw new RuntimeException("cf-bug");} //{
+//        if (!isOrdered())
+//            return this;
+//        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE, StreamOpFlag.NOT_ORDERED) {
+//            @Override
+//            Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
+//                return sink;
+//            }
+//        };
+//    }
+
+    @Override
+    public final LongStream filter(LongPredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(predicate);
+//        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
+//                                     StreamOpFlag.NOT_SIZED) {
+//            @Override
+//            Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
+//                return new Sink.ChainedLong<Long>(sink) {
+//                    @Override
+//                    public void begin(long size) {
+//                        downstream.begin(-1);
+//                    }
+//
+//                    @Override
+//                    public void accept(long t) {
+//                        if (predicate.test(t))
+//                            downstream.accept(t);
+//                    }
+//                };
+//            }
+//        };
+//    }
+
+    @Override
+    public final LongStream peek(LongConsumer action) {throw new RuntimeException("cf-bug");} //{
+//        Objects.requireNonNull(action);
+//        return new StatelessOp<Long>(this, StreamShape.LONG_VALUE,
+//                                     0) {
+//            @Override
+//            Sink<Long> opWrapSink(int flags, Sink<Long> sink) {
+//                return new Sink.ChainedLong<Long>(sink) {
+//                    @Override
+//                    public void accept(long t) {
+//                        action.accept(t);
+//                        downstream.accept(t);
+//                    }
+//                };
+//            }
+//        };
+//    }
 
     // Stateful intermediate ops from LongStream
 
     @Override
-    public final LongStream limit(long maxSize) {
-        if (maxSize < 0)
-            throw new IllegalArgumentException(Long.toString(maxSize));
-        return SliceOps.makeLong(this, 0, maxSize);
-    }
-
-    @Override
-    public final LongStream skip(long n) {
-        if (n < 0)
-            throw new IllegalArgumentException(Long.toString(n));
-        if (n == 0)
-            return this;
-        else
-            return SliceOps.makeLong(this, n, -1);
-    }
-
-    @Override
-    public final LongStream sorted() {
-        return SortedOps.makeLong(this);
-    }
-
-    @Override
-    public final LongStream distinct() {
-        // While functional and quick to implement, this approach is not very efficient.
-        // An efficient version requires a long-specific map/set implementation.
-        return boxed().distinct().mapToLong(i -> (long) i);
-    }
+    public final LongStream limit(long maxSize) {throw new RuntimeException("cf-bug");} //{
+//        if (maxSize < 0)
+//            throw new IllegalArgumentException(Long.toString(maxSize));
+//        return SliceOps.makeLong(this, 0, maxSize);
+//    }
+
+    @Override
+    public final LongStream skip(long n) {throw new RuntimeException("cf-bug");} //{
+//        if (n < 0)
+//            throw new IllegalArgumentException(Long.toString(n));
+//        if (n == 0)
+//            return this;
+//        else
+//            return SliceOps.makeLong(this, n, -1);
+//    }
+
+    @Override
+    public final LongStream sorted() {throw new RuntimeException("cf-bug");} //{
+//        return SortedOps.makeLong(this);
+//    }
+
+    @Override
+    public final LongStream distinct() {throw new RuntimeException("cf-bug");} //{
+//        // While functional and quick to implement, this approach is not very efficient.
+//        // An efficient version requires a long-specific map/set implementation.
+//        return boxed().distinct().mapToLong(i -> (long) i);
+//    }
 
     // Terminal ops from LongStream
 
     @Override
-    public void forEach(LongConsumer action) {
-        evaluate(ForEachOps.makeLong(action, false));
-    }
+    public void forEach(LongConsumer action) {throw new RuntimeException("cf-bug");} //{
+//        evaluate(ForEachOps.makeLong(action, false));
+//    }
 
     @Override
-    public void forEachOrdered(LongConsumer action) {
-        evaluate(ForEachOps.makeLong(action, true));
-    }
+    public void forEachOrdered(LongConsumer action) {throw new RuntimeException("cf-bug");} //{
+//        evaluate(ForEachOps.makeLong(action, true));
+//    }
 
     @Override
-    public final long sum() {
-        // use better algorithm to compensate for intermediate overflow?
-        return reduce(0, Long::sum);
-    }
+    public final long sum() {throw new RuntimeException("cf-bug");} //{
+//        // use better algorithm to compensate for intermediate overflow?
+//        return reduce(0, Long::sum);
+//    }
 
     @Override
-    public final OptionalLong min() {
-        return reduce(Math::min);
-    }
+    public final OptionalLong min() {throw new RuntimeException("cf-bug");} //{
+//        return reduce(Math::min);
+//    }
 
     @Override
-    public final OptionalLong max() {
-        return reduce(Math::max);
-    }
+    public final OptionalLong max() {throw new RuntimeException("cf-bug");} //{
+//        return reduce(Math::max);
+//    }
 
     @Override
-    public final OptionalDouble average() {
-        long[] avg = collect(() -> new long[2],
-                             (ll, i) -> {
-                                 ll[0]++;
-                                 ll[1] += i;
-                             },
-                             (ll, rr) -> {
-                                 ll[0] += rr[0];
-                                 ll[1] += rr[1];
-                             });
-        return avg[0] > 0
-               ? OptionalDouble.of((double) avg[1] / avg[0])
-               : OptionalDouble.empty();
-    }
+    public final OptionalDouble average() {throw new RuntimeException("cf-bug");} //{
+//        long[] avg = collect(() -> new long[2],
+//                             (ll, i) -> {
+//                                 ll[0]++;
+//                                 ll[1] += i;
+//                             },
+//                             (ll, rr) -> {
+//                                 ll[0] += rr[0];
+//                                 ll[1] += rr[1];
+//                             });
+//        return avg[0] > 0
+//               ? OptionalDouble.of((double) avg[1] / avg[0])
+//               : OptionalDouble.empty();
+//    }
 
     @Override
-    public final long count() {
-        return map(e -> 1L).sum();
-    }
+    public final long count() {throw new RuntimeException("cf-bug");} //{
+//        return map(e -> 1L).sum();
+//    }
 
     @Override
-    public final LongSummaryStatistics summaryStatistics() {
-        return collect(LongSummaryStatistics::new, LongSummaryStatistics::accept,
-                       LongSummaryStatistics::combine);
-    }
+    public final LongSummaryStatistics summaryStatistics() {throw new RuntimeException("cf-bug");} //{
+//        return collect(LongSummaryStatistics::new, LongSummaryStatistics::accept,
+//                       LongSummaryStatistics::combine);
+//    }
 
     @Override
-    public final long reduce(long identity, LongBinaryOperator op) {
-        return evaluate(ReduceOps.makeLong(identity, op));
-    }
+    public final long reduce(long identity, LongBinaryOperator op) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(ReduceOps.makeLong(identity, op));
+//    }
 
     @Override
-    public final OptionalLong reduce(LongBinaryOperator op) {
-        return evaluate(ReduceOps.makeLong(op));
-    }
+    public final OptionalLong reduce(LongBinaryOperator op) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(ReduceOps.makeLong(op));
+//    }
 
     @Override
     public final <R> R collect(Supplier<R> supplier,
                                ObjLongConsumer<R> accumulator,
-                               BiConsumer<R, R> combiner) {
-        BinaryOperator<R> operator = (left, right) -> {
-            combiner.accept(left, right);
-            return left;
-        };
-        return evaluate(ReduceOps.makeLong(supplier, accumulator, operator));
-    }
+                               BiConsumer<R, R> combiner) {throw new RuntimeException("cf-bug");} //{
+//        BinaryOperator<R> operator = (left, right) -> {
+//            combiner.accept(left, right);
+//            return left;
+//        };
+//        return evaluate(ReduceOps.makeLong(supplier, accumulator, operator));
+//    }
 
     @Override
-    public final boolean anyMatch(LongPredicate predicate) {
-        return evaluate(MatchOps.makeLong(predicate, MatchOps.MatchKind.ANY));
-    }
+    public final boolean anyMatch(LongPredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeLong(predicate, MatchOps.MatchKind.ANY));
+//    }
 
     @Override
-    public final boolean allMatch(LongPredicate predicate) {
-        return evaluate(MatchOps.makeLong(predicate, MatchOps.MatchKind.ALL));
-    }
+    public final boolean allMatch(LongPredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeLong(predicate, MatchOps.MatchKind.ALL));
+//    }
 
     @Override
-    public final boolean noneMatch(LongPredicate predicate) {
-        return evaluate(MatchOps.makeLong(predicate, MatchOps.MatchKind.NONE));
-    }
+    public final boolean noneMatch(LongPredicate predicate) {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(MatchOps.makeLong(predicate, MatchOps.MatchKind.NONE));
+//    }
 
     @Override
-    public final OptionalLong findFirst() {
-        return evaluate(FindOps.makeLong(true));
-    }
+    public final OptionalLong findFirst() {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(FindOps.makeLong(true));
+//    }
 
     @Override
-    public final OptionalLong findAny() {
-        return evaluate(FindOps.makeLong(false));
-    }
+    public final OptionalLong findAny() {throw new RuntimeException("cf-bug");} //{
+//        return evaluate(FindOps.makeLong(false));
+//    }
 
     @Override
-    public final long[] toArray() {
-        return Nodes.flattenLong((Node.OfLong) evaluateToArrayNode(Long[]::new))
-                .asPrimitiveArray();
-    }
+    public final long[] toArray() {throw new RuntimeException("cf-bug");} //{
+//        return Nodes.flattenLong((Node.OfLong) evaluateToArrayNode(Long[]::new))
+//                .asPrimitiveArray();
+//    }
 
 
     //
@@ -523,34 +523,34 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            throw new UnsupportedOperationException();
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            throw new UnsupportedOperationException();
+//        }
 
         @Override
-        final Sink<E_IN> opWrapSink(int flags, Sink<Long> sink) {
-            throw new UnsupportedOperationException();
-        }
+        final Sink<E_IN> opWrapSink(int flags, Sink<Long> sink) {throw new RuntimeException("cf-bug");} //{
+//            throw new UnsupportedOperationException();
+//        }
 
         // Optimized sequential terminal operations for the head of the pipeline
 
         @Override
-        public void forEach(LongConsumer action) {
-            if (!isParallel()) {
-                adapt(sourceStageSpliterator()).forEachRemaining(action);
-            } else {
-                super.forEach(action);
-            }
-        }
+        public void forEach(LongConsumer action) {throw new RuntimeException("cf-bug");} //{
+//            if (!isParallel()) {
+//                adapt(sourceStageSpliterator()).forEachRemaining(action);
+//            } else {
+//                super.forEach(action);
+//            }
+//        }
 
         @Override
-        public void forEachOrdered(LongConsumer action) {
-            if (!isParallel()) {
-                adapt(sourceStageSpliterator()).forEachRemaining(action);
-            } else {
-                super.forEachOrdered(action);
-            }
-        }
+        public void forEachOrdered(LongConsumer action) {throw new RuntimeException("cf-bug");} //{
+//            if (!isParallel()) {
+//                adapt(sourceStageSpliterator()).forEachRemaining(action);
+//            } else {
+//                super.forEachOrdered(action);
+//            }
+//        }
     }
 
     /** Base class for a stateless intermediate stage of a LongStream.
@@ -574,9 +574,9 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            return false;
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            return false;
+//        }
     }
 
     /**
@@ -601,9 +601,9 @@
         }
 
         @Override
-        final boolean opIsStateful() {
-            return true;
-        }
+        final boolean opIsStateful() {throw new RuntimeException("cf-bug");} //{
+//            return true;
+//        }
 
         @Override
         abstract <P_IN> Node<Long> opEvaluateParallel(PipelineHelper<Long> helper,
--- a/java/util/AbstractMap.java	2016-06-27 17:23:07.124869427 -0700
+++ b/java/util/AbstractMap.java	2016-06-29 11:14:19.075830467 -0700
@@ -90,9 +90,9 @@
      * This implementation returns <tt>entrySet().size()</tt>.
      */
     @Pure
-    public int size(@GuardSatisfied AbstractMap<K, V> this) {
-        return entrySet().size();
-    }
+    public int size(@GuardSatisfied AbstractMap<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//        return entrySet().size();
+//    }
 
     /**
      * {@inheritDoc}
@@ -101,9 +101,9 @@
      * This implementation returns <tt>size() == 0</tt>.
      */
     @Pure
-    public boolean isEmpty(@GuardSatisfied AbstractMap<K, V> this) {
-        return size() == 0;
-    }
+    public boolean isEmpty(@GuardSatisfied AbstractMap<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//        return size() == 0;
+//    }
 
     /**
      * {@inheritDoc}
@@ -119,23 +119,23 @@
      * @throws NullPointerException {@inheritDoc}
      */
     @Pure
-    public boolean containsValue(@GuardSatisfied AbstractMap<K, V> this, @GuardSatisfied @Nullable Object value) {
-        Iterator<Entry<K,V>> i = entrySet().iterator();
-        if (value==null) {
-            while (i.hasNext()) {
-                Entry<K,V> e = i.next();
-                if (e.getValue()==null)
-                    return true;
-            }
-        } else {
-            while (i.hasNext()) {
-                Entry<K,V> e = i.next();
-                if (value.equals(e.getValue()))
-                    return true;
-            }
-        }
-        return false;
-    }
+    public boolean containsValue(@GuardSatisfied AbstractMap<K, V> this, @GuardSatisfied @Nullable Object value) {throw new RuntimeException("cf-bug");} //{
+//        Iterator<Entry<K,V>> i = entrySet().iterator();
+//        if (value==null) {
+//            while (i.hasNext()) {
+//                Entry<K,V> e = i.next();
+//                if (e.getValue()==null)
+//                    return true;
+//            }
+//        } else {
+//            while (i.hasNext()) {
+//                Entry<K,V> e = i.next();
+//                if (value.equals(e.getValue()))
+//                    return true;
+//            }
+//        }
+//        return false;
+//    }
 
     /**
      * {@inheritDoc}
@@ -152,23 +152,23 @@
      * @throws NullPointerException {@inheritDoc}
      */
     @Pure
-    public boolean containsKey(@GuardSatisfied AbstractMap<K, V> this, @GuardSatisfied @Nullable Object key) {
-        Iterator<Map.Entry<K,V>> i = entrySet().iterator();
-        if (key==null) {
-            while (i.hasNext()) {
-                Entry<K,V> e = i.next();
-                if (e.getKey()==null)
-                    return true;
-            }
-        } else {
-            while (i.hasNext()) {
-                Entry<K,V> e = i.next();
-                if (key.equals(e.getKey()))
-                    return true;
-            }
-        }
-        return false;
-    }
+    public boolean containsKey(@GuardSatisfied AbstractMap<K, V> this, @GuardSatisfied @Nullable Object key) {throw new RuntimeException("cf-bug");} //{
+//        Iterator<Map.Entry<K,V>> i = entrySet().iterator();
+//        if (key==null) {
+//            while (i.hasNext()) {
+//                Entry<K,V> e = i.next();
+//                if (e.getKey()==null)
+//                    return true;
+//            }
+//        } else {
+//            while (i.hasNext()) {
+//                Entry<K,V> e = i.next();
+//                if (key.equals(e.getKey()))
+//                    return true;
+//            }
+//        }
+//        return false;
+//    }
 
     /**
      * {@inheritDoc}
@@ -185,23 +185,23 @@
      * @throws NullPointerException          {@inheritDoc}
      */
     @Pure
-    public @Nullable V get(@GuardSatisfied AbstractMap<K, V> this, @GuardSatisfied @Nullable Object key) {
-        Iterator<Entry<K,V>> i = entrySet().iterator();
-        if (key==null) {
-            while (i.hasNext()) {
-                Entry<K,V> e = i.next();
-                if (e.getKey()==null)
-                    return e.getValue();
-            }
-        } else {
-            while (i.hasNext()) {
-                Entry<K,V> e = i.next();
-                if (key.equals(e.getKey()))
-                    return e.getValue();
-            }
-        }
-        return null;
-    }
+    public @Nullable V get(@GuardSatisfied AbstractMap<K, V> this, @GuardSatisfied @Nullable Object key) {throw new RuntimeException("cf-bug");} //{
+//        Iterator<Entry<K,V>> i = entrySet().iterator();
+//        if (key==null) {
+//            while (i.hasNext()) {
+//                Entry<K,V> e = i.next();
+//                if (e.getKey()==null)
+//                    return e.getValue();
+//            }
+//        } else {
+//            while (i.hasNext()) {
+//                Entry<K,V> e = i.next();
+//                if (key.equals(e.getKey()))
+//                    return e.getValue();
+//            }
+//        }
+//        return null;
+//    }
 
 
     // Modification Operations
@@ -219,9 +219,9 @@
      * @throws IllegalArgumentException      {@inheritDoc}
      */
     @ReleasesNoLocks
-    public @Nullable V put(@GuardSatisfied AbstractMap<K, V> this, K key, V value) {
-        throw new UnsupportedOperationException();
-    }
+    public @Nullable V put(@GuardSatisfied AbstractMap<K, V> this, K key, V value) {throw new RuntimeException("cf-bug");} //{
+//        throw new UnsupportedOperationException();
+//    }
 
     /**
      * {@inheritDoc}
@@ -245,30 +245,30 @@
      * @throws ClassCastException            {@inheritDoc}
      * @throws NullPointerException          {@inheritDoc}
      */
-    public @Nullable V remove(@Nullable Object key) {
-        Iterator<Entry<K,V>> i = entrySet().iterator();
-        Entry<K,V> correctEntry = null;
-        if (key==null) {
-            while (correctEntry==null && i.hasNext()) {
-                Entry<K,V> e = i.next();
-                if (e.getKey()==null)
-                    correctEntry = e;
-            }
-        } else {
-            while (correctEntry==null && i.hasNext()) {
-                Entry<K,V> e = i.next();
-                if (key.equals(e.getKey()))
-                    correctEntry = e;
-            }
-        }
-
-        V oldValue = null;
-        if (correctEntry !=null) {
-            oldValue = correctEntry.getValue();
-            i.remove();
-        }
-        return oldValue;
-    }
+    public @Nullable V remove(@Nullable Object key) {throw new RuntimeException("cf-bug");} //{
+//        Iterator<Entry<K,V>> i = entrySet().iterator();
+//        Entry<K,V> correctEntry = null;
+//        if (key==null) {
+//            while (correctEntry==null && i.hasNext()) {
+//                Entry<K,V> e = i.next();
+//                if (e.getKey()==null)
+//                    correctEntry = e;
+//            }
+//        } else {
+//            while (correctEntry==null && i.hasNext()) {
+//                Entry<K,V> e = i.next();
+//                if (key.equals(e.getKey()))
+//                    correctEntry = e;
+//            }
+//        }
+//
+//        V oldValue = null;
+//        if (correctEntry !=null) {
+//            oldValue = correctEntry.getValue();
+//            i.remove();
+//        }
+//        return oldValue;
+//    }
 
 
     // Bulk Operations
@@ -290,10 +290,10 @@
      * @throws NullPointerException          {@inheritDoc}
      * @throws IllegalArgumentException      {@inheritDoc}
      */
-    public void putAll(Map<? extends K, ? extends V> m) {
-        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
-            put(e.getKey(), e.getValue());
-    }
+    public void putAll(Map<? extends K, ? extends V> m) {throw new RuntimeException("cf-bug");} //{
+//        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())
+//            put(e.getKey(), e.getValue());
+//    }
 
     /**
      * {@inheritDoc}
@@ -307,9 +307,9 @@
      *
      * @throws UnsupportedOperationException {@inheritDoc}
      */
-    public void clear() {
-        entrySet().clear();
-    }
+    public void clear() {throw new RuntimeException("cf-bug");} //{
+//        entrySet().clear();
+//    }
 
 
     // Views
@@ -358,48 +358,48 @@
      * method will not all return the same set.
      */
     @SideEffectFree
-    public Set<@KeyFor({"this"}) K> keySet(@GuardSatisfied AbstractMap<K, V> this) {
-        Set<K> ks = keySet;
-        if (ks == null) {
-            ks = new AbstractSet<K>() {
-                public Iterator<K> iterator() {
-                    return new Iterator<K>() {
-                        private Iterator<Entry<K,V>> i = entrySet().iterator();
-
-                        public boolean hasNext() {
-                            return i.hasNext();
-                        }
-
-                        public K next() {
-                            return i.next().getKey();
-                        }
-
-                        public void remove() {
-                            i.remove();
-                        }
-                    };
-                }
-
-                public int size() {
-                    return AbstractMap.this.size();
-                }
-
-                public boolean isEmpty() {
-                    return AbstractMap.this.isEmpty();
-                }
-
-                public void clear() {
-                    AbstractMap.this.clear();
-                }
-
-                public boolean contains(Object k) {
-                    return AbstractMap.this.containsKey(k);
-                }
-            };
-            keySet = ks;
-        }
-        return ks;
-    }
+    public Set<@KeyFor({"this"}) K> keySet(@GuardSatisfied AbstractMap<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//        Set<K> ks = keySet;
+//        if (ks == null) {
+//            ks = new AbstractSet<K>() {
+//                public Iterator<K> iterator() {
+//                    return new Iterator<K>() {
+//                        private Iterator<Entry<K,V>> i = entrySet().iterator();
+//
+//                        public boolean hasNext() {
+//                            return i.hasNext();
+//                        }
+//
+//                        public K next() {
+//                            return i.next().getKey();
+//                        }
+//
+//                        public void remove() {
+//                            i.remove();
+//                        }
+//                    };
+//                }
+//
+//                public int size() {
+//                    return AbstractMap.this.size();
+//                }
+//
+//                public boolean isEmpty() {
+//                    return AbstractMap.this.isEmpty();
+//                }
+//
+//                public void clear() {
+//                    AbstractMap.this.clear();
+//                }
+//
+//                public boolean contains(Object k) {
+//                    return AbstractMap.this.containsKey(k);
+//                }
+//            };
+//            keySet = ks;
+//        }
+//        return ks;
+//    }
 
     /**
      * {@inheritDoc}
@@ -418,48 +418,48 @@
      * method will not all return the same collection.
      */
     @SideEffectFree
-    public Collection<V> values(@GuardSatisfied AbstractMap<K, V> this) {
-        Collection<V> vals = values;
-        if (vals == null) {
-            vals = new AbstractCollection<V>() {
-                public Iterator<V> iterator() {
-                    return new Iterator<V>() {
-                        private Iterator<Entry<K,V>> i = entrySet().iterator();
-
-                        public boolean hasNext() {
-                            return i.hasNext();
-                        }
-
-                        public V next() {
-                            return i.next().getValue();
-                        }
-
-                        public void remove() {
-                            i.remove();
-                        }
-                    };
-                }
-
-                public int size() {
-                    return AbstractMap.this.size();
-                }
-
-                public boolean isEmpty() {
-                    return AbstractMap.this.isEmpty();
-                }
-
-                public void clear() {
-                    AbstractMap.this.clear();
-                }
-
-                public boolean contains(Object v) {
-                    return AbstractMap.this.containsValue(v);
-                }
-            };
-            values = vals;
-        }
-        return vals;
-    }
+    public Collection<V> values(@GuardSatisfied AbstractMap<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//        Collection<V> vals = values;
+//        if (vals == null) {
+//            vals = new AbstractCollection<V>() {
+//                public Iterator<V> iterator() {
+//                    return new Iterator<V>() {
+//                        private Iterator<Entry<K,V>> i = entrySet().iterator();
+//
+//                        public boolean hasNext() {
+//                            return i.hasNext();
+//                        }
+//
+//                        public V next() {
+//                            return i.next().getValue();
+//                        }
+//
+//                        public void remove() {
+//                            i.remove();
+//                        }
+//                    };
+//                }
+//
+//                public int size() {
+//                    return AbstractMap.this.size();
+//                }
+//
+//                public boolean isEmpty() {
+//                    return AbstractMap.this.isEmpty();
+//                }
+//
+//                public void clear() {
+//                    AbstractMap.this.clear();
+//                }
+//
+//                public boolean contains(Object v) {
+//                    return AbstractMap.this.containsValue(v);
+//                }
+//            };
+//            values = vals;
+//        }
+//        return vals;
+//    }
 
     @SideEffectFree
     public abstract Set<Entry<@KeyFor({"this"}) K,V>> entrySet(@GuardSatisfied AbstractMap<K, V> this);
@@ -490,38 +490,38 @@
      * @return <tt>true</tt> if the specified object is equal to this map
      */
     @Pure
-    public boolean equals(@GuardSatisfied AbstractMap<K, V> this, @GuardSatisfied @Nullable Object o) {
-        if (o == this)
-            return true;
-
-        if (!(o instanceof Map))
-            return false;
-        Map<?,?> m = (Map<?,?>) o;
-        if (m.size() != size())
-            return false;
-
-        try {
-            Iterator<Entry<K,V>> i = entrySet().iterator();
-            while (i.hasNext()) {
-                Entry<K,V> e = i.next();
-                K key = e.getKey();
-                V value = e.getValue();
-                if (value == null) {
-                    if (!(m.get(key)==null && m.containsKey(key)))
-                        return false;
-                } else {
-                    if (!value.equals(m.get(key)))
-                        return false;
-                }
-            }
-        } catch (ClassCastException unused) {
-            return false;
-        } catch (NullPointerException unused) {
-            return false;
-        }
-
-        return true;
-    }
+    public boolean equals(@GuardSatisfied AbstractMap<K, V> this, @GuardSatisfied @Nullable Object o) {throw new RuntimeException("cf-bug");} //{
+//        if (o == this)
+//            return true;
+//
+//        if (!(o instanceof Map))
+//            return false;
+//        Map<?,?> m = (Map<?,?>) o;
+//        if (m.size() != size())
+//            return false;
+//
+//        try {
+//            Iterator<Entry<K,V>> i = entrySet().iterator();
+//            while (i.hasNext()) {
+//                Entry<K,V> e = i.next();
+//                K key = e.getKey();
+//                V value = e.getValue();
+//                if (value == null) {
+//                    if (!(m.get(key)==null && m.containsKey(key)))
+//                        return false;
+//                } else {
+//                    if (!value.equals(m.get(key)))
+//                        return false;
+//                }
+//            }
+//        } catch (ClassCastException unused) {
+//            return false;
+//        } catch (NullPointerException unused) {
+//            return false;
+//        }
+//
+//        return true;
+//    }
 
     /**
      * Returns the hash code value for this map.  The hash code of a map is
@@ -542,13 +542,13 @@
      * @see Set#equals(Object)
      */
     @Pure
-    public int hashCode(@GuardSatisfied AbstractMap<K, V> this) {
-        int h = 0;
-        Iterator<Entry<K,V>> i = entrySet().iterator();
-        while (i.hasNext())
-            h += i.next().hashCode();
-        return h;
-    }
+    public int hashCode(@GuardSatisfied AbstractMap<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//        int h = 0;
+//        Iterator<Entry<K,V>> i = entrySet().iterator();
+//        while (i.hasNext())
+//            h += i.next().hashCode();
+//        return h;
+//    }
 
     /**
      * Returns a string representation of this map.  The string representation
@@ -563,25 +563,25 @@
      * @return a string representation of this map
      */
     @SideEffectFree
-    public String toString(@GuardSatisfied AbstractMap<K, V> this) {
-        Iterator<Entry<K,V>> i = entrySet().iterator();
-        if (! i.hasNext())
-            return "{}";
-
-        StringBuilder sb = new StringBuilder();
-        sb.append('{');
-        for (;;) {
-            Entry<K,V> e = i.next();
-            K key = e.getKey();
-            V value = e.getValue();
-            sb.append(key   == this ? "(this Map)" : key);
-            sb.append('=');
-            sb.append(value == this ? "(this Map)" : value);
-            if (! i.hasNext())
-                return sb.append('}').toString();
-            sb.append(',').append(' ');
-        }
-    }
+    public String toString(@GuardSatisfied AbstractMap<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//        Iterator<Entry<K,V>> i = entrySet().iterator();
+//        if (! i.hasNext())
+//            return "{}";
+//
+//        StringBuilder sb = new StringBuilder();
+//        sb.append('{');
+//        for (;;) {
+//            Entry<K,V> e = i.next();
+//            K key = e.getKey();
+//            V value = e.getValue();
+//            sb.append(key   == this ? "(this Map)" : key);
+//            sb.append('=');
+//            sb.append(value == this ? "(this Map)" : value);
+//            if (! i.hasNext())
+//                return sb.append('}').toString();
+//            sb.append(',').append(' ');
+//        }
+//    }
 
     /**
      * Returns a shallow copy of this <tt>AbstractMap</tt> instance: the keys
@@ -589,12 +589,12 @@
      *
      * @return a shallow copy of this map
      */
-    protected Object clone() throws CloneNotSupportedException {
-        AbstractMap<?,?> result = (AbstractMap<?,?>)super.clone();
-        result.keySet = null;
-        result.values = null;
-        return result;
-    }
+    protected Object clone() throws CloneNotSupportedException {throw new RuntimeException("cf-bug");} //{
+//        AbstractMap<?,?> result = (AbstractMap<?,?>)super.clone();
+//        result.keySet = null;
+//        result.values = null;
+//        return result;
+//    }
 
     /**
      * Utility method for SimpleEntry and SimpleImmutableEntry.
@@ -602,9 +602,9 @@
      *
      * NB: Do not replace with Object.equals until JDK-8015417 is resolved.
      */
-    private static boolean eq(Object o1, Object o2) {
-        return o1 == null ? o2 == null : o1.equals(o2);
-    }
+    private static boolean eq(Object o1, Object o2) {throw new RuntimeException("cf-bug");} //{
+//        return o1 == null ? o2 == null : o1.equals(o2);
+//    }
 
     // Implementation Note: SimpleEntry and SimpleImmutableEntry
     // are distinct unrelated classes, even though they share
@@ -662,9 +662,9 @@
          * @return the key corresponding to this entry
          */
         @Pure
-        public K getKey(AbstractMap.SimpleEntry<K, V> this) {
-            return key;
-        }
+        public K getKey(AbstractMap.SimpleEntry<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//            return key;
+//        }
 
         /**
          * Returns the value corresponding to this entry.
@@ -672,9 +672,9 @@
          * @return the value corresponding to this entry
          */
         @Pure
-        public V getValue(AbstractMap.SimpleEntry<K, V> this) {
-            return value;
-        }
+        public V getValue(AbstractMap.SimpleEntry<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//            return value;
+//        }
 
         /**
          * Replaces the value corresponding to this entry with the specified
@@ -683,11 +683,11 @@
          * @param value new value to be stored in this entry
          * @return the old value corresponding to the entry
          */
-        public V setValue(V value) {
-            V oldValue = this.value;
-            this.value = value;
-            return oldValue;
-        }
+        public V setValue(V value) {throw new RuntimeException("cf-bug");} //{
+//            V oldValue = this.value;
+//            this.value = value;
+//            return oldValue;
+//        }
 
         /**
          * Compares the specified object with this entry for equality.
@@ -711,12 +711,12 @@
          * @see    #hashCode
          */
         @Pure
-        public boolean equals(AbstractMap.SimpleEntry<K, V> this, @GuardSatisfied @Nullable Object o) {
-            if (!(o instanceof Map.Entry))
-                return false;
-            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
-            return eq(key, e.getKey()) && eq(value, e.getValue());
-        }
+        public boolean equals(AbstractMap.SimpleEntry<K, V> this, @GuardSatisfied @Nullable Object o) {throw new RuntimeException("cf-bug");} //{
+//            if (!(o instanceof Map.Entry))
+//                return false;
+//            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
+//            return eq(key, e.getKey()) && eq(value, e.getValue());
+//        }
 
         /**
          * Returns the hash code value for this map entry.  The hash code
@@ -732,10 +732,10 @@
          * @see    #equals
          */
         @Pure
-        public int hashCode(AbstractMap.SimpleEntry<K, V> this) {
-            return (key   == null ? 0 :   key.hashCode()) ^
-                   (value == null ? 0 : value.hashCode());
-        }
+        public int hashCode(AbstractMap.SimpleEntry<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//            return (key   == null ? 0 :   key.hashCode()) ^
+//                   (value == null ? 0 : value.hashCode());
+//        }
 
         /**
          * Returns a String representation of this map entry.  This
@@ -746,9 +746,9 @@
          * @return a String representation of this map entry
          */
         @SideEffectFree
-        public String toString(AbstractMap.SimpleEntry<K, V> this) {
-            return key + "=" + value;
-        }
+        public String toString(AbstractMap.SimpleEntry<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//            return key + "=" + value;
+//        }
 
     }
 
@@ -798,9 +798,9 @@
          * @return the key corresponding to this entry
          */
         @Pure
-        public K getKey(AbstractMap.SimpleImmutableEntry<K, V> this) {
-            return key;
-        }
+        public K getKey(AbstractMap.SimpleImmutableEntry<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//            return key;
+//        }
 
         /**
          * Returns the value corresponding to this entry.
@@ -808,9 +808,9 @@
          * @return the value corresponding to this entry
          */
         @Pure
-        public V getValue(AbstractMap.SimpleImmutableEntry<K, V> this) {
-            return value;
-        }
+        public V getValue(AbstractMap.SimpleImmutableEntry<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//            return value;
+//        }
 
         /**
          * Replaces the value corresponding to this entry with the specified
@@ -822,9 +822,9 @@
          * @return (Does not return)
          * @throws UnsupportedOperationException always
          */
-        public V setValue(V value) {
-            throw new UnsupportedOperationException();
-        }
+        public V setValue(V value) {throw new RuntimeException("cf-bug");} //{
+//            throw new UnsupportedOperationException();
+//        }
 
         /**
          * Compares the specified object with this entry for equality.
@@ -848,12 +848,12 @@
          * @see    #hashCode
          */
         @Pure
-        public boolean equals(AbstractMap.SimpleImmutableEntry<K, V> this, @GuardSatisfied @Nullable Object o) {
-            if (!(o instanceof Map.Entry))
-                return false;
-            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
-            return eq(key, e.getKey()) && eq(value, e.getValue());
-        }
+        public boolean equals(AbstractMap.SimpleImmutableEntry<K, V> this, @GuardSatisfied @Nullable Object o) {throw new RuntimeException("cf-bug");} //{
+//            if (!(o instanceof Map.Entry))
+//                return false;
+//            Map.Entry<?,?> e = (Map.Entry<?,?>)o;
+//            return eq(key, e.getKey()) && eq(value, e.getValue());
+//        }
 
         /**
          * Returns the hash code value for this map entry.  The hash code
@@ -869,10 +869,10 @@
          * @see    #equals
          */
         @Pure
-        public int hashCode(AbstractMap.SimpleImmutableEntry<K, V> this) {
-            return (key   == null ? 0 :   key.hashCode()) ^
-                   (value == null ? 0 : value.hashCode());
-        }
+        public int hashCode(AbstractMap.SimpleImmutableEntry<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//            return (key   == null ? 0 :   key.hashCode()) ^
+//                   (value == null ? 0 : value.hashCode());
+//        }
 
         /**
          * Returns a String representation of this map entry.  This
@@ -883,9 +883,9 @@
          * @return a String representation of this map entry
          */
         @SideEffectFree
-        public String toString(AbstractMap.SimpleImmutableEntry<K, V> this) {
-            return key + "=" + value;
-        }
+        public String toString(AbstractMap.SimpleImmutableEntry<K, V> this) {throw new RuntimeException("cf-bug");} //{
+//            return key + "=" + value;
+//        }
 
     }
 
--- a/java/util/ResourceBundle.java	2016-06-27 17:10:38.460257032 -0700
+++ b/java/util/ResourceBundle.java	2016-06-29 16:23:11.133195332 -0700
@@ -342,9 +342,9 @@
      *
      * @since 1.8
      */
-    public String getBaseBundleName() {
-        return name;
-    }
+    public String getBaseBundleName() {throw new RuntimeException("cf-bug");} //{
+//        return name;
+//    }
 
     /**
      * The parent bundle of this bundle.
@@ -414,9 +414,9 @@
      * @exception ClassCastException if the object found for the given key is not a string
      * @return the string for the given key
      */
-    public final @Localized @I18nMakeFormat String getString(@LocalizableKey @PropertyKey String key) {
-        return (String) getObject(key);
-    }
+    public final @Localized @I18nMakeFormat String getString(@LocalizableKey @PropertyKey String key) {throw new RuntimeException("cf-bug");} //{
+//        return (String) getObject(key);
+//    }
 
     /**
      * Gets a string array for the given key from this resource bundle or one of its parents.
@@ -431,9 +431,9 @@
      * @exception ClassCastException if the object found for the given key is not a string array
      * @return the string array for the given key
      */
-    public final String @Localized [] getStringArray(@LocalizableKey @PropertyKey String key) {
-        return (String[]) getObject(key);
-    }
+    public final String @Localized [] getStringArray(@LocalizableKey @PropertyKey String key) {throw new RuntimeException("cf-bug");} //{
+//        return (String[]) getObject(key);
+//    }
 
     /**
      * Gets an object for the given key from this resource bundle or one of its parents.
@@ -448,22 +448,22 @@
      * @exception MissingResourceException if no object for the given key can be found
      * @return the object for the given key
      */
-    public final @Localized Object getObject(@LocalizableKey @PropertyKey String key) {
-        Object obj = handleGetObject(key);
-        if (obj == null) {
-            if (parent != null) {
-                obj = parent.getObject(key);
-            }
-            if (obj == null) {
-                throw new MissingResourceException("Can't find resource for bundle "
-                                                   +this.getClass().getName()
-                                                   +", key "+key,
-                                                   this.getClass().getName(),
-                                                   key);
-            }
-        }
-        return obj;
-    }
+    public final @Localized Object getObject(@LocalizableKey @PropertyKey String key) {throw new RuntimeException("cf-bug");} //{
+//        Object obj = handleGetObject(key);
+//        if (obj == null) {
+//            if (parent != null) {
+//                obj = parent.getObject(key);
+//            }
+//            if (obj == null) {
+//                throw new MissingResourceException("Can't find resource for bundle "
+//                                                   +this.getClass().getName()
+//                                                   +", key "+key,
+//                                                   this.getClass().getName(),
+//                                                   key);
+//            }
+//        }
+//        return obj;
+//    }
 
     /**
      * Returns the locale of this resource bundle. This method can be used after a
@@ -472,28 +472,28 @@
      *
      * @return the locale of this resource bundle
      */
-    public Locale getLocale() {
-        return locale;
-    }
+    public Locale getLocale() {throw new RuntimeException("cf-bug");} //{
+//        return locale;
+//    }
 
     /*
      * Automatic determination of the ClassLoader to be used to load
      * resources on behalf of the client.
      */
-    private static ClassLoader getLoader(Class<?> caller) {
-        ClassLoader cl = caller == null ? null : caller.getClassLoader();
-        if (cl == null) {
-            // When the caller's loader is the boot class loader, cl is null
-            // here. In that case, ClassLoader.getSystemClassLoader() may
-            // return the same class loader that the application is
-            // using. We therefore use a wrapper ClassLoader to create a
-            // separate scope for bundles loaded on behalf of the Java
-            // runtime so that these bundles cannot be returned from the
-            // cache to the application (5048280).
-            cl = RBClassLoader.INSTANCE;
-        }
-        return cl;
-    }
+    private static ClassLoader getLoader(Class<?> caller) {throw new RuntimeException("cf-bug");} //{
+//        ClassLoader cl = caller == null ? null : caller.getClassLoader();
+//        if (cl == null) {
+//            // When the caller's loader is the boot class loader, cl is null
+//            // here. In that case, ClassLoader.getSystemClassLoader() may
+//            // return the same class loader that the application is
+//            // using. We therefore use a wrapper ClassLoader to create a
+//            // separate scope for bundles loaded on behalf of the Java
+//            // runtime so that these bundles cannot be returned from the
+//            // cache to the application (5048280).
+//            cl = RBClassLoader.INSTANCE;
+//        }
+//        return cl;
+//    }
 
     /**
      * A wrapper of ClassLoader.getSystemClassLoader().
@@ -509,24 +509,24 @@
 
         private RBClassLoader() {
         }
-        public Class<?> loadClass(String name) throws ClassNotFoundException {
-            if (loader != null) {
-                return loader.loadClass(name);
-            }
-            return Class.forName(name);
-        }
-        public URL getResource(String name) {
-            if (loader != null) {
-                return loader.getResource(name);
-            }
-            return ClassLoader.getSystemResource(name);
-        }
-        public InputStream getResourceAsStream(String name) {
-            if (loader != null) {
-                return loader.getResourceAsStream(name);
-            }
-            return ClassLoader.getSystemResourceAsStream(name);
-        }
+        public Class<?> loadClass(String name) throws ClassNotFoundException {throw new RuntimeException("cf-bug");} //{
+//            if (loader != null) {
+//                return loader.loadClass(name);
+//            }
+//            return Class.forName(name);
+//        }
+        public URL getResource(String name) {throw new RuntimeException("cf-bug");} //{
+//            if (loader != null) {
+//                return loader.getResource(name);
+//            }
+//            return ClassLoader.getSystemResource(name);
+//        }
+        public InputStream getResourceAsStream(String name) {throw new RuntimeException("cf-bug");} //{
+//            if (loader != null) {
+//                return loader.getResourceAsStream(name);
+//            }
+//            return ClassLoader.getSystemResourceAsStream(name);
+//        }
     }
 
     /**
@@ -536,10 +536,10 @@
      *
      * @param parent this bundle's parent bundle.
      */
-    protected void setParent(ResourceBundle parent) {
-        assert parent != NONEXISTENT_BUNDLE;
-        this.parent = parent;
-    }
+    protected void setParent(ResourceBundle parent) {throw new RuntimeException("cf-bug");} //{
+//        assert parent != NONEXISTENT_BUNDLE;
+//        this.parent = parent;
+//    }
 
     /**
      * Key used for cached resource bundles.  The key checks the base
@@ -586,133 +586,133 @@
             calculateHashCode();
         }
 
-        String getName() {
-            return name;
-        }
-
-        CacheKey setName(String baseName) {
-            if (!this.name.equals(baseName)) {
-                this.name = baseName;
-                calculateHashCode();
-            }
-            return this;
-        }
-
-        Locale getLocale() {
-            return locale;
-        }
-
-        CacheKey setLocale(Locale locale) {
-            if (!this.locale.equals(locale)) {
-                this.locale = locale;
-                calculateHashCode();
-            }
-            return this;
-        }
-
-        ClassLoader getLoader() {
-            return (loaderRef != null) ? loaderRef.get() : null;
-        }
-
-        public boolean equals(Object other) {
-            if (this == other) {
-                return true;
-            }
-            try {
-                final CacheKey otherEntry = (CacheKey)other;
-                //quick check to see if they are not equal
-                if (hashCodeCache != otherEntry.hashCodeCache) {
-                    return false;
-                }
-                //are the names the same?
-                if (!name.equals(otherEntry.name)) {
-                    return false;
-                }
-                // are the locales the same?
-                if (!locale.equals(otherEntry.locale)) {
-                    return false;
-                }
-                //are refs (both non-null) or (both null)?
-                if (loaderRef == null) {
-                    return otherEntry.loaderRef == null;
-                }
-                ClassLoader loader = loaderRef.get();
-                return (otherEntry.loaderRef != null)
-                        // with a null reference we can no longer find
-                        // out which class loader was referenced; so
-                        // treat it as unequal
-                        && (loader != null)
-                        && (loader == otherEntry.loaderRef.get());
-            } catch (    NullPointerException | ClassCastException e) {
-            }
-            return false;
-        }
-
-        public int hashCode() {
-            return hashCodeCache;
-        }
-
-        private void calculateHashCode() {
-            hashCodeCache = name.hashCode() << 3;
-            hashCodeCache ^= locale.hashCode();
-            ClassLoader loader = getLoader();
-            if (loader != null) {
-                hashCodeCache ^= loader.hashCode();
-            }
-        }
-
-        public Object clone() {
-            try {
-                CacheKey clone = (CacheKey) super.clone();
-                if (loaderRef != null) {
-                    clone.loaderRef = new LoaderReference(loaderRef.get(),
-                                                          referenceQueue, clone);
-                }
-                // Clear the reference to a Throwable
-                clone.cause = null;
-                return clone;
-            } catch (CloneNotSupportedException e) {
-                //this should never happen
-                throw new InternalError(e);
-            }
-        }
-
-        String getFormat() {
-            return format;
-        }
-
-        void setFormat(String format) {
-            this.format = format;
-        }
-
-        private void setCause(Throwable cause) {
-            if (this.cause == null) {
-                this.cause = cause;
-            } else {
-                // Override the cause if the previous one is
-                // ClassNotFoundException.
-                if (this.cause instanceof ClassNotFoundException) {
-                    this.cause = cause;
-                }
-            }
-        }
-
-        private Throwable getCause() {
-            return cause;
-        }
-
-        public String toString() {
-            String l = locale.toString();
-            if (l.length() == 0) {
-                if (locale.getVariant().length() != 0) {
-                    l = "__" + locale.getVariant();
-                } else {
-                    l = "\"\"";
-                }
-            }
-            return "CacheKey[" + name + ", lc=" + l + ", ldr=" + getLoader()
-                + "(format=" + format + ")]";
-        }
+        String getName() {throw new RuntimeException("cf-bug");} //{
+//            return name;
+//        }
+
+        CacheKey setName(String baseName) {throw new RuntimeException("cf-bug");} //{
+//            if (!this.name.equals(baseName)) {
+//                this.name = baseName;
+//                calculateHashCode();
+//            }
+//            return this;
+//        }
+
+        Locale getLocale() {throw new RuntimeException("cf-bug");} //{
+//            return locale;
+//        }
+
+        CacheKey setLocale(Locale locale) {throw new RuntimeException("cf-bug");} //{
+//            if (!this.locale.equals(locale)) {
+//                this.locale = locale;
+//                calculateHashCode();
+//            }
+//            return this;
+//        }
+
+        ClassLoader getLoader() {throw new RuntimeException("cf-bug");} //{
+//            return (loaderRef != null) ? loaderRef.get() : null;
+//        }
+
+        public boolean equals(Object other) {throw new RuntimeException("cf-bug");} //{
+//            if (this == other) {
+//                return true;
+//            }
+//            try {
+//                final CacheKey otherEntry = (CacheKey)other;
+//                //quick check to see if they are not equal
+//                if (hashCodeCache != otherEntry.hashCodeCache) {
+//                    return false;
+//                }
+//                //are the names the same?
+//                if (!name.equals(otherEntry.name)) {
+//                    return false;
+//                }
+//                // are the locales the same?
+//                if (!locale.equals(otherEntry.locale)) {
+//                    return false;
+//                }
+//                //are refs (both non-null) or (both null)?
+//                if (loaderRef == null) {
+//                    return otherEntry.loaderRef == null;
+//                }
+//                ClassLoader loader = loaderRef.get();
+//                return (otherEntry.loaderRef != null)
+//                        // with a null reference we can no longer find
+//                        // out which class loader was referenced; so
+//                        // treat it as unequal
+//                        && (loader != null)
+//                        && (loader == otherEntry.loaderRef.get());
+//            } catch (    NullPointerException | ClassCastException e) {
+//            }
+//            return false;
+//        }
+
+        public int hashCode() {throw new RuntimeException("cf-bug");} //{
+//            return hashCodeCache;
+//        }
+
+        private void calculateHashCode() {throw new RuntimeException("cf-bug");} //{
+//            hashCodeCache = name.hashCode() << 3;
+//            hashCodeCache ^= locale.hashCode();
+//            ClassLoader loader = getLoader();
+//            if (loader != null) {
+//                hashCodeCache ^= loader.hashCode();
+//            }
+//        }
+
+        public Object clone() {throw new RuntimeException("cf-bug");} //{
+//            try {
+//                CacheKey clone = (CacheKey) super.clone();
+//                if (loaderRef != null) {
+//                    clone.loaderRef = new LoaderReference(loaderRef.get(),
+//                                                          referenceQueue, clone);
+//                }
+//                // Clear the reference to a Throwable
+//                clone.cause = null;
+//                return clone;
+//            } catch (CloneNotSupportedException e) {
+//                //this should never happen
+//                throw new InternalError(e);
+//            }
+//        }
+
+        String getFormat() {throw new RuntimeException("cf-bug");} //{
+//            return format;
+//        }
+
+        void setFormat(String format) {throw new RuntimeException("cf-bug");} //{
+//            this.format = format;
+//        }
+
+        private void setCause(Throwable cause) {throw new RuntimeException("cf-bug");} //{
+//            if (this.cause == null) {
+//                this.cause = cause;
+//            } else {
+//                // Override the cause if the previous one is
+//                // ClassNotFoundException.
+//                if (this.cause instanceof ClassNotFoundException) {
+//                    this.cause = cause;
+//                }
+//            }
+//        }
+
+        private Throwable getCause() {throw new RuntimeException("cf-bug");} //{
+//            return cause;
+//        }
+
+        public String toString() {throw new RuntimeException("cf-bug");} //{
+//            String l = locale.toString();
+//            if (l.length() == 0) {
+//                if (locale.getVariant().length() != 0) {
+//                    l = "__" + locale.getVariant();
+//                } else {
+//                    l = "\"\"";
+//                }
+//            }
+//            return "CacheKey[" + name + ", lc=" + l + ", ldr=" + getLoader()
+//                + "(format=" + format + ")]";
+//        }
     }
 
     /**
@@ -780,11 +780,11 @@
      */
     @CallerSensitive
     public static final ResourceBundle getBundle(@BinaryName String baseName)
-    {
-        return getBundleImpl(baseName, Locale.getDefault(),
-                             getLoader(Reflection.getCallerClass()),
-                             getDefaultControl(baseName));
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        return getBundleImpl(baseName, Locale.getDefault(),
+//                             getLoader(Reflection.getCallerClass()),
+//                             getDefaultControl(baseName));
+//    }
 
     /**
      * Returns a resource bundle using the specified base name, the
@@ -822,11 +822,11 @@
      */
     @CallerSensitive
     public static final ResourceBundle getBundle(@BinaryName String baseName,
-                                                 Control control) {
-        return getBundleImpl(baseName, Locale.getDefault(),
-                             getLoader(Reflection.getCallerClass()),
-                             control);
-    }
+                                                 Control control) {throw new RuntimeException("cf-bug");} //{
+//        return getBundleImpl(baseName, Locale.getDefault(),
+//                             getLoader(Reflection.getCallerClass()),
+//                             control);
+//    }
 
     /**
      * Gets a resource bundle using the specified base name and locale,
@@ -852,11 +852,11 @@
     @CallerSensitive
     public static final ResourceBundle getBundle(@BinaryName String baseName,
                                                  Locale locale)
-    {
-        return getBundleImpl(baseName, locale,
-                             getLoader(Reflection.getCallerClass()),
-                             getDefaultControl(baseName));
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        return getBundleImpl(baseName, locale,
+//                             getLoader(Reflection.getCallerClass()),
+//                             getDefaultControl(baseName));
+//    }
 
     /**
      * Returns a resource bundle using the specified base name, target
@@ -897,11 +897,11 @@
      */
     @CallerSensitive
     public static final ResourceBundle getBundle(@BinaryName String baseName, Locale targetLocale,
-                                                 Control control) {
-        return getBundleImpl(baseName, targetLocale,
-                             getLoader(Reflection.getCallerClass()),
-                             control);
-    }
+                                                 Control control) {throw new RuntimeException("cf-bug");} //{
+//        return getBundleImpl(baseName, targetLocale,
+//                             getLoader(Reflection.getCallerClass()),
+//                             control);
+//    }
 
     /**
      * Gets a resource bundle using the specified base name, locale, and class
@@ -1086,12 +1086,12 @@
      */
     public static ResourceBundle getBundle(@BinaryName String baseName, Locale locale,
                                            ClassLoader loader)
-    {
-        if (loader == null) {
-            throw new NullPointerException();
-        }
-        return getBundleImpl(baseName, locale, loader, getDefaultControl(baseName));
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        if (loader == null) {
+//            throw new NullPointerException();
+//        }
+//        return getBundleImpl(baseName, locale, loader, getDefaultControl(baseName));
+//    }
 
     /**
      * Returns a resource bundle using the specified base name, target
@@ -1303,281 +1303,281 @@
      * @since 1.6
      */
     public static ResourceBundle getBundle(@BinaryName String baseName, Locale targetLocale,
-                                           ClassLoader loader, Control control) {
-        if (loader == null || control == null) {
-            throw new NullPointerException();
-        }
-        return getBundleImpl(baseName, targetLocale, loader, control);
-    }
-
-    private static Control getDefaultControl(String baseName) {
-        if (providers != null) {
-            for (ResourceBundleControlProvider provider : providers) {
-                Control control = provider.getControl(baseName);
-                if (control != null) {
-                    return control;
-                }
-            }
-        }
-        return Control.INSTANCE;
-    }
+                                           ClassLoader loader, Control control) {throw new RuntimeException("cf-bug");} //{
+//        if (loader == null || control == null) {
+//            throw new NullPointerException();
+//        }
+//        return getBundleImpl(baseName, targetLocale, loader, control);
+//    }
+
+    private static Control getDefaultControl(String baseName) {throw new RuntimeException("cf-bug");} //{
+//        if (providers != null) {
+//            for (ResourceBundleControlProvider provider : providers) {
+//                Control control = provider.getControl(baseName);
+//                if (control != null) {
+//                    return control;
+//                }
+//            }
+//        }
+//        return Control.INSTANCE;
+//    }
 
     private static ResourceBundle getBundleImpl(String baseName, Locale locale,
-                                                ClassLoader loader, Control control) {
-        if (locale == null || control == null) {
-            throw new NullPointerException();
-        }
-
-        // We create a CacheKey here for use by this call. The base
-        // name and loader will never change during the bundle loading
-        // process. We have to make sure that the locale is set before
-        // using it as a cache key.
-        CacheKey cacheKey = new CacheKey(baseName, locale, loader);
-        ResourceBundle bundle = null;
-
-        // Quick lookup of the cache.
-        BundleReference bundleRef = cacheList.get(cacheKey);
-        if (bundleRef != null) {
-            bundle = bundleRef.get();
-            bundleRef = null;
-        }
-
-        // If this bundle and all of its parents are valid (not expired),
-        // then return this bundle. If any of the bundles is expired, we
-        // don't call control.needsReload here but instead drop into the
-        // complete loading process below.
-        if (isValidBundle(bundle) && hasValidParentChain(bundle)) {
-            return bundle;
-        }
-
-        // No valid bundle was found in the cache, so we need to load the
-        // resource bundle and its parents.
-
-        boolean isKnownControl = (control == Control.INSTANCE) ||
-                                   (control instanceof SingleFormatControl);
-        List<String> formats = control.getFormats(baseName);
-        if (!isKnownControl && !checkList(formats)) {
-            throw new IllegalArgumentException("Invalid Control: getFormats");
-        }
-
-        ResourceBundle baseBundle = null;
-        for (Locale targetLocale = locale;
-             targetLocale != null;
-             targetLocale = control.getFallbackLocale(baseName, targetLocale)) {
-            List<Locale> candidateLocales = control.getCandidateLocales(baseName, targetLocale);
-            if (!isKnownControl && !checkList(candidateLocales)) {
-                throw new IllegalArgumentException("Invalid Control: getCandidateLocales");
-            }
-
-            bundle = findBundle(cacheKey, candidateLocales, formats, 0, control, baseBundle);
-
-            // If the loaded bundle is the base bundle and exactly for the
-            // requested locale or the only candidate locale, then take the
-            // bundle as the resulting one. If the loaded bundle is the base
-            // bundle, it's put on hold until we finish processing all
-            // fallback locales.
-            if (isValidBundle(bundle)) {
-                boolean isBaseBundle = Locale.ROOT.equals(bundle.locale);
-                if (!isBaseBundle || bundle.locale.equals(locale)
-                    || (candidateLocales.size() == 1
-                        && bundle.locale.equals(candidateLocales.get(0)))) {
-                    break;
-                }
-
-                // If the base bundle has been loaded, keep the reference in
-                // baseBundle so that we can avoid any redundant loading in case
-                // the control specify not to cache bundles.
-                if (isBaseBundle && baseBundle == null) {
-                    baseBundle = bundle;
-                }
-            }
-        }
-
-        if (bundle == null) {
-            if (baseBundle == null) {
-                throwMissingResourceException(baseName, locale, cacheKey.getCause());
-            }
-            bundle = baseBundle;
-        }
-
-        return bundle;
-    }
+                                                ClassLoader loader, Control control) {throw new RuntimeException("cf-bug");} //{
+//        if (locale == null || control == null) {
+//            throw new NullPointerException();
+//        }
+//
+//        // We create a CacheKey here for use by this call. The base
+//        // name and loader will never change during the bundle loading
+//        // process. We have to make sure that the locale is set before
+//        // using it as a cache key.
+//        CacheKey cacheKey = new CacheKey(baseName, locale, loader);
+//        ResourceBundle bundle = null;
+//
+//        // Quick lookup of the cache.
+//        BundleReference bundleRef = cacheList.get(cacheKey);
+//        if (bundleRef != null) {
+//            bundle = bundleRef.get();
+//            bundleRef = null;
+//        }
+//
+//        // If this bundle and all of its parents are valid (not expired),
+//        // then return this bundle. If any of the bundles is expired, we
+//        // don't call control.needsReload here but instead drop into the
+//        // complete loading process below.
+//        if (isValidBundle(bundle) && hasValidParentChain(bundle)) {
+//            return bundle;
+//        }
+//
+//        // No valid bundle was found in the cache, so we need to load the
+//        // resource bundle and its parents.
+//
+//        boolean isKnownControl = (control == Control.INSTANCE) ||
+//                                   (control instanceof SingleFormatControl);
+//        List<String> formats = control.getFormats(baseName);
+//        if (!isKnownControl && !checkList(formats)) {
+//            throw new IllegalArgumentException("Invalid Control: getFormats");
+//        }
+//
+//        ResourceBundle baseBundle = null;
+//        for (Locale targetLocale = locale;
+//             targetLocale != null;
+//             targetLocale = control.getFallbackLocale(baseName, targetLocale)) {
+//            List<Locale> candidateLocales = control.getCandidateLocales(baseName, targetLocale);
+//            if (!isKnownControl && !checkList(candidateLocales)) {
+//                throw new IllegalArgumentException("Invalid Control: getCandidateLocales");
+//            }
+//
+//            bundle = findBundle(cacheKey, candidateLocales, formats, 0, control, baseBundle);
+//
+//            // If the loaded bundle is the base bundle and exactly for the
+//            // requested locale or the only candidate locale, then take the
+//            // bundle as the resulting one. If the loaded bundle is the base
+//            // bundle, it's put on hold until we finish processing all
+//            // fallback locales.
+//            if (isValidBundle(bundle)) {
+//                boolean isBaseBundle = Locale.ROOT.equals(bundle.locale);
+//                if (!isBaseBundle || bundle.locale.equals(locale)
+//                    || (candidateLocales.size() == 1
+//                        && bundle.locale.equals(candidateLocales.get(0)))) {
+//                    break;
+//                }
+//
+//                // If the base bundle has been loaded, keep the reference in
+//                // baseBundle so that we can avoid any redundant loading in case
+//                // the control specify not to cache bundles.
+//                if (isBaseBundle && baseBundle == null) {
+//                    baseBundle = bundle;
+//                }
+//            }
+//        }
+//
+//        if (bundle == null) {
+//            if (baseBundle == null) {
+//                throwMissingResourceException(baseName, locale, cacheKey.getCause());
+//            }
+//            bundle = baseBundle;
+//        }
+//
+//        return bundle;
+//    }
 
     /**
      * Checks if the given <code>List</code> is not null, not empty,
      * not having null in its elements.
      */
-    private static boolean checkList(List<?> a) {
-        boolean valid = (a != null && !a.isEmpty());
-        if (valid) {
-            int size = a.size();
-            for (int i = 0; valid && i < size; i++) {
-                valid = (a.get(i) != null);
-            }
-        }
-        return valid;
-    }
+    private static boolean checkList(List<?> a) {throw new RuntimeException("cf-bug");} //{
+//        boolean valid = (a != null && !a.isEmpty());
+//        if (valid) {
+//            int size = a.size();
+//            for (int i = 0; valid && i < size; i++) {
+//                valid = (a.get(i) != null);
+//            }
+//        }
+//        return valid;
+//    }
 
     private static ResourceBundle findBundle(CacheKey cacheKey,
                                              List<Locale> candidateLocales,
                                              List<String> formats,
                                              int index,
                                              Control control,
-                                             ResourceBundle baseBundle) {
-        Locale targetLocale = candidateLocales.get(index);
-        ResourceBundle parent = null;
-        if (index != candidateLocales.size() - 1) {
-            parent = findBundle(cacheKey, candidateLocales, formats, index + 1,
-                                control, baseBundle);
-        } else if (baseBundle != null && Locale.ROOT.equals(targetLocale)) {
-            return baseBundle;
-        }
-
-        // Before we do the real loading work, see whether we need to
-        // do some housekeeping: If references to class loaders or
-        // resource bundles have been nulled out, remove all related
-        // information from the cache.
-        Object ref;
-        while ((ref = referenceQueue.poll()) != null) {
-            cacheList.remove(((CacheKeyReference)ref).getCacheKey());
-        }
-
-        // flag indicating the resource bundle has expired in the cache
-        boolean expiredBundle = false;
-
-        // First, look up the cache to see if it's in the cache, without
-        // attempting to load bundle.
-        cacheKey.setLocale(targetLocale);
-        ResourceBundle bundle = findBundleInCache(cacheKey, control);
-        if (isValidBundle(bundle)) {
-            expiredBundle = bundle.expired;
-            if (!expiredBundle) {
-                // If its parent is the one asked for by the candidate
-                // locales (the runtime lookup path), we can take the cached
-                // one. (If it's not identical, then we'd have to check the
-                // parent's parents to be consistent with what's been
-                // requested.)
-                if (bundle.parent == parent) {
-                    return bundle;
-                }
-                // Otherwise, remove the cached one since we can't keep
-                // the same bundles having different parents.
-                BundleReference bundleRef = cacheList.get(cacheKey);
-                if (bundleRef != null && bundleRef.get() == bundle) {
-                    cacheList.remove(cacheKey, bundleRef);
-                }
-            }
-        }
-
-        if (bundle != NONEXISTENT_BUNDLE) {
-            CacheKey constKey = (CacheKey) cacheKey.clone();
-
-            try {
-                bundle = loadBundle(cacheKey, formats, control, expiredBundle);
-                if (bundle != null) {
-                    if (bundle.parent == null) {
-                        bundle.setParent(parent);
-                    }
-                    bundle.locale = targetLocale;
-                    bundle = putBundleInCache(cacheKey, bundle, control);
-                    return bundle;
-                }
-
-                // Put NONEXISTENT_BUNDLE in the cache as a mark that there's no bundle
-                // instance for the locale.
-                putBundleInCache(cacheKey, NONEXISTENT_BUNDLE, control);
-            } finally {
-                if (constKey.getCause() instanceof InterruptedException) {
-                    Thread.currentThread().interrupt();
-                }
-            }
-        }
-        return parent;
-    }
+                                             ResourceBundle baseBundle) {throw new RuntimeException("cf-bug");} //{
+//        Locale targetLocale = candidateLocales.get(index);
+//        ResourceBundle parent = null;
+//        if (index != candidateLocales.size() - 1) {
+//            parent = findBundle(cacheKey, candidateLocales, formats, index + 1,
+//                                control, baseBundle);
+//        } else if (baseBundle != null && Locale.ROOT.equals(targetLocale)) {
+//            return baseBundle;
+//        }
+//
+//        // Before we do the real loading work, see whether we need to
+//        // do some housekeeping: If references to class loaders or
+//        // resource bundles have been nulled out, remove all related
+//        // information from the cache.
+//        Object ref;
+//        while ((ref = referenceQueue.poll()) != null) {
+//            cacheList.remove(((CacheKeyReference)ref).getCacheKey());
+//        }
+//
+//        // flag indicating the resource bundle has expired in the cache
+//        boolean expiredBundle = false;
+//
+//        // First, look up the cache to see if it's in the cache, without
+//        // attempting to load bundle.
+//        cacheKey.setLocale(targetLocale);
+//        ResourceBundle bundle = findBundleInCache(cacheKey, control);
+//        if (isValidBundle(bundle)) {
+//            expiredBundle = bundle.expired;
+//            if (!expiredBundle) {
+//                // If its parent is the one asked for by the candidate
+//                // locales (the runtime lookup path), we can take the cached
+//                // one. (If it's not identical, then we'd have to check the
+//                // parent's parents to be consistent with what's been
+//                // requested.)
+//                if (bundle.parent == parent) {
+//                    return bundle;
+//                }
+//                // Otherwise, remove the cached one since we can't keep
+//                // the same bundles having different parents.
+//                BundleReference bundleRef = cacheList.get(cacheKey);
+//                if (bundleRef != null && bundleRef.get() == bundle) {
+//                    cacheList.remove(cacheKey, bundleRef);
+//                }
+//            }
+//        }
+//
+//        if (bundle != NONEXISTENT_BUNDLE) {
+//            CacheKey constKey = (CacheKey) cacheKey.clone();
+//
+//            try {
+//                bundle = loadBundle(cacheKey, formats, control, expiredBundle);
+//                if (bundle != null) {
+//                    if (bundle.parent == null) {
+//                        bundle.setParent(parent);
+//                    }
+//                    bundle.locale = targetLocale;
+//                    bundle = putBundleInCache(cacheKey, bundle, control);
+//                    return bundle;
+//                }
+//
+//                // Put NONEXISTENT_BUNDLE in the cache as a mark that there's no bundle
+//                // instance for the locale.
+//                putBundleInCache(cacheKey, NONEXISTENT_BUNDLE, control);
+//            } finally {
+//                if (constKey.getCause() instanceof InterruptedException) {
+//                    Thread.currentThread().interrupt();
+//                }
+//            }
+//        }
+//        return parent;
+//    }
 
     private static ResourceBundle loadBundle(CacheKey cacheKey,
                                              List<String> formats,
                                              Control control,
-                                             boolean reload) {
-
-        // Here we actually load the bundle in the order of formats
-        // specified by the getFormats() value.
-        Locale targetLocale = cacheKey.getLocale();
-
-        ResourceBundle bundle = null;
-        int size = formats.size();
-        for (int i = 0; i < size; i++) {
-            String format = formats.get(i);
-            try {
-                bundle = control.newBundle(cacheKey.getName(), targetLocale, format,
-                                           cacheKey.getLoader(), reload);
-            } catch (LinkageError error) {
-                // We need to handle the LinkageError case due to
-                // inconsistent case-sensitivity in ClassLoader.
-                // See 6572242 for details.
-                cacheKey.setCause(error);
-            } catch (Exception cause) {
-                cacheKey.setCause(cause);
-            }
-            if (bundle != null) {
-                // Set the format in the cache key so that it can be
-                // used when calling needsReload later.
-                cacheKey.setFormat(format);
-                bundle.name = cacheKey.getName();
-                bundle.locale = targetLocale;
-                // Bundle provider might reuse instances. So we should make
-                // sure to clear the expired flag here.
-                bundle.expired = false;
-                break;
-            }
-        }
-
-        return bundle;
-    }
-
-    private static boolean isValidBundle(ResourceBundle bundle) {
-        return bundle != null && bundle != NONEXISTENT_BUNDLE;
-    }
+                                             boolean reload) {throw new RuntimeException("cf-bug");} //{
+//
+//        // Here we actually load the bundle in the order of formats
+//        // specified by the getFormats() value.
+//        Locale targetLocale = cacheKey.getLocale();
+//
+//        ResourceBundle bundle = null;
+//        int size = formats.size();
+//        for (int i = 0; i < size; i++) {
+//            String format = formats.get(i);
+//            try {
+//                bundle = control.newBundle(cacheKey.getName(), targetLocale, format,
+//                                           cacheKey.getLoader(), reload);
+//            } catch (LinkageError error) {
+//                // We need to handle the LinkageError case due to
+//                // inconsistent case-sensitivity in ClassLoader.
+//                // See 6572242 for details.
+//                cacheKey.setCause(error);
+//            } catch (Exception cause) {
+//                cacheKey.setCause(cause);
+//            }
+//            if (bundle != null) {
+//                // Set the format in the cache key so that it can be
+//                // used when calling needsReload later.
+//                cacheKey.setFormat(format);
+//                bundle.name = cacheKey.getName();
+//                bundle.locale = targetLocale;
+//                // Bundle provider might reuse instances. So we should make
+//                // sure to clear the expired flag here.
+//                bundle.expired = false;
+//                break;
+//            }
+//        }
+//
+//        return bundle;
+//    }
+
+    private static boolean isValidBundle(ResourceBundle bundle) {throw new RuntimeException("cf-bug");} //{
+//        return bundle != null && bundle != NONEXISTENT_BUNDLE;
+//    }
 
     /**
      * Determines whether any of resource bundles in the parent chain,
      * including the leaf, have expired.
      */
-    private static boolean hasValidParentChain(ResourceBundle bundle) {
-        long now = System.currentTimeMillis();
-        while (bundle != null) {
-            if (bundle.expired) {
-                return false;
-            }
-            CacheKey key = bundle.cacheKey;
-            if (key != null) {
-                long expirationTime = key.expirationTime;
-                if (expirationTime >= 0 && expirationTime <= now) {
-                    return false;
-                }
-            }
-            bundle = bundle.parent;
-        }
-        return true;
-    }
+    private static boolean hasValidParentChain(ResourceBundle bundle) {throw new RuntimeException("cf-bug");} //{
+//        long now = System.currentTimeMillis();
+//        while (bundle != null) {
+//            if (bundle.expired) {
+//                return false;
+//            }
+//            CacheKey key = bundle.cacheKey;
+//            if (key != null) {
+//                long expirationTime = key.expirationTime;
+//                if (expirationTime >= 0 && expirationTime <= now) {
+//                    return false;
+//                }
+//            }
+//            bundle = bundle.parent;
+//        }
+//        return true;
+//    }
 
     /**
      * Throw a MissingResourceException with proper message
      */
     private static void throwMissingResourceException(String baseName,
                                                       Locale locale,
-                                                      Throwable cause) {
-        // If the cause is a MissingResourceException, avoid creating
-        // a long chain. (6355009)
-        if (cause instanceof MissingResourceException) {
-            cause = null;
-        }
-        throw new MissingResourceException("Can't find bundle for base name "
-                                           + baseName + ", locale " + locale,
-                                           baseName + "_" + locale, // className
-                                           "",                      // key
-                                           cause);
-    }
+                                                      Throwable cause) {throw new RuntimeException("cf-bug");} //{
+//        // If the cause is a MissingResourceException, avoid creating
+//        // a long chain. (6355009)
+//        if (cause instanceof MissingResourceException) {
+//            cause = null;
+//        }
+//        throw new MissingResourceException("Can't find bundle for base name "
+//                                           + baseName + ", locale " + locale,
+//                                           baseName + "_" + locale, // className
+//                                           "",                      // key
+//                                           cause);
+//    }
 
     /**
      * Finds a bundle in the cache. Any expired bundles are marked as
@@ -1590,102 +1590,102 @@
      * upon return if the bundle in the cache has expired.
      */
     private static ResourceBundle findBundleInCache(CacheKey cacheKey,
-                                                    Control control) {
-        BundleReference bundleRef = cacheList.get(cacheKey);
-        if (bundleRef == null) {
-            return null;
-        }
-        ResourceBundle bundle = bundleRef.get();
-        if (bundle == null) {
-            return null;
-        }
-        ResourceBundle p = bundle.parent;
-        assert p != NONEXISTENT_BUNDLE;
-        // If the parent has expired, then this one must also expire. We
-        // check only the immediate parent because the actual loading is
-        // done from the root (base) to leaf (child) and the purpose of
-        // checking is to propagate expiration towards the leaf. For
-        // example, if the requested locale is ja_JP_JP and there are
-        // bundles for all of the candidates in the cache, we have a list,
-        //
-        // base <- ja <- ja_JP <- ja_JP_JP
-        //
-        // If ja has expired, then it will reload ja and the list becomes a
-        // tree.
-        //
-        // base <- ja (new)
-        //  "   <- ja (expired) <- ja_JP <- ja_JP_JP
-        //
-        // When looking up ja_JP in the cache, it finds ja_JP in the cache
-        // which references to the expired ja. Then, ja_JP is marked as
-        // expired and removed from the cache. This will be propagated to
-        // ja_JP_JP.
-        //
-        // Now, it's possible, for example, that while loading new ja_JP,
-        // someone else has started loading the same bundle and finds the
-        // base bundle has expired. Then, what we get from the first
-        // getBundle call includes the expired base bundle. However, if
-        // someone else didn't start its loading, we wouldn't know if the
-        // base bundle has expired at the end of the loading process. The
-        // expiration control doesn't guarantee that the returned bundle and
-        // its parents haven't expired.
-        //
-        // We could check the entire parent chain to see if there's any in
-        // the chain that has expired. But this process may never end. An
-        // extreme case would be that getTimeToLive returns 0 and
-        // needsReload always returns true.
-        if (p != null && p.expired) {
-            assert bundle != NONEXISTENT_BUNDLE;
-            bundle.expired = true;
-            bundle.cacheKey = null;
-            cacheList.remove(cacheKey, bundleRef);
-            bundle = null;
-        } else {
-            CacheKey key = bundleRef.getCacheKey();
-            long expirationTime = key.expirationTime;
-            if (!bundle.expired && expirationTime >= 0 &&
-                expirationTime <= System.currentTimeMillis()) {
-                // its TTL period has expired.
-                if (bundle != NONEXISTENT_BUNDLE) {
-                    // Synchronize here to call needsReload to avoid
-                    // redundant concurrent calls for the same bundle.
-                    synchronized (bundle) {
-                        expirationTime = key.expirationTime;
-                        if (!bundle.expired && expirationTime >= 0 &&
-                            expirationTime <= System.currentTimeMillis()) {
-                            try {
-                                bundle.expired = control.needsReload(key.getName(),
-                                                                     key.getLocale(),
-                                                                     key.getFormat(),
-                                                                     key.getLoader(),
-                                                                     bundle,
-                                                                     key.loadTime);
-                            } catch (Exception e) {
-                                cacheKey.setCause(e);
-                            }
-                            if (bundle.expired) {
-                                // If the bundle needs to be reloaded, then
-                                // remove the bundle from the cache, but
-                                // return the bundle with the expired flag
-                                // on.
-                                bundle.cacheKey = null;
-                                cacheList.remove(cacheKey, bundleRef);
-                            } else {
-                                // Update the expiration control info. and reuse
-                                // the same bundle instance
-                                setExpirationTime(key, control);
-                            }
-                        }
-                    }
-                } else {
-                    // We just remove NONEXISTENT_BUNDLE from the cache.
-                    cacheList.remove(cacheKey, bundleRef);
-                    bundle = null;
-                }
-            }
-        }
-        return bundle;
-    }
+                                                    Control control) {throw new RuntimeException("cf-bug");} //{
+//        BundleReference bundleRef = cacheList.get(cacheKey);
+//        if (bundleRef == null) {
+//            return null;
+//        }
+//        ResourceBundle bundle = bundleRef.get();
+//        if (bundle == null) {
+//            return null;
+//        }
+//        ResourceBundle p = bundle.parent;
+//        assert p != NONEXISTENT_BUNDLE;
+//        // If the parent has expired, then this one must also expire. We
+//        // check only the immediate parent because the actual loading is
+//        // done from the root (base) to leaf (child) and the purpose of
+//        // checking is to propagate expiration towards the leaf. For
+//        // example, if the requested locale is ja_JP_JP and there are
+//        // bundles for all of the candidates in the cache, we have a list,
+//        //
+//        // base <- ja <- ja_JP <- ja_JP_JP
+//        //
+//        // If ja has expired, then it will reload ja and the list becomes a
+//        // tree.
+//        //
+//        // base <- ja (new)
+//        //  "   <- ja (expired) <- ja_JP <- ja_JP_JP
+//        //
+//        // When looking up ja_JP in the cache, it finds ja_JP in the cache
+//        // which references to the expired ja. Then, ja_JP is marked as
+//        // expired and removed from the cache. This will be propagated to
+//        // ja_JP_JP.
+//        //
+//        // Now, it's possible, for example, that while loading new ja_JP,
+//        // someone else has started loading the same bundle and finds the
+//        // base bundle has expired. Then, what we get from the first
+//        // getBundle call includes the expired base bundle. However, if
+//        // someone else didn't start its loading, we wouldn't know if the
+//        // base bundle has expired at the end of the loading process. The
+//        // expiration control doesn't guarantee that the returned bundle and
+//        // its parents haven't expired.
+//        //
+//        // We could check the entire parent chain to see if there's any in
+//        // the chain that has expired. But this process may never end. An
+//        // extreme case would be that getTimeToLive returns 0 and
+//        // needsReload always returns true.
+//        if (p != null && p.expired) {
+//            assert bundle != NONEXISTENT_BUNDLE;
+//            bundle.expired = true;
+//            bundle.cacheKey = null;
+//            cacheList.remove(cacheKey, bundleRef);
+//            bundle = null;
+//        } else {
+//            CacheKey key = bundleRef.getCacheKey();
+//            long expirationTime = key.expirationTime;
+//            if (!bundle.expired && expirationTime >= 0 &&
+//                expirationTime <= System.currentTimeMillis()) {
+//                // its TTL period has expired.
+//                if (bundle != NONEXISTENT_BUNDLE) {
+//                    // Synchronize here to call needsReload to avoid
+//                    // redundant concurrent calls for the same bundle.
+//                    synchronized (bundle) {
+//                        expirationTime = key.expirationTime;
+//                        if (!bundle.expired && expirationTime >= 0 &&
+//                            expirationTime <= System.currentTimeMillis()) {
+//                            try {
+//                                bundle.expired = control.needsReload(key.getName(),
+//                                                                     key.getLocale(),
+//                                                                     key.getFormat(),
+//                                                                     key.getLoader(),
+//                                                                     bundle,
+//                                                                     key.loadTime);
+//                            } catch (Exception e) {
+//                                cacheKey.setCause(e);
+//                            }
+//                            if (bundle.expired) {
+//                                // If the bundle needs to be reloaded, then
+//                                // remove the bundle from the cache, but
+//                                // return the bundle with the expired flag
+//                                // on.
+//                                bundle.cacheKey = null;
+//                                cacheList.remove(cacheKey, bundleRef);
+//                            } else {
+//                                // Update the expiration control info. and reuse
+//                                // the same bundle instance
+//                                setExpirationTime(key, control);
+//                            }
+//                        }
+//                    }
+//                } else {
+//                    // We just remove NONEXISTENT_BUNDLE from the cache.
+//                    cacheList.remove(cacheKey, bundleRef);
+//                    bundle = null;
+//                }
+//            }
+//        }
+//        return bundle;
+//    }
 
     /**
      * Put a new bundle in the cache.
@@ -1698,52 +1698,52 @@
      */
     private static ResourceBundle putBundleInCache(CacheKey cacheKey,
                                                    ResourceBundle bundle,
-                                                   Control control) {
-        setExpirationTime(cacheKey, control);
-        if (cacheKey.expirationTime != Control.TTL_DONT_CACHE) {
-            CacheKey key = (CacheKey) cacheKey.clone();
-            BundleReference bundleRef = new BundleReference(bundle, referenceQueue, key);
-            bundle.cacheKey = key;
-
-            // Put the bundle in the cache if it's not been in the cache.
-            BundleReference result = cacheList.putIfAbsent(key, bundleRef);
-
-            // If someone else has put the same bundle in the cache before
-            // us and it has not expired, we should use the one in the cache.
-            if (result != null) {
-                ResourceBundle rb = result.get();
-                if (rb != null && !rb.expired) {
-                    // Clear the back link to the cache key
-                    bundle.cacheKey = null;
-                    bundle = rb;
-                    // Clear the reference in the BundleReference so that
-                    // it won't be enqueued.
-                    bundleRef.clear();
-                } else {
-                    // Replace the invalid (garbage collected or expired)
-                    // instance with the valid one.
-                    cacheList.put(key, bundleRef);
-                }
-            }
-        }
-        return bundle;
-    }
-
-    private static void setExpirationTime(CacheKey cacheKey, Control control) {
-        long ttl = control.getTimeToLive(cacheKey.getName(),
-                                         cacheKey.getLocale());
-        if (ttl >= 0) {
-            // If any expiration time is specified, set the time to be
-            // expired in the cache.
-            long now = System.currentTimeMillis();
-            cacheKey.loadTime = now;
-            cacheKey.expirationTime = now + ttl;
-        } else if (ttl >= Control.TTL_NO_EXPIRATION_CONTROL) {
-            cacheKey.expirationTime = ttl;
-        } else {
-            throw new IllegalArgumentException("Invalid Control: TTL=" + ttl);
-        }
-    }
+                                                   Control control) {throw new RuntimeException("cf-bug");} //{
+//        setExpirationTime(cacheKey, control);
+//        if (cacheKey.expirationTime != Control.TTL_DONT_CACHE) {
+//            CacheKey key = (CacheKey) cacheKey.clone();
+//            BundleReference bundleRef = new BundleReference(bundle, referenceQueue, key);
+//            bundle.cacheKey = key;
+//
+//            // Put the bundle in the cache if it's not been in the cache.
+//            BundleReference result = cacheList.putIfAbsent(key, bundleRef);
+//
+//            // If someone else has put the same bundle in the cache before
+//            // us and it has not expired, we should use the one in the cache.
+//            if (result != null) {
+//                ResourceBundle rb = result.get();
+//                if (rb != null && !rb.expired) {
+//                    // Clear the back link to the cache key
+//                    bundle.cacheKey = null;
+//                    bundle = rb;
+//                    // Clear the reference in the BundleReference so that
+//                    // it won't be enqueued.
+//                    bundleRef.clear();
+//                } else {
+//                    // Replace the invalid (garbage collected or expired)
+//                    // instance with the valid one.
+//                    cacheList.put(key, bundleRef);
+//                }
+//            }
+//        }
+//        return bundle;
+//    }
+
+    private static void setExpirationTime(CacheKey cacheKey, Control control) {throw new RuntimeException("cf-bug");} //{
+//        long ttl = control.getTimeToLive(cacheKey.getName(),
+//                                         cacheKey.getLocale());
+//        if (ttl >= 0) {
+//            // If any expiration time is specified, set the time to be
+//            // expired in the cache.
+//            long now = System.currentTimeMillis();
+//            cacheKey.loadTime = now;
+//            cacheKey.expirationTime = now + ttl;
+//        } else if (ttl >= Control.TTL_NO_EXPIRATION_CONTROL) {
+//            cacheKey.expirationTime = ttl;
+//        } else {
+//            throw new IllegalArgumentException("Invalid Control: TTL=" + ttl);
+//        }
+//    }
 
     /**
      * Removes all resource bundles from the cache that have been loaded
@@ -1753,9 +1753,9 @@
      * @see ResourceBundle.Control#getTimeToLive(String,Locale)
      */
     @CallerSensitive
-    public static final void clearCache() {
-        clearCache(getLoader(Reflection.getCallerClass()));
-    }
+    public static final void clearCache() {throw new RuntimeException("cf-bug");} //{
+//        clearCache(getLoader(Reflection.getCallerClass()));
+//    }
 
     /**
      * Removes all resource bundles from the cache that have been loaded
@@ -1766,17 +1766,17 @@
      * @since 1.6
      * @see ResourceBundle.Control#getTimeToLive(String,Locale)
      */
-    public static final void clearCache(ClassLoader loader) {
-        if (loader == null) {
-            throw new NullPointerException();
-        }
-        Set<CacheKey> set = cacheList.keySet();
-        for (CacheKey key : set) {
-            if (key.getLoader() == loader) {
-                set.remove(key);
-            }
-        }
-    }
+    public static final void clearCache(ClassLoader loader) {throw new RuntimeException("cf-bug");} //{
+//        if (loader == null) {
+//            throw new NullPointerException();
+//        }
+//        Set<CacheKey> set = cacheList.keySet();
+//        for (CacheKey key : set) {
+//            if (key.getLoader() == loader) {
+//                set.remove(key);
+//            }
+//        }
+//    }
 
     /**
      * Gets an object for the given key from this resource bundle.
@@ -1812,17 +1812,17 @@
      * @since 1.6
      */
     @Pure
-    public boolean containsKey(@GuardSatisfied ResourceBundle this, String key) {
-        if (key == null) {
-            throw new NullPointerException();
-        }
-        for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
-            if (rb.handleKeySet().contains(key)) {
-                return true;
-            }
-        }
-        return false;
-    }
+    public boolean containsKey(@GuardSatisfied ResourceBundle this, String key) {throw new RuntimeException("cf-bug");} //{
+//        if (key == null) {
+//            throw new NullPointerException();
+//        }
+//        for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
+//            if (rb.handleKeySet().contains(key)) {
+//                return true;
+//            }
+//        }
+//        return false;
+//    }
 
     /**
      * Returns a <code>Set</code> of all keys contained in this
@@ -1833,13 +1833,13 @@
      * @since 1.6
      */
     @SideEffectFree
-    public Set<@KeyFor({"this"}) String> keySet(@GuardSatisfied ResourceBundle this) {
-        Set<String> keys = new HashSet<>();
-        for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
-            keys.addAll(rb.handleKeySet());
-        }
-        return keys;
-    }
+    public Set<@KeyFor({"this"}) String> keySet(@GuardSatisfied ResourceBundle this) {throw new RuntimeException("cf-bug");} //{
+//        Set<String> keys = new HashSet<>();
+//        for (ResourceBundle rb = this; rb != null; rb = rb.parent) {
+//            keys.addAll(rb.handleKeySet());
+//        }
+//        return keys;
+//    }
 
     /**
      * Returns a <code>Set</code> of the keys contained <em>only</em>
@@ -1858,24 +1858,24 @@
      *        <code>ResourceBundle</code>
      * @since 1.6
      */
-    protected Set<String> handleKeySet() {
-        if (keySet == null) {
-            synchronized (this) {
-                if (keySet == null) {
-                    Set<String> keys = new HashSet<>();
-                    Enumeration<String> enumKeys = getKeys();
-                    while (enumKeys.hasMoreElements()) {
-                        String key = enumKeys.nextElement();
-                        if (handleGetObject(key) != null) {
-                            keys.add(key);
-                        }
-                    }
-                    keySet = keys;
-                }
-            }
-        }
-        return keySet;
-    }
+    protected Set<String> handleKeySet() {throw new RuntimeException("cf-bug");} //{
+//        if (keySet == null) {
+//            synchronized (this) {
+//                if (keySet == null) {
+//                    Set<String> keys = new HashSet<>();
+//                    Enumeration<String> enumKeys = getKeys();
+//                    while (enumKeys.hasMoreElements()) {
+//                        String key = enumKeys.nextElement();
+//                        if (handleGetObject(key) != null) {
+//                            keys.add(key);
+//                        }
+//                    }
+//                    keySet = keys;
+//                }
+//            }
+//        }
+//        return keySet;
+//    }
 
 
 
@@ -2108,18 +2108,18 @@
          * @exception IllegalArgumentException
          *        if <code>formats</code> is unknown
          */
-        public static final Control getControl(List<String> formats) {
-            if (formats.equals(Control.FORMAT_PROPERTIES)) {
-                return SingleFormatControl.PROPERTIES_ONLY;
-            }
-            if (formats.equals(Control.FORMAT_CLASS)) {
-                return SingleFormatControl.CLASS_ONLY;
-            }
-            if (formats.equals(Control.FORMAT_DEFAULT)) {
-                return Control.INSTANCE;
-            }
-            throw new IllegalArgumentException();
-        }
+        public static final Control getControl(List<String> formats) {throw new RuntimeException("cf-bug");} //{
+//            if (formats.equals(Control.FORMAT_PROPERTIES)) {
+//                return SingleFormatControl.PROPERTIES_ONLY;
+//            }
+//            if (formats.equals(Control.FORMAT_CLASS)) {
+//                return SingleFormatControl.CLASS_ONLY;
+//            }
+//            if (formats.equals(Control.FORMAT_DEFAULT)) {
+//                return Control.INSTANCE;
+//            }
+//            throw new IllegalArgumentException();
+//        }
 
         /**
          * Returns a <code>ResourceBundle.Control</code> in which the {@link
@@ -2143,18 +2143,18 @@
          * @exception IllegalArgumentException
          *        if <code>formats</code> is unknown
          */
-        public static final Control getNoFallbackControl(List<String> formats) {
-            if (formats.equals(Control.FORMAT_DEFAULT)) {
-                return NoFallbackControl.NO_FALLBACK;
-            }
-            if (formats.equals(Control.FORMAT_PROPERTIES)) {
-                return NoFallbackControl.PROPERTIES_ONLY_NO_FALLBACK;
-            }
-            if (formats.equals(Control.FORMAT_CLASS)) {
-                return NoFallbackControl.CLASS_ONLY_NO_FALLBACK;
-            }
-            throw new IllegalArgumentException();
-        }
+        public static final Control getNoFallbackControl(List<String> formats) {throw new RuntimeException("cf-bug");} //{
+//            if (formats.equals(Control.FORMAT_DEFAULT)) {
+//                return NoFallbackControl.NO_FALLBACK;
+//            }
+//            if (formats.equals(Control.FORMAT_PROPERTIES)) {
+//                return NoFallbackControl.PROPERTIES_ONLY_NO_FALLBACK;
+//            }
+//            if (formats.equals(Control.FORMAT_CLASS)) {
+//                return NoFallbackControl.CLASS_ONLY_NO_FALLBACK;
+//            }
+//            throw new IllegalArgumentException();
+//        }
 
         /**
          * Returns a <code>List</code> of <code>String</code>s containing
@@ -2190,12 +2190,12 @@
          * @see #FORMAT_CLASS
          * @see #FORMAT_PROPERTIES
          */
-        public List<String> getFormats(String baseName) {
-            if (baseName == null) {
-                throw new NullPointerException();
-            }
-            return FORMAT_DEFAULT;
-        }
+        public List<String> getFormats(String baseName) {throw new RuntimeException("cf-bug");} //{
+//            if (baseName == null) {
+//                throw new NullPointerException();
+//            }
+//            return FORMAT_DEFAULT;
+//        }
 
         /**
          * Returns a <code>List</code> of <code>Locale</code>s as candidate
@@ -2375,132 +2375,132 @@
          *        if <code>baseName</code> or <code>locale</code> is
          *        <code>null</code>
          */
-        public List<Locale> getCandidateLocales(String baseName, Locale locale) {
-            if (baseName == null) {
-                throw new NullPointerException();
-            }
-            return new ArrayList<>(CANDIDATES_CACHE.get(locale.getBaseLocale()));
-        }
+        public List<Locale> getCandidateLocales(String baseName, Locale locale) {throw new RuntimeException("cf-bug");} //{
+//            if (baseName == null) {
+//                throw new NullPointerException();
+//            }
+//            return new ArrayList<>(CANDIDATES_CACHE.get(locale.getBaseLocale()));
+//        }
 
         private static final CandidateListCache CANDIDATES_CACHE = new CandidateListCache();
 
         private static class CandidateListCache extends LocaleObjectCache<BaseLocale, List<Locale>> {
-            protected List<Locale> createObject(BaseLocale base) {
-                String language = base.getLanguage();
-                String script = base.getScript();
-                String region = base.getRegion();
-                String variant = base.getVariant();
-
-                // Special handling for Norwegian
-                boolean isNorwegianBokmal = false;
-                boolean isNorwegianNynorsk = false;
-                if (language.equals("no")) {
-                    if (region.equals("NO") && variant.equals("NY")) {
-                        variant = "";
-                        isNorwegianNynorsk = true;
-                    } else {
-                        isNorwegianBokmal = true;
-                    }
-                }
-                if (language.equals("nb") || isNorwegianBokmal) {
-                    List<Locale> tmpList = getDefaultList("nb", script, region, variant);
-                    // Insert a locale replacing "nb" with "no" for every list entry
-                    List<Locale> bokmalList = new LinkedList<>();
-                    for (Locale l : tmpList) {
-                        bokmalList.add(l);
-                        if (l.getLanguage().length() == 0) {
-                            break;
-                        }
-                        bokmalList.add(Locale.getInstance("no", l.getScript(), l.getCountry(),
-                                l.getVariant(), null));
-                    }
-                    return bokmalList;
-                } else if (language.equals("nn") || isNorwegianNynorsk) {
-                    // Insert no_NO_NY, no_NO, no after nn
-                    List<Locale> nynorskList = getDefaultList("nn", script, region, variant);
-                    int idx = nynorskList.size() - 1;
-                    nynorskList.add(idx++, Locale.getInstance("no", "NO", "NY"));
-                    nynorskList.add(idx++, Locale.getInstance("no", "NO", ""));
-                    nynorskList.add(idx++, Locale.getInstance("no", "", ""));
-                    return nynorskList;
-                }
-                // Special handling for Chinese
-                else if (language.equals("zh")) {
-                    if (script.length() == 0 && region.length() > 0) {
-                        // Supply script for users who want to use zh_Hans/zh_Hant
-                        // as bundle names (recommended for Java7+)
-                        switch (region) {
-                        case "TW":
-                        case "HK":
-                        case "MO":
-                            script = "Hant";
-                            break;
-                        case "CN":
-                        case "SG":
-                            script = "Hans";
-                            break;
-                        }
-                    } else if (script.length() > 0 && region.length() == 0) {
-                        // Supply region(country) for users who still package Chinese
-                        // bundles using old convension.
-                        switch (script) {
-                        case "Hans":
-                            region = "CN";
-                            break;
-                        case "Hant":
-                            region = "TW";
-                            break;
-                        }
-                    }
-                }
-
-                return getDefaultList(language, script, region, variant);
-            }
-
-            private static List<Locale> getDefaultList(String language, String script, String region, String variant) {
-                List<String> variants = null;
-
-                if (variant.length() > 0) {
-                    variants = new LinkedList<>();
-                    int idx = variant.length();
-                    while (idx != -1) {
-                        variants.add(variant.substring(0, idx));
-                        idx = variant.lastIndexOf('_', --idx);
-                    }
-                }
-
-                List<Locale> list = new LinkedList<>();
-
-                if (variants != null) {
-                    for (String v : variants) {
-                        list.add(Locale.getInstance(language, script, region, v, null));
-                    }
-                }
-                if (region.length() > 0) {
-                    list.add(Locale.getInstance(language, script, region, "", null));
-                }
-                if (script.length() > 0) {
-                    list.add(Locale.getInstance(language, script, "", "", null));
-
-                    // With script, after truncating variant, region and script,
-                    // start over without script.
-                    if (variants != null) {
-                        for (String v : variants) {
-                            list.add(Locale.getInstance(language, "", region, v, null));
-                        }
-                    }
-                    if (region.length() > 0) {
-                        list.add(Locale.getInstance(language, "", region, "", null));
-                    }
-                }
-                if (language.length() > 0) {
-                    list.add(Locale.getInstance(language, "", "", "", null));
-                }
-                // Add root locale at the end
-                list.add(Locale.ROOT);
-
-                return list;
-            }
+            protected List<Locale> createObject(BaseLocale base) {throw new RuntimeException("cf-bug");} //{
+//                String language = base.getLanguage();
+//                String script = base.getScript();
+//                String region = base.getRegion();
+//                String variant = base.getVariant();
+//
+//                // Special handling for Norwegian
+//                boolean isNorwegianBokmal = false;
+//                boolean isNorwegianNynorsk = false;
+//                if (language.equals("no")) {
+//                    if (region.equals("NO") && variant.equals("NY")) {
+//                        variant = "";
+//                        isNorwegianNynorsk = true;
+//                    } else {
+//                        isNorwegianBokmal = true;
+//                    }
+//                }
+//                if (language.equals("nb") || isNorwegianBokmal) {
+//                    List<Locale> tmpList = getDefaultList("nb", script, region, variant);
+//                    // Insert a locale replacing "nb" with "no" for every list entry
+//                    List<Locale> bokmalList = new LinkedList<>();
+//                    for (Locale l : tmpList) {
+//                        bokmalList.add(l);
+//                        if (l.getLanguage().length() == 0) {
+//                            break;
+//                        }
+//                        bokmalList.add(Locale.getInstance("no", l.getScript(), l.getCountry(),
+//                                l.getVariant(), null));
+//                    }
+//                    return bokmalList;
+//                } else if (language.equals("nn") || isNorwegianNynorsk) {
+//                    // Insert no_NO_NY, no_NO, no after nn
+//                    List<Locale> nynorskList = getDefaultList("nn", script, region, variant);
+//                    int idx = nynorskList.size() - 1;
+//                    nynorskList.add(idx++, Locale.getInstance("no", "NO", "NY"));
+//                    nynorskList.add(idx++, Locale.getInstance("no", "NO", ""));
+//                    nynorskList.add(idx++, Locale.getInstance("no", "", ""));
+//                    return nynorskList;
+//                }
+//                // Special handling for Chinese
+//                else if (language.equals("zh")) {
+//                    if (script.length() == 0 && region.length() > 0) {
+//                        // Supply script for users who want to use zh_Hans/zh_Hant
+//                        // as bundle names (recommended for Java7+)
+//                        switch (region) {
+//                        case "TW":
+//                        case "HK":
+//                        case "MO":
+//                            script = "Hant";
+//                            break;
+//                        case "CN":
+//                        case "SG":
+//                            script = "Hans";
+//                            break;
+//                        }
+//                    } else if (script.length() > 0 && region.length() == 0) {
+//                        // Supply region(country) for users who still package Chinese
+//                        // bundles using old convension.
+//                        switch (script) {
+//                        case "Hans":
+//                            region = "CN";
+//                            break;
+//                        case "Hant":
+//                            region = "TW";
+//                            break;
+//                        }
+//                    }
+//                }
+//
+//                return getDefaultList(language, script, region, variant);
+//            }
+
+            private static List<Locale> getDefaultList(String language, String script, String region, String variant) {throw new RuntimeException("cf-bug");} //{
+//                List<String> variants = null;
+//
+//                if (variant.length() > 0) {
+//                    variants = new LinkedList<>();
+//                    int idx = variant.length();
+//                    while (idx != -1) {
+//                        variants.add(variant.substring(0, idx));
+//                        idx = variant.lastIndexOf('_', --idx);
+//                    }
+//                }
+//
+//                List<Locale> list = new LinkedList<>();
+//
+//                if (variants != null) {
+//                    for (String v : variants) {
+//                        list.add(Locale.getInstance(language, script, region, v, null));
+//                    }
+//                }
+//                if (region.length() > 0) {
+//                    list.add(Locale.getInstance(language, script, region, "", null));
+//                }
+//                if (script.length() > 0) {
+//                    list.add(Locale.getInstance(language, script, "", "", null));
+//
+//                    // With script, after truncating variant, region and script,
+//                    // start over without script.
+//                    if (variants != null) {
+//                        for (String v : variants) {
+//                            list.add(Locale.getInstance(language, "", region, v, null));
+//                        }
+//                    }
+//                    if (region.length() > 0) {
+//                        list.add(Locale.getInstance(language, "", region, "", null));
+//                    }
+//                }
+//                if (language.length() > 0) {
+//                    list.add(Locale.getInstance(language, "", "", "", null));
+//                }
+//                // Add root locale at the end
+//                list.add(Locale.ROOT);
+//
+//                return list;
+//            }
         }
 
         /**
@@ -2539,13 +2539,13 @@
          *        if <code>baseName</code> or <code>locale</code>
          *        is <code>null</code>
          */
-        public Locale getFallbackLocale(String baseName, Locale locale) {
-            if (baseName == null) {
-                throw new NullPointerException();
-            }
-            Locale defaultLocale = Locale.getDefault();
-            return locale.equals(defaultLocale) ? null : defaultLocale;
-        }
+        public Locale getFallbackLocale(String baseName, Locale locale) {throw new RuntimeException("cf-bug");} //{
+//            if (baseName == null) {
+//                throw new NullPointerException();
+//            }
+//            Locale defaultLocale = Locale.getDefault();
+//            return locale.equals(defaultLocale) ? null : defaultLocale;
+//        }
 
         /**
          * Instantiates a resource bundle for the given bundle name of the
@@ -2645,70 +2645,70 @@
          */
         public ResourceBundle newBundle(@BinaryName String baseName, Locale locale, String format,
                                         ClassLoader loader, boolean reload)
-                    throws IllegalAccessException, InstantiationException, IOException {
-            String bundleName = toBundleName(baseName, locale);
-            ResourceBundle bundle = null;
-            if (format.equals("java.class")) {
-                try {
-                    @SuppressWarnings("unchecked")
-                    Class<? extends ResourceBundle> bundleClass
-                        = (Class<? extends ResourceBundle>)loader.loadClass(bundleName);
-
-                    // If the class isn't a ResourceBundle subclass, throw a
-                    // ClassCastException.
-                    if (ResourceBundle.class.isAssignableFrom(bundleClass)) {
-                        bundle = bundleClass.newInstance();
-                    } else {
-                        throw new ClassCastException(bundleClass.getName()
-                                     + " cannot be cast to ResourceBundle");
-                    }
-                } catch (ClassNotFoundException e) {
-                }
-            } else if (format.equals("java.properties")) {
-                final String resourceName = toResourceName0(bundleName, "properties");
-                if (resourceName == null) {
-                    return bundle;
-                }
-                final ClassLoader classLoader = loader;
-                final boolean reloadFlag = reload;
-                InputStream stream = null;
-                try {
-                    stream = AccessController.doPrivileged(
-                        new PrivilegedExceptionAction<InputStream>() {
-                            public InputStream run() throws IOException {
-                                InputStream is = null;
-                                if (reloadFlag) {
-                                    URL url = classLoader.getResource(resourceName);
-                                    if (url != null) {
-                                        URLConnection connection = url.openConnection();
-                                        if (connection != null) {
-                                            // Disable caches to get fresh data for
-                                            // reloading.
-                                            connection.setUseCaches(false);
-                                            is = connection.getInputStream();
-                                        }
-                                    }
-                                } else {
-                                    is = classLoader.getResourceAsStream(resourceName);
-                                }
-                                return is;
-                            }
-                        });
-                } catch (PrivilegedActionException e) {
-                    throw (IOException) e.getException();
-                }
-                if (stream != null) {
-                    try {
-                        bundle = new PropertyResourceBundle(stream);
-                    } finally {
-                        stream.close();
-                    }
-                }
-            } else {
-                throw new IllegalArgumentException("unknown format: " + format);
-            }
-            return bundle;
-        }
+                    throws IllegalAccessException, InstantiationException, IOException {throw new RuntimeException("cf-bug");} //{
+//            String bundleName = toBundleName(baseName, locale);
+//            ResourceBundle bundle = null;
+//            if (format.equals("java.class")) {
+//                try {
+//                    @SuppressWarnings("unchecked")
+//                    Class<? extends ResourceBundle> bundleClass
+//                        = (Class<? extends ResourceBundle>)loader.loadClass(bundleName);
+//
+//                    // If the class isn't a ResourceBundle subclass, throw a
+//                    // ClassCastException.
+//                    if (ResourceBundle.class.isAssignableFrom(bundleClass)) {
+//                        bundle = bundleClass.newInstance();
+//                    } else {
+//                        throw new ClassCastException(bundleClass.getName()
+//                                     + " cannot be cast to ResourceBundle");
+//                    }
+//                } catch (ClassNotFoundException e) {
+//                }
+//            } else if (format.equals("java.properties")) {
+//                final String resourceName = toResourceName0(bundleName, "properties");
+//                if (resourceName == null) {
+//                    return bundle;
+//                }
+//                final ClassLoader classLoader = loader;
+//                final boolean reloadFlag = reload;
+//                InputStream stream = null;
+//                try {
+//                    stream = AccessController.doPrivileged(
+//                        new PrivilegedExceptionAction<InputStream>() {
+//                            public InputStream run() throws IOException {
+//                                InputStream is = null;
+//                                if (reloadFlag) {
+//                                    URL url = classLoader.getResource(resourceName);
+//                                    if (url != null) {
+//                                        URLConnection connection = url.openConnection();
+//                                        if (connection != null) {
+//                                            // Disable caches to get fresh data for
+//                                            // reloading.
+//                                            connection.setUseCaches(false);
+//                                            is = connection.getInputStream();
+//                                        }
+//                                    }
+//                                } else {
+//                                    is = classLoader.getResourceAsStream(resourceName);
+//                                }
+//                                return is;
+//                            }
+//                        });
+//                } catch (PrivilegedActionException e) {
+//                    throw (IOException) e.getException();
+//                }
+//                if (stream != null) {
+//                    try {
+//                        bundle = new PropertyResourceBundle(stream);
+//                    } finally {
+//                        stream.close();
+//                    }
+//                }
+//            } else {
+//                throw new IllegalArgumentException("unknown format: " + format);
+//            }
+//            return bundle;
+//        }
 
         /**
          * Returns the time-to-live (TTL) value for resource bundles that
@@ -2756,12 +2756,12 @@
          *        if <code>baseName</code> or <code>locale</code> is
          *        <code>null</code>
          */
-        public long getTimeToLive(String baseName, Locale locale) {
-            if (baseName == null || locale == null) {
-                throw new NullPointerException();
-            }
-            return TTL_NO_EXPIRATION_CONTROL;
-        }
+        public long getTimeToLive(String baseName, Locale locale) {throw new RuntimeException("cf-bug");} //{
+//            if (baseName == null || locale == null) {
+//                throw new NullPointerException();
+//            }
+//            return TTL_NO_EXPIRATION_CONTROL;
+//        }
 
         /**
          * Determines if the expired <code>bundle</code> in the cache needs
@@ -2813,47 +2813,47 @@
          */
         public boolean needsReload(@BinaryName String baseName, Locale locale,
                                    String format, ClassLoader loader,
-                                   ResourceBundle bundle, long loadTime) {
-            if (bundle == null) {
-                throw new NullPointerException();
-            }
-            if (format.equals("java.class") || format.equals("java.properties")) {
-                format = format.substring(5);
-            }
-            boolean result = false;
-            try {
-                String resourceName = toResourceName0(toBundleName(baseName, locale), format);
-                if (resourceName == null) {
-                    return result;
-                }
-                URL url = loader.getResource(resourceName);
-                if (url != null) {
-                    long lastModified = 0;
-                    URLConnection connection = url.openConnection();
-                    if (connection != null) {
-                        // disable caches to get the correct data
-                        connection.setUseCaches(false);
-                        if (connection instanceof JarURLConnection) {
-                            JarEntry ent = ((JarURLConnection)connection).getJarEntry();
-                            if (ent != null) {
-                                lastModified = ent.getTime();
-                                if (lastModified == -1) {
-                                    lastModified = 0;
-                                }
-                            }
-                        } else {
-                            lastModified = connection.getLastModified();
-                        }
-                    }
-                    result = lastModified >= loadTime;
-                }
-            } catch (NullPointerException npe) {
-                throw npe;
-            } catch (Exception e) {
-                // ignore other exceptions
-            }
-            return result;
-        }
+                                   ResourceBundle bundle, long loadTime) {throw new RuntimeException("cf-bug");} //{
+//            if (bundle == null) {
+//                throw new NullPointerException();
+//            }
+//            if (format.equals("java.class") || format.equals("java.properties")) {
+//                format = format.substring(5);
+//            }
+//            boolean result = false;
+//            try {
+//                String resourceName = toResourceName0(toBundleName(baseName, locale), format);
+//                if (resourceName == null) {
+//                    return result;
+//                }
+//                URL url = loader.getResource(resourceName);
+//                if (url != null) {
+//                    long lastModified = 0;
+//                    URLConnection connection = url.openConnection();
+//                    if (connection != null) {
+//                        // disable caches to get the correct data
+//                        connection.setUseCaches(false);
+//                        if (connection instanceof JarURLConnection) {
+//                            JarEntry ent = ((JarURLConnection)connection).getJarEntry();
+//                            if (ent != null) {
+//                                lastModified = ent.getTime();
+//                                if (lastModified == -1) {
+//                                    lastModified = 0;
+//                                }
+//                            }
+//                        } else {
+//                            lastModified = connection.getLastModified();
+//                        }
+//                    }
+//                    result = lastModified >= loadTime;
+//                }
+//            } catch (NullPointerException npe) {
+//                throw npe;
+//            } catch (Exception e) {
+//                // ignore other exceptions
+//            }
+//            return result;
+//        }
 
         /**
          * Converts the given <code>baseName</code> and <code>locale</code>
@@ -2897,42 +2897,42 @@
          *        if <code>baseName</code> or <code>locale</code>
          *        is <code>null</code>
          */
-        public @BinaryName String toBundleName(@BinaryName String baseName, Locale locale) {
-            if (locale == Locale.ROOT) {
-                return baseName;
-            }
-
-            String language = locale.getLanguage();
-            String script = locale.getScript();
-            String country = locale.getCountry();
-            String variant = locale.getVariant();
-
-            if (language == "" && country == "" && variant == "") {
-                return baseName;
-            }
-
-            StringBuilder sb = new StringBuilder(baseName);
-            sb.append('_');
-            if (script != "") {
-                if (variant != "") {
-                    sb.append(language).append('_').append(script).append('_').append(country).append('_').append(variant);
-                } else if (country != "") {
-                    sb.append(language).append('_').append(script).append('_').append(country);
-                } else {
-                    sb.append(language).append('_').append(script);
-                }
-            } else {
-                if (variant != "") {
-                    sb.append(language).append('_').append(country).append('_').append(variant);
-                } else if (country != "") {
-                    sb.append(language).append('_').append(country);
-                } else {
-                    sb.append(language);
-                }
-            }
-            return sb.toString();
-
-        }
+        public @BinaryName String toBundleName(@BinaryName String baseName, Locale locale) {throw new RuntimeException("cf-bug");} //{
+//            if (locale == Locale.ROOT) {
+//                return baseName;
+//            }
+//
+//            String language = locale.getLanguage();
+//            String script = locale.getScript();
+//            String country = locale.getCountry();
+//            String variant = locale.getVariant();
+//
+//            if (language == "" && country == "" && variant == "") {
+//                return baseName;
+//            }
+//
+//            StringBuilder sb = new StringBuilder(baseName);
+//            sb.append('_');
+//            if (script != "") {
+//                if (variant != "") {
+//                    sb.append(language).append('_').append(script).append('_').append(country).append('_').append(variant);
+//                } else if (country != "") {
+//                    sb.append(language).append('_').append(script).append('_').append(country);
+//                } else {
+//                    sb.append(language).append('_').append(script);
+//                }
+//            } else {
+//                if (variant != "") {
+//                    sb.append(language).append('_').append(country).append('_').append(variant);
+//                } else if (country != "") {
+//                    sb.append(language).append('_').append(country);
+//                } else {
+//                    sb.append(language);
+//                }
+//            }
+//            return sb.toString();
+//
+//        }
 
         /**
          * Converts the given <code>bundleName</code> to the form required
@@ -2954,20 +2954,20 @@
          *         if <code>bundleName</code> or <code>suffix</code>
          *         is <code>null</code>
          */
-        public final String toResourceName(String bundleName, String suffix) {
-            StringBuilder sb = new StringBuilder(bundleName.length() + 1 + suffix.length());
-            sb.append(bundleName.replace('.', '/')).append('.').append(suffix);
-            return sb.toString();
-        }
-
-        private String toResourceName0(String bundleName, String suffix) {
-            // application protocol check
-            if (bundleName.contains("://")) {
-                return null;
-            } else {
-                return toResourceName(bundleName, suffix);
-            }
-        }
+        public final String toResourceName(String bundleName, String suffix) {throw new RuntimeException("cf-bug");} //{
+//            StringBuilder sb = new StringBuilder(bundleName.length() + 1 + suffix.length());
+//            sb.append(bundleName.replace('.', '/')).append('.').append(suffix);
+//            return sb.toString();
+//        }
+
+        private String toResourceName0(String bundleName, String suffix) {throw new RuntimeException("cf-bug");} //{
+//            // application protocol check
+//            if (bundleName.contains("://")) {
+//                return null;
+//            } else {
+//                return toResourceName(bundleName, suffix);
+//            }
+//        }
     }
 
     private static class SingleFormatControl extends Control {
@@ -2983,12 +2983,12 @@
             this.formats = formats;
         }
 
-        public List<String> getFormats(String baseName) {
-            if (baseName == null) {
-                throw new NullPointerException();
-            }
-            return formats;
-        }
+        public List<String> getFormats(String baseName) {throw new RuntimeException("cf-bug");} //{
+//            if (baseName == null) {
+//                throw new NullPointerException();
+//            }
+//            return formats;
+//        }
     }
 
     private static final class NoFallbackControl extends SingleFormatControl {
@@ -3005,11 +3005,11 @@
             super(formats);
         }
 
-        public Locale getFallbackLocale(String baseName, Locale locale) {
-            if (baseName == null || locale == null) {
-                throw new NullPointerException();
-            }
-            return null;
-        }
+        public Locale getFallbackLocale(String baseName, Locale locale) {throw new RuntimeException("cf-bug");} //{
+//            if (baseName == null || locale == null) {
+//                throw new NullPointerException();
+//            }
+//            return null;
+//        }
     }
 }
--- a/javax/imageio/spi/PartiallyOrderedSet.java	2016-06-22 19:55:28.692934467 -0700
+++ b/javax/imageio/spi/PartiallyOrderedSet.java	2016-06-29 11:33:56.570451082 -0700
@@ -68,55 +68,55 @@
      */
     public PartiallyOrderedSet() {}
 
-    public int size() {
-        return nodes.size();
-    }
-
-    public boolean contains(Object o) {
-        return nodes.contains(o);
-    }
+    public int size() {throw new RuntimeException("cf-bug");} //{
+//        return nodes.size();
+//    }
+
+    public boolean contains(Object o) {throw new RuntimeException("cf-bug");} //{
+//        return nodes.contains(o);
+//    }
 
     /**
      * Returns an iterator over the elements contained in this
      * collection, with an ordering that respects the orderings set
      * by the <code>setOrdering</code> method.
      */
-    public Iterator iterator() {
-        return new PartialOrderIterator(poNodes.values().iterator());
-    }
+    public Iterator iterator() {throw new RuntimeException("cf-bug");} //{
+//        return new PartialOrderIterator(poNodes.values().iterator());
+//    }
 
     /**
      * Adds an <code>Object</code> to this
      * <code>PartiallyOrderedSet</code>.
      */
-    public boolean add(Object o) {
-        if (nodes.contains(o)) {
-            return false;
-        }
-
-        DigraphNode node = new DigraphNode(o);
-        poNodes.put(o, node);
-        return true;
-    }
+    public boolean add(Object o) {throw new RuntimeException("cf-bug");} //{
+//        if (nodes.contains(o)) {
+//            return false;
+//        }
+//
+//        DigraphNode node = new DigraphNode(o);
+//        poNodes.put(o, node);
+//        return true;
+//    }
 
     /**
      * Removes an <code>Object</code> from this
      * <code>PartiallyOrderedSet</code>.
      */
-    public boolean remove(Object o) {
-        DigraphNode node = (DigraphNode)poNodes.get(o);
-        if (node == null) {
-            return false;
-        }
-
-        poNodes.remove(o);
-        node.dispose();
-        return true;
-    }
-
-    public void clear() {
-        poNodes.clear();
-    }
+    public boolean remove(Object o) {throw new RuntimeException("cf-bug");} //{
+//        DigraphNode node = (DigraphNode)poNodes.get(o);
+//        if (node == null) {
+//            return false;
+//        }
+//
+//        poNodes.remove(o);
+//        node.dispose();
+//        return true;
+//    }
+
+    public void clear() {throw new RuntimeException("cf-bug");} //{
+//        poNodes.clear();
+//    }
 
     /**
      * Sets an ordering between two nodes.  When an iterator is
@@ -127,43 +127,43 @@
      * @return <code>true</code> if no prior ordering existed
      * between the nodes, <code>false</code>otherwise.
      */
-    public boolean setOrdering(Object first, Object second) {
-        DigraphNode firstPONode =
-            (DigraphNode)poNodes.get(first);
-        DigraphNode secondPONode =
-            (DigraphNode)poNodes.get(second);
-
-        secondPONode.removeEdge(firstPONode);
-        return firstPONode.addEdge(secondPONode);
-    }
+    public boolean setOrdering(Object first, Object second) {throw new RuntimeException("cf-bug");} //{
+//        DigraphNode firstPONode =
+//            (DigraphNode)poNodes.get(first);
+//        DigraphNode secondPONode =
+//            (DigraphNode)poNodes.get(second);
+//
+//        secondPONode.removeEdge(firstPONode);
+//        return firstPONode.addEdge(secondPONode);
+//    }
 
     /**
      * Removes any ordering between two nodes.
      *
      * @return true if a prior prefence existed between the nodes.
      */
-    public boolean unsetOrdering(Object first, Object second) {
-        DigraphNode firstPONode =
-            (DigraphNode)poNodes.get(first);
-        DigraphNode secondPONode =
-            (DigraphNode)poNodes.get(second);
-
-        return firstPONode.removeEdge(secondPONode) ||
-            secondPONode.removeEdge(firstPONode);
-    }
+    public boolean unsetOrdering(Object first, Object second) {throw new RuntimeException("cf-bug");} //{
+//        DigraphNode firstPONode =
+//            (DigraphNode)poNodes.get(first);
+//        DigraphNode secondPONode =
+//            (DigraphNode)poNodes.get(second);
+//
+//        return firstPONode.removeEdge(secondPONode) ||
+//            secondPONode.removeEdge(firstPONode);
+//    }
 
     /**
      * Returns <code>true</code> if an ordering exists between two
      * nodes.
      */
-    public boolean hasOrdering(Object preferred, Object other) {
-        DigraphNode preferredPONode =
-            (DigraphNode)poNodes.get(preferred);
-        DigraphNode otherPONode =
-            (DigraphNode)poNodes.get(other);
-
-        return preferredPONode.hasEdge(otherPONode);
-    }
+    public boolean hasOrdering(Object preferred, Object other) {throw new RuntimeException("cf-bug");} //{
+//        DigraphNode preferredPONode =
+//            (DigraphNode)poNodes.get(preferred);
+//        DigraphNode otherPONode =
+//            (DigraphNode)poNodes.get(other);
+//
+//        return preferredPONode.hasEdge(otherPONode);
+//    }
 }
 
 class PartialOrderIterator implements Iterator {
@@ -185,30 +185,30 @@
         }
     }
 
-    public boolean hasNext() {
-        return !zeroList.isEmpty();
-    }
-
-    public Object next() {
-        DigraphNode first = (DigraphNode)zeroList.removeFirst();
-
-        // For each out node of the output node, decrement its in-degree
-        Iterator outNodes = first.getOutNodes();
-        while (outNodes.hasNext()) {
-            DigraphNode node = (DigraphNode)outNodes.next();
-            int inDegree = ((Integer)inDegrees.get(node)).intValue() - 1;
-            inDegrees.put(node, new Integer(inDegree));
-
-            // If the in-degree has fallen to 0, place the node on the list
-            if (inDegree == 0) {
-                zeroList.add(node);
-            }
-        }
-
-        return first.getData();
-    }
-
-    public void remove() {
-        throw new UnsupportedOperationException();
-    }
+    public boolean hasNext() {throw new RuntimeException("cf-bug");} //{
+//        return !zeroList.isEmpty();
+//    }
+
+    public Object next() {throw new RuntimeException("cf-bug");} //{
+//        DigraphNode first = (DigraphNode)zeroList.removeFirst();
+//
+//        // For each out node of the output node, decrement its in-degree
+//        Iterator outNodes = first.getOutNodes();
+//        while (outNodes.hasNext()) {
+//            DigraphNode node = (DigraphNode)outNodes.next();
+//            int inDegree = ((Integer)inDegrees.get(node)).intValue() - 1;
+//            inDegrees.put(node, new Integer(inDegree));
+//
+//            // If the in-degree has fallen to 0, place the node on the list
+//            if (inDegree == 0) {
+//                zeroList.add(node);
+//            }
+//        }
+//
+//        return first.getData();
+//    }
+
+    public void remove() {throw new RuntimeException("cf-bug");} //{
+//        throw new UnsupportedOperationException();
+//    }
 }
--- a/javax/imageio/spi/ServiceRegistry.java	2016-06-22 19:55:28.705934531 -0700
+++ b/javax/imageio/spi/ServiceRegistry.java	2016-06-29 11:36:05.166069255 -0700
@@ -170,12 +170,12 @@
      */
     public static <T> Iterator<T> lookupProviders(Class<T> providerClass,
                                                   ClassLoader loader)
-    {
-        if (providerClass == null) {
-            throw new IllegalArgumentException("providerClass == null!");
-        }
-        return ServiceLoader.load(providerClass, loader).iterator();
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        if (providerClass == null) {
+//            throw new IllegalArgumentException("providerClass == null!");
+//        }
+//        return ServiceLoader.load(providerClass, loader).iterator();
+//    }
 
     /**
      * Locates and incrementally instantiates the available providers
@@ -201,12 +201,12 @@
      * @exception IllegalArgumentException if
      * <code>providerClass</code> is <code>null</code>.
      */
-    public static <T> Iterator<T> lookupProviders(Class<T> providerClass) {
-        if (providerClass == null) {
-            throw new IllegalArgumentException("providerClass == null!");
-        }
-        return ServiceLoader.load(providerClass).iterator();
-    }
+    public static <T> Iterator<T> lookupProviders(Class<T> providerClass) {throw new RuntimeException("cf-bug");} //{
+//        if (providerClass == null) {
+//            throw new IllegalArgumentException("providerClass == null!");
+//        }
+//        return ServiceLoader.load(providerClass).iterator();
+//    }
 
     /**
      * Returns an <code>Iterator</code> of <code>Class</code> objects
@@ -216,26 +216,26 @@
      * @return an <code>Iterator</code> containing
      * <code>Class</code>objects.
      */
-    public Iterator<Class<?>> getCategories() {
-        Set keySet = categoryMap.keySet();
-        return keySet.iterator();
-    }
+    public Iterator<Class<?>> getCategories() {throw new RuntimeException("cf-bug");} //{
+//        Set keySet = categoryMap.keySet();
+//        return keySet.iterator();
+//    }
 
     /**
      * Returns an Iterator containing the subregistries to which the
      * provider belongs.
      */
-    private Iterator getSubRegistries(Object provider) {
-        List l = new ArrayList();
-        Iterator iter = categoryMap.keySet().iterator();
-        while (iter.hasNext()) {
-            Class c = (Class)iter.next();
-            if (c.isAssignableFrom(provider.getClass())) {
-                l.add((SubRegistry)categoryMap.get(c));
-            }
-        }
-        return l.iterator();
-    }
+    private Iterator getSubRegistries(Object provider) {throw new RuntimeException("cf-bug");} //{
+//        List l = new ArrayList();
+//        Iterator iter = categoryMap.keySet().iterator();
+//        while (iter.hasNext()) {
+//            Class c = (Class)iter.next();
+//            if (c.isAssignableFrom(provider.getClass())) {
+//                l.add((SubRegistry)categoryMap.get(c));
+//            }
+//        }
+//        return l.iterator();
+//    }
 
     /**
      * Adds a service provider object to the registry.  The provider
@@ -264,20 +264,20 @@
      * the <code>Class</code> defined by <code>category</code>.
      */
     public <T> boolean registerServiceProvider(T provider,
-                                               Class<T> category) {
-        if (provider == null) {
-            throw new IllegalArgumentException("provider == null!");
-        }
-        SubRegistry reg = (SubRegistry)categoryMap.get(category);
-        if (reg == null) {
-            throw new IllegalArgumentException("category unknown!");
-        }
-        if (!category.isAssignableFrom(provider.getClass())) {
-            throw new ClassCastException();
-        }
-
-        return reg.registerServiceProvider(provider);
-    }
+                                               Class<T> category) {throw new RuntimeException("cf-bug");} //{
+//        if (provider == null) {
+//            throw new IllegalArgumentException("provider == null!");
+//        }
+//        SubRegistry reg = (SubRegistry)categoryMap.get(category);
+//        if (reg == null) {
+//            throw new IllegalArgumentException("category unknown!");
+//        }
+//        if (!category.isAssignableFrom(provider.getClass())) {
+//            throw new ClassCastException();
+//        }
+//
+//        return reg.registerServiceProvider(provider);
+//    }
 
     /**
      * Adds a service provider object to the registry.  The provider
@@ -297,16 +297,16 @@
      * @exception IllegalArgumentException if
      * <code>provider</code> is <code>null</code>.
      */
-    public void registerServiceProvider(Object provider) {
-        if (provider == null) {
-            throw new IllegalArgumentException("provider == null!");
-        }
-        Iterator regs = getSubRegistries(provider);
-        while (regs.hasNext()) {
-            SubRegistry reg = (SubRegistry)regs.next();
-            reg.registerServiceProvider(provider);
-        }
-    }
+    public void registerServiceProvider(Object provider) {throw new RuntimeException("cf-bug");} //{
+//        if (provider == null) {
+//            throw new IllegalArgumentException("provider == null!");
+//        }
+//        Iterator regs = getSubRegistries(provider);
+//        while (regs.hasNext()) {
+//            SubRegistry reg = (SubRegistry)regs.next();
+//            reg.registerServiceProvider(provider);
+//        }
+//    }
 
     /**
      * Adds a set of service provider objects, taken from an
@@ -328,14 +328,14 @@
      * @exception IllegalArgumentException if <code>providers</code>
      * is <code>null</code> or contains a <code>null</code> entry.
      */
-    public void registerServiceProviders(Iterator<?> providers) {
-        if (providers == null) {
-            throw new IllegalArgumentException("provider == null!");
-        }
-        while (providers.hasNext()) {
-            registerServiceProvider(providers.next());
-        }
-    }
+    public void registerServiceProviders(Iterator<?> providers) {throw new RuntimeException("cf-bug");} //{
+//        if (providers == null) {
+//            throw new IllegalArgumentException("provider == null!");
+//        }
+//        while (providers.hasNext()) {
+//            registerServiceProvider(providers.next());
+//        }
+//    }
 
     /**
      * Removes a service provider object from the given category.  If
@@ -367,19 +367,19 @@
      * the class defined by <code>category</code>.
      */
     public <T> boolean deregisterServiceProvider(T provider,
-                                                 Class<T> category) {
-        if (provider == null) {
-            throw new IllegalArgumentException("provider == null!");
-        }
-        SubRegistry reg = (SubRegistry)categoryMap.get(category);
-        if (reg == null) {
-            throw new IllegalArgumentException("category unknown!");
-        }
-        if (!category.isAssignableFrom(provider.getClass())) {
-            throw new ClassCastException();
-        }
-        return reg.deregisterServiceProvider(provider);
-    }
+                                                 Class<T> category) {throw new RuntimeException("cf-bug");} //{
+//        if (provider == null) {
+//            throw new IllegalArgumentException("provider == null!");
+//        }
+//        SubRegistry reg = (SubRegistry)categoryMap.get(category);
+//        if (reg == null) {
+//            throw new IllegalArgumentException("category unknown!");
+//        }
+//        if (!category.isAssignableFrom(provider.getClass())) {
+//            throw new ClassCastException();
+//        }
+//        return reg.deregisterServiceProvider(provider);
+//    }
 
     /**
      * Removes a service provider object from all categories that
@@ -390,16 +390,16 @@
      * @exception IllegalArgumentException if <code>provider</code> is
      * <code>null</code>.
      */
-    public void deregisterServiceProvider(Object provider) {
-        if (provider == null) {
-            throw new IllegalArgumentException("provider == null!");
-        }
-        Iterator regs = getSubRegistries(provider);
-        while (regs.hasNext()) {
-            SubRegistry reg = (SubRegistry)regs.next();
-            reg.deregisterServiceProvider(provider);
-        }
-    }
+    public void deregisterServiceProvider(Object provider) {throw new RuntimeException("cf-bug");} //{
+//        if (provider == null) {
+//            throw new IllegalArgumentException("provider == null!");
+//        }
+//        Iterator regs = getSubRegistries(provider);
+//        while (regs.hasNext()) {
+//            SubRegistry reg = (SubRegistry)regs.next();
+//            reg.deregisterServiceProvider(provider);
+//        }
+//    }
 
     /**
      * Returns <code>true</code> if <code>provider</code> is currently
@@ -413,20 +413,20 @@
      * @exception IllegalArgumentException if <code>provider</code> is
      * <code>null</code>.
      */
-    public boolean contains(Object provider) {
-        if (provider == null) {
-            throw new IllegalArgumentException("provider == null!");
-        }
-        Iterator regs = getSubRegistries(provider);
-        while (regs.hasNext()) {
-            SubRegistry reg = (SubRegistry)regs.next();
-            if (reg.contains(provider)) {
-                return true;
-            }
-        }
-
-        return false;
-    }
+    public boolean contains(Object provider) {throw new RuntimeException("cf-bug");} //{
+//        if (provider == null) {
+//            throw new IllegalArgumentException("provider == null!");
+//        }
+//        Iterator regs = getSubRegistries(provider);
+//        while (regs.hasNext()) {
+//            SubRegistry reg = (SubRegistry)regs.next();
+//            if (reg.contains(provider)) {
+//                return true;
+//            }
+//        }
+//
+//        return false;
+//    }
 
     /**
      * Returns an <code>Iterator</code> containing all registered
@@ -450,13 +450,13 @@
      * corresponding to <code>category</code>.
      */
     public <T> Iterator<T> getServiceProviders(Class<T> category,
-                                               boolean useOrdering) {
-        SubRegistry reg = (SubRegistry)categoryMap.get(category);
-        if (reg == null) {
-            throw new IllegalArgumentException("category unknown!");
-        }
-        return reg.getServiceProviders(useOrdering);
-    }
+                                               boolean useOrdering) {throw new RuntimeException("cf-bug");} //{
+//        SubRegistry reg = (SubRegistry)categoryMap.get(category);
+//        if (reg == null) {
+//            throw new IllegalArgumentException("category unknown!");
+//        }
+//        return reg.getServiceProviders(useOrdering);
+//    }
 
     /**
      * A simple filter interface used by
@@ -507,14 +507,14 @@
      */
     public <T> Iterator<T> getServiceProviders(Class<T> category,
                                                Filter filter,
-                                               boolean useOrdering) {
-        SubRegistry reg = (SubRegistry)categoryMap.get(category);
-        if (reg == null) {
-            throw new IllegalArgumentException("category unknown!");
-        }
-        Iterator iter = getServiceProviders(category, useOrdering);
-        return new FilterIterator(iter, filter);
-    }
+                                               boolean useOrdering) {throw new RuntimeException("cf-bug");} //{
+//        SubRegistry reg = (SubRegistry)categoryMap.get(category);
+//        if (reg == null) {
+//            throw new IllegalArgumentException("category unknown!");
+//        }
+//        Iterator iter = getServiceProviders(category, useOrdering);
+//        return new FilterIterator(iter, filter);
+//    }
 
     /**
      * Returns the currently registered service provider object that
@@ -534,23 +534,23 @@
      * @exception IllegalArgumentException if <code>providerClass</code> is
      * <code>null</code>.
      */
-    public <T> T getServiceProviderByClass(Class<T> providerClass) {
-        if (providerClass == null) {
-            throw new IllegalArgumentException("providerClass == null!");
-        }
-        Iterator iter = categoryMap.keySet().iterator();
-        while (iter.hasNext()) {
-            Class c = (Class)iter.next();
-            if (c.isAssignableFrom(providerClass)) {
-                SubRegistry reg = (SubRegistry)categoryMap.get(c);
-                T provider = reg.getServiceProviderByClass(providerClass);
-                if (provider != null) {
-                    return provider;
-                }
-            }
-        }
-        return null;
-    }
+    public <T> T getServiceProviderByClass(Class<T> providerClass) {throw new RuntimeException("cf-bug");} //{
+//        if (providerClass == null) {
+//            throw new IllegalArgumentException("providerClass == null!");
+//        }
+//        Iterator iter = categoryMap.keySet().iterator();
+//        while (iter.hasNext()) {
+//            Class c = (Class)iter.next();
+//            if (c.isAssignableFrom(providerClass)) {
+//                SubRegistry reg = (SubRegistry)categoryMap.get(c);
+//                T provider = reg.getServiceProviderByClass(providerClass);
+//                if (provider != null) {
+//                    return provider;
+//                }
+//            }
+//        }
+//        return null;
+//    }
 
     /**
      * Sets a pairwise ordering between two service provider objects
@@ -582,23 +582,23 @@
      */
     public <T> boolean setOrdering(Class<T> category,
                                    T firstProvider,
-                                   T secondProvider) {
-        if (firstProvider == null || secondProvider == null) {
-            throw new IllegalArgumentException("provider is null!");
-        }
-        if (firstProvider == secondProvider) {
-            throw new IllegalArgumentException("providers are the same!");
-        }
-        SubRegistry reg = (SubRegistry)categoryMap.get(category);
-        if (reg == null) {
-            throw new IllegalArgumentException("category unknown!");
-        }
-        if (reg.contains(firstProvider) &&
-            reg.contains(secondProvider)) {
-            return reg.setOrdering(firstProvider, secondProvider);
-        }
-        return false;
-    }
+                                   T secondProvider) {throw new RuntimeException("cf-bug");} //{
+//        if (firstProvider == null || secondProvider == null) {
+//            throw new IllegalArgumentException("provider is null!");
+//        }
+//        if (firstProvider == secondProvider) {
+//            throw new IllegalArgumentException("providers are the same!");
+//        }
+//        SubRegistry reg = (SubRegistry)categoryMap.get(category);
+//        if (reg == null) {
+//            throw new IllegalArgumentException("category unknown!");
+//        }
+//        if (reg.contains(firstProvider) &&
+//            reg.contains(secondProvider)) {
+//            return reg.setOrdering(firstProvider, secondProvider);
+//        }
+//        return false;
+//    }
 
     /**
      * Sets a pairwise ordering between two service provider objects
@@ -628,23 +628,23 @@
      */
     public <T> boolean unsetOrdering(Class<T> category,
                                      T firstProvider,
-                                     T secondProvider) {
-        if (firstProvider == null || secondProvider == null) {
-            throw new IllegalArgumentException("provider is null!");
-        }
-        if (firstProvider == secondProvider) {
-            throw new IllegalArgumentException("providers are the same!");
-        }
-        SubRegistry reg = (SubRegistry)categoryMap.get(category);
-        if (reg == null) {
-            throw new IllegalArgumentException("category unknown!");
-        }
-        if (reg.contains(firstProvider) &&
-            reg.contains(secondProvider)) {
-            return reg.unsetOrdering(firstProvider, secondProvider);
-        }
-        return false;
-    }
+                                     T secondProvider) {throw new RuntimeException("cf-bug");} //{
+//        if (firstProvider == null || secondProvider == null) {
+//            throw new IllegalArgumentException("provider is null!");
+//        }
+//        if (firstProvider == secondProvider) {
+//            throw new IllegalArgumentException("providers are the same!");
+//        }
+//        SubRegistry reg = (SubRegistry)categoryMap.get(category);
+//        if (reg == null) {
+//            throw new IllegalArgumentException("category unknown!");
+//        }
+//        if (reg.contains(firstProvider) &&
+//            reg.contains(secondProvider)) {
+//            return reg.unsetOrdering(firstProvider, secondProvider);
+//        }
+//        return false;
+//    }
 
     /**
      * Deregisters all service provider object currently registered
@@ -655,25 +655,25 @@
      * @exception IllegalArgumentException if there is no category
      * corresponding to <code>category</code>.
      */
-    public void deregisterAll(Class<?> category) {
-        SubRegistry reg = (SubRegistry)categoryMap.get(category);
-        if (reg == null) {
-            throw new IllegalArgumentException("category unknown!");
-        }
-        reg.clear();
-    }
+    public void deregisterAll(Class<?> category) {throw new RuntimeException("cf-bug");} //{
+//        SubRegistry reg = (SubRegistry)categoryMap.get(category);
+//        if (reg == null) {
+//            throw new IllegalArgumentException("category unknown!");
+//        }
+//        reg.clear();
+//    }
 
     /**
      * Deregisters all currently registered service providers from all
      * categories.
      */
-    public void deregisterAll() {
-        Iterator iter = categoryMap.values().iterator();
-        while (iter.hasNext()) {
-            SubRegistry reg = (SubRegistry)iter.next();
-            reg.clear();
-        }
-    }
+    public void deregisterAll() {throw new RuntimeException("cf-bug");} //{
+//        Iterator iter = categoryMap.values().iterator();
+//        while (iter.hasNext()) {
+//            SubRegistry reg = (SubRegistry)iter.next();
+//            reg.clear();
+//        }
+//    }
 
     /**
      * Finalizes this object prior to garbage collection.  The
@@ -684,10 +684,10 @@
      * @exception Throwable if an error occurs during superclass
      * finalization.
      */
-    public void finalize() throws Throwable {
-        deregisterAll();
-        super.finalize();
-    }
+    public void finalize() throws Throwable {throw new RuntimeException("cf-bug");} //{
+//        deregisterAll();
+//        super.finalize();
+//    }
 }
 
 
@@ -712,88 +712,88 @@
         this.category = category;
     }
 
-    public boolean registerServiceProvider(Object provider) {
-        Object oprovider = map.get(provider.getClass());
-        boolean present =  oprovider != null;
-
-        if (present) {
-            deregisterServiceProvider(oprovider);
-        }
-        map.put(provider.getClass(), provider);
-        poset.add(provider);
-        if (provider instanceof RegisterableService) {
-            RegisterableService rs = (RegisterableService)provider;
-            rs.onRegistration(registry, category);
-        }
-
-        return !present;
-    }
+    public boolean registerServiceProvider(Object provider) {throw new RuntimeException("cf-bug");} //{
+//        Object oprovider = map.get(provider.getClass());
+//        boolean present =  oprovider != null;
+//
+//        if (present) {
+//            deregisterServiceProvider(oprovider);
+//        }
+//        map.put(provider.getClass(), provider);
+//        poset.add(provider);
+//        if (provider instanceof RegisterableService) {
+//            RegisterableService rs = (RegisterableService)provider;
+//            rs.onRegistration(registry, category);
+//        }
+//
+//        return !present;
+//    }
 
     /**
      * If the provider was not previously registered, do nothing.
      *
      * @return true if the provider was previously registered.
      */
-    public boolean deregisterServiceProvider(Object provider) {
-        Object oprovider = map.get(provider.getClass());
-
-        if (provider == oprovider) {
-            map.remove(provider.getClass());
-            poset.remove(provider);
-            if (provider instanceof RegisterableService) {
-                RegisterableService rs = (RegisterableService)provider;
-                rs.onDeregistration(registry, category);
-            }
-
-            return true;
-        }
-        return false;
-    }
-
-    public boolean contains(Object provider) {
-        Object oprovider = map.get(provider.getClass());
-        return oprovider == provider;
-    }
+    public boolean deregisterServiceProvider(Object provider) {throw new RuntimeException("cf-bug");} //{
+//        Object oprovider = map.get(provider.getClass());
+//
+//        if (provider == oprovider) {
+//            map.remove(provider.getClass());
+//            poset.remove(provider);
+//            if (provider instanceof RegisterableService) {
+//                RegisterableService rs = (RegisterableService)provider;
+//                rs.onDeregistration(registry, category);
+//            }
+//
+//            return true;
+//        }
+//        return false;
+//    }
+
+    public boolean contains(Object provider) {throw new RuntimeException("cf-bug");} //{
+//        Object oprovider = map.get(provider.getClass());
+//        return oprovider == provider;
+//    }
 
     public boolean setOrdering(Object firstProvider,
-                               Object secondProvider) {
-        return poset.setOrdering(firstProvider, secondProvider);
-    }
+                               Object secondProvider) {throw new RuntimeException("cf-bug");} //{
+//        return poset.setOrdering(firstProvider, secondProvider);
+//    }
 
     public boolean unsetOrdering(Object firstProvider,
-                                 Object secondProvider) {
-        return poset.unsetOrdering(firstProvider, secondProvider);
-    }
-
-    public Iterator getServiceProviders(boolean useOrdering) {
-        if (useOrdering) {
-            return poset.iterator();
-        } else {
-            return map.values().iterator();
-        }
-    }
-
-    public <T> T getServiceProviderByClass(Class<T> providerClass) {
-        return (T)map.get(providerClass);
-    }
-
-    public void clear() {
-        Iterator iter = map.values().iterator();
-        while (iter.hasNext()) {
-            Object provider = iter.next();
-            iter.remove();
-
-            if (provider instanceof RegisterableService) {
-                RegisterableService rs = (RegisterableService)provider;
-                rs.onDeregistration(registry, category);
-            }
-        }
-        poset.clear();
-    }
-
-    public void finalize() {
-        clear();
-    }
+                                 Object secondProvider) {throw new RuntimeException("cf-bug");} //{
+//        return poset.unsetOrdering(firstProvider, secondProvider);
+//    }
+
+    public Iterator getServiceProviders(boolean useOrdering) {throw new RuntimeException("cf-bug");} //{
+//        if (useOrdering) {
+//            return poset.iterator();
+//        } else {
+//            return map.values().iterator();
+//        }
+//    }
+
+    public <T> T getServiceProviderByClass(Class<T> providerClass) {throw new RuntimeException("cf-bug");} //{
+//        return (T)map.get(providerClass);
+//    }
+
+    public void clear() {throw new RuntimeException("cf-bug");} //{
+//        Iterator iter = map.values().iterator();
+//        while (iter.hasNext()) {
+//            Object provider = iter.next();
+//            iter.remove();
+//
+//            if (provider instanceof RegisterableService) {
+//                RegisterableService rs = (RegisterableService)provider;
+//                rs.onDeregistration(registry, category);
+//            }
+//        }
+//        poset.clear();
+//    }
+
+    public void finalize() {throw new RuntimeException("cf-bug");} //{
+//        clear();
+//    }
 }
 
 
@@ -815,32 +815,32 @@
         advance();
     }
 
-    private void advance() {
-        while (iter.hasNext()) {
-            T elt = iter.next();
-            if (filter.filter(elt)) {
-                next = elt;
-                return;
-            }
-        }
-
-        next = null;
-    }
-
-    public boolean hasNext() {
-        return next != null;
-    }
-
-    public T next() {
-        if (next == null) {
-            throw new NoSuchElementException();
-        }
-        T o = next;
-        advance();
-        return o;
-    }
-
-    public void remove() {
-        throw new UnsupportedOperationException();
-    }
+    private void advance() {throw new RuntimeException("cf-bug");} //{
+//        while (iter.hasNext()) {
+//            T elt = iter.next();
+//            if (filter.filter(elt)) {
+//                next = elt;
+//                return;
+//            }
+//        }
+//
+//        next = null;
+//    }
+
+    public boolean hasNext() {throw new RuntimeException("cf-bug");} //{
+//        return next != null;
+//    }
+
+    public T next() {throw new RuntimeException("cf-bug");} //{
+//        if (next == null) {
+//            throw new NoSuchElementException();
+//        }
+//        T o = next;
+//        advance();
+//        return o;
+//    }
+
+    public void remove() {throw new RuntimeException("cf-bug");} //{
+//        throw new UnsupportedOperationException();
+//    }
 }
--- a/javax/swing/JLayer.java	2016-06-22 19:55:09.867841654 -0700
+++ b/javax/swing/JLayer.java	2016-06-29 12:26:41.462991490 -0700
@@ -209,9 +209,9 @@
      *
      * @see #setView(Component)
      */
-    public V getView() {
-        return view;
-    }
+    public V getView() {throw new RuntimeException("cf-bug");} //{
+//        return view;
+//    }
 
     /**
      * Sets the {@code JLayer}'s view component, which can be {@code null}.
@@ -221,19 +221,19 @@
      *
      * @see #getView()
      */
-    public void setView(V view) {
-        Component oldView = getView();
-        if (oldView != null) {
-            super.remove(oldView);
-        }
-        if (view != null) {
-            super.addImpl(view, null, getComponentCount());
-        }
-        this.view = view;
-        firePropertyChange("view", oldView, view);
-        revalidate();
-        repaint();
-    }
+    public void setView(V view) {throw new RuntimeException("cf-bug");} //{
+//        Component oldView = getView();
+//        if (oldView != null) {
+//            super.remove(oldView);
+//        }
+//        if (view != null) {
+//            super.addImpl(view, null, getComponentCount());
+//        }
+//        this.view = view;
+//        firePropertyChange("view", oldView, view);
+//        revalidate();
+//        repaint();
+//    }
 
     /**
      * Sets the {@link javax.swing.plaf.LayerUI} which will perform painting
@@ -241,19 +241,19 @@
      *
      * @param ui the {@link javax.swing.plaf.LayerUI} for this {@code JLayer}
      */
-    public void setUI(LayerUI<? super V> ui) {
-        this.layerUI = ui;
-        super.setUI(ui);
-    }
+    public void setUI(LayerUI<? super V> ui) {throw new RuntimeException("cf-bug");} //{
+//        this.layerUI = ui;
+//        super.setUI(ui);
+//    }
 
     /**
      * Returns the {@link javax.swing.plaf.LayerUI} for this {@code JLayer}.
      *
      * @return the {@code LayerUI} for this {@code JLayer}
      */
-    public LayerUI<? super V> getUI() {
-        return layerUI;
-    }
+    public LayerUI<? super V> getUI() {throw new RuntimeException("cf-bug");} //{
+//        return layerUI;
+//    }
 
     /**
      * Returns the {@code JLayer}'s glassPane component or {@code null}.
@@ -264,9 +264,9 @@
      *
      * @see #setGlassPane(JPanel)
      */
-    public JPanel getGlassPane() {
-        return glassPane;
-    }
+    public JPanel getGlassPane() {throw new RuntimeException("cf-bug");} //{
+//        return glassPane;
+//    }
 
     /**
      * Sets the {@code JLayer}'s glassPane component, which can be {@code null}.
@@ -276,24 +276,24 @@
      *
      * @see #getGlassPane()
      */
-    public void setGlassPane(JPanel glassPane) {
-        Component oldGlassPane = getGlassPane();
-        boolean isGlassPaneVisible = false;
-        if (oldGlassPane != null) {
-            isGlassPaneVisible = oldGlassPane.isVisible();
-            super.remove(oldGlassPane);
-        }
-        if (glassPane != null) {
-            AWTAccessor.getComponentAccessor().setMixingCutoutShape(glassPane,
-                    new Rectangle());
-            glassPane.setVisible(isGlassPaneVisible);
-            super.addImpl(glassPane, null, 0);
-        }
-        this.glassPane = glassPane;
-        firePropertyChange("glassPane", oldGlassPane, glassPane);
-        revalidate();
-        repaint();
-    }
+    public void setGlassPane(JPanel glassPane) {throw new RuntimeException("cf-bug");} //{
+//        Component oldGlassPane = getGlassPane();
+//        boolean isGlassPaneVisible = false;
+//        if (oldGlassPane != null) {
+//            isGlassPaneVisible = oldGlassPane.isVisible();
+//            super.remove(oldGlassPane);
+//        }
+//        if (glassPane != null) {
+//            AWTAccessor.getComponentAccessor().setMixingCutoutShape(glassPane,
+//                    new Rectangle());
+//            glassPane.setVisible(isGlassPaneVisible);
+//            super.addImpl(glassPane, null, 0);
+//        }
+//        this.glassPane = glassPane;
+//        firePropertyChange("glassPane", oldGlassPane, glassPane);
+//        revalidate();
+//        repaint();
+//    }
 
     /**
      * Called by the constructor methods to create a default {@code glassPane}.
@@ -302,9 +302,9 @@
      *
      * @return the default {@code glassPane}
      */
-    public JPanel createGlassPane() {
-        return new DefaultLayerGlassPane();
-    }
+    public JPanel createGlassPane() {throw new RuntimeException("cf-bug");} //{
+//        return new DefaultLayerGlassPane();
+//    }
 
     /**
      * Sets the layout manager for this container.  This method is
@@ -316,11 +316,11 @@
      * @param mgr the specified layout manager
      * @exception IllegalArgumentException this method is not supported
      */
-    public void setLayout(LayoutManager mgr) {
-        if (mgr != null) {
-            throw new IllegalArgumentException("JLayer.setLayout() not supported");
-        }
-    }
+    public void setLayout(LayoutManager mgr) {throw new RuntimeException("cf-bug");} //{
+//        if (mgr != null) {
+//            throw new IllegalArgumentException("JLayer.setLayout() not supported");
+//        }
+//    }
 
     /**
      * A non-{@code null} border, or non-zero insets, isn't supported, to prevent the geometry
@@ -334,11 +334,11 @@
      * @param border the {@code Border} to set
      * @exception IllegalArgumentException this method is not supported
      */
-    public void setBorder(Border border) {
-        if (border != null) {
-            throw new IllegalArgumentException("JLayer.setBorder() not supported");
-        }
-    }
+    public void setBorder(Border border) {throw new RuntimeException("cf-bug");} //{
+//        if (border != null) {
+//            throw new IllegalArgumentException("JLayer.setBorder() not supported");
+//        }
+//    }
 
     /**
      * This method is not supported by {@code JLayer}
@@ -349,38 +349,38 @@
      * @see #setView(Component)
      * @see #setGlassPane(JPanel)
      */
-    protected void addImpl(Component comp, Object constraints, int index) {
-        throw new UnsupportedOperationException(
-                "Adding components to JLayer is not supported, " +
-                        "use setView() or setGlassPane() instead");
-    }
+    protected void addImpl(Component comp, Object constraints, int index) {throw new RuntimeException("cf-bug");} //{
+//        throw new UnsupportedOperationException(
+//                "Adding components to JLayer is not supported, " +
+//                        "use setView() or setGlassPane() instead");
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public void remove(Component comp) {
-        if (comp == null) {
-            super.remove(comp);
-        } else if (comp == getView()) {
-            setView(null);
-        } else if (comp == getGlassPane()) {
-            setGlassPane(null);
-        } else {
-            super.remove(comp);
-        }
-    }
+    public void remove(Component comp) {throw new RuntimeException("cf-bug");} //{
+//        if (comp == null) {
+//            super.remove(comp);
+//        } else if (comp == getView()) {
+//            setView(null);
+//        } else if (comp == getGlassPane()) {
+//            setGlassPane(null);
+//        } else {
+//            super.remove(comp);
+//        }
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public void removeAll() {
-        if (view != null) {
-            setView(null);
-        }
-        if (glassPane != null) {
-            setGlassPane(null);
-        }
-    }
+    public void removeAll() {throw new RuntimeException("cf-bug");} //{
+//        if (view != null) {
+//            setView(null);
+//        }
+//        if (glassPane != null) {
+//            setGlassPane(null);
+//        }
+//    }
 
     /**
      * Always returns {@code true} to cause painting to originate from {@code JLayer},
@@ -389,9 +389,9 @@
      * @return true
      * @see JComponent#isPaintingOrigin()
      */
-    protected boolean isPaintingOrigin() {
-        return true;
-    }
+    protected boolean isPaintingOrigin() {throw new RuntimeException("cf-bug");} //{
+//        return true;
+//    }
 
     /**
      * Delegates its functionality to the
@@ -403,36 +403,36 @@
      * @param w  the width of the region to be painted
      * @param h  the height of the region to be painted
      */
-    public void paintImmediately(int x, int y, int w, int h) {
-        if (!isPaintingImmediately && getUI() != null) {
-            isPaintingImmediately = true;
-            try {
-                getUI().paintImmediately(x, y, w, h, this);
-            } finally {
-                isPaintingImmediately = false;
-            }
-        } else {
-            super.paintImmediately(x, y, w, h);
-        }
-    }
+    public void paintImmediately(int x, int y, int w, int h) {throw new RuntimeException("cf-bug");} //{
+//        if (!isPaintingImmediately && getUI() != null) {
+//            isPaintingImmediately = true;
+//            try {
+//                getUI().paintImmediately(x, y, w, h, this);
+//            } finally {
+//                isPaintingImmediately = false;
+//            }
+//        } else {
+//            super.paintImmediately(x, y, w, h);
+//        }
+//    }
 
     /**
      * Delegates all painting to the {@link javax.swing.plaf.LayerUI} object.
      *
      * @param g the {@code Graphics} to render to
      */
-    public void paint(Graphics g) {
-        if (!isPainting) {
-            isPainting = true;
-            try {
-                super.paintComponent(g);
-            } finally {
-                isPainting = false;
-            }
-        } else {
-            super.paint(g);
-        }
-    }
+    public void paint(Graphics g) {throw new RuntimeException("cf-bug");} //{
+//        if (!isPainting) {
+//            isPainting = true;
+//            try {
+//                super.paintComponent(g);
+//            } finally {
+//                isPainting = false;
+//            }
+//        } else {
+//            super.paint(g);
+//        }
+//    }
 
     /**
      * This method is empty, because all painting is done by
@@ -453,18 +453,18 @@
      *
      * @return false
      */
-    public boolean isOptimizedDrawingEnabled() {
-        return false;
-    }
+    public boolean isOptimizedDrawingEnabled() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public void propertyChange(PropertyChangeEvent evt) {
-        if (getUI() != null) {
-            getUI().applyPropertyChange(evt, this);
-        }
-    }
+    public void propertyChange(PropertyChangeEvent evt) {throw new RuntimeException("cf-bug");} //{
+//        if (getUI() != null) {
+//            getUI().applyPropertyChange(evt, this);
+//        }
+//    }
 
     /**
      * Enables the events from JLayer and <b>all its descendants</b>
@@ -502,19 +502,19 @@
      * @see LayerUI#eventDispatched(AWTEvent, JLayer)
      * @see Component#isDisplayable()
      */
-    public void setLayerEventMask(long layerEventMask) {
-        long oldEventMask = getLayerEventMask();
-        this.eventMask = layerEventMask;
-        firePropertyChange("layerEventMask", oldEventMask, layerEventMask);
-        if (layerEventMask != oldEventMask) {
-            disableEvents(oldEventMask);
-            enableEvents(eventMask);
-            if (isDisplayable()) {
-                eventController.updateAWTEventListener(
-                        oldEventMask, layerEventMask);
-            }
-        }
-    }
+    public void setLayerEventMask(long layerEventMask) {throw new RuntimeException("cf-bug");} //{
+//        long oldEventMask = getLayerEventMask();
+//        this.eventMask = layerEventMask;
+//        firePropertyChange("layerEventMask", oldEventMask, layerEventMask);
+//        if (layerEventMask != oldEventMask) {
+//            disableEvents(oldEventMask);
+//            enableEvents(eventMask);
+//            if (isDisplayable()) {
+//                eventController.updateAWTEventListener(
+//                        oldEventMask, layerEventMask);
+//            }
+//        }
+//    }
 
     /**
      * Returns the bitmap of event mask to receive by this {@code JLayer}
@@ -527,19 +527,19 @@
      *
      * @return the bitmask of event types to receive for this {@code JLayer}
      */
-    public long getLayerEventMask() {
-        return eventMask;
-    }
+    public long getLayerEventMask() {throw new RuntimeException("cf-bug");} //{
+//        return eventMask;
+//    }
 
     /**
      * Delegates its functionality to the {@link javax.swing.plaf.LayerUI#updateUI(JLayer)} method,
      * if {@code LayerUI} is set.
      */
-    public void updateUI() {
-        if (getUI() != null) {
-            getUI().updateUI(this);
-        }
-    }
+    public void updateUI() {throw new RuntimeException("cf-bug");} //{
+//        if (getUI() != null) {
+//            getUI().updateUI(this);
+//        }
+//    }
 
     /**
      * Returns the preferred size of the viewport for a view component.
@@ -551,12 +551,12 @@
      *
      * @see Scrollable
      */
-    public Dimension getPreferredScrollableViewportSize() {
-        if (getView() instanceof Scrollable) {
-            return ((Scrollable)getView()).getPreferredScrollableViewportSize();
-        }
-        return getPreferredSize();
-    }
+    public Dimension getPreferredScrollableViewportSize() {throw new RuntimeException("cf-bug");} //{
+//        if (getView() instanceof Scrollable) {
+//            return ((Scrollable)getView()).getPreferredScrollableViewportSize();
+//        }
+//        return getPreferredSize();
+//    }
 
     /**
      * Returns a scroll increment, which is required for components
@@ -571,14 +571,14 @@
      * @see Scrollable
      */
     public int getScrollableBlockIncrement(Rectangle visibleRect,
-                                           int orientation, int direction) {
-        if (getView() instanceof Scrollable) {
-            return ((Scrollable)getView()).getScrollableBlockIncrement(visibleRect,
-                    orientation, direction);
-        }
-        return (orientation == SwingConstants.VERTICAL) ? visibleRect.height :
-                visibleRect.width;
-    }
+                                           int orientation, int direction) {throw new RuntimeException("cf-bug");} //{
+//        if (getView() instanceof Scrollable) {
+//            return ((Scrollable)getView()).getScrollableBlockIncrement(visibleRect,
+//                    orientation, direction);
+//        }
+//        return (orientation == SwingConstants.VERTICAL) ? visibleRect.height :
+//                visibleRect.width;
+//    }
 
     /**
      * Returns {@code false} to indicate that the height of the viewport does not
@@ -592,12 +592,12 @@
      *
      * @see Scrollable
      */
-    public boolean getScrollableTracksViewportHeight() {
-        if (getView() instanceof Scrollable) {
-            return ((Scrollable)getView()).getScrollableTracksViewportHeight();
-        }
-        return false;
-    }
+    public boolean getScrollableTracksViewportHeight() {throw new RuntimeException("cf-bug");} //{
+//        if (getView() instanceof Scrollable) {
+//            return ((Scrollable)getView()).getScrollableTracksViewportHeight();
+//        }
+//        return false;
+//    }
 
     /**
      * Returns {@code false} to indicate that the width of the viewport does not
@@ -611,12 +611,12 @@
      *
      * @see Scrollable
      */
-    public boolean getScrollableTracksViewportWidth() {
-        if (getView() instanceof Scrollable) {
-            return ((Scrollable)getView()).getScrollableTracksViewportWidth();
-        }
-        return false;
-    }
+    public boolean getScrollableTracksViewportWidth() {throw new RuntimeException("cf-bug");} //{
+//        if (getView() instanceof Scrollable) {
+//            return ((Scrollable)getView()).getScrollableTracksViewportWidth();
+//        }
+//        return false;
+//    }
 
     /**
      * Returns a scroll increment, which is required for components
@@ -637,66 +637,66 @@
      * @see Scrollable
      */
     public int getScrollableUnitIncrement(Rectangle visibleRect, int orientation,
-                                          int direction) {
-        if (getView() instanceof Scrollable) {
-            return ((Scrollable) getView()).getScrollableUnitIncrement(
-                    visibleRect, orientation, direction);
-        }
-        return 1;
-    }
+                                          int direction) {throw new RuntimeException("cf-bug");} //{
+//        if (getView() instanceof Scrollable) {
+//            return ((Scrollable) getView()).getScrollableUnitIncrement(
+//                    visibleRect, orientation, direction);
+//        }
+//        return 1;
+//    }
 
     private void readObject(ObjectInputStream s)
-            throws IOException, ClassNotFoundException {
-        s.defaultReadObject();
-        if (layerUI != null) {
-            setUI(layerUI);
-        }
-        if (eventMask != 0) {
-            eventController.updateAWTEventListener(0, eventMask);
-        }
-    }
+            throws IOException, ClassNotFoundException {throw new RuntimeException("cf-bug");} //{
+//        s.defaultReadObject();
+//        if (layerUI != null) {
+//            setUI(layerUI);
+//        }
+//        if (eventMask != 0) {
+//            eventController.updateAWTEventListener(0, eventMask);
+//        }
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public void addNotify() {
-        super.addNotify();
-        eventController.updateAWTEventListener(0, eventMask);
-    }
+    public void addNotify() {throw new RuntimeException("cf-bug");} //{
+//        super.addNotify();
+//        eventController.updateAWTEventListener(0, eventMask);
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public void removeNotify() {
-        super.removeNotify();
-        eventController.updateAWTEventListener(eventMask, 0);
-    }
+    public void removeNotify() {throw new RuntimeException("cf-bug");} //{
+//        super.removeNotify();
+//        eventController.updateAWTEventListener(eventMask, 0);
+//    }
 
     /**
      * Delegates its functionality to the {@link javax.swing.plaf.LayerUI#doLayout(JLayer)} method,
      * if {@code LayerUI} is set.
      */
-    public void doLayout() {
-        if (getUI() != null) {
-            getUI().doLayout(this);
-        }
-    }
+    public void doLayout() {throw new RuntimeException("cf-bug");} //{
+//        if (getUI() != null) {
+//            getUI().doLayout(this);
+//        }
+//    }
 
     /**
      * Gets the AccessibleContext associated with this {@code JLayer}.
      *
      * @return the AccessibleContext associated with this {@code JLayer}.
      */
-    public AccessibleContext getAccessibleContext() {
-        if (accessibleContext == null) {
-            accessibleContext = new AccessibleJComponent() {
-                public AccessibleRole getAccessibleRole() {
-                    return AccessibleRole.PANEL;
-                }
-            };
-        }
-        return accessibleContext;
-    }
+    public AccessibleContext getAccessibleContext() {throw new RuntimeException("cf-bug");} //{
+//        if (accessibleContext == null) {
+//            accessibleContext = new AccessibleJComponent() {
+//                public AccessibleRole getAccessibleRole() {
+//                    return AccessibleRole.PANEL;
+//                }
+//            };
+//        }
+//        return accessibleContext;
+//    }
 
     /**
      * static AWTEventListener to be shared with all AbstractLayerUIs
@@ -720,105 +720,105 @@
                         AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK;
 
         @SuppressWarnings("unchecked")
-        public void eventDispatched(AWTEvent event) {
-            Object source = event.getSource();
-            if (source instanceof Component) {
-                Component component = (Component) source;
-                while (component != null) {
-                    if (component instanceof JLayer) {
-                        JLayer l = (JLayer) component;
-                        LayerUI ui = l.getUI();
-                        if (ui != null &&
-                                isEventEnabled(l.getLayerEventMask(), event.getID()) &&
-                                (!(event instanceof InputEvent) || !((InputEvent)event).isConsumed())) {
-                            ui.eventDispatched(event, l);
-                        }
-                    }
-                    component = component.getParent();
-                }
-            }
-        }
-
-        private void updateAWTEventListener(long oldEventMask, long newEventMask) {
-            if (oldEventMask != 0) {
-                layerMaskList.remove(oldEventMask);
-            }
-            if (newEventMask != 0) {
-                layerMaskList.add(newEventMask);
-            }
-            long combinedMask = 0;
-            for (Long mask : layerMaskList) {
-                combinedMask |= mask;
-            }
-            // filter out all unaccepted events
-            combinedMask &= ACCEPTED_EVENTS;
-            if (combinedMask == 0) {
-                removeAWTEventListener();
-            } else if (getCurrentEventMask() != combinedMask) {
-                removeAWTEventListener();
-                addAWTEventListener(combinedMask);
-            }
-            currentEventMask = combinedMask;
-        }
-
-        private long getCurrentEventMask() {
-            return currentEventMask;
-        }
-
-        private void addAWTEventListener(final long eventMask) {
-            AccessController.doPrivileged(new PrivilegedAction<Void>() {
-                public Void run() {
-                    Toolkit.getDefaultToolkit().
-                            addAWTEventListener(LayerEventController.this, eventMask);
-                    return null;
-                }
-            });
-
-        }
-
-        private void removeAWTEventListener() {
-            AccessController.doPrivileged(new PrivilegedAction<Void>() {
-                public Void run() {
-                    Toolkit.getDefaultToolkit().
-                            removeAWTEventListener(LayerEventController.this);
-                    return null;
-                }
-            });
-        }
-
-        private boolean isEventEnabled(long eventMask, int id) {
-            return (((eventMask & AWTEvent.COMPONENT_EVENT_MASK) != 0 &&
-                    id >= ComponentEvent.COMPONENT_FIRST &&
-                    id <= ComponentEvent.COMPONENT_LAST)
-                    || ((eventMask & AWTEvent.CONTAINER_EVENT_MASK) != 0 &&
-                    id >= ContainerEvent.CONTAINER_FIRST &&
-                    id <= ContainerEvent.CONTAINER_LAST)
-                    || ((eventMask & AWTEvent.FOCUS_EVENT_MASK) != 0 &&
-                    id >= FocusEvent.FOCUS_FIRST &&
-                    id <= FocusEvent.FOCUS_LAST)
-                    || ((eventMask & AWTEvent.KEY_EVENT_MASK) != 0 &&
-                    id >= KeyEvent.KEY_FIRST &&
-                    id <= KeyEvent.KEY_LAST)
-                    || ((eventMask & AWTEvent.MOUSE_WHEEL_EVENT_MASK) != 0 &&
-                    id == MouseEvent.MOUSE_WHEEL)
-                    || ((eventMask & AWTEvent.MOUSE_MOTION_EVENT_MASK) != 0 &&
-                    (id == MouseEvent.MOUSE_MOVED ||
-                            id == MouseEvent.MOUSE_DRAGGED))
-                    || ((eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0 &&
-                    id != MouseEvent.MOUSE_MOVED &&
-                    id != MouseEvent.MOUSE_DRAGGED &&
-                    id != MouseEvent.MOUSE_WHEEL &&
-                    id >= MouseEvent.MOUSE_FIRST &&
-                    id <= MouseEvent.MOUSE_LAST)
-                    || ((eventMask & AWTEvent.INPUT_METHOD_EVENT_MASK) != 0 &&
-                    id >= InputMethodEvent.INPUT_METHOD_FIRST &&
-                    id <= InputMethodEvent.INPUT_METHOD_LAST)
-                    || ((eventMask & AWTEvent.HIERARCHY_EVENT_MASK) != 0 &&
-                    id == HierarchyEvent.HIERARCHY_CHANGED)
-                    || ((eventMask & AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0 &&
-                    (id == HierarchyEvent.ANCESTOR_MOVED ||
-                            id == HierarchyEvent.ANCESTOR_RESIZED)));
-        }
+        public void eventDispatched(AWTEvent event) {throw new RuntimeException("cf-bug");} //{
+//            Object source = event.getSource();
+//            if (source instanceof Component) {
+//                Component component = (Component) source;
+//                while (component != null) {
+//                    if (component instanceof JLayer) {
+//                        JLayer l = (JLayer) component;
+//                        LayerUI ui = l.getUI();
+//                        if (ui != null &&
+//                                isEventEnabled(l.getLayerEventMask(), event.getID()) &&
+//                                (!(event instanceof InputEvent) || !((InputEvent)event).isConsumed())) {
+//                            ui.eventDispatched(event, l);
+//                        }
+//                    }
+//                    component = component.getParent();
+//                }
+//            }
+//        }
+
+        private void updateAWTEventListener(long oldEventMask, long newEventMask) {throw new RuntimeException("cf-bug");} //{
+//            if (oldEventMask != 0) {
+//                layerMaskList.remove(oldEventMask);
+//            }
+//            if (newEventMask != 0) {
+//                layerMaskList.add(newEventMask);
+//            }
+//            long combinedMask = 0;
+//            for (Long mask : layerMaskList) {
+//                combinedMask |= mask;
+//            }
+//            // filter out all unaccepted events
+//            combinedMask &= ACCEPTED_EVENTS;
+//            if (combinedMask == 0) {
+//                removeAWTEventListener();
+//            } else if (getCurrentEventMask() != combinedMask) {
+//                removeAWTEventListener();
+//                addAWTEventListener(combinedMask);
+//            }
+//            currentEventMask = combinedMask;
+//        }
+
+        private long getCurrentEventMask() {throw new RuntimeException("cf-bug");} //{
+//            return currentEventMask;
+//        }
+
+        private void addAWTEventListener(final long eventMask) {throw new RuntimeException("cf-bug");} //{
+//            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+//                public Void run() {
+//                    Toolkit.getDefaultToolkit().
+//                            addAWTEventListener(LayerEventController.this, eventMask);
+//                    return null;
+//                }
+//            });
+//
+//        }
+
+        private void removeAWTEventListener() {throw new RuntimeException("cf-bug");} //{
+//            AccessController.doPrivileged(new PrivilegedAction<Void>() {
+//                public Void run() {
+//                    Toolkit.getDefaultToolkit().
+//                            removeAWTEventListener(LayerEventController.this);
+//                    return null;
+//                }
+//            });
+//        }
+
+        private boolean isEventEnabled(long eventMask, int id) {throw new RuntimeException("cf-bug");} //{
+//            return (((eventMask & AWTEvent.COMPONENT_EVENT_MASK) != 0 &&
+//                    id >= ComponentEvent.COMPONENT_FIRST &&
+//                    id <= ComponentEvent.COMPONENT_LAST)
+//                    || ((eventMask & AWTEvent.CONTAINER_EVENT_MASK) != 0 &&
+//                    id >= ContainerEvent.CONTAINER_FIRST &&
+//                    id <= ContainerEvent.CONTAINER_LAST)
+//                    || ((eventMask & AWTEvent.FOCUS_EVENT_MASK) != 0 &&
+//                    id >= FocusEvent.FOCUS_FIRST &&
+//                    id <= FocusEvent.FOCUS_LAST)
+//                    || ((eventMask & AWTEvent.KEY_EVENT_MASK) != 0 &&
+//                    id >= KeyEvent.KEY_FIRST &&
+//                    id <= KeyEvent.KEY_LAST)
+//                    || ((eventMask & AWTEvent.MOUSE_WHEEL_EVENT_MASK) != 0 &&
+//                    id == MouseEvent.MOUSE_WHEEL)
+//                    || ((eventMask & AWTEvent.MOUSE_MOTION_EVENT_MASK) != 0 &&
+//                    (id == MouseEvent.MOUSE_MOVED ||
+//                            id == MouseEvent.MOUSE_DRAGGED))
+//                    || ((eventMask & AWTEvent.MOUSE_EVENT_MASK) != 0 &&
+//                    id != MouseEvent.MOUSE_MOVED &&
+//                    id != MouseEvent.MOUSE_DRAGGED &&
+//                    id != MouseEvent.MOUSE_WHEEL &&
+//                    id >= MouseEvent.MOUSE_FIRST &&
+//                    id <= MouseEvent.MOUSE_LAST)
+//                    || ((eventMask & AWTEvent.INPUT_METHOD_EVENT_MASK) != 0 &&
+//                    id >= InputMethodEvent.INPUT_METHOD_FIRST &&
+//                    id <= InputMethodEvent.INPUT_METHOD_LAST)
+//                    || ((eventMask & AWTEvent.HIERARCHY_EVENT_MASK) != 0 &&
+//                    id == HierarchyEvent.HIERARCHY_CHANGED)
+//                    || ((eventMask & AWTEvent.HIERARCHY_BOUNDS_EVENT_MASK) != 0 &&
+//                    (id == HierarchyEvent.ANCESTOR_MOVED ||
+//                            id == HierarchyEvent.ANCESTOR_RESIZED)));
+//        }
     }
 
     /**
@@ -845,21 +845,21 @@
          * @param y the <i>y</i> coordinate of the point
          * @return true if this component logically contains x,y
          */
-        public boolean contains(int x, int y) {
-            for (int i = 0; i < getComponentCount(); i++) {
-                Component c = getComponent(i);
-                Point point = SwingUtilities.convertPoint(this, new Point(x, y), c);
-                if(c.isVisible() && c.contains(point)){
-                    return true;
-                }
-            }
-            if (getMouseListeners().length == 0
-                    && getMouseMotionListeners().length == 0
-                    && getMouseWheelListeners().length == 0
-                    && !isCursorSet()) {
-                return false;
-            }
-            return super.contains(x, y);
-        }
+        public boolean contains(int x, int y) {throw new RuntimeException("cf-bug");} //{
+//            for (int i = 0; i < getComponentCount(); i++) {
+//                Component c = getComponent(i);
+//                Point point = SwingUtilities.convertPoint(this, new Point(x, y), c);
+//                if(c.isVisible() && c.contains(point)){
+//                    return true;
+//                }
+//            }
+//            if (getMouseListeners().length == 0
+//                    && getMouseMotionListeners().length == 0
+//                    && getMouseWheelListeners().length == 0
+//                    && !isCursorSet()) {
+//                return false;
+//            }
+//            return super.contains(x, y);
+//        }
     }
 }
--- javax/swing/JTextField.java	2016-06-27 19:24:07.842733433 -0700
+++ javax/swing/JTextField.java	2016-06-29 14:11:02.783628787 -0700
@@ -254,9 +254,9 @@
      * @see JComponent#getUIClassID
      * @see UIDefaults#getUI
      */
-    public String getUIClassID() {
-        return uiClassID;
-    }
+    public String getUIClassID() {throw new RuntimeException("cf-bug");} //{
+//        return uiClassID;
+//    }
 
 
     /**
@@ -272,12 +272,12 @@
      *        bound: true
      *       expert: true
      */
-    public void setDocument(Document doc) {
-        if (doc != null) {
-            doc.putProperty("filterNewlines", Boolean.TRUE);
-        }
-        super.setDocument(doc);
-    }
+    public void setDocument(Document doc) {throw new RuntimeException("cf-bug");} //{
+//        if (doc != null) {
+//            doc.putProperty("filterNewlines", Boolean.TRUE);
+//        }
+//        super.setDocument(doc);
+//    }
 
     /**
      * Calls to <code>revalidate</code> that come from within the
@@ -294,9 +294,9 @@
      * @see java.awt.Container#isValidateRoot
      */
     @Override
-    public boolean isValidateRoot() {
-        return !(SwingUtilities.getUnwrappedParent(this) instanceof JViewport);
-    }
+    public boolean isValidateRoot() {throw new RuntimeException("cf-bug");} //{
+//        return !(SwingUtilities.getUnwrappedParent(this) instanceof JViewport);
+//    }
 
 
     /**
@@ -312,9 +312,9 @@
      *
      * @return the horizontal alignment
      */
-    public int getHorizontalAlignment() {
-        return horizontalAlignment;
-    }
+    public int getHorizontalAlignment() {throw new RuntimeException("cf-bug");} //{
+//        return horizontalAlignment;
+//    }
 
     /**
      * Sets the horizontal alignment of the text.
@@ -341,20 +341,20 @@
      *        enum: LEFT JTextField.LEFT CENTER JTextField.CENTER RIGHT JTextField.RIGHT
      *              LEADING JTextField.LEADING TRAILING JTextField.TRAILING
      */
-     public void setHorizontalAlignment(int alignment) {
-        if (alignment == horizontalAlignment) return;
-        int oldValue = horizontalAlignment;
-        if ((alignment == LEFT) || (alignment == CENTER) ||
-            (alignment == RIGHT)|| (alignment == LEADING) ||
-            (alignment == TRAILING)) {
-            horizontalAlignment = alignment;
-        } else {
-            throw new IllegalArgumentException("horizontalAlignment");
-        }
-        firePropertyChange("horizontalAlignment", oldValue, horizontalAlignment);
-        invalidate();
-        repaint();
-    }
+     public void setHorizontalAlignment(int alignment) {throw new RuntimeException("cf-bug");} //{
+//        if (alignment == horizontalAlignment) return;
+//        int oldValue = horizontalAlignment;
+//        if ((alignment == LEFT) || (alignment == CENTER) ||
+//            (alignment == RIGHT)|| (alignment == LEADING) ||
+//            (alignment == TRAILING)) {
+//            horizontalAlignment = alignment;
+//        } else {
+//            throw new IllegalArgumentException("horizontalAlignment");
+//        }
+//        firePropertyChange("horizontalAlignment", oldValue, horizontalAlignment);
+//        invalidate();
+//        repaint();
+//    }
 
     /**
      * Creates the default implementation of the model
@@ -363,18 +363,18 @@
      *
      * @return the default model implementation
      */
-    protected Document createDefaultModel() {
-        return new PlainDocument();
-    }
+    protected Document createDefaultModel() {throw new RuntimeException("cf-bug");} //{
+//        return new PlainDocument();
+//    }
 
     /**
      * Returns the number of columns in this <code>TextField</code>.
      *
      * @return the number of columns &gt;= 0
      */
-    public int getColumns() {
-        return columns;
-    }
+    public int getColumns() {throw new RuntimeException("cf-bug");} //{
+//        return columns;
+//    }
 
     /**
      * Sets the number of columns in this <code>TextField</code>,
@@ -386,16 +386,16 @@
      * @beaninfo
      * description: the number of columns preferred for display
      */
-    public void setColumns(int columns) {
-        int oldVal = this.columns;
-        if (columns < 0) {
-            throw new IllegalArgumentException("columns less than zero.");
-        }
-        if (columns != oldVal) {
-            this.columns = columns;
-            invalidate();
-        }
-    }
+    public void setColumns(int columns) {throw new RuntimeException("cf-bug");} //{
+//        int oldVal = this.columns;
+//        if (columns < 0) {
+//            throw new IllegalArgumentException("columns less than zero.");
+//        }
+//        if (columns != oldVal) {
+//            this.columns = columns;
+//            invalidate();
+//        }
+//    }
 
     /**
      * Returns the column width.
@@ -407,13 +407,13 @@
      *
      * @return the column width &gt;= 1
      */
-    protected int getColumnWidth() {
-        if (columnWidth == 0) {
-            FontMetrics metrics = getFontMetrics(getFont());
-            columnWidth = metrics.charWidth('m');
-        }
-        return columnWidth;
-    }
+    protected int getColumnWidth() {throw new RuntimeException("cf-bug");} //{
+//        if (columnWidth == 0) {
+//            FontMetrics metrics = getFontMetrics(getFont());
+//            columnWidth = metrics.charWidth('m');
+//        }
+//        return columnWidth;
+//    }
 
     /**
      * Returns the preferred size <code>Dimensions</code> needed for this
@@ -423,15 +423,15 @@
      *
      * @return the dimension of this textfield
      */
-    public Dimension getPreferredSize() {
-        Dimension size = super.getPreferredSize();
-        if (columns != 0) {
-            Insets insets = getInsets();
-            size.width = columns * getColumnWidth() +
-                insets.left + insets.right;
-        }
-        return size;
-    }
+    public Dimension getPreferredSize() {throw new RuntimeException("cf-bug");} //{
+//        Dimension size = super.getPreferredSize();
+//        if (columns != 0) {
+//            Insets insets = getInsets();
+//            size.width = columns * getColumnWidth() +
+//                insets.left + insets.right;
+//        }
+//        return size;
+//    }
 
     /**
      * Sets the current font.  This removes cached row height and column
@@ -440,10 +440,10 @@
      *
      * @param f the new font
      */
-    public void setFont(Font f) {
-        super.setFont(f);
-        columnWidth = 0;
-    }
+    public void setFont(Font f) {throw new RuntimeException("cf-bug");} //{
+//        super.setFont(f);
+//        columnWidth = 0;
+//    }
 
     /**
      * Adds the specified action listener to receive
@@ -451,9 +451,9 @@
      *
      * @param l the action listener to be added
      */
-    public synchronized void addActionListener(ActionListener l) {
-        listenerList.add(ActionListener.class, l);
-    }
+    public synchronized void addActionListener(ActionListener l) {throw new RuntimeException("cf-bug");} //{
+//        listenerList.add(ActionListener.class, l);
+//    }
 
     /**
      * Removes the specified action listener so that it no longer
@@ -461,13 +461,13 @@
      *
      * @param l the action listener to be removed
      */
-    public synchronized void removeActionListener(ActionListener l) {
-        if ((l != null) && (getAction() == l)) {
-            setAction(null);
-        } else {
-            listenerList.remove(ActionListener.class, l);
-        }
-    }
+    public synchronized void removeActionListener(ActionListener l) {throw new RuntimeException("cf-bug");} //{
+//        if ((l != null) && (getAction() == l)) {
+//            setAction(null);
+//        } else {
+//            listenerList.remove(ActionListener.class, l);
+//        }
+//    }
 
     /**
      * Returns an array of all the <code>ActionListener</code>s added
@@ -477,9 +477,9 @@
      *         array if no listeners have been added
      * @since 1.4
      */
-    public synchronized ActionListener[] getActionListeners() {
-        return listenerList.getListeners(ActionListener.class);
-    }
+    public synchronized ActionListener[] getActionListeners() {throw new RuntimeException("cf-bug");} //{
+//        return listenerList.getListeners(ActionListener.class);
+//    }
 
     /**
      * Notifies all listeners that have registered interest for
@@ -489,38 +489,38 @@
      * first order.
      * @see EventListenerList
      */
-    protected void fireActionPerformed() {
-        // Guaranteed to return a non-null array
-        Object[] listeners = listenerList.getListenerList();
-        int modifiers = 0;
-        AWTEvent currentEvent = EventQueue.getCurrentEvent();
-        if (currentEvent instanceof InputEvent) {
-            modifiers = ((InputEvent)currentEvent).getModifiers();
-        } else if (currentEvent instanceof ActionEvent) {
-            modifiers = ((ActionEvent)currentEvent).getModifiers();
-        }
-        ActionEvent e =
-            new ActionEvent(this, ActionEvent.ACTION_PERFORMED,
-                            (command != null) ? command : getText(),
-                            EventQueue.getMostRecentEventTime(), modifiers);
-
-        // Process the listeners last to first, notifying
-        // those that are interested in this event
-        for (int i = listeners.length-2; i>=0; i-=2) {
-            if (listeners[i]==ActionListener.class) {
-                ((ActionListener)listeners[i+1]).actionPerformed(e);
-            }
-        }
-    }
+    protected void fireActionPerformed() {throw new RuntimeException("cf-bug");} //{
+//        // Guaranteed to return a non-null array
+//        Object[] listeners = listenerList.getListenerList();
+//        int modifiers = 0;
+//        AWTEvent currentEvent = EventQueue.getCurrentEvent();
+//        if (currentEvent instanceof InputEvent) {
+//            modifiers = ((InputEvent)currentEvent).getModifiers();
+//        } else if (currentEvent instanceof ActionEvent) {
+//            modifiers = ((ActionEvent)currentEvent).getModifiers();
+//        }
+//        ActionEvent e =
+//            new ActionEvent(this, ActionEvent.ACTION_PERFORMED,
+//                            (command != null) ? command : getText(),
+//                            EventQueue.getMostRecentEventTime(), modifiers);
+//
+//        // Process the listeners last to first, notifying
+//        // those that are interested in this event
+//        for (int i = listeners.length-2; i>=0; i-=2) {
+//            if (listeners[i]==ActionListener.class) {
+//                ((ActionListener)listeners[i+1]).actionPerformed(e);
+//            }
+//        }
+//    }
 
     /**
      * Sets the command string used for action events.
      *
      * @param command the command string
      */
-    public void setActionCommand(String command) {
-        this.command = command;
-    }
+    public void setActionCommand(String command) {throw new RuntimeException("cf-bug");} //{
+//        this.command = command;
+//    }
 
     private Action action;
     private PropertyChangeListener actionPropertyChangeListener;
@@ -565,39 +565,39 @@
      *    attribute: visualUpdate true
      *  description: the Action instance connected with this ActionEvent source
      */
-    public void setAction(Action a) {
-        Action oldValue = getAction();
-        if (action==null || !action.equals(a)) {
-            action = a;
-            if (oldValue!=null) {
-                removeActionListener(oldValue);
-                oldValue.removePropertyChangeListener(actionPropertyChangeListener);
-                actionPropertyChangeListener = null;
-            }
-            configurePropertiesFromAction(action);
-            if (action!=null) {
-                // Don't add if it is already a listener
-                if (!isListener(ActionListener.class, action)) {
-                    addActionListener(action);
-                }
-                // Reverse linkage:
-                actionPropertyChangeListener = createActionPropertyChangeListener(action);
-                action.addPropertyChangeListener(actionPropertyChangeListener);
-            }
-            firePropertyChange("action", oldValue, action);
-        }
-    }
-
-    private boolean isListener(Class c, ActionListener a) {
-        boolean isListener = false;
-        Object[] listeners = listenerList.getListenerList();
-        for (int i = listeners.length-2; i>=0; i-=2) {
-            if (listeners[i]==c && listeners[i+1]==a) {
-                    isListener=true;
-            }
-        }
-        return isListener;
-    }
+    public void setAction(Action a) {throw new RuntimeException("cf-bug");} //{
+//        Action oldValue = getAction();
+//        if (action==null || !action.equals(a)) {
+//            action = a;
+//            if (oldValue!=null) {
+//                removeActionListener(oldValue);
+//                oldValue.removePropertyChangeListener(actionPropertyChangeListener);
+//                actionPropertyChangeListener = null;
+//            }
+//            configurePropertiesFromAction(action);
+//            if (action!=null) {
+//                // Don't add if it is already a listener
+//                if (!isListener(ActionListener.class, action)) {
+//                    addActionListener(action);
+//                }
+//                // Reverse linkage:
+//                actionPropertyChangeListener = createActionPropertyChangeListener(action);
+//                action.addPropertyChangeListener(actionPropertyChangeListener);
+//            }
+//            firePropertyChange("action", oldValue, action);
+//        }
+//    }
+
+    private boolean isListener(Class c, ActionListener a) {throw new RuntimeException("cf-bug");} //{
+//        boolean isListener = false;
+//        Object[] listeners = listenerList.getListenerList();
+//        for (int i = listeners.length-2; i>=0; i-=2) {
+//            if (listeners[i]==c && listeners[i+1]==a) {
+//                    isListener=true;
+//            }
+//        }
+//        return isListener;
+//    }
 
     /**
      * Returns the currently set <code>Action</code> for this
@@ -610,9 +610,9 @@
      * @see Action
      * @see #setAction
      */
-    public Action getAction() {
-        return action;
-    }
+    public Action getAction() {throw new RuntimeException("cf-bug");} //{
+//        return action;
+//    }
 
     /**
      * Sets the properties on this textfield to match those in the specified
@@ -626,11 +626,11 @@
      * @see Action
      * @see #setAction
      */
-    protected void configurePropertiesFromAction(Action a) {
-        AbstractAction.setEnabledFromAction(this, a);
-        AbstractAction.setToolTipTextFromAction(this, a);
-        setActionCommandFromAction(a);
-    }
+    protected void configurePropertiesFromAction(Action a) {throw new RuntimeException("cf-bug");} //{
+//        AbstractAction.setEnabledFromAction(this, a);
+//        AbstractAction.setToolTipTextFromAction(this, a);
+//        setActionCommandFromAction(a);
+//    }
 
     /**
      * Updates the textfield's state in response to property changes in
@@ -651,20 +651,20 @@
      * @see Action
      * @see #configurePropertiesFromAction
      */
-    protected void actionPropertyChanged(Action action, String propertyName) {
-        if (propertyName == Action.ACTION_COMMAND_KEY) {
-            setActionCommandFromAction(action);
-        } else if (propertyName == "enabled") {
-            AbstractAction.setEnabledFromAction(this, action);
-        } else if (propertyName == Action.SHORT_DESCRIPTION) {
-            AbstractAction.setToolTipTextFromAction(this, action);
-        }
-    }
-
-    private void setActionCommandFromAction(Action action) {
-        setActionCommand((action == null) ? null :
-                         (String)action.getValue(Action.ACTION_COMMAND_KEY));
-    }
+    protected void actionPropertyChanged(Action action, String propertyName) {throw new RuntimeException("cf-bug");} //{
+//        if (propertyName == Action.ACTION_COMMAND_KEY) {
+//            setActionCommandFromAction(action);
+//        } else if (propertyName == "enabled") {
+//            AbstractAction.setEnabledFromAction(this, action);
+//        } else if (propertyName == Action.SHORT_DESCRIPTION) {
+//            AbstractAction.setToolTipTextFromAction(this, action);
+//        }
+//    }
+
+    private void setActionCommandFromAction(Action action) {throw new RuntimeException("cf-bug");} //{
+//        setActionCommand((action == null) ? null :
+//                         (String)action.getValue(Action.ACTION_COMMAND_KEY));
+//    }
 
     /**
      * Creates and returns a <code>PropertyChangeListener</code> that is
@@ -680,9 +680,9 @@
      * @see Action
      * @see #setAction
      */
-    protected PropertyChangeListener createActionPropertyChangeListener(Action a) {
-        return new TextFieldActionPropertyChangeListener(this, a);
-    }
+    protected PropertyChangeListener createActionPropertyChangeListener(Action a) {throw new RuntimeException("cf-bug");} //{
+//        return new TextFieldActionPropertyChangeListener(this, a);
+//    }
 
     private static class TextFieldActionPropertyChangeListener extends
                          ActionPropertyChangeListener<JTextField> {
@@ -692,13 +692,13 @@
 
         protected void actionPropertyChanged(JTextField textField,
                                              Action action,
-                                             PropertyChangeEvent e) {
-            if (AbstractAction.shouldReconfigure(e)) {
-                textField.configurePropertiesFromAction(action);
-            } else {
-                textField.actionPropertyChanged(action, e.getPropertyName());
-            }
-        }
+                                             PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//            if (AbstractAction.shouldReconfigure(e)) {
+//                textField.configurePropertiesFromAction(action);
+//            } else {
+//                textField.actionPropertyChanged(action, e.getPropertyName());
+//            }
+//        }
     }
 
     /**
@@ -710,9 +710,9 @@
      *
      * @return the command list
      */
-    public Action[] getActions() {
-        return TextAction.augmentList(super.getActions(), defaultActions);
-    }
+    public Action[] getActions() {throw new RuntimeException("cf-bug");} //{
+//        return TextAction.augmentList(super.getActions(), defaultActions);
+//    }
 
     /**
      * Processes action events occurring on this textfield by
@@ -720,9 +720,9 @@
      * This is normally called by the controller registered with
      * textfield.
      */
-    public void postActionEvent() {
-        fireActionPerformed();
-    }
+    public void postActionEvent() {throw new RuntimeException("cf-bug");} //{
+//        fireActionPerformed();
+//    }
 
     // --- Scrolling support -----------------------------------
 
@@ -740,63 +740,63 @@
      * @return the visibility
      * @see BoundedRangeModel
      */
-    public BoundedRangeModel getHorizontalVisibility() {
-        return visibility;
-    }
+    public BoundedRangeModel getHorizontalVisibility() {throw new RuntimeException("cf-bug");} //{
+//        return visibility;
+//    }
 
     /**
      * Gets the scroll offset, in pixels.
      *
      * @return the offset &gt;= 0
      */
-    public int getScrollOffset() {
-        return visibility.getValue();
-    }
+    public int getScrollOffset() {throw new RuntimeException("cf-bug");} //{
+//        return visibility.getValue();
+//    }
 
     /**
      * Sets the scroll offset, in pixels.
      *
      * @param scrollOffset the offset &gt;= 0
      */
-    public void setScrollOffset(int scrollOffset) {
-        visibility.setValue(scrollOffset);
-    }
+    public void setScrollOffset(int scrollOffset) {throw new RuntimeException("cf-bug");} //{
+//        visibility.setValue(scrollOffset);
+//    }
 
     /**
      * Scrolls the field left or right.
      *
      * @param r the region to scroll
      */
-    public void scrollRectToVisible(Rectangle r) {
-        // convert to coordinate system of the bounded range
-        Insets i = getInsets();
-        int x0 = r.x + visibility.getValue() - i.left;
-        int x1 = x0 + r.width;
-        if (x0 < visibility.getValue()) {
-            // Scroll to the left
-            visibility.setValue(x0);
-        } else if(x1 > visibility.getValue() + visibility.getExtent()) {
-            // Scroll to the right
-            visibility.setValue(x1 - visibility.getExtent());
-        }
-    }
+    public void scrollRectToVisible(Rectangle r) {throw new RuntimeException("cf-bug");} //{
+//        // convert to coordinate system of the bounded range
+//        Insets i = getInsets();
+//        int x0 = r.x + visibility.getValue() - i.left;
+//        int x1 = x0 + r.width;
+//        if (x0 < visibility.getValue()) {
+//            // Scroll to the left
+//            visibility.setValue(x0);
+//        } else if(x1 > visibility.getValue() + visibility.getExtent()) {
+//            // Scroll to the right
+//            visibility.setValue(x1 - visibility.getExtent());
+//        }
+//    }
 
     /**
      * Returns true if the receiver has an <code>ActionListener</code>
      * installed.
      */
-    boolean hasActionListener() {
-        // Guaranteed to return a non-null array
-        Object[] listeners = listenerList.getListenerList();
-        // Process the listeners last to first, notifying
-        // those that are interested in this event
-        for (int i = listeners.length-2; i>=0; i-=2) {
-            if (listeners[i]==ActionListener.class) {
-                return true;
-            }
-        }
-        return false;
-    }
+    boolean hasActionListener() {throw new RuntimeException("cf-bug");} //{
+//        // Guaranteed to return a non-null array
+//        Object[] listeners = listenerList.getListenerList();
+//        // Process the listeners last to first, notifying
+//        // those that are interested in this event
+//        for (int i = listeners.length-2; i>=0; i-=2) {
+//            if (listeners[i]==ActionListener.class) {
+//                return true;
+//            }
+//        }
+//        return false;
+//    }
 
     // --- variables -------------------------------------------
 
@@ -832,28 +832,28 @@
             super(notifyAction);
         }
 
-        public void actionPerformed(ActionEvent e) {
-            JTextComponent target = getFocusedComponent();
-            if (target instanceof JTextField) {
-                JTextField field = (JTextField) target;
-                field.postActionEvent();
-            }
-        }
-
-        public boolean isEnabled() {
-            JTextComponent target = getFocusedComponent();
-            if (target instanceof JTextField) {
-                return ((JTextField)target).hasActionListener();
-            }
-            return false;
-        }
+        public void actionPerformed(ActionEvent e) {throw new RuntimeException("cf-bug");} //{
+//            JTextComponent target = getFocusedComponent();
+//            if (target instanceof JTextField) {
+//                JTextField field = (JTextField) target;
+//                field.postActionEvent();
+//            }
+//        }
+
+        public boolean isEnabled() {throw new RuntimeException("cf-bug");} //{
+//            JTextComponent target = getFocusedComponent();
+//            if (target instanceof JTextField) {
+//                return ((JTextField)target).hasActionListener();
+//            }
+//            return false;
+//        }
     }
 
     class ScrollRepainter implements ChangeListener, Serializable {
 
-        public void stateChanged(ChangeEvent e) {
-            repaint();
-        }
+        public void stateChanged(ChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//            repaint();
+//        }
 
     }
 
@@ -863,16 +863,16 @@
      * <code>JComponent</code> for more
      * information about serialization in Swing.
      */
-    private void writeObject(ObjectOutputStream s) throws IOException {
-        s.defaultWriteObject();
-        if (getUIClassID().equals(uiClassID)) {
-            byte count = JComponent.getWriteObjCounter(this);
-            JComponent.setWriteObjCounter(this, --count);
-            if (count == 0 && ui != null) {
-                ui.installUI(this);
-            }
-        }
-    }
+    private void writeObject(ObjectOutputStream s) throws IOException {throw new RuntimeException("cf-bug");} //{
+//        s.defaultWriteObject();
+//        if (getUIClassID().equals(uiClassID)) {
+//            byte count = JComponent.getWriteObjCounter(this);
+//            JComponent.setWriteObjCounter(this, --count);
+//            if (count == 0 && ui != null) {
+//                ui.installUI(this);
+//            }
+//        }
+//    }
 
 
     /**
@@ -884,28 +884,28 @@
      *
      * @return  a string representation of this <code>JTextField</code>
      */
-    protected String paramString() {
-        String horizontalAlignmentString;
-        if (horizontalAlignment == LEFT) {
-            horizontalAlignmentString = "LEFT";
-        } else if (horizontalAlignment == CENTER) {
-            horizontalAlignmentString = "CENTER";
-        } else if (horizontalAlignment == RIGHT) {
-            horizontalAlignmentString = "RIGHT";
-        } else if (horizontalAlignment == LEADING) {
-            horizontalAlignmentString = "LEADING";
-        } else if (horizontalAlignment == TRAILING) {
-            horizontalAlignmentString = "TRAILING";
-        } else horizontalAlignmentString = "";
-        String commandString = (command != null ?
-                                command : "");
-
-        return super.paramString() +
-        ",columns=" + columns +
-        ",columnWidth=" + columnWidth +
-        ",command=" + commandString +
-        ",horizontalAlignment=" + horizontalAlignmentString;
-    }
+    protected String paramString() {throw new RuntimeException("cf-bug");} //{
+//        String horizontalAlignmentString;
+//        if (horizontalAlignment == LEFT) {
+//            horizontalAlignmentString = "LEFT";
+//        } else if (horizontalAlignment == CENTER) {
+//            horizontalAlignmentString = "CENTER";
+//        } else if (horizontalAlignment == RIGHT) {
+//            horizontalAlignmentString = "RIGHT";
+//        } else if (horizontalAlignment == LEADING) {
+//            horizontalAlignmentString = "LEADING";
+//        } else if (horizontalAlignment == TRAILING) {
+//            horizontalAlignmentString = "TRAILING";
+//        } else horizontalAlignmentString = "";
+//        String commandString = (command != null ?
+//                                command : "");
+//
+//        return super.paramString() +
+//        ",columns=" + columns +
+//        ",columnWidth=" + columnWidth +
+//        ",command=" + commandString +
+//        ",horizontalAlignment=" + horizontalAlignmentString;
+//    }
 
 
 /////////////////
@@ -924,12 +924,12 @@
      * @return an <code>AccessibleJTextField</code> that serves as the
      *         <code>AccessibleContext</code> of this <code>JTextField</code>
      */
-    public AccessibleContext getAccessibleContext() {
-        if (accessibleContext == null) {
-            accessibleContext = new AccessibleJTextField();
-        }
-        return accessibleContext;
-    }
+    public AccessibleContext getAccessibleContext() {throw new RuntimeException("cf-bug");} //{
+//        if (accessibleContext == null) {
+//            accessibleContext = new AccessibleJTextField();
+//        }
+//        return accessibleContext;
+//    }
 
     /**
      * This class implements accessibility support for the
@@ -955,10 +955,10 @@
          * of the object
          * @see AccessibleState
          */
-        public AccessibleStateSet getAccessibleStateSet() {
-            AccessibleStateSet states = super.getAccessibleStateSet();
-            states.add(AccessibleState.SINGLE_LINE);
-            return states;
-        }
+        public AccessibleStateSet getAccessibleStateSet() {throw new RuntimeException("cf-bug");} //{
+//            AccessibleStateSet states = super.getAccessibleStateSet();
+//            states.add(AccessibleState.SINGLE_LINE);
+//            return states;
+//        }
     }
 }
--- javax/swing/plaf/synth/SynthInternalFrameTitlePane.java	2016-06-22 19:55:20.104892126 -0700
+++ javax/swing/plaf/synth/SynthInternalFrameTitlePane.java	2016-06-29 14:11:21.110719411 -0700
@@ -58,439 +58,439 @@
         super(f);
     }
 
-    public String getUIClassID() {
-        return "InternalFrameTitlePaneUI";
-    }
-
-    public SynthContext getContext(JComponent c) {
-        return getContext(c, getComponentState(c));
-    }
-
-    public SynthContext getContext(JComponent c, int state) {
-        return SynthContext.getContext(c, style, state);
-    }
-
-    private Region getRegion(JComponent c) {
-        return SynthLookAndFeel.getRegion(c);
-    }
-
-    private int getComponentState(JComponent c) {
-        if (frame != null) {
-            if (frame.isSelected()) {
-                return SELECTED;
-            }
-        }
-        return SynthLookAndFeel.getComponentState(c);
-    }
-
-    protected void addSubComponents() {
-        menuButton.setName("InternalFrameTitlePane.menuButton");
-        iconButton.setName("InternalFrameTitlePane.iconifyButton");
-        maxButton.setName("InternalFrameTitlePane.maximizeButton");
-        closeButton.setName("InternalFrameTitlePane.closeButton");
-
-        add(menuButton);
-        add(iconButton);
-        add(maxButton);
-        add(closeButton);
-    }
-
-    protected void installListeners() {
-        super.installListeners();
-        frame.addPropertyChangeListener(this);
-        addPropertyChangeListener(this);
-    }
-
-    protected void uninstallListeners() {
-        frame.removePropertyChangeListener(this);
-        removePropertyChangeListener(this);
-        super.uninstallListeners();
-    }
-
-    private void updateStyle(JComponent c) {
-        SynthContext context = getContext(this, ENABLED);
-        SynthStyle oldStyle = style;
-        style = SynthLookAndFeel.updateStyle(context, this);
-        if (style != oldStyle) {
-            maxIcon =
-                style.getIcon(context,"InternalFrameTitlePane.maximizeIcon");
-            minIcon =
-                style.getIcon(context,"InternalFrameTitlePane.minimizeIcon");
-            iconIcon =
-                style.getIcon(context,"InternalFrameTitlePane.iconifyIcon");
-            closeIcon =
-                style.getIcon(context,"InternalFrameTitlePane.closeIcon");
-            titleSpacing = style.getInt(context,
-                              "InternalFrameTitlePane.titleSpacing", 2);
-            buttonSpacing = style.getInt(context,
-                              "InternalFrameTitlePane.buttonSpacing", 2);
-            String alignString = (String)style.get(context,
-                              "InternalFrameTitlePane.titleAlignment");
-            titleAlignment = SwingConstants.LEADING;
-            if (alignString != null) {
-                alignString = alignString.toUpperCase();
-                if (alignString.equals("TRAILING")) {
-                    titleAlignment = SwingConstants.TRAILING;
-                }
-                else if (alignString.equals("CENTER")) {
-                    titleAlignment = SwingConstants.CENTER;
-                }
-            }
-        }
-        context.dispose();
-    }
-
-    protected void installDefaults() {
-        super.installDefaults();
-        updateStyle(this);
-    }
-
-    protected void uninstallDefaults() {
-        SynthContext context = getContext(this, ENABLED);
-        style.uninstallDefaults(context);
-        context.dispose();
-        style = null;
-        JInternalFrame.JDesktopIcon di = frame.getDesktopIcon();
-        if(di != null && di.getComponentPopupMenu() == systemPopupMenu) {
-            // Release link to systemMenu from the JInternalFrame
-            di.setComponentPopupMenu(null);
-        }
-        super.uninstallDefaults();
-    }
+    public String getUIClassID() {throw new RuntimeException("cf-bug");} //{
+//        return "InternalFrameTitlePaneUI";
+//    }
+
+    public SynthContext getContext(JComponent c) {throw new RuntimeException("cf-bug");} //{
+//        return getContext(c, getComponentState(c));
+//    }
+
+    public SynthContext getContext(JComponent c, int state) {throw new RuntimeException("cf-bug");} //{
+//        return SynthContext.getContext(c, style, state);
+//    }
+
+    private Region getRegion(JComponent c) {throw new RuntimeException("cf-bug");} //{
+//        return SynthLookAndFeel.getRegion(c);
+//    }
+
+    private int getComponentState(JComponent c) {throw new RuntimeException("cf-bug");} //{
+//        if (frame != null) {
+//            if (frame.isSelected()) {
+//                return SELECTED;
+//            }
+//        }
+//        return SynthLookAndFeel.getComponentState(c);
+//    }
+
+    protected void addSubComponents() {throw new RuntimeException("cf-bug");} //{
+//        menuButton.setName("InternalFrameTitlePane.menuButton");
+//        iconButton.setName("InternalFrameTitlePane.iconifyButton");
+//        maxButton.setName("InternalFrameTitlePane.maximizeButton");
+//        closeButton.setName("InternalFrameTitlePane.closeButton");
+//
+//        add(menuButton);
+//        add(iconButton);
+//        add(maxButton);
+//        add(closeButton);
+//    }
+
+    protected void installListeners() {throw new RuntimeException("cf-bug");} //{
+//        super.installListeners();
+//        frame.addPropertyChangeListener(this);
+//        addPropertyChangeListener(this);
+//    }
+
+    protected void uninstallListeners() {throw new RuntimeException("cf-bug");} //{
+//        frame.removePropertyChangeListener(this);
+//        removePropertyChangeListener(this);
+//        super.uninstallListeners();
+//    }
+
+    private void updateStyle(JComponent c) {throw new RuntimeException("cf-bug");} //{
+//        SynthContext context = getContext(this, ENABLED);
+//        SynthStyle oldStyle = style;
+//        style = SynthLookAndFeel.updateStyle(context, this);
+//        if (style != oldStyle) {
+//            maxIcon =
+//                style.getIcon(context,"InternalFrameTitlePane.maximizeIcon");
+//            minIcon =
+//                style.getIcon(context,"InternalFrameTitlePane.minimizeIcon");
+//            iconIcon =
+//                style.getIcon(context,"InternalFrameTitlePane.iconifyIcon");
+//            closeIcon =
+//                style.getIcon(context,"InternalFrameTitlePane.closeIcon");
+//            titleSpacing = style.getInt(context,
+//                              "InternalFrameTitlePane.titleSpacing", 2);
+//            buttonSpacing = style.getInt(context,
+//                              "InternalFrameTitlePane.buttonSpacing", 2);
+//            String alignString = (String)style.get(context,
+//                              "InternalFrameTitlePane.titleAlignment");
+//            titleAlignment = SwingConstants.LEADING;
+//            if (alignString != null) {
+//                alignString = alignString.toUpperCase();
+//                if (alignString.equals("TRAILING")) {
+//                    titleAlignment = SwingConstants.TRAILING;
+//                }
+//                else if (alignString.equals("CENTER")) {
+//                    titleAlignment = SwingConstants.CENTER;
+//                }
+//            }
+//        }
+//        context.dispose();
+//    }
+
+    protected void installDefaults() {throw new RuntimeException("cf-bug");} //{
+//        super.installDefaults();
+//        updateStyle(this);
+//    }
+
+    protected void uninstallDefaults() {throw new RuntimeException("cf-bug");} //{
+//        SynthContext context = getContext(this, ENABLED);
+//        style.uninstallDefaults(context);
+//        context.dispose();
+//        style = null;
+//        JInternalFrame.JDesktopIcon di = frame.getDesktopIcon();
+//        if(di != null && di.getComponentPopupMenu() == systemPopupMenu) {
+//            // Release link to systemMenu from the JInternalFrame
+//            di.setComponentPopupMenu(null);
+//        }
+//        super.uninstallDefaults();
+//    }
 
     private static class JPopupMenuUIResource extends JPopupMenu implements
         UIResource { }
 
-    protected void assembleSystemMenu() {
-        systemPopupMenu = new JPopupMenuUIResource();
-        addSystemMenuItems(systemPopupMenu);
-        enableActions();
-        menuButton = createNoFocusButton();
-        updateMenuIcon();
-        menuButton.addMouseListener(new MouseAdapter() {
-            public void mousePressed(MouseEvent e) {
-                try {
-                    frame.setSelected(true);
-                } catch(PropertyVetoException pve) {
-                }
-                showSystemMenu();
-            }
-        });
-        JPopupMenu p = frame.getComponentPopupMenu();
-        if (p == null || p instanceof UIResource) {
-            frame.setComponentPopupMenu(systemPopupMenu);
-        }
-        if (frame.getDesktopIcon() != null) {
-            p = frame.getDesktopIcon().getComponentPopupMenu();
-            if (p == null || p instanceof UIResource) {
-                frame.getDesktopIcon().setComponentPopupMenu(systemPopupMenu);
-            }
-        }
-        setInheritsPopupMenu(true);
-    }
-
-    protected void addSystemMenuItems(JPopupMenu menu) {
-        JMenuItem mi = menu.add(restoreAction);
-        mi.setMnemonic(getButtonMnemonic("restore"));
-        mi = menu.add(moveAction);
-        mi.setMnemonic(getButtonMnemonic("move"));
-        mi = menu.add(sizeAction);
-        mi.setMnemonic(getButtonMnemonic("size"));
-        mi = menu.add(iconifyAction);
-        mi.setMnemonic(getButtonMnemonic("minimize"));
-        mi = menu.add(maximizeAction);
-        mi.setMnemonic(getButtonMnemonic("maximize"));
-        menu.add(new JSeparator());
-        mi = menu.add(closeAction);
-        mi.setMnemonic(getButtonMnemonic("close"));
-    }
-
-    private static int getButtonMnemonic(String button) {
-        try {
-            return Integer.parseInt(UIManager.getString(
-                    "InternalFrameTitlePane." + button + "Button.mnemonic"));
-        } catch (NumberFormatException e) {
-            return -1;
-        }
-    }
-
-    protected void showSystemMenu() {
-        Insets insets = frame.getInsets();
-        if (!frame.isIcon()) {
-            systemPopupMenu.show(frame, menuButton.getX(), getY() + getHeight());
-        } else {
-            systemPopupMenu.show(menuButton,
-                getX() - insets.left - insets.right,
-                getY() - systemPopupMenu.getPreferredSize().height -
-                    insets.bottom - insets.top);
-        }
-    }
+    protected void assembleSystemMenu() {throw new RuntimeException("cf-bug");} //{
+//        systemPopupMenu = new JPopupMenuUIResource();
+//        addSystemMenuItems(systemPopupMenu);
+//        enableActions();
+//        menuButton = createNoFocusButton();
+//        updateMenuIcon();
+//        menuButton.addMouseListener(new MouseAdapter() {
+//            public void mousePressed(MouseEvent e) {
+//                try {
+//                    frame.setSelected(true);
+//                } catch(PropertyVetoException pve) {
+//                }
+//                showSystemMenu();
+//            }
+//        });
+//        JPopupMenu p = frame.getComponentPopupMenu();
+//        if (p == null || p instanceof UIResource) {
+//            frame.setComponentPopupMenu(systemPopupMenu);
+//        }
+//        if (frame.getDesktopIcon() != null) {
+//            p = frame.getDesktopIcon().getComponentPopupMenu();
+//            if (p == null || p instanceof UIResource) {
+//                frame.getDesktopIcon().setComponentPopupMenu(systemPopupMenu);
+//            }
+//        }
+//        setInheritsPopupMenu(true);
+//    }
+
+    protected void addSystemMenuItems(JPopupMenu menu) {throw new RuntimeException("cf-bug");} //{
+//        JMenuItem mi = menu.add(restoreAction);
+//        mi.setMnemonic(getButtonMnemonic("restore"));
+//        mi = menu.add(moveAction);
+//        mi.setMnemonic(getButtonMnemonic("move"));
+//        mi = menu.add(sizeAction);
+//        mi.setMnemonic(getButtonMnemonic("size"));
+//        mi = menu.add(iconifyAction);
+//        mi.setMnemonic(getButtonMnemonic("minimize"));
+//        mi = menu.add(maximizeAction);
+//        mi.setMnemonic(getButtonMnemonic("maximize"));
+//        menu.add(new JSeparator());
+//        mi = menu.add(closeAction);
+//        mi.setMnemonic(getButtonMnemonic("close"));
+//    }
+
+    private static int getButtonMnemonic(String button) {throw new RuntimeException("cf-bug");} //{
+//        try {
+//            return Integer.parseInt(UIManager.getString(
+//                    "InternalFrameTitlePane." + button + "Button.mnemonic"));
+//        } catch (NumberFormatException e) {
+//            return -1;
+//        }
+//    }
+
+    protected void showSystemMenu() {throw new RuntimeException("cf-bug");} //{
+//        Insets insets = frame.getInsets();
+//        if (!frame.isIcon()) {
+//            systemPopupMenu.show(frame, menuButton.getX(), getY() + getHeight());
+//        } else {
+//            systemPopupMenu.show(menuButton,
+//                getX() - insets.left - insets.right,
+//                getY() - systemPopupMenu.getPreferredSize().height -
+//                    insets.bottom - insets.top);
+//        }
+//    }
 
     // SynthInternalFrameTitlePane has no UI, we'll invoke paint on it.
-    public void paintComponent(Graphics g) {
-        SynthContext context = getContext(this);
-        SynthLookAndFeel.update(context, g);
-        context.getPainter().paintInternalFrameTitlePaneBackground(context,
-                          g, 0, 0, getWidth(), getHeight());
-        paint(context, g);
-        context.dispose();
-    }
-
-    protected void paint(SynthContext context, Graphics g) {
-        String title = frame.getTitle();
-
-        if (title != null) {
-            SynthStyle style = context.getStyle();
-
-            g.setColor(style.getColor(context, ColorType.TEXT_FOREGROUND));
-            g.setFont(style.getFont(context));
-
-            // Center text vertically.
-            FontMetrics fm = SwingUtilities2.getFontMetrics(frame, g);
-            int baseline = (getHeight() + fm.getAscent() - fm.getLeading() -
-                            fm.getDescent()) / 2;
-            JButton lastButton = null;
-            if (frame.isIconifiable()) {
-                lastButton = iconButton;
-            }
-            else if (frame.isMaximizable()) {
-                lastButton = maxButton;
-            }
-            else if (frame.isClosable()) {
-                lastButton = closeButton;
-            }
-            int maxX;
-            int minX;
-            boolean ltr = SynthLookAndFeel.isLeftToRight(frame);
-            int titleAlignment = this.titleAlignment;
-            if (ltr) {
-                if (lastButton != null) {
-                    maxX = lastButton.getX() - titleSpacing;
-                }
-                else {
-                    maxX = frame.getWidth() - frame.getInsets().right -
-                           titleSpacing;
-                }
-                minX = menuButton.getX() + menuButton.getWidth() +
-                       titleSpacing;
-            }
-            else {
-                if (lastButton != null) {
-                    minX = lastButton.getX() + lastButton.getWidth() +
-                           titleSpacing;
-                }
-                else {
-                    minX = frame.getInsets().left + titleSpacing;
-                }
-                maxX = menuButton.getX() - titleSpacing;
-                if (titleAlignment == SwingConstants.LEADING) {
-                    titleAlignment = SwingConstants.TRAILING;
-                }
-                else if (titleAlignment == SwingConstants.TRAILING) {
-                    titleAlignment = SwingConstants.LEADING;
-                }
-            }
-            String clippedTitle = getTitle(title, fm, maxX - minX);
-            if (clippedTitle == title) {
-                // String fit, align as necessary.
-                if (titleAlignment == SwingConstants.TRAILING) {
-                    minX = maxX - style.getGraphicsUtils(context).
-                        computeStringWidth(context, g.getFont(), fm, title);
-                }
-                else if (titleAlignment == SwingConstants.CENTER) {
-                    int width = style.getGraphicsUtils(context).
-                           computeStringWidth(context, g.getFont(), fm, title);
-                    minX = Math.max(minX, (getWidth() - width) / 2);
-                    minX = Math.min(maxX - width, minX);
-                }
-            }
-            style.getGraphicsUtils(context).paintText(
-                context, g, clippedTitle, minX, baseline - fm.getAscent(), -1);
-        }
-    }
+    public void paintComponent(Graphics g) {throw new RuntimeException("cf-bug");} //{
+//        SynthContext context = getContext(this);
+//        SynthLookAndFeel.update(context, g);
+//        context.getPainter().paintInternalFrameTitlePaneBackground(context,
+//                          g, 0, 0, getWidth(), getHeight());
+//        paint(context, g);
+//        context.dispose();
+//    }
+
+    protected void paint(SynthContext context, Graphics g) {throw new RuntimeException("cf-bug");} //{
+//        String title = frame.getTitle();
+//
+//        if (title != null) {
+//            SynthStyle style = context.getStyle();
+//
+//            g.setColor(style.getColor(context, ColorType.TEXT_FOREGROUND));
+//            g.setFont(style.getFont(context));
+//
+//            // Center text vertically.
+//            FontMetrics fm = SwingUtilities2.getFontMetrics(frame, g);
+//            int baseline = (getHeight() + fm.getAscent() - fm.getLeading() -
+//                            fm.getDescent()) / 2;
+//            JButton lastButton = null;
+//            if (frame.isIconifiable()) {
+//                lastButton = iconButton;
+//            }
+//            else if (frame.isMaximizable()) {
+//                lastButton = maxButton;
+//            }
+//            else if (frame.isClosable()) {
+//                lastButton = closeButton;
+//            }
+//            int maxX;
+//            int minX;
+//            boolean ltr = SynthLookAndFeel.isLeftToRight(frame);
+//            int titleAlignment = this.titleAlignment;
+//            if (ltr) {
+//                if (lastButton != null) {
+//                    maxX = lastButton.getX() - titleSpacing;
+//                }
+//                else {
+//                    maxX = frame.getWidth() - frame.getInsets().right -
+//                           titleSpacing;
+//                }
+//                minX = menuButton.getX() + menuButton.getWidth() +
+//                       titleSpacing;
+//            }
+//            else {
+//                if (lastButton != null) {
+//                    minX = lastButton.getX() + lastButton.getWidth() +
+//                           titleSpacing;
+//                }
+//                else {
+//                    minX = frame.getInsets().left + titleSpacing;
+//                }
+//                maxX = menuButton.getX() - titleSpacing;
+//                if (titleAlignment == SwingConstants.LEADING) {
+//                    titleAlignment = SwingConstants.TRAILING;
+//                }
+//                else if (titleAlignment == SwingConstants.TRAILING) {
+//                    titleAlignment = SwingConstants.LEADING;
+//                }
+//            }
+//            String clippedTitle = getTitle(title, fm, maxX - minX);
+//            if (clippedTitle == title) {
+//                // String fit, align as necessary.
+//                if (titleAlignment == SwingConstants.TRAILING) {
+//                    minX = maxX - style.getGraphicsUtils(context).
+//                        computeStringWidth(context, g.getFont(), fm, title);
+//                }
+//                else if (titleAlignment == SwingConstants.CENTER) {
+//                    int width = style.getGraphicsUtils(context).
+//                           computeStringWidth(context, g.getFont(), fm, title);
+//                    minX = Math.max(minX, (getWidth() - width) / 2);
+//                    minX = Math.min(maxX - width, minX);
+//                }
+//            }
+//            style.getGraphicsUtils(context).paintText(
+//                context, g, clippedTitle, minX, baseline - fm.getAscent(), -1);
+//        }
+//    }
 
     public void paintBorder(SynthContext context, Graphics g, int x,
-                            int y, int w, int h) {
-        context.getPainter().paintInternalFrameTitlePaneBorder(context,
-                                                            g, x, y, w, h);
-    }
-
-    protected LayoutManager createLayout() {
-        SynthContext context = getContext(this);
-        LayoutManager lm =
-            (LayoutManager)style.get(context, "InternalFrameTitlePane.titlePaneLayout");
-        context.dispose();
-        return (lm != null) ? lm : new SynthTitlePaneLayout();
-    }
-
-    public void propertyChange(PropertyChangeEvent evt) {
-        if (evt.getSource() == this) {
-            if (SynthLookAndFeel.shouldUpdateStyle(evt)) {
-                updateStyle(this);
-            }
-        }
-        else {
-            // Changes for the internal frame
-            if (evt.getPropertyName() == JInternalFrame.FRAME_ICON_PROPERTY) {
-                updateMenuIcon();
-            }
-        }
-    }
+                            int y, int w, int h) {throw new RuntimeException("cf-bug");} //{
+//        context.getPainter().paintInternalFrameTitlePaneBorder(context,
+//                                                            g, x, y, w, h);
+//    }
+
+    protected LayoutManager createLayout() {throw new RuntimeException("cf-bug");} //{
+//        SynthContext context = getContext(this);
+//        LayoutManager lm =
+//            (LayoutManager)style.get(context, "InternalFrameTitlePane.titlePaneLayout");
+//        context.dispose();
+//        return (lm != null) ? lm : new SynthTitlePaneLayout();
+//    }
+
+    public void propertyChange(PropertyChangeEvent evt) {throw new RuntimeException("cf-bug");} //{
+//        if (evt.getSource() == this) {
+//            if (SynthLookAndFeel.shouldUpdateStyle(evt)) {
+//                updateStyle(this);
+//            }
+//        }
+//        else {
+//            // Changes for the internal frame
+//            if (evt.getPropertyName() == JInternalFrame.FRAME_ICON_PROPERTY) {
+//                updateMenuIcon();
+//            }
+//        }
+//    }
 
     /**
      * Resets the menuButton icon to match that of the frame.
      */
-    private void updateMenuIcon() {
-        Icon frameIcon = frame.getFrameIcon();
-        SynthContext context = getContext(this);
-        if (frameIcon != null) {
-            Dimension maxSize = (Dimension)context.getStyle().get(context,
-                                "InternalFrameTitlePane.maxFrameIconSize");
-            int maxWidth = 16;
-            int maxHeight = 16;
-            if (maxSize != null) {
-                maxWidth = maxSize.width;
-                maxHeight = maxSize.height;
-            }
-            if ((frameIcon.getIconWidth() > maxWidth ||
-                     frameIcon.getIconHeight() > maxHeight) &&
-                    (frameIcon instanceof ImageIcon)) {
-                frameIcon = new ImageIcon(((ImageIcon)frameIcon).
-                             getImage().getScaledInstance(maxWidth, maxHeight,
-                             Image.SCALE_SMOOTH));
-            }
-        }
-        context.dispose();
-        menuButton.setIcon(frameIcon);
-    }
+    private void updateMenuIcon() {throw new RuntimeException("cf-bug");} //{
+//        Icon frameIcon = frame.getFrameIcon();
+//        SynthContext context = getContext(this);
+//        if (frameIcon != null) {
+//            Dimension maxSize = (Dimension)context.getStyle().get(context,
+//                                "InternalFrameTitlePane.maxFrameIconSize");
+//            int maxWidth = 16;
+//            int maxHeight = 16;
+//            if (maxSize != null) {
+//                maxWidth = maxSize.width;
+//                maxHeight = maxSize.height;
+//            }
+//            if ((frameIcon.getIconWidth() > maxWidth ||
+//                     frameIcon.getIconHeight() > maxHeight) &&
+//                    (frameIcon instanceof ImageIcon)) {
+//                frameIcon = new ImageIcon(((ImageIcon)frameIcon).
+//                             getImage().getScaledInstance(maxWidth, maxHeight,
+//                             Image.SCALE_SMOOTH));
+//            }
+//        }
+//        context.dispose();
+//        menuButton.setIcon(frameIcon);
+//    }
 
 
     class SynthTitlePaneLayout implements LayoutManager {
         public void addLayoutComponent(String name, Component c) {}
         public void removeLayoutComponent(Component c) {}
-        public Dimension preferredLayoutSize(Container c)  {
-            return minimumLayoutSize(c);
-        }
-
-        public Dimension minimumLayoutSize(Container c) {
-            SynthContext context = getContext(
-                             SynthInternalFrameTitlePane.this);
-            int width = 0;
-            int height = 0;
-
-            int buttonCount = 0;
-            Dimension pref;
-
-            if (frame.isClosable()) {
-                pref = closeButton.getPreferredSize();
-                width += pref.width;
-                height = Math.max(pref.height, height);
-                buttonCount++;
-            }
-            if (frame.isMaximizable()) {
-                pref = maxButton.getPreferredSize();
-                width += pref.width;
-                height = Math.max(pref.height, height);
-                buttonCount++;
-            }
-            if (frame.isIconifiable()) {
-                pref = iconButton.getPreferredSize();
-                width += pref.width;
-                height = Math.max(pref.height, height);
-                buttonCount++;
-            }
-            pref = menuButton.getPreferredSize();
-            width += pref.width;
-            height = Math.max(pref.height, height);
-
-            width += Math.max(0, (buttonCount - 1) * buttonSpacing);
-
-            FontMetrics fm = SynthInternalFrameTitlePane.this.getFontMetrics(
-                                          getFont());
-            SynthGraphicsUtils graphicsUtils = context.getStyle().
-                                       getGraphicsUtils(context);
-            String frameTitle = frame.getTitle();
-            int title_w = frameTitle != null ? graphicsUtils.
-                               computeStringWidth(context, fm.getFont(),
-                               fm, frameTitle) : 0;
-            int title_length = frameTitle != null ? frameTitle.length() : 0;
-
-            // Leave room for three characters in the title.
-            if (title_length > 3) {
-                int subtitle_w = graphicsUtils.computeStringWidth(context,
-                    fm.getFont(), fm, frameTitle.substring(0, 3) + "...");
-                width += (title_w < subtitle_w) ? title_w : subtitle_w;
-            } else {
-                width += title_w;
-            }
-
-            height = Math.max(fm.getHeight() + 2, height);
-
-            width += titleSpacing + titleSpacing;
-
-            Insets insets = getInsets();
-            height += insets.top + insets.bottom;
-            width += insets.left + insets.right;
-            context.dispose();
-            return new Dimension(width, height);
-        }
+        public Dimension preferredLayoutSize(Container c)  {throw new RuntimeException("cf-bug");} //{
+//            return minimumLayoutSize(c);
+//        }
+
+        public Dimension minimumLayoutSize(Container c) {throw new RuntimeException("cf-bug");} //{
+//            SynthContext context = getContext(
+//                             SynthInternalFrameTitlePane.this);
+//            int width = 0;
+//            int height = 0;
+//
+//            int buttonCount = 0;
+//            Dimension pref;
+//
+//            if (frame.isClosable()) {
+//                pref = closeButton.getPreferredSize();
+//                width += pref.width;
+//                height = Math.max(pref.height, height);
+//                buttonCount++;
+//            }
+//            if (frame.isMaximizable()) {
+//                pref = maxButton.getPreferredSize();
+//                width += pref.width;
+//                height = Math.max(pref.height, height);
+//                buttonCount++;
+//            }
+//            if (frame.isIconifiable()) {
+//                pref = iconButton.getPreferredSize();
+//                width += pref.width;
+//                height = Math.max(pref.height, height);
+//                buttonCount++;
+//            }
+//            pref = menuButton.getPreferredSize();
+//            width += pref.width;
+//            height = Math.max(pref.height, height);
+//
+//            width += Math.max(0, (buttonCount - 1) * buttonSpacing);
+//
+//            FontMetrics fm = SynthInternalFrameTitlePane.this.getFontMetrics(
+//                                          getFont());
+//            SynthGraphicsUtils graphicsUtils = context.getStyle().
+//                                       getGraphicsUtils(context);
+//            String frameTitle = frame.getTitle();
+//            int title_w = frameTitle != null ? graphicsUtils.
+//                               computeStringWidth(context, fm.getFont(),
+//                               fm, frameTitle) : 0;
+//            int title_length = frameTitle != null ? frameTitle.length() : 0;
+//
+//            // Leave room for three characters in the title.
+//            if (title_length > 3) {
+//                int subtitle_w = graphicsUtils.computeStringWidth(context,
+//                    fm.getFont(), fm, frameTitle.substring(0, 3) + "...");
+//                width += (title_w < subtitle_w) ? title_w : subtitle_w;
+//            } else {
+//                width += title_w;
+//            }
+//
+//            height = Math.max(fm.getHeight() + 2, height);
+//
+//            width += titleSpacing + titleSpacing;
+//
+//            Insets insets = getInsets();
+//            height += insets.top + insets.bottom;
+//            width += insets.left + insets.right;
+//            context.dispose();
+//            return new Dimension(width, height);
+//        }
 
         private int center(Component c, Insets insets, int x,
-                           boolean trailing) {
-            Dimension pref = c.getPreferredSize();
-            if (trailing) {
-                x -= pref.width;
-            }
-            c.setBounds(x, insets.top +
-                        (getHeight() - insets.top - insets.bottom -
-                         pref.height) / 2, pref.width, pref.height);
-            if (pref.width > 0) {
-                if (trailing) {
-                    return x - buttonSpacing;
-                }
-                return x + pref.width + buttonSpacing;
-            }
-            return x;
-        }
-
-        public void layoutContainer(Container c) {
-            Insets insets = c.getInsets();
-            Dimension pref;
-
-            if (SynthLookAndFeel.isLeftToRight(frame)) {
-                center(menuButton, insets, insets.left, false);
-                int x = getWidth() - insets.right;
-                if (frame.isClosable()) {
-                    x = center(closeButton, insets, x, true);
-                }
-                if (frame.isMaximizable()) {
-                    x = center(maxButton, insets, x, true);
-                }
-                if (frame.isIconifiable()) {
-                    x = center(iconButton, insets, x, true);
-                }
-            }
-            else {
-                center(menuButton, insets, getWidth() - insets.right,
-                       true);
-                int x = insets.left;
-                if (frame.isClosable()) {
-                    x = center(closeButton, insets, x, false);
-                }
-                if (frame.isMaximizable()) {
-                    x = center(maxButton, insets, x, false);
-                }
-                if (frame.isIconifiable()) {
-                    x = center(iconButton, insets, x, false);
-                }
-            }
-        }
-    }
-
-    private JButton createNoFocusButton() {
-        JButton button = new JButton();
-        button.setFocusable(false);
-        button.setMargin(new Insets(0,0,0,0));
-        return button;
-    }
+                           boolean trailing) {throw new RuntimeException("cf-bug");} //{
+//            Dimension pref = c.getPreferredSize();
+//            if (trailing) {
+//                x -= pref.width;
+//            }
+//            c.setBounds(x, insets.top +
+//                        (getHeight() - insets.top - insets.bottom -
+//                         pref.height) / 2, pref.width, pref.height);
+//            if (pref.width > 0) {
+//                if (trailing) {
+//                    return x - buttonSpacing;
+//                }
+//                return x + pref.width + buttonSpacing;
+//            }
+//            return x;
+//        }
+
+        public void layoutContainer(Container c) {throw new RuntimeException("cf-bug");} //{
+//            Insets insets = c.getInsets();
+//            Dimension pref;
+//
+//            if (SynthLookAndFeel.isLeftToRight(frame)) {
+//                center(menuButton, insets, insets.left, false);
+//                int x = getWidth() - insets.right;
+//                if (frame.isClosable()) {
+//                    x = center(closeButton, insets, x, true);
+//                }
+//                if (frame.isMaximizable()) {
+//                    x = center(maxButton, insets, x, true);
+//                }
+//                if (frame.isIconifiable()) {
+//                    x = center(iconButton, insets, x, true);
+//                }
+//            }
+//            else {
+//                center(menuButton, insets, getWidth() - insets.right,
+//                       true);
+//                int x = insets.left;
+//                if (frame.isClosable()) {
+//                    x = center(closeButton, insets, x, false);
+//                }
+//                if (frame.isMaximizable()) {
+//                    x = center(maxButton, insets, x, false);
+//                }
+//                if (frame.isIconifiable()) {
+//                    x = center(iconButton, insets, x, false);
+//                }
+//            }
+//        }
+    }
+
+    private JButton createNoFocusButton() {throw new RuntimeException("cf-bug");} //{
+//        JButton button = new JButton();
+//        button.setFocusable(false);
+//        button.setMargin(new Insets(0,0,0,0));
+//        return button;
+//    }
 }
--- javax/swing/plaf/basic/BasicLookAndFeel.java	2016-06-22 19:55:14.873866335 -0700
+++ javax/swing/plaf/basic/BasicLookAndFeel.java	2016-06-29 12:34:25.018069446 -0700
@@ -140,78 +140,78 @@
      * @see #initSystemColorDefaults
      * @see #initComponentDefaults
      */
-    public UIDefaults getDefaults() {
-        UIDefaults table = new UIDefaults(610, 0.75f);
-
-        initClassDefaults(table);
-        initSystemColorDefaults(table);
-        initComponentDefaults(table);
-
-        return table;
-    }
+    public UIDefaults getDefaults() {throw new RuntimeException("cf-bug");} //{
+//        UIDefaults table = new UIDefaults(610, 0.75f);
+//
+//        initClassDefaults(table);
+//        initSystemColorDefaults(table);
+//        initComponentDefaults(table);
+//
+//        return table;
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public void initialize() {
-        if (needsEventHelper) {
-            installAWTEventListener();
-        }
-    }
-
-    void installAWTEventListener() {
-        if (invocator == null) {
-            invocator = new AWTEventHelper();
-            needsEventHelper = true;
-
-            // Add a PropertyChangeListener to our AppContext so we're alerted
-            // when the AppContext is disposed(), at which time this laf should
-            // be uninitialize()d.
-            disposer = new PropertyChangeListener() {
-                public void propertyChange(PropertyChangeEvent prpChg) {
-                    uninitialize();
-                }
-            };
-            AppContext.getAppContext().addPropertyChangeListener(
-                                                        AppContext.GUI_DISPOSED,
-                                                        disposer);
-        }
-    }
+    public void initialize() {throw new RuntimeException("cf-bug");} //{
+//        if (needsEventHelper) {
+//            installAWTEventListener();
+//        }
+//    }
+
+    void installAWTEventListener() {throw new RuntimeException("cf-bug");} //{
+//        if (invocator == null) {
+//            invocator = new AWTEventHelper();
+//            needsEventHelper = true;
+//
+//            // Add a PropertyChangeListener to our AppContext so we're alerted
+//            // when the AppContext is disposed(), at which time this laf should
+//            // be uninitialize()d.
+//            disposer = new PropertyChangeListener() {
+//                public void propertyChange(PropertyChangeEvent prpChg) {
+//                    uninitialize();
+//                }
+//            };
+//            AppContext.getAppContext().addPropertyChangeListener(
+//                                                        AppContext.GUI_DISPOSED,
+//                                                        disposer);
+//        }
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public void uninitialize() {
-        AppContext context = AppContext.getAppContext();
-        synchronized (BasicPopupMenuUI.MOUSE_GRABBER_KEY) {
-            Object grabber = context.get(BasicPopupMenuUI.MOUSE_GRABBER_KEY);
-            if (grabber != null) {
-                ((BasicPopupMenuUI.MouseGrabber)grabber).uninstall();
-            }
-        }
-        synchronized (BasicPopupMenuUI.MENU_KEYBOARD_HELPER_KEY) {
-            Object helper =
-                    context.get(BasicPopupMenuUI.MENU_KEYBOARD_HELPER_KEY);
-            if (helper != null) {
-                ((BasicPopupMenuUI.MenuKeyboardHelper)helper).uninstall();
-            }
-        }
-
-        if(invocator != null) {
-            AccessController.doPrivileged(invocator);
-            invocator = null;
-        }
-
-        if (disposer != null) {
-            // Note that we're likely calling removePropertyChangeListener()
-            // during the course of AppContext.firePropertyChange().
-            // However, EventListenerAggreggate has code to safely modify
-            // the list under such circumstances.
-            context.removePropertyChangeListener(AppContext.GUI_DISPOSED,
-                                                 disposer);
-            disposer = null;
-        }
-    }
+    public void uninitialize() {throw new RuntimeException("cf-bug");} //{
+//        AppContext context = AppContext.getAppContext();
+//        synchronized (BasicPopupMenuUI.MOUSE_GRABBER_KEY) {
+//            Object grabber = context.get(BasicPopupMenuUI.MOUSE_GRABBER_KEY);
+//            if (grabber != null) {
+//                ((BasicPopupMenuUI.MouseGrabber)grabber).uninstall();
+//            }
+//        }
+//        synchronized (BasicPopupMenuUI.MENU_KEYBOARD_HELPER_KEY) {
+//            Object helper =
+//                    context.get(BasicPopupMenuUI.MENU_KEYBOARD_HELPER_KEY);
+//            if (helper != null) {
+//                ((BasicPopupMenuUI.MenuKeyboardHelper)helper).uninstall();
+//            }
+//        }
+//
+//        if(invocator != null) {
+//            AccessController.doPrivileged(invocator);
+//            invocator = null;
+//        }
+//
+//        if (disposer != null) {
+//            // Note that we're likely calling removePropertyChangeListener()
+//            // during the course of AppContext.firePropertyChange().
+//            // However, EventListenerAggreggate has code to safely modify
+//            // the list under such circumstances.
+//            context.removePropertyChangeListener(AppContext.GUI_DISPOSED,
+//                                                 disposer);
+//            disposer = null;
+//        }
+//    }
 
     /**
      * Populates {@code table} with mappings from {@code uiClassID} to the
@@ -229,56 +229,56 @@
      * @see #getDefaults
      */
     protected void initClassDefaults(UIDefaults table)
-    {
-        final String basicPackageName = "javax.swing.plaf.basic.";
-        Object[] uiDefaults = {
-                   "ButtonUI", basicPackageName + "BasicButtonUI",
-                 "CheckBoxUI", basicPackageName + "BasicCheckBoxUI",
-             "ColorChooserUI", basicPackageName + "BasicColorChooserUI",
-       "FormattedTextFieldUI", basicPackageName + "BasicFormattedTextFieldUI",
-                  "MenuBarUI", basicPackageName + "BasicMenuBarUI",
-                     "MenuUI", basicPackageName + "BasicMenuUI",
-                 "MenuItemUI", basicPackageName + "BasicMenuItemUI",
-         "CheckBoxMenuItemUI", basicPackageName + "BasicCheckBoxMenuItemUI",
-      "RadioButtonMenuItemUI", basicPackageName + "BasicRadioButtonMenuItemUI",
-              "RadioButtonUI", basicPackageName + "BasicRadioButtonUI",
-             "ToggleButtonUI", basicPackageName + "BasicToggleButtonUI",
-                "PopupMenuUI", basicPackageName + "BasicPopupMenuUI",
-              "ProgressBarUI", basicPackageName + "BasicProgressBarUI",
-                "ScrollBarUI", basicPackageName + "BasicScrollBarUI",
-               "ScrollPaneUI", basicPackageName + "BasicScrollPaneUI",
-                "SplitPaneUI", basicPackageName + "BasicSplitPaneUI",
-                   "SliderUI", basicPackageName + "BasicSliderUI",
-                "SeparatorUI", basicPackageName + "BasicSeparatorUI",
-                  "SpinnerUI", basicPackageName + "BasicSpinnerUI",
-         "ToolBarSeparatorUI", basicPackageName + "BasicToolBarSeparatorUI",
-       "PopupMenuSeparatorUI", basicPackageName + "BasicPopupMenuSeparatorUI",
-               "TabbedPaneUI", basicPackageName + "BasicTabbedPaneUI",
-                 "TextAreaUI", basicPackageName + "BasicTextAreaUI",
-                "TextFieldUI", basicPackageName + "BasicTextFieldUI",
-            "PasswordFieldUI", basicPackageName + "BasicPasswordFieldUI",
-                 "TextPaneUI", basicPackageName + "BasicTextPaneUI",
-               "EditorPaneUI", basicPackageName + "BasicEditorPaneUI",
-                     "TreeUI", basicPackageName + "BasicTreeUI",
-                    "LabelUI", basicPackageName + "BasicLabelUI",
-                     "ListUI", basicPackageName + "BasicListUI",
-                  "ToolBarUI", basicPackageName + "BasicToolBarUI",
-                  "ToolTipUI", basicPackageName + "BasicToolTipUI",
-                 "ComboBoxUI", basicPackageName + "BasicComboBoxUI",
-                    "TableUI", basicPackageName + "BasicTableUI",
-              "TableHeaderUI", basicPackageName + "BasicTableHeaderUI",
-            "InternalFrameUI", basicPackageName + "BasicInternalFrameUI",
-              "DesktopPaneUI", basicPackageName + "BasicDesktopPaneUI",
-              "DesktopIconUI", basicPackageName + "BasicDesktopIconUI",
-              "FileChooserUI", basicPackageName + "BasicFileChooserUI",
-               "OptionPaneUI", basicPackageName + "BasicOptionPaneUI",
-                    "PanelUI", basicPackageName + "BasicPanelUI",
-                 "ViewportUI", basicPackageName + "BasicViewportUI",
-                 "RootPaneUI", basicPackageName + "BasicRootPaneUI",
-        };
-
-        table.putDefaults(uiDefaults);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        final String basicPackageName = "javax.swing.plaf.basic.";
+//        Object[] uiDefaults = {
+//                   "ButtonUI", basicPackageName + "BasicButtonUI",
+//                 "CheckBoxUI", basicPackageName + "BasicCheckBoxUI",
+//             "ColorChooserUI", basicPackageName + "BasicColorChooserUI",
+//       "FormattedTextFieldUI", basicPackageName + "BasicFormattedTextFieldUI",
+//                  "MenuBarUI", basicPackageName + "BasicMenuBarUI",
+//                     "MenuUI", basicPackageName + "BasicMenuUI",
+//                 "MenuItemUI", basicPackageName + "BasicMenuItemUI",
+//         "CheckBoxMenuItemUI", basicPackageName + "BasicCheckBoxMenuItemUI",
+//      "RadioButtonMenuItemUI", basicPackageName + "BasicRadioButtonMenuItemUI",
+//              "RadioButtonUI", basicPackageName + "BasicRadioButtonUI",
+//             "ToggleButtonUI", basicPackageName + "BasicToggleButtonUI",
+//                "PopupMenuUI", basicPackageName + "BasicPopupMenuUI",
+//              "ProgressBarUI", basicPackageName + "BasicProgressBarUI",
+//                "ScrollBarUI", basicPackageName + "BasicScrollBarUI",
+//               "ScrollPaneUI", basicPackageName + "BasicScrollPaneUI",
+//                "SplitPaneUI", basicPackageName + "BasicSplitPaneUI",
+//                   "SliderUI", basicPackageName + "BasicSliderUI",
+//                "SeparatorUI", basicPackageName + "BasicSeparatorUI",
+//                  "SpinnerUI", basicPackageName + "BasicSpinnerUI",
+//         "ToolBarSeparatorUI", basicPackageName + "BasicToolBarSeparatorUI",
+//       "PopupMenuSeparatorUI", basicPackageName + "BasicPopupMenuSeparatorUI",
+//               "TabbedPaneUI", basicPackageName + "BasicTabbedPaneUI",
+//                 "TextAreaUI", basicPackageName + "BasicTextAreaUI",
+//                "TextFieldUI", basicPackageName + "BasicTextFieldUI",
+//            "PasswordFieldUI", basicPackageName + "BasicPasswordFieldUI",
+//                 "TextPaneUI", basicPackageName + "BasicTextPaneUI",
+//               "EditorPaneUI", basicPackageName + "BasicEditorPaneUI",
+//                     "TreeUI", basicPackageName + "BasicTreeUI",
+//                    "LabelUI", basicPackageName + "BasicLabelUI",
+//                     "ListUI", basicPackageName + "BasicListUI",
+//                  "ToolBarUI", basicPackageName + "BasicToolBarUI",
+//                  "ToolTipUI", basicPackageName + "BasicToolTipUI",
+//                 "ComboBoxUI", basicPackageName + "BasicComboBoxUI",
+//                    "TableUI", basicPackageName + "BasicTableUI",
+//              "TableHeaderUI", basicPackageName + "BasicTableHeaderUI",
+//            "InternalFrameUI", basicPackageName + "BasicInternalFrameUI",
+//              "DesktopPaneUI", basicPackageName + "BasicDesktopPaneUI",
+//              "DesktopIconUI", basicPackageName + "BasicDesktopIconUI",
+//              "FileChooserUI", basicPackageName + "BasicFileChooserUI",
+//               "OptionPaneUI", basicPackageName + "BasicOptionPaneUI",
+//                    "PanelUI", basicPackageName + "BasicPanelUI",
+//                 "ViewportUI", basicPackageName + "BasicViewportUI",
+//                 "RootPaneUI", basicPackageName + "BasicRootPaneUI",
+//        };
+//
+//        table.putDefaults(uiDefaults);
+//    }
 
     /**
      * Populates {@code table} with system colors. This creates an
@@ -320,38 +320,38 @@
      * @see #loadSystemColors
      */
     protected void initSystemColorDefaults(UIDefaults table)
-    {
-        String[] defaultSystemColors = {
-                "desktop", "#005C5C", /* Color of the desktop background */
-          "activeCaption", "#000080", /* Color for captions (title bars) when they are active. */
-      "activeCaptionText", "#FFFFFF", /* Text color for text in captions (title bars). */
-    "activeCaptionBorder", "#C0C0C0", /* Border color for caption (title bar) window borders. */
-        "inactiveCaption", "#808080", /* Color for captions (title bars) when not active. */
-    "inactiveCaptionText", "#C0C0C0", /* Text color for text in inactive captions (title bars). */
-  "inactiveCaptionBorder", "#C0C0C0", /* Border color for inactive caption (title bar) window borders. */
-                 "window", "#FFFFFF", /* Default color for the interior of windows */
-           "windowBorder", "#000000", /* ??? */
-             "windowText", "#000000", /* ??? */
-                   "menu", "#C0C0C0", /* Background color for menus */
-               "menuText", "#000000", /* Text color for menus  */
-                   "text", "#C0C0C0", /* Text background color */
-               "textText", "#000000", /* Text foreground color */
-          "textHighlight", "#000080", /* Text background color when selected */
-      "textHighlightText", "#FFFFFF", /* Text color when selected */
-       "textInactiveText", "#808080", /* Text color when disabled */
-                "control", "#C0C0C0", /* Default color for controls (buttons, sliders, etc) */
-            "controlText", "#000000", /* Default color for text in controls */
-       "controlHighlight", "#C0C0C0", /* Specular highlight (opposite of the shadow) */
-     "controlLtHighlight", "#FFFFFF", /* Highlight color for controls */
-          "controlShadow", "#808080", /* Shadow color for controls */
-        "controlDkShadow", "#000000", /* Dark shadow color for controls */
-              "scrollbar", "#E0E0E0", /* Scrollbar background (usually the "track") */
-                   "info", "#FFFFE1", /* ??? */
-               "infoText", "#000000"  /* ??? */
-        };
-
-        loadSystemColors(table, defaultSystemColors, isNativeLookAndFeel());
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        String[] defaultSystemColors = {
+//                "desktop", "#005C5C", /* Color of the desktop background */
+//          "activeCaption", "#000080", /* Color for captions (title bars) when they are active. */
+//      "activeCaptionText", "#FFFFFF", /* Text color for text in captions (title bars). */
+//    "activeCaptionBorder", "#C0C0C0", /* Border color for caption (title bar) window borders. */
+//        "inactiveCaption", "#808080", /* Color for captions (title bars) when not active. */
+//    "inactiveCaptionText", "#C0C0C0", /* Text color for text in inactive captions (title bars). */
+//  "inactiveCaptionBorder", "#C0C0C0", /* Border color for inactive caption (title bar) window borders. */
+//                 "window", "#FFFFFF", /* Default color for the interior of windows */
+//           "windowBorder", "#000000", /* ??? */
+//             "windowText", "#000000", /* ??? */
+//                   "menu", "#C0C0C0", /* Background color for menus */
+//               "menuText", "#000000", /* Text color for menus  */
+//                   "text", "#C0C0C0", /* Text background color */
+//               "textText", "#000000", /* Text foreground color */
+//          "textHighlight", "#000080", /* Text background color when selected */
+//      "textHighlightText", "#FFFFFF", /* Text color when selected */
+//       "textInactiveText", "#808080", /* Text color when disabled */
+//                "control", "#C0C0C0", /* Default color for controls (buttons, sliders, etc) */
+//            "controlText", "#000000", /* Default color for text in controls */
+//       "controlHighlight", "#C0C0C0", /* Specular highlight (opposite of the shadow) */
+//     "controlLtHighlight", "#FFFFFF", /* Highlight color for controls */
+//          "controlShadow", "#808080", /* Shadow color for controls */
+//        "controlDkShadow", "#000000", /* Dark shadow color for controls */
+//              "scrollbar", "#E0E0E0", /* Scrollbar background (usually the "track") */
+//                   "info", "#FFFFE1", /* ??? */
+//               "infoText", "#000000"  /* ??? */
+//        };
+//
+//        loadSystemColors(table, defaultSystemColors, isNativeLookAndFeel());
+//    }
 
 
     /**
@@ -400,34 +400,34 @@
      * @see java.awt.Color#decode(String)
      */
     protected void loadSystemColors(UIDefaults table, String[] systemColors, boolean useNative)
-    {
-        /* PENDING(hmuller) We don't load the system colors below because
-         * they're not reliable.  Hopefully we'll be able to do better in
-         * a future version of AWT.
-         */
-        if (useNative) {
-            for(int i = 0; i < systemColors.length; i += 2) {
-                Color color = Color.black;
-                try {
-                    String name = systemColors[i];
-                    color = (Color)(SystemColor.class.getField(name).get(null));
-                } catch (Exception e) {
-                }
-                table.put(systemColors[i], new ColorUIResource(color));
-            }
-        } else {
-            for(int i = 0; i < systemColors.length; i += 2) {
-                Color color = Color.black;
-                try {
-                    color = Color.decode(systemColors[i + 1]);
-                }
-                catch(NumberFormatException e) {
-                    e.printStackTrace();
-                }
-                table.put(systemColors[i], new ColorUIResource(color));
-            }
-        }
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        /* PENDING(hmuller) We don't load the system colors below because
+//         * they're not reliable.  Hopefully we'll be able to do better in
+//         * a future version of AWT.
+//         */
+//        if (useNative) {
+//            for(int i = 0; i < systemColors.length; i += 2) {
+//                Color color = Color.black;
+//                try {
+//                    String name = systemColors[i];
+//                    color = (Color)(SystemColor.class.getField(name).get(null));
+//                } catch (Exception e) {
+//                }
+//                table.put(systemColors[i], new ColorUIResource(color));
+//            }
+//        } else {
+//            for(int i = 0; i < systemColors.length; i += 2) {
+//                Color color = Color.black;
+//                try {
+//                    color = Color.decode(systemColors[i + 1]);
+//                }
+//                catch(NumberFormatException e) {
+//                    e.printStackTrace();
+//                }
+//                table.put(systemColors[i], new ColorUIResource(color));
+//            }
+//        }
+//    }
     /**
      * Initialize the defaults table with the name of the ResourceBundle
      * used for getting localized defaults.  Also initialize the default
@@ -435,10 +435,10 @@
      * default locale should generally not be relied upon. It is here for
      * compatibility with releases prior to 1.4.
      */
-    private void initResourceBundle(UIDefaults table) {
-        table.setDefaultLocale( Locale.getDefault() );
-        table.addResourceBundle( "com.sun.swing.internal.plaf.basic.resources.basic" );
-    }
+    private void initResourceBundle(UIDefaults table) {throw new RuntimeException("cf-bug");} //{
+//        table.setDefaultLocale( Locale.getDefault() );
+//        table.addResourceBundle( "com.sun.swing.internal.plaf.basic.resources.basic" );
+//    }
 
     /**
      * Populates {@code table} with the defaults for the basic look and
@@ -448,1479 +448,1479 @@
      * @throws NullPointerException if {@code table} is {@code null}
      */
     protected void initComponentDefaults(UIDefaults table)
-    {
-
-        initResourceBundle(table);
-
-        // *** Shared Integers
-        Integer fiveHundred = new Integer(500);
-
-        // *** Shared Longs
-        Long oneThousand = new Long(1000);
-
-        // *** Shared Fonts
-        Integer twelve = new Integer(12);
-        Integer fontPlain = new Integer(Font.PLAIN);
-        Integer fontBold = new Integer(Font.BOLD);
-        Object dialogPlain12 = new SwingLazyValue(
-                          "javax.swing.plaf.FontUIResource",
-                          null,
-                          new Object[] {Font.DIALOG, fontPlain, twelve});
-        Object serifPlain12 = new SwingLazyValue(
-                          "javax.swing.plaf.FontUIResource",
-                          null,
-                          new Object[] {Font.SERIF, fontPlain, twelve});
-        Object sansSerifPlain12 =  new SwingLazyValue(
-                          "javax.swing.plaf.FontUIResource",
-                          null,
-                          new Object[] {Font.SANS_SERIF, fontPlain, twelve});
-        Object monospacedPlain12 = new SwingLazyValue(
-                          "javax.swing.plaf.FontUIResource",
-                          null,
-                          new Object[] {Font.MONOSPACED, fontPlain, twelve});
-        Object dialogBold12 = new SwingLazyValue(
-                          "javax.swing.plaf.FontUIResource",
-                          null,
-                          new Object[] {Font.DIALOG, fontBold, twelve});
-
-
-        // *** Shared Colors
-        ColorUIResource red = new ColorUIResource(Color.red);
-        ColorUIResource black = new ColorUIResource(Color.black);
-        ColorUIResource white = new ColorUIResource(Color.white);
-        ColorUIResource yellow = new ColorUIResource(Color.yellow);
-        ColorUIResource gray = new ColorUIResource(Color.gray);
-        ColorUIResource lightGray = new ColorUIResource(Color.lightGray);
-        ColorUIResource darkGray = new ColorUIResource(Color.darkGray);
-        ColorUIResource scrollBarTrack = new ColorUIResource(224, 224, 224);
-
-        Color control = table.getColor("control");
-        Color controlDkShadow = table.getColor("controlDkShadow");
-        Color controlHighlight = table.getColor("controlHighlight");
-        Color controlLtHighlight = table.getColor("controlLtHighlight");
-        Color controlShadow = table.getColor("controlShadow");
-        Color controlText = table.getColor("controlText");
-        Color menu = table.getColor("menu");
-        Color menuText = table.getColor("menuText");
-        Color textHighlight = table.getColor("textHighlight");
-        Color textHighlightText = table.getColor("textHighlightText");
-        Color textInactiveText = table.getColor("textInactiveText");
-        Color textText = table.getColor("textText");
-        Color window = table.getColor("window");
-
-        // *** Shared Insets
-        InsetsUIResource zeroInsets = new InsetsUIResource(0,0,0,0);
-        InsetsUIResource twoInsets = new InsetsUIResource(2,2,2,2);
-        InsetsUIResource threeInsets = new InsetsUIResource(3,3,3,3);
-
-        // *** Shared Borders
-        Object marginBorder = new SwingLazyValue(
-                          "javax.swing.plaf.basic.BasicBorders$MarginBorder");
-        Object etchedBorder = new SwingLazyValue(
-                          "javax.swing.plaf.BorderUIResource",
-                          "getEtchedBorderUIResource");
-        Object loweredBevelBorder = new SwingLazyValue(
-                          "javax.swing.plaf.BorderUIResource",
-                          "getLoweredBevelBorderUIResource");
-
-        Object popupMenuBorder = new SwingLazyValue(
-                          "javax.swing.plaf.basic.BasicBorders",
-                          "getInternalFrameBorder");
-
-        Object blackLineBorder = new SwingLazyValue(
-                          "javax.swing.plaf.BorderUIResource",
-                          "getBlackLineBorderUIResource");
-        Object focusCellHighlightBorder = new SwingLazyValue(
-                          "javax.swing.plaf.BorderUIResource$LineBorderUIResource",
-                          null,
-                          new Object[] {yellow});
-
-        Object noFocusBorder = new BorderUIResource.EmptyBorderUIResource(1,1,1,1);
-
-        Object tableHeaderBorder = new SwingLazyValue(
-                          "javax.swing.plaf.BorderUIResource$BevelBorderUIResource",
-                          null,
-                          new Object[] { new Integer(BevelBorder.RAISED),
-                                         controlLtHighlight,
-                                         control,
-                                         controlDkShadow,
-                                         controlShadow });
-
-
-        // *** Button value objects
-
-        Object buttonBorder =
-            new SwingLazyValue(
-                            "javax.swing.plaf.basic.BasicBorders",
-                            "getButtonBorder");
-
-        Object buttonToggleBorder =
-            new SwingLazyValue(
-                            "javax.swing.plaf.basic.BasicBorders",
-                            "getToggleButtonBorder");
-
-        Object radioButtonBorder =
-            new SwingLazyValue(
-                            "javax.swing.plaf.basic.BasicBorders",
-                            "getRadioButtonBorder");
-
-        // *** FileChooser / FileView value objects
-
-        Object newFolderIcon = SwingUtilities2.makeIcon(getClass(),
-                                                        BasicLookAndFeel.class,
-                                                        "icons/NewFolder.gif");
-        Object upFolderIcon = SwingUtilities2.makeIcon(getClass(),
-                                                       BasicLookAndFeel.class,
-                                                       "icons/UpFolder.gif");
-        Object homeFolderIcon = SwingUtilities2.makeIcon(getClass(),
-                                                         BasicLookAndFeel.class,
-                                                         "icons/HomeFolder.gif");
-        Object detailsViewIcon = SwingUtilities2.makeIcon(getClass(),
-                                                          BasicLookAndFeel.class,
-                                                          "icons/DetailsView.gif");
-        Object listViewIcon = SwingUtilities2.makeIcon(getClass(),
-                                                       BasicLookAndFeel.class,
-                                                       "icons/ListView.gif");
-        Object directoryIcon = SwingUtilities2.makeIcon(getClass(),
-                                                        BasicLookAndFeel.class,
-                                                        "icons/Directory.gif");
-        Object fileIcon = SwingUtilities2.makeIcon(getClass(),
-                                                   BasicLookAndFeel.class,
-                                                   "icons/File.gif");
-        Object computerIcon = SwingUtilities2.makeIcon(getClass(),
-                                                       BasicLookAndFeel.class,
-                                                       "icons/Computer.gif");
-        Object hardDriveIcon = SwingUtilities2.makeIcon(getClass(),
-                                                        BasicLookAndFeel.class,
-                                                        "icons/HardDrive.gif");
-        Object floppyDriveIcon = SwingUtilities2.makeIcon(getClass(),
-                                                          BasicLookAndFeel.class,
-                                                          "icons/FloppyDrive.gif");
-
-
-        // *** InternalFrame value objects
-
-        Object internalFrameBorder = new SwingLazyValue(
-                "javax.swing.plaf.basic.BasicBorders",
-                "getInternalFrameBorder");
-
-        // *** List value objects
-
-        Object listCellRendererActiveValue = new UIDefaults.ActiveValue() {
-            public Object createValue(UIDefaults table) {
-                return new DefaultListCellRenderer.UIResource();
-            }
-        };
-
-
-        // *** Menus value objects
-
-        Object menuBarBorder =
-            new SwingLazyValue(
-                "javax.swing.plaf.basic.BasicBorders",
-                "getMenuBarBorder");
-
-        Object menuItemCheckIcon =
-            new SwingLazyValue(
-                "javax.swing.plaf.basic.BasicIconFactory",
-                "getMenuItemCheckIcon");
-
-        Object menuItemArrowIcon =
-            new SwingLazyValue(
-                "javax.swing.plaf.basic.BasicIconFactory",
-                "getMenuItemArrowIcon");
-
-
-        Object menuArrowIcon =
-            new SwingLazyValue(
-                "javax.swing.plaf.basic.BasicIconFactory",
-                "getMenuArrowIcon");
-
-        Object checkBoxIcon =
-            new SwingLazyValue(
-                "javax.swing.plaf.basic.BasicIconFactory",
-                "getCheckBoxIcon");
-
-        Object radioButtonIcon =
-            new SwingLazyValue(
-                "javax.swing.plaf.basic.BasicIconFactory",
-                "getRadioButtonIcon");
-
-        Object checkBoxMenuItemIcon =
-            new SwingLazyValue(
-                "javax.swing.plaf.basic.BasicIconFactory",
-                "getCheckBoxMenuItemIcon");
-
-        Object radioButtonMenuItemIcon =
-            new SwingLazyValue(
-                "javax.swing.plaf.basic.BasicIconFactory",
-                "getRadioButtonMenuItemIcon");
-
-        Object menuItemAcceleratorDelimiter = "+";
-
-        // *** OptionPane value objects
-
-        Object optionPaneMinimumSize = new DimensionUIResource(262, 90);
-
-        Integer zero =  new Integer(0);
-        Object zeroBorder = new SwingLazyValue(
-                           "javax.swing.plaf.BorderUIResource$EmptyBorderUIResource",
-                           new Object[] {zero, zero, zero, zero});
-
-        Integer ten = new Integer(10);
-        Object optionPaneBorder = new SwingLazyValue(
-                           "javax.swing.plaf.BorderUIResource$EmptyBorderUIResource",
-                           new Object[] {ten, ten, twelve, ten});
-
-        Object optionPaneButtonAreaBorder = new SwingLazyValue(
-                           "javax.swing.plaf.BorderUIResource$EmptyBorderUIResource",
-                           new Object[] {new Integer(6), zero, zero, zero});
-
-
-        // *** ProgessBar value objects
-
-        Object progressBarBorder =
-            new SwingLazyValue(
-                            "javax.swing.plaf.basic.BasicBorders",
-                            "getProgressBarBorder");
-
-        // ** ScrollBar value objects
-
-        Object minimumThumbSize = new DimensionUIResource(8,8);
-        Object maximumThumbSize = new DimensionUIResource(4096,4096);
-
-        // ** Slider value objects
-
-        Object sliderFocusInsets = twoInsets;
-
-        Object toolBarSeparatorSize = new DimensionUIResource( 10, 10 );
-
-
-        // *** SplitPane value objects
-
-        Object splitPaneBorder =
-            new SwingLazyValue(
-                            "javax.swing.plaf.basic.BasicBorders",
-                            "getSplitPaneBorder");
-        Object splitPaneDividerBorder =
-            new SwingLazyValue(
-                            "javax.swing.plaf.basic.BasicBorders",
-                            "getSplitPaneDividerBorder");
-
-        // ** TabbedBane value objects
-
-        Object tabbedPaneTabInsets = new InsetsUIResource(0, 4, 1, 4);
-
-        Object tabbedPaneTabPadInsets = new InsetsUIResource(2, 2, 2, 1);
-
-        Object tabbedPaneTabAreaInsets = new InsetsUIResource(3, 2, 0, 2);
-
-        Object tabbedPaneContentBorderInsets = new InsetsUIResource(2, 2, 3, 3);
-
-
-        // *** Text value objects
-
-        Object textFieldBorder =
-            new SwingLazyValue(
-                            "javax.swing.plaf.basic.BasicBorders",
-                            "getTextFieldBorder");
-
-        Object editorMargin = threeInsets;
-
-        Object caretBlinkRate = fiveHundred;
-        Integer four = new Integer(4);
-
-        Object[] allAuditoryCues = new Object[] {
-                "CheckBoxMenuItem.commandSound",
-                "InternalFrame.closeSound",
-                "InternalFrame.maximizeSound",
-                "InternalFrame.minimizeSound",
-                "InternalFrame.restoreDownSound",
-                "InternalFrame.restoreUpSound",
-                "MenuItem.commandSound",
-                "OptionPane.errorSound",
-                "OptionPane.informationSound",
-                "OptionPane.questionSound",
-                "OptionPane.warningSound",
-                "PopupMenu.popupSound",
-                "RadioButtonMenuItem.commandSound"};
-
-        Object[] noAuditoryCues = new Object[] {"mute"};
-
-        // *** Component Defaults
-
-        Object[] defaults = {
-            // *** Auditory Feedback
-            "AuditoryCues.cueList", allAuditoryCues,
-            "AuditoryCues.allAuditoryCues", allAuditoryCues,
-            "AuditoryCues.noAuditoryCues", noAuditoryCues,
-            // this key defines which of the various cues to render.
-            // L&Fs that want auditory feedback NEED to override playList.
-            "AuditoryCues.playList", null,
-
-            // *** Buttons
-            "Button.defaultButtonFollowsFocus", Boolean.TRUE,
-            "Button.font", dialogPlain12,
-            "Button.background", control,
-            "Button.foreground", controlText,
-            "Button.shadow", controlShadow,
-            "Button.darkShadow", controlDkShadow,
-            "Button.light", controlHighlight,
-            "Button.highlight", controlLtHighlight,
-            "Button.border", buttonBorder,
-            "Button.margin", new InsetsUIResource(2, 14, 2, 14),
-            "Button.textIconGap", four,
-            "Button.textShiftOffset", zero,
-            "Button.focusInputMap", new UIDefaults.LazyInputMap(new Object[] {
-                         "SPACE", "pressed",
-                "released SPACE", "released",
-                         "ENTER", "pressed",
-                "released ENTER", "released"
-              }),
-
-            "ToggleButton.font", dialogPlain12,
-            "ToggleButton.background", control,
-            "ToggleButton.foreground", controlText,
-            "ToggleButton.shadow", controlShadow,
-            "ToggleButton.darkShadow", controlDkShadow,
-            "ToggleButton.light", controlHighlight,
-            "ToggleButton.highlight", controlLtHighlight,
-            "ToggleButton.border", buttonToggleBorder,
-            "ToggleButton.margin", new InsetsUIResource(2, 14, 2, 14),
-            "ToggleButton.textIconGap", four,
-            "ToggleButton.textShiftOffset", zero,
-            "ToggleButton.focusInputMap",
-              new UIDefaults.LazyInputMap(new Object[] {
-                            "SPACE", "pressed",
-                   "released SPACE", "released"
-                }),
-
-            "RadioButton.font", dialogPlain12,
-            "RadioButton.background", control,
-            "RadioButton.foreground", controlText,
-            "RadioButton.shadow", controlShadow,
-            "RadioButton.darkShadow", controlDkShadow,
-            "RadioButton.light", controlHighlight,
-            "RadioButton.highlight", controlLtHighlight,
-            "RadioButton.border", radioButtonBorder,
-            "RadioButton.margin", twoInsets,
-            "RadioButton.textIconGap", four,
-            "RadioButton.textShiftOffset", zero,
-            "RadioButton.icon", radioButtonIcon,
-            "RadioButton.focusInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                          "SPACE", "pressed",
-                 "released SPACE", "released",
-                         "RETURN", "pressed"
-              }),
-
-            "CheckBox.font", dialogPlain12,
-            "CheckBox.background", control,
-            "CheckBox.foreground", controlText,
-            "CheckBox.border", radioButtonBorder,
-            "CheckBox.margin", twoInsets,
-            "CheckBox.textIconGap", four,
-            "CheckBox.textShiftOffset", zero,
-            "CheckBox.icon", checkBoxIcon,
-            "CheckBox.focusInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                            "SPACE", "pressed",
-                   "released SPACE", "released"
-                 }),
-            "FileChooser.useSystemExtensionHiding", Boolean.FALSE,
-
-            // *** ColorChooser
-            "ColorChooser.font", dialogPlain12,
-            "ColorChooser.background", control,
-            "ColorChooser.foreground", controlText,
-
-            "ColorChooser.swatchesSwatchSize", new Dimension(10, 10),
-            "ColorChooser.swatchesRecentSwatchSize", new Dimension(10, 10),
-            "ColorChooser.swatchesDefaultRecentColor", control,
-
-            // *** ComboBox
-            "ComboBox.font", sansSerifPlain12,
-            "ComboBox.background", window,
-            "ComboBox.foreground", textText,
-            "ComboBox.buttonBackground", control,
-            "ComboBox.buttonShadow", controlShadow,
-            "ComboBox.buttonDarkShadow", controlDkShadow,
-            "ComboBox.buttonHighlight", controlLtHighlight,
-            "ComboBox.selectionBackground", textHighlight,
-            "ComboBox.selectionForeground", textHighlightText,
-            "ComboBox.disabledBackground", control,
-            "ComboBox.disabledForeground", textInactiveText,
-            "ComboBox.timeFactor", oneThousand,
-            "ComboBox.isEnterSelectablePopup", Boolean.FALSE,
-            "ComboBox.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                      "ESCAPE", "hidePopup",
-                     "PAGE_UP", "pageUpPassThrough",
-                   "PAGE_DOWN", "pageDownPassThrough",
-                        "HOME", "homePassThrough",
-                         "END", "endPassThrough",
-                       "ENTER", "enterPressed"
-                 }),
-            "ComboBox.noActionOnKeyNavigation", Boolean.FALSE,
-
-            // *** FileChooser
-
-            "FileChooser.newFolderIcon", newFolderIcon,
-            "FileChooser.upFolderIcon", upFolderIcon,
-            "FileChooser.homeFolderIcon", homeFolderIcon,
-            "FileChooser.detailsViewIcon", detailsViewIcon,
-            "FileChooser.listViewIcon", listViewIcon,
-            "FileChooser.readOnly", Boolean.FALSE,
-            "FileChooser.usesSingleFilePane", Boolean.FALSE,
-            "FileChooser.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                     "ESCAPE", "cancelSelection",
-                     "F5", "refresh",
-                 }),
-
-            "FileView.directoryIcon", directoryIcon,
-            "FileView.fileIcon", fileIcon,
-            "FileView.computerIcon", computerIcon,
-            "FileView.hardDriveIcon", hardDriveIcon,
-            "FileView.floppyDriveIcon", floppyDriveIcon,
-
-            // *** InternalFrame
-            "InternalFrame.titleFont", dialogBold12,
-            "InternalFrame.borderColor", control,
-            "InternalFrame.borderShadow", controlShadow,
-            "InternalFrame.borderDarkShadow", controlDkShadow,
-            "InternalFrame.borderHighlight", controlLtHighlight,
-            "InternalFrame.borderLight", controlHighlight,
-            "InternalFrame.border", internalFrameBorder,
-            "InternalFrame.icon",   SwingUtilities2.makeIcon(getClass(),
-                                                             BasicLookAndFeel.class,
-                                                             "icons/JavaCup16.png"),
-
-            /* Default frame icons are undefined for Basic. */
-            "InternalFrame.maximizeIcon",
-            new SwingLazyValue(
-                           "javax.swing.plaf.basic.BasicIconFactory",
-                           "createEmptyFrameIcon"),
-            "InternalFrame.minimizeIcon",
-            new SwingLazyValue(
-                           "javax.swing.plaf.basic.BasicIconFactory",
-                           "createEmptyFrameIcon"),
-            "InternalFrame.iconifyIcon",
-            new SwingLazyValue(
-                           "javax.swing.plaf.basic.BasicIconFactory",
-                           "createEmptyFrameIcon"),
-            "InternalFrame.closeIcon",
-            new SwingLazyValue(
-                           "javax.swing.plaf.basic.BasicIconFactory",
-                           "createEmptyFrameIcon"),
-            // InternalFrame Auditory Cue Mappings
-            "InternalFrame.closeSound", null,
-            "InternalFrame.maximizeSound", null,
-            "InternalFrame.minimizeSound", null,
-            "InternalFrame.restoreDownSound", null,
-            "InternalFrame.restoreUpSound", null,
-
-            "InternalFrame.activeTitleBackground", table.get("activeCaption"),
-            "InternalFrame.activeTitleForeground", table.get("activeCaptionText"),
-            "InternalFrame.inactiveTitleBackground", table.get("inactiveCaption"),
-            "InternalFrame.inactiveTitleForeground", table.get("inactiveCaptionText"),
-            "InternalFrame.windowBindings", new Object[] {
-              "shift ESCAPE", "showSystemMenu",
-                "ctrl SPACE", "showSystemMenu",
-                    "ESCAPE", "hideSystemMenu"},
-
-            "InternalFrameTitlePane.iconifyButtonOpacity", Boolean.TRUE,
-            "InternalFrameTitlePane.maximizeButtonOpacity", Boolean.TRUE,
-            "InternalFrameTitlePane.closeButtonOpacity", Boolean.TRUE,
-
-        "DesktopIcon.border", internalFrameBorder,
-
-            "Desktop.minOnScreenInsets", threeInsets,
-            "Desktop.background", table.get("desktop"),
-            "Desktop.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                 "ctrl F5", "restore",
-                 "ctrl F4", "close",
-                 "ctrl F7", "move",
-                 "ctrl F8", "resize",
-                   "RIGHT", "right",
-                "KP_RIGHT", "right",
-             "shift RIGHT", "shrinkRight",
-          "shift KP_RIGHT", "shrinkRight",
-                    "LEFT", "left",
-                 "KP_LEFT", "left",
-              "shift LEFT", "shrinkLeft",
-           "shift KP_LEFT", "shrinkLeft",
-                      "UP", "up",
-                   "KP_UP", "up",
-                "shift UP", "shrinkUp",
-             "shift KP_UP", "shrinkUp",
-                    "DOWN", "down",
-                 "KP_DOWN", "down",
-              "shift DOWN", "shrinkDown",
-           "shift KP_DOWN", "shrinkDown",
-                  "ESCAPE", "escape",
-                 "ctrl F9", "minimize",
-                "ctrl F10", "maximize",
-                 "ctrl F6", "selectNextFrame",
-                "ctrl TAB", "selectNextFrame",
-             "ctrl alt F6", "selectNextFrame",
-       "shift ctrl alt F6", "selectPreviousFrame",
-                "ctrl F12", "navigateNext",
-          "shift ctrl F12", "navigatePrevious"
-              }),
-
-            // *** Label
-            "Label.font", dialogPlain12,
-            "Label.background", control,
-            "Label.foreground", controlText,
-            "Label.disabledForeground", white,
-            "Label.disabledShadow", controlShadow,
-            "Label.border", null,
-
-            // *** List
-            "List.font", dialogPlain12,
-            "List.background", window,
-            "List.foreground", textText,
-            "List.selectionBackground", textHighlight,
-            "List.selectionForeground", textHighlightText,
-            "List.noFocusBorder", noFocusBorder,
-            "List.focusCellHighlightBorder", focusCellHighlightBorder,
-            "List.dropLineColor", controlShadow,
-            "List.border", null,
-            "List.cellRenderer", listCellRendererActiveValue,
-            "List.timeFactor", oneThousand,
-            "List.focusInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                           "ctrl C", "copy",
-                           "ctrl V", "paste",
-                           "ctrl X", "cut",
-                             "COPY", "copy",
-                            "PASTE", "paste",
-                              "CUT", "cut",
-                   "control INSERT", "copy",
-                     "shift INSERT", "paste",
-                     "shift DELETE", "cut",
-                               "UP", "selectPreviousRow",
-                            "KP_UP", "selectPreviousRow",
-                         "shift UP", "selectPreviousRowExtendSelection",
-                      "shift KP_UP", "selectPreviousRowExtendSelection",
-                    "ctrl shift UP", "selectPreviousRowExtendSelection",
-                 "ctrl shift KP_UP", "selectPreviousRowExtendSelection",
-                          "ctrl UP", "selectPreviousRowChangeLead",
-                       "ctrl KP_UP", "selectPreviousRowChangeLead",
-                             "DOWN", "selectNextRow",
-                          "KP_DOWN", "selectNextRow",
-                       "shift DOWN", "selectNextRowExtendSelection",
-                    "shift KP_DOWN", "selectNextRowExtendSelection",
-                  "ctrl shift DOWN", "selectNextRowExtendSelection",
-               "ctrl shift KP_DOWN", "selectNextRowExtendSelection",
-                        "ctrl DOWN", "selectNextRowChangeLead",
-                     "ctrl KP_DOWN", "selectNextRowChangeLead",
-                             "LEFT", "selectPreviousColumn",
-                          "KP_LEFT", "selectPreviousColumn",
-                       "shift LEFT", "selectPreviousColumnExtendSelection",
-                    "shift KP_LEFT", "selectPreviousColumnExtendSelection",
-                  "ctrl shift LEFT", "selectPreviousColumnExtendSelection",
-               "ctrl shift KP_LEFT", "selectPreviousColumnExtendSelection",
-                        "ctrl LEFT", "selectPreviousColumnChangeLead",
-                     "ctrl KP_LEFT", "selectPreviousColumnChangeLead",
-                            "RIGHT", "selectNextColumn",
-                         "KP_RIGHT", "selectNextColumn",
-                      "shift RIGHT", "selectNextColumnExtendSelection",
-                   "shift KP_RIGHT", "selectNextColumnExtendSelection",
-                 "ctrl shift RIGHT", "selectNextColumnExtendSelection",
-              "ctrl shift KP_RIGHT", "selectNextColumnExtendSelection",
-                       "ctrl RIGHT", "selectNextColumnChangeLead",
-                    "ctrl KP_RIGHT", "selectNextColumnChangeLead",
-                             "HOME", "selectFirstRow",
-                       "shift HOME", "selectFirstRowExtendSelection",
-                  "ctrl shift HOME", "selectFirstRowExtendSelection",
-                        "ctrl HOME", "selectFirstRowChangeLead",
-                              "END", "selectLastRow",
-                        "shift END", "selectLastRowExtendSelection",
-                   "ctrl shift END", "selectLastRowExtendSelection",
-                         "ctrl END", "selectLastRowChangeLead",
-                          "PAGE_UP", "scrollUp",
-                    "shift PAGE_UP", "scrollUpExtendSelection",
-               "ctrl shift PAGE_UP", "scrollUpExtendSelection",
-                     "ctrl PAGE_UP", "scrollUpChangeLead",
-                        "PAGE_DOWN", "scrollDown",
-                  "shift PAGE_DOWN", "scrollDownExtendSelection",
-             "ctrl shift PAGE_DOWN", "scrollDownExtendSelection",
-                   "ctrl PAGE_DOWN", "scrollDownChangeLead",
-                           "ctrl A", "selectAll",
-                       "ctrl SLASH", "selectAll",
-                  "ctrl BACK_SLASH", "clearSelection",
-                            "SPACE", "addToSelection",
-                       "ctrl SPACE", "toggleAndAnchor",
-                      "shift SPACE", "extendTo",
-                 "ctrl shift SPACE", "moveSelectionTo"
-                 }),
-            "List.focusInputMap.RightToLeft",
-               new UIDefaults.LazyInputMap(new Object[] {
-                             "LEFT", "selectNextColumn",
-                          "KP_LEFT", "selectNextColumn",
-                       "shift LEFT", "selectNextColumnExtendSelection",
-                    "shift KP_LEFT", "selectNextColumnExtendSelection",
-                  "ctrl shift LEFT", "selectNextColumnExtendSelection",
-               "ctrl shift KP_LEFT", "selectNextColumnExtendSelection",
-                        "ctrl LEFT", "selectNextColumnChangeLead",
-                     "ctrl KP_LEFT", "selectNextColumnChangeLead",
-                            "RIGHT", "selectPreviousColumn",
-                         "KP_RIGHT", "selectPreviousColumn",
-                      "shift RIGHT", "selectPreviousColumnExtendSelection",
-                   "shift KP_RIGHT", "selectPreviousColumnExtendSelection",
-                 "ctrl shift RIGHT", "selectPreviousColumnExtendSelection",
-              "ctrl shift KP_RIGHT", "selectPreviousColumnExtendSelection",
-                       "ctrl RIGHT", "selectPreviousColumnChangeLead",
-                    "ctrl KP_RIGHT", "selectPreviousColumnChangeLead",
-                 }),
-
-            // *** Menus
-            "MenuBar.font", dialogPlain12,
-            "MenuBar.background", menu,
-            "MenuBar.foreground", menuText,
-            "MenuBar.shadow", controlShadow,
-            "MenuBar.highlight", controlLtHighlight,
-            "MenuBar.border", menuBarBorder,
-            "MenuBar.windowBindings", new Object[] {
-                "F10", "takeFocus" },
-
-            "MenuItem.font", dialogPlain12,
-            "MenuItem.acceleratorFont", dialogPlain12,
-            "MenuItem.background", menu,
-            "MenuItem.foreground", menuText,
-            "MenuItem.selectionForeground", textHighlightText,
-            "MenuItem.selectionBackground", textHighlight,
-            "MenuItem.disabledForeground", null,
-            "MenuItem.acceleratorForeground", menuText,
-            "MenuItem.acceleratorSelectionForeground", textHighlightText,
-            "MenuItem.acceleratorDelimiter", menuItemAcceleratorDelimiter,
-            "MenuItem.border", marginBorder,
-            "MenuItem.borderPainted", Boolean.FALSE,
-            "MenuItem.margin", twoInsets,
-            "MenuItem.checkIcon", menuItemCheckIcon,
-            "MenuItem.arrowIcon", menuItemArrowIcon,
-            "MenuItem.commandSound", null,
-
-            "RadioButtonMenuItem.font", dialogPlain12,
-            "RadioButtonMenuItem.acceleratorFont", dialogPlain12,
-            "RadioButtonMenuItem.background", menu,
-            "RadioButtonMenuItem.foreground", menuText,
-            "RadioButtonMenuItem.selectionForeground", textHighlightText,
-            "RadioButtonMenuItem.selectionBackground", textHighlight,
-            "RadioButtonMenuItem.disabledForeground", null,
-            "RadioButtonMenuItem.acceleratorForeground", menuText,
-            "RadioButtonMenuItem.acceleratorSelectionForeground", textHighlightText,
-            "RadioButtonMenuItem.border", marginBorder,
-            "RadioButtonMenuItem.borderPainted", Boolean.FALSE,
-            "RadioButtonMenuItem.margin", twoInsets,
-            "RadioButtonMenuItem.checkIcon", radioButtonMenuItemIcon,
-            "RadioButtonMenuItem.arrowIcon", menuItemArrowIcon,
-            "RadioButtonMenuItem.commandSound", null,
-
-            "CheckBoxMenuItem.font", dialogPlain12,
-            "CheckBoxMenuItem.acceleratorFont", dialogPlain12,
-            "CheckBoxMenuItem.background", menu,
-            "CheckBoxMenuItem.foreground", menuText,
-            "CheckBoxMenuItem.selectionForeground", textHighlightText,
-            "CheckBoxMenuItem.selectionBackground", textHighlight,
-            "CheckBoxMenuItem.disabledForeground", null,
-            "CheckBoxMenuItem.acceleratorForeground", menuText,
-            "CheckBoxMenuItem.acceleratorSelectionForeground", textHighlightText,
-            "CheckBoxMenuItem.border", marginBorder,
-            "CheckBoxMenuItem.borderPainted", Boolean.FALSE,
-            "CheckBoxMenuItem.margin", twoInsets,
-            "CheckBoxMenuItem.checkIcon", checkBoxMenuItemIcon,
-            "CheckBoxMenuItem.arrowIcon", menuItemArrowIcon,
-            "CheckBoxMenuItem.commandSound", null,
-
-            "Menu.font", dialogPlain12,
-            "Menu.acceleratorFont", dialogPlain12,
-            "Menu.background", menu,
-            "Menu.foreground", menuText,
-            "Menu.selectionForeground", textHighlightText,
-            "Menu.selectionBackground", textHighlight,
-            "Menu.disabledForeground", null,
-            "Menu.acceleratorForeground", menuText,
-            "Menu.acceleratorSelectionForeground", textHighlightText,
-            "Menu.border", marginBorder,
-            "Menu.borderPainted", Boolean.FALSE,
-            "Menu.margin", twoInsets,
-            "Menu.checkIcon", menuItemCheckIcon,
-            "Menu.arrowIcon", menuArrowIcon,
-            "Menu.menuPopupOffsetX", new Integer(0),
-            "Menu.menuPopupOffsetY", new Integer(0),
-            "Menu.submenuPopupOffsetX", new Integer(0),
-            "Menu.submenuPopupOffsetY", new Integer(0),
-            "Menu.shortcutKeys", new int[]{
-                SwingUtilities2.getSystemMnemonicKeyMask()
-            },
-            "Menu.crossMenuMnemonic", Boolean.TRUE,
-            // Menu.cancelMode affects the cancel menu action behaviour;
-            // currently supports:
-            // "hideLastSubmenu" (default)
-            //     hides the last open submenu,
-            //     and move selection one step back
-            // "hideMenuTree"
-            //     resets selection and
-            //     hide the entire structure of open menu and its submenus
-            "Menu.cancelMode", "hideLastSubmenu",
-
-             // Menu.preserveTopLevelSelection affects
-             // the cancel menu action behaviour
-             // if set to true then top level menu selection
-             // will be preserved when the last popup was cancelled;
-             // the menu itself will be unselect with the next cancel action
-             "Menu.preserveTopLevelSelection", Boolean.FALSE,
-
-            // PopupMenu
-            "PopupMenu.font", dialogPlain12,
-            "PopupMenu.background", menu,
-            "PopupMenu.foreground", menuText,
-            "PopupMenu.border", popupMenuBorder,
-                 // Internal Frame Auditory Cue Mappings
-            "PopupMenu.popupSound", null,
-            // These window InputMap bindings are used when the Menu is
-            // selected.
-            "PopupMenu.selectedWindowInputMapBindings", new Object[] {
-                  "ESCAPE", "cancel",
-                    "DOWN", "selectNext",
-                 "KP_DOWN", "selectNext",
-                      "UP", "selectPrevious",
-                   "KP_UP", "selectPrevious",
-                    "LEFT", "selectParent",
-                 "KP_LEFT", "selectParent",
-                   "RIGHT", "selectChild",
-                "KP_RIGHT", "selectChild",
-                   "ENTER", "return",
-              "ctrl ENTER", "return",
-                   "SPACE", "return"
-            },
-            "PopupMenu.selectedWindowInputMapBindings.RightToLeft", new Object[] {
-                    "LEFT", "selectChild",
-                 "KP_LEFT", "selectChild",
-                   "RIGHT", "selectParent",
-                "KP_RIGHT", "selectParent",
-            },
-            "PopupMenu.consumeEventOnClose", Boolean.FALSE,
-
-            // *** OptionPane
-            // You can additionaly define OptionPane.messageFont which will
-            // dictate the fonts used for the message, and
-            // OptionPane.buttonFont, which defines the font for the buttons.
-            "OptionPane.font", dialogPlain12,
-            "OptionPane.background", control,
-            "OptionPane.foreground", controlText,
-            "OptionPane.messageForeground", controlText,
-            "OptionPane.border", optionPaneBorder,
-            "OptionPane.messageAreaBorder", zeroBorder,
-            "OptionPane.buttonAreaBorder", optionPaneButtonAreaBorder,
-            "OptionPane.minimumSize", optionPaneMinimumSize,
-            "OptionPane.errorIcon", SwingUtilities2.makeIcon(getClass(),
-                                                             BasicLookAndFeel.class,
-                                                             "icons/Error.gif"),
-            "OptionPane.informationIcon", SwingUtilities2.makeIcon(getClass(),
-                                                                   BasicLookAndFeel.class,
-                                                                   "icons/Inform.gif"),
-            "OptionPane.warningIcon", SwingUtilities2.makeIcon(getClass(),
-                                                               BasicLookAndFeel.class,
-                                                               "icons/Warn.gif"),
-            "OptionPane.questionIcon", SwingUtilities2.makeIcon(getClass(),
-                                                                BasicLookAndFeel.class,
-                                                                "icons/Question.gif"),
-            "OptionPane.windowBindings", new Object[] {
-                "ESCAPE", "close" },
-                 // OptionPane Auditory Cue Mappings
-            "OptionPane.errorSound", null,
-            "OptionPane.informationSound", null, // Info and Plain
-            "OptionPane.questionSound", null,
-            "OptionPane.warningSound", null,
-            "OptionPane.buttonClickThreshhold", fiveHundred,
-
-            // *** Panel
-            "Panel.font", dialogPlain12,
-            "Panel.background", control,
-            "Panel.foreground", textText,
-
-            // *** ProgressBar
-            "ProgressBar.font", dialogPlain12,
-            "ProgressBar.foreground",  textHighlight,
-            "ProgressBar.background", control,
-            "ProgressBar.selectionForeground", control,
-            "ProgressBar.selectionBackground", textHighlight,
-            "ProgressBar.border", progressBarBorder,
-            "ProgressBar.cellLength", new Integer(1),
-            "ProgressBar.cellSpacing", zero,
-            "ProgressBar.repaintInterval", new Integer(50),
-            "ProgressBar.cycleTime", new Integer(3000),
-            "ProgressBar.horizontalSize", new DimensionUIResource(146, 12),
-            "ProgressBar.verticalSize", new DimensionUIResource(12, 146),
-
-           // *** Separator
-            "Separator.shadow", controlShadow,          // DEPRECATED - DO NOT USE!
-            "Separator.highlight", controlLtHighlight,  // DEPRECATED - DO NOT USE!
-
-            "Separator.background", controlLtHighlight,
-            "Separator.foreground", controlShadow,
-
-            // *** ScrollBar/ScrollPane/Viewport
-            "ScrollBar.background", scrollBarTrack,
-            "ScrollBar.foreground", control,
-            "ScrollBar.track", table.get("scrollbar"),
-            "ScrollBar.trackHighlight", controlDkShadow,
-            "ScrollBar.thumb", control,
-            "ScrollBar.thumbHighlight", controlLtHighlight,
-            "ScrollBar.thumbDarkShadow", controlDkShadow,
-            "ScrollBar.thumbShadow", controlShadow,
-            "ScrollBar.border", null,
-            "ScrollBar.minimumThumbSize", minimumThumbSize,
-            "ScrollBar.maximumThumbSize", maximumThumbSize,
-            "ScrollBar.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                       "RIGHT", "positiveUnitIncrement",
-                    "KP_RIGHT", "positiveUnitIncrement",
-                        "DOWN", "positiveUnitIncrement",
-                     "KP_DOWN", "positiveUnitIncrement",
-                   "PAGE_DOWN", "positiveBlockIncrement",
-                        "LEFT", "negativeUnitIncrement",
-                     "KP_LEFT", "negativeUnitIncrement",
-                          "UP", "negativeUnitIncrement",
-                       "KP_UP", "negativeUnitIncrement",
-                     "PAGE_UP", "negativeBlockIncrement",
-                        "HOME", "minScroll",
-                         "END", "maxScroll"
-                 }),
-            "ScrollBar.ancestorInputMap.RightToLeft",
-               new UIDefaults.LazyInputMap(new Object[] {
-                       "RIGHT", "negativeUnitIncrement",
-                    "KP_RIGHT", "negativeUnitIncrement",
-                        "LEFT", "positiveUnitIncrement",
-                     "KP_LEFT", "positiveUnitIncrement",
-                 }),
-            "ScrollBar.width", new Integer(16),
-
-            "ScrollPane.font", dialogPlain12,
-            "ScrollPane.background", control,
-            "ScrollPane.foreground", controlText,
-            "ScrollPane.border", textFieldBorder,
-            "ScrollPane.viewportBorder", null,
-            "ScrollPane.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                           "RIGHT", "unitScrollRight",
-                        "KP_RIGHT", "unitScrollRight",
-                            "DOWN", "unitScrollDown",
-                         "KP_DOWN", "unitScrollDown",
-                            "LEFT", "unitScrollLeft",
-                         "KP_LEFT", "unitScrollLeft",
-                              "UP", "unitScrollUp",
-                           "KP_UP", "unitScrollUp",
-                         "PAGE_UP", "scrollUp",
-                       "PAGE_DOWN", "scrollDown",
-                    "ctrl PAGE_UP", "scrollLeft",
-                  "ctrl PAGE_DOWN", "scrollRight",
-                       "ctrl HOME", "scrollHome",
-                        "ctrl END", "scrollEnd"
-                 }),
-            "ScrollPane.ancestorInputMap.RightToLeft",
-               new UIDefaults.LazyInputMap(new Object[] {
-                    "ctrl PAGE_UP", "scrollRight",
-                  "ctrl PAGE_DOWN", "scrollLeft",
-                 }),
-
-            "Viewport.font", dialogPlain12,
-            "Viewport.background", control,
-            "Viewport.foreground", textText,
-
-            // *** Slider
-            "Slider.font", dialogPlain12,
-            "Slider.foreground", control,
-            "Slider.background", control,
-            "Slider.highlight", controlLtHighlight,
-            "Slider.tickColor", Color.black,
-            "Slider.shadow", controlShadow,
-            "Slider.focus", controlDkShadow,
-            "Slider.border", null,
-            "Slider.horizontalSize", new Dimension(200, 21),
-            "Slider.verticalSize", new Dimension(21, 200),
-            "Slider.minimumHorizontalSize", new Dimension(36, 21),
-            "Slider.minimumVerticalSize", new Dimension(21, 36),
-            "Slider.focusInsets", sliderFocusInsets,
-            "Slider.focusInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                       "RIGHT", "positiveUnitIncrement",
-                    "KP_RIGHT", "positiveUnitIncrement",
-                        "DOWN", "negativeUnitIncrement",
-                     "KP_DOWN", "negativeUnitIncrement",
-                   "PAGE_DOWN", "negativeBlockIncrement",
-                        "LEFT", "negativeUnitIncrement",
-                     "KP_LEFT", "negativeUnitIncrement",
-                          "UP", "positiveUnitIncrement",
-                       "KP_UP", "positiveUnitIncrement",
-                     "PAGE_UP", "positiveBlockIncrement",
-                        "HOME", "minScroll",
-                         "END", "maxScroll"
-                 }),
-            "Slider.focusInputMap.RightToLeft",
-               new UIDefaults.LazyInputMap(new Object[] {
-                       "RIGHT", "negativeUnitIncrement",
-                    "KP_RIGHT", "negativeUnitIncrement",
-                        "LEFT", "positiveUnitIncrement",
-                     "KP_LEFT", "positiveUnitIncrement",
-                 }),
-            "Slider.onlyLeftMouseButtonDrag", Boolean.TRUE,
-
-            // *** Spinner
-            "Spinner.font", monospacedPlain12,
-            "Spinner.background", control,
-            "Spinner.foreground", control,
-            "Spinner.border", textFieldBorder,
-            "Spinner.arrowButtonBorder", null,
-            "Spinner.arrowButtonInsets", null,
-            "Spinner.arrowButtonSize", new Dimension(16, 5),
-            "Spinner.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                               "UP", "increment",
-                            "KP_UP", "increment",
-                             "DOWN", "decrement",
-                          "KP_DOWN", "decrement",
-               }),
-            "Spinner.editorBorderPainted", Boolean.FALSE,
-            "Spinner.editorAlignment", JTextField.TRAILING,
-
-            // *** SplitPane
-            "SplitPane.background", control,
-            "SplitPane.highlight", controlLtHighlight,
-            "SplitPane.shadow", controlShadow,
-            "SplitPane.darkShadow", controlDkShadow,
-            "SplitPane.border", splitPaneBorder,
-            "SplitPane.dividerSize", new Integer(7),
-            "SplitPaneDivider.border", splitPaneDividerBorder,
-            "SplitPaneDivider.draggingColor", darkGray,
-            "SplitPane.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                        "UP", "negativeIncrement",
-                      "DOWN", "positiveIncrement",
-                      "LEFT", "negativeIncrement",
-                     "RIGHT", "positiveIncrement",
-                     "KP_UP", "negativeIncrement",
-                   "KP_DOWN", "positiveIncrement",
-                   "KP_LEFT", "negativeIncrement",
-                  "KP_RIGHT", "positiveIncrement",
-                      "HOME", "selectMin",
-                       "END", "selectMax",
-                        "F8", "startResize",
-                        "F6", "toggleFocus",
-                  "ctrl TAB", "focusOutForward",
-            "ctrl shift TAB", "focusOutBackward"
-                 }),
-
-            // *** TabbedPane
-            "TabbedPane.font", dialogPlain12,
-            "TabbedPane.background", control,
-            "TabbedPane.foreground", controlText,
-            "TabbedPane.highlight", controlLtHighlight,
-            "TabbedPane.light", controlHighlight,
-            "TabbedPane.shadow", controlShadow,
-            "TabbedPane.darkShadow", controlDkShadow,
-            "TabbedPane.selected", null,
-            "TabbedPane.focus", controlText,
-            "TabbedPane.textIconGap", four,
-
-            // Causes tabs to be painted on top of the content area border.
-            // The amount of overlap is then controlled by tabAreaInsets.bottom,
-            // which is zero by default
-            "TabbedPane.tabsOverlapBorder", Boolean.FALSE,
-            "TabbedPane.selectionFollowsFocus", Boolean.TRUE,
-
-            "TabbedPane.labelShift", 1,
-            "TabbedPane.selectedLabelShift", -1,
-            "TabbedPane.tabInsets", tabbedPaneTabInsets,
-            "TabbedPane.selectedTabPadInsets", tabbedPaneTabPadInsets,
-            "TabbedPane.tabAreaInsets", tabbedPaneTabAreaInsets,
-            "TabbedPane.contentBorderInsets", tabbedPaneContentBorderInsets,
-            "TabbedPane.tabRunOverlay", new Integer(2),
-            "TabbedPane.tabsOpaque", Boolean.TRUE,
-            "TabbedPane.contentOpaque", Boolean.TRUE,
-            "TabbedPane.focusInputMap",
-              new UIDefaults.LazyInputMap(new Object[] {
-                         "RIGHT", "navigateRight",
-                      "KP_RIGHT", "navigateRight",
-                          "LEFT", "navigateLeft",
-                       "KP_LEFT", "navigateLeft",
-                            "UP", "navigateUp",
-                         "KP_UP", "navigateUp",
-                          "DOWN", "navigateDown",
-                       "KP_DOWN", "navigateDown",
-                     "ctrl DOWN", "requestFocusForVisibleComponent",
-                  "ctrl KP_DOWN", "requestFocusForVisibleComponent",
-                }),
-            "TabbedPane.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                   "ctrl PAGE_DOWN", "navigatePageDown",
-                     "ctrl PAGE_UP", "navigatePageUp",
-                          "ctrl UP", "requestFocus",
-                       "ctrl KP_UP", "requestFocus",
-                 }),
-
-
-            // *** Table
-            "Table.font", dialogPlain12,
-            "Table.foreground", controlText,  // cell text color
-            "Table.background", window,  // cell background color
-            "Table.selectionForeground", textHighlightText,
-            "Table.selectionBackground", textHighlight,
-            "Table.dropLineColor", controlShadow,
-            "Table.dropLineShortColor", black,
-            "Table.gridColor", gray,  // grid line color
-            "Table.focusCellBackground", window,
-            "Table.focusCellForeground", controlText,
-            "Table.focusCellHighlightBorder", focusCellHighlightBorder,
-            "Table.scrollPaneBorder", loweredBevelBorder,
-            "Table.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                               "ctrl C", "copy",
-                               "ctrl V", "paste",
-                               "ctrl X", "cut",
-                                 "COPY", "copy",
-                                "PASTE", "paste",
-                                  "CUT", "cut",
-                       "control INSERT", "copy",
-                         "shift INSERT", "paste",
-                         "shift DELETE", "cut",
-                                "RIGHT", "selectNextColumn",
-                             "KP_RIGHT", "selectNextColumn",
-                          "shift RIGHT", "selectNextColumnExtendSelection",
-                       "shift KP_RIGHT", "selectNextColumnExtendSelection",
-                     "ctrl shift RIGHT", "selectNextColumnExtendSelection",
-                  "ctrl shift KP_RIGHT", "selectNextColumnExtendSelection",
-                           "ctrl RIGHT", "selectNextColumnChangeLead",
-                        "ctrl KP_RIGHT", "selectNextColumnChangeLead",
-                                 "LEFT", "selectPreviousColumn",
-                              "KP_LEFT", "selectPreviousColumn",
-                           "shift LEFT", "selectPreviousColumnExtendSelection",
-                        "shift KP_LEFT", "selectPreviousColumnExtendSelection",
-                      "ctrl shift LEFT", "selectPreviousColumnExtendSelection",
-                   "ctrl shift KP_LEFT", "selectPreviousColumnExtendSelection",
-                            "ctrl LEFT", "selectPreviousColumnChangeLead",
-                         "ctrl KP_LEFT", "selectPreviousColumnChangeLead",
-                                 "DOWN", "selectNextRow",
-                              "KP_DOWN", "selectNextRow",
-                           "shift DOWN", "selectNextRowExtendSelection",
-                        "shift KP_DOWN", "selectNextRowExtendSelection",
-                      "ctrl shift DOWN", "selectNextRowExtendSelection",
-                   "ctrl shift KP_DOWN", "selectNextRowExtendSelection",
-                            "ctrl DOWN", "selectNextRowChangeLead",
-                         "ctrl KP_DOWN", "selectNextRowChangeLead",
-                                   "UP", "selectPreviousRow",
-                                "KP_UP", "selectPreviousRow",
-                             "shift UP", "selectPreviousRowExtendSelection",
-                          "shift KP_UP", "selectPreviousRowExtendSelection",
-                        "ctrl shift UP", "selectPreviousRowExtendSelection",
-                     "ctrl shift KP_UP", "selectPreviousRowExtendSelection",
-                              "ctrl UP", "selectPreviousRowChangeLead",
-                           "ctrl KP_UP", "selectPreviousRowChangeLead",
-                                 "HOME", "selectFirstColumn",
-                           "shift HOME", "selectFirstColumnExtendSelection",
-                      "ctrl shift HOME", "selectFirstRowExtendSelection",
-                            "ctrl HOME", "selectFirstRow",
-                                  "END", "selectLastColumn",
-                            "shift END", "selectLastColumnExtendSelection",
-                       "ctrl shift END", "selectLastRowExtendSelection",
-                             "ctrl END", "selectLastRow",
-                              "PAGE_UP", "scrollUpChangeSelection",
-                        "shift PAGE_UP", "scrollUpExtendSelection",
-                   "ctrl shift PAGE_UP", "scrollLeftExtendSelection",
-                         "ctrl PAGE_UP", "scrollLeftChangeSelection",
-                            "PAGE_DOWN", "scrollDownChangeSelection",
-                      "shift PAGE_DOWN", "scrollDownExtendSelection",
-                 "ctrl shift PAGE_DOWN", "scrollRightExtendSelection",
-                       "ctrl PAGE_DOWN", "scrollRightChangeSelection",
-                                  "TAB", "selectNextColumnCell",
-                            "shift TAB", "selectPreviousColumnCell",
-                                "ENTER", "selectNextRowCell",
-                          "shift ENTER", "selectPreviousRowCell",
-                               "ctrl A", "selectAll",
-                           "ctrl SLASH", "selectAll",
-                      "ctrl BACK_SLASH", "clearSelection",
-                               "ESCAPE", "cancel",
-                                   "F2", "startEditing",
-                                "SPACE", "addToSelection",
-                           "ctrl SPACE", "toggleAndAnchor",
-                          "shift SPACE", "extendTo",
-                     "ctrl shift SPACE", "moveSelectionTo",
-                                   "F8", "focusHeader"
-                 }),
-            "Table.ancestorInputMap.RightToLeft",
-               new UIDefaults.LazyInputMap(new Object[] {
-                                "RIGHT", "selectPreviousColumn",
-                             "KP_RIGHT", "selectPreviousColumn",
-                          "shift RIGHT", "selectPreviousColumnExtendSelection",
-                       "shift KP_RIGHT", "selectPreviousColumnExtendSelection",
-                     "ctrl shift RIGHT", "selectPreviousColumnExtendSelection",
-                  "ctrl shift KP_RIGHT", "selectPreviousColumnExtendSelection",
-                           "ctrl RIGHT", "selectPreviousColumnChangeLead",
-                        "ctrl KP_RIGHT", "selectPreviousColumnChangeLead",
-                                 "LEFT", "selectNextColumn",
-                              "KP_LEFT", "selectNextColumn",
-                           "shift LEFT", "selectNextColumnExtendSelection",
-                        "shift KP_LEFT", "selectNextColumnExtendSelection",
-                      "ctrl shift LEFT", "selectNextColumnExtendSelection",
-                   "ctrl shift KP_LEFT", "selectNextColumnExtendSelection",
-                            "ctrl LEFT", "selectNextColumnChangeLead",
-                         "ctrl KP_LEFT", "selectNextColumnChangeLead",
-                         "ctrl PAGE_UP", "scrollRightChangeSelection",
-                       "ctrl PAGE_DOWN", "scrollLeftChangeSelection",
-                   "ctrl shift PAGE_UP", "scrollRightExtendSelection",
-                 "ctrl shift PAGE_DOWN", "scrollLeftExtendSelection",
-                 }),
-            "Table.ascendingSortIcon",  new SwingLazyValue(
-                     "sun.swing.icon.SortArrowIcon",
-                     null, new Object[] { Boolean.TRUE,
-                                          "Table.sortIconColor" }),
-            "Table.descendingSortIcon",  new SwingLazyValue(
-                     "sun.swing.icon.SortArrowIcon",
-                     null, new Object[] { Boolean.FALSE,
-                                          "Table.sortIconColor" }),
-            "Table.sortIconColor", controlShadow,
-
-            "TableHeader.font", dialogPlain12,
-            "TableHeader.foreground", controlText, // header text color
-            "TableHeader.background", control, // header background
-            "TableHeader.cellBorder", tableHeaderBorder,
-
-            // Support for changing the background/border of the currently
-            // selected header column when the header has the keyboard focus.
-            "TableHeader.focusCellBackground", table.getColor("text"), // like text component bg
-            "TableHeader.focusCellForeground", null,
-            "TableHeader.focusCellBorder", null,
-            "TableHeader.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                                "SPACE", "toggleSortOrder",
-                                 "LEFT", "selectColumnToLeft",
-                              "KP_LEFT", "selectColumnToLeft",
-                                "RIGHT", "selectColumnToRight",
-                             "KP_RIGHT", "selectColumnToRight",
-                             "alt LEFT", "moveColumnLeft",
-                          "alt KP_LEFT", "moveColumnLeft",
-                            "alt RIGHT", "moveColumnRight",
-                         "alt KP_RIGHT", "moveColumnRight",
-                       "alt shift LEFT", "resizeLeft",
-                    "alt shift KP_LEFT", "resizeLeft",
-                      "alt shift RIGHT", "resizeRight",
-                   "alt shift KP_RIGHT", "resizeRight",
-                               "ESCAPE", "focusTable",
-               }),
-
-            // *** Text
-            "TextField.font", sansSerifPlain12,
-            "TextField.background", window,
-            "TextField.foreground", textText,
-            "TextField.shadow", controlShadow,
-            "TextField.darkShadow", controlDkShadow,
-            "TextField.light", controlHighlight,
-            "TextField.highlight", controlLtHighlight,
-            "TextField.inactiveForeground", textInactiveText,
-            "TextField.inactiveBackground", control,
-            "TextField.selectionBackground", textHighlight,
-            "TextField.selectionForeground", textHighlightText,
-            "TextField.caretForeground", textText,
-            "TextField.caretBlinkRate", caretBlinkRate,
-            "TextField.border", textFieldBorder,
-            "TextField.margin", zeroInsets,
-
-            "FormattedTextField.font", sansSerifPlain12,
-            "FormattedTextField.background", window,
-            "FormattedTextField.foreground", textText,
-            "FormattedTextField.inactiveForeground", textInactiveText,
-            "FormattedTextField.inactiveBackground", control,
-            "FormattedTextField.selectionBackground", textHighlight,
-            "FormattedTextField.selectionForeground", textHighlightText,
-            "FormattedTextField.caretForeground", textText,
-            "FormattedTextField.caretBlinkRate", caretBlinkRate,
-            "FormattedTextField.border", textFieldBorder,
-            "FormattedTextField.margin", zeroInsets,
-            "FormattedTextField.focusInputMap",
-              new UIDefaults.LazyInputMap(new Object[] {
-                           "ctrl C", DefaultEditorKit.copyAction,
-                           "ctrl V", DefaultEditorKit.pasteAction,
-                           "ctrl X", DefaultEditorKit.cutAction,
-                             "COPY", DefaultEditorKit.copyAction,
-                            "PASTE", DefaultEditorKit.pasteAction,
-                              "CUT", DefaultEditorKit.cutAction,
-                   "control INSERT", DefaultEditorKit.copyAction,
-                     "shift INSERT", DefaultEditorKit.pasteAction,
-                     "shift DELETE", DefaultEditorKit.cutAction,
-                       "shift LEFT", DefaultEditorKit.selectionBackwardAction,
-                    "shift KP_LEFT", DefaultEditorKit.selectionBackwardAction,
-                      "shift RIGHT", DefaultEditorKit.selectionForwardAction,
-                   "shift KP_RIGHT", DefaultEditorKit.selectionForwardAction,
-                        "ctrl LEFT", DefaultEditorKit.previousWordAction,
-                     "ctrl KP_LEFT", DefaultEditorKit.previousWordAction,
-                       "ctrl RIGHT", DefaultEditorKit.nextWordAction,
-                    "ctrl KP_RIGHT", DefaultEditorKit.nextWordAction,
-                  "ctrl shift LEFT", DefaultEditorKit.selectionPreviousWordAction,
-               "ctrl shift KP_LEFT", DefaultEditorKit.selectionPreviousWordAction,
-                 "ctrl shift RIGHT", DefaultEditorKit.selectionNextWordAction,
-              "ctrl shift KP_RIGHT", DefaultEditorKit.selectionNextWordAction,
-                           "ctrl A", DefaultEditorKit.selectAllAction,
-                             "HOME", DefaultEditorKit.beginLineAction,
-                              "END", DefaultEditorKit.endLineAction,
-                       "shift HOME", DefaultEditorKit.selectionBeginLineAction,
-                        "shift END", DefaultEditorKit.selectionEndLineAction,
-                       "BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
-                 "shift BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
-                           "ctrl H", DefaultEditorKit.deletePrevCharAction,
-                           "DELETE", DefaultEditorKit.deleteNextCharAction,
-                      "ctrl DELETE", DefaultEditorKit.deleteNextWordAction,
-                  "ctrl BACK_SPACE", DefaultEditorKit.deletePrevWordAction,
-                            "RIGHT", DefaultEditorKit.forwardAction,
-                             "LEFT", DefaultEditorKit.backwardAction,
-                         "KP_RIGHT", DefaultEditorKit.forwardAction,
-                          "KP_LEFT", DefaultEditorKit.backwardAction,
-                            "ENTER", JTextField.notifyAction,
-                  "ctrl BACK_SLASH", "unselect",
-                  "control shift O", "toggle-componentOrientation",
-                           "ESCAPE", "reset-field-edit",
-                               "UP", "increment",
-                            "KP_UP", "increment",
-                             "DOWN", "decrement",
-                          "KP_DOWN", "decrement",
-              }),
-
-            "PasswordField.font", monospacedPlain12,
-            "PasswordField.background", window,
-            "PasswordField.foreground", textText,
-            "PasswordField.inactiveForeground", textInactiveText,
-            "PasswordField.inactiveBackground", control,
-            "PasswordField.selectionBackground", textHighlight,
-            "PasswordField.selectionForeground", textHighlightText,
-            "PasswordField.caretForeground", textText,
-            "PasswordField.caretBlinkRate", caretBlinkRate,
-            "PasswordField.border", textFieldBorder,
-            "PasswordField.margin", zeroInsets,
-            "PasswordField.echoChar", '*',
-
-            "TextArea.font", monospacedPlain12,
-            "TextArea.background", window,
-            "TextArea.foreground", textText,
-            "TextArea.inactiveForeground", textInactiveText,
-            "TextArea.selectionBackground", textHighlight,
-            "TextArea.selectionForeground", textHighlightText,
-            "TextArea.caretForeground", textText,
-            "TextArea.caretBlinkRate", caretBlinkRate,
-            "TextArea.border", marginBorder,
-            "TextArea.margin", zeroInsets,
-
-            "TextPane.font", serifPlain12,
-            "TextPane.background", white,
-            "TextPane.foreground", textText,
-            "TextPane.selectionBackground", textHighlight,
-            "TextPane.selectionForeground", textHighlightText,
-            "TextPane.caretForeground", textText,
-            "TextPane.caretBlinkRate", caretBlinkRate,
-            "TextPane.inactiveForeground", textInactiveText,
-            "TextPane.border", marginBorder,
-            "TextPane.margin", editorMargin,
-
-            "EditorPane.font", serifPlain12,
-            "EditorPane.background", white,
-            "EditorPane.foreground", textText,
-            "EditorPane.selectionBackground", textHighlight,
-            "EditorPane.selectionForeground", textHighlightText,
-            "EditorPane.caretForeground", textText,
-            "EditorPane.caretBlinkRate", caretBlinkRate,
-            "EditorPane.inactiveForeground", textInactiveText,
-            "EditorPane.border", marginBorder,
-            "EditorPane.margin", editorMargin,
-
-            "html.pendingImage", SwingUtilities2.makeIcon(getClass(),
-                                    BasicLookAndFeel.class,
-                                    "icons/image-delayed.png"),
-            "html.missingImage", SwingUtilities2.makeIcon(getClass(),
-                                    BasicLookAndFeel.class,
-                                    "icons/image-failed.png"),
-            // *** TitledBorder
-            "TitledBorder.font", dialogPlain12,
-            "TitledBorder.titleColor", controlText,
-            "TitledBorder.border", etchedBorder,
-
-            // *** ToolBar
-            "ToolBar.font", dialogPlain12,
-            "ToolBar.background", control,
-            "ToolBar.foreground", controlText,
-            "ToolBar.shadow", controlShadow,
-            "ToolBar.darkShadow", controlDkShadow,
-            "ToolBar.light", controlHighlight,
-            "ToolBar.highlight", controlLtHighlight,
-            "ToolBar.dockingBackground", control,
-            "ToolBar.dockingForeground", red,
-            "ToolBar.floatingBackground", control,
-            "ToolBar.floatingForeground", darkGray,
-            "ToolBar.border", etchedBorder,
-            "ToolBar.separatorSize", toolBarSeparatorSize,
-            "ToolBar.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                        "UP", "navigateUp",
-                     "KP_UP", "navigateUp",
-                      "DOWN", "navigateDown",
-                   "KP_DOWN", "navigateDown",
-                      "LEFT", "navigateLeft",
-                   "KP_LEFT", "navigateLeft",
-                     "RIGHT", "navigateRight",
-                  "KP_RIGHT", "navigateRight"
-                 }),
-
-            // *** ToolTips
-            "ToolTip.font", sansSerifPlain12,
-            "ToolTip.background", table.get("info"),
-            "ToolTip.foreground", table.get("infoText"),
-            "ToolTip.border", blackLineBorder,
-            // ToolTips also support backgroundInactive, borderInactive,
-            // and foregroundInactive
-
-        // *** ToolTipManager
-            // ToolTipManager.enableToolTipMode currently supports:
-            // "allWindows" (default):
-            //     enables tool tips for all windows of all java applications,
-            //     whether the windows are active or inactive
-            // "activeApplication"
-            //     enables tool tips for windows of an application only when
-            //     the application has an active window
-            "ToolTipManager.enableToolTipMode", "allWindows",
-
-        // *** Tree
-            "Tree.paintLines", Boolean.TRUE,
-            "Tree.lineTypeDashed", Boolean.FALSE,
-            "Tree.font", dialogPlain12,
-            "Tree.background", window,
-            "Tree.foreground", textText,
-            "Tree.hash", gray,
-            "Tree.textForeground", textText,
-            "Tree.textBackground", table.get("text"),
-            "Tree.selectionForeground", textHighlightText,
-            "Tree.selectionBackground", textHighlight,
-            "Tree.selectionBorderColor", black,
-            "Tree.dropLineColor", controlShadow,
-            "Tree.editorBorder", blackLineBorder,
-            "Tree.leftChildIndent", new Integer(7),
-            "Tree.rightChildIndent", new Integer(13),
-            "Tree.rowHeight", new Integer(16),
-            "Tree.scrollsOnExpand", Boolean.TRUE,
-            "Tree.openIcon", SwingUtilities2.makeIcon(getClass(),
-                                                      BasicLookAndFeel.class,
-                                                      "icons/TreeOpen.gif"),
-            "Tree.closedIcon", SwingUtilities2.makeIcon(getClass(),
-                                                        BasicLookAndFeel.class,
-                                                        "icons/TreeClosed.gif"),
-            "Tree.leafIcon", SwingUtilities2.makeIcon(getClass(),
-                                                      BasicLookAndFeel.class,
-                                                      "icons/TreeLeaf.gif"),
-            "Tree.expandedIcon", null,
-            "Tree.collapsedIcon", null,
-            "Tree.changeSelectionWithFocus", Boolean.TRUE,
-            "Tree.drawsFocusBorderAroundIcon", Boolean.FALSE,
-            "Tree.timeFactor", oneThousand,
-            "Tree.focusInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                                 "ctrl C", "copy",
-                                 "ctrl V", "paste",
-                                 "ctrl X", "cut",
-                                   "COPY", "copy",
-                                  "PASTE", "paste",
-                                    "CUT", "cut",
-                         "control INSERT", "copy",
-                           "shift INSERT", "paste",
-                           "shift DELETE", "cut",
-                                     "UP", "selectPrevious",
-                                  "KP_UP", "selectPrevious",
-                               "shift UP", "selectPreviousExtendSelection",
-                            "shift KP_UP", "selectPreviousExtendSelection",
-                          "ctrl shift UP", "selectPreviousExtendSelection",
-                       "ctrl shift KP_UP", "selectPreviousExtendSelection",
-                                "ctrl UP", "selectPreviousChangeLead",
-                             "ctrl KP_UP", "selectPreviousChangeLead",
-                                   "DOWN", "selectNext",
-                                "KP_DOWN", "selectNext",
-                             "shift DOWN", "selectNextExtendSelection",
-                          "shift KP_DOWN", "selectNextExtendSelection",
-                        "ctrl shift DOWN", "selectNextExtendSelection",
-                     "ctrl shift KP_DOWN", "selectNextExtendSelection",
-                              "ctrl DOWN", "selectNextChangeLead",
-                           "ctrl KP_DOWN", "selectNextChangeLead",
-                                  "RIGHT", "selectChild",
-                               "KP_RIGHT", "selectChild",
-                                   "LEFT", "selectParent",
-                                "KP_LEFT", "selectParent",
-                                "PAGE_UP", "scrollUpChangeSelection",
-                          "shift PAGE_UP", "scrollUpExtendSelection",
-                     "ctrl shift PAGE_UP", "scrollUpExtendSelection",
-                           "ctrl PAGE_UP", "scrollUpChangeLead",
-                              "PAGE_DOWN", "scrollDownChangeSelection",
-                        "shift PAGE_DOWN", "scrollDownExtendSelection",
-                   "ctrl shift PAGE_DOWN", "scrollDownExtendSelection",
-                         "ctrl PAGE_DOWN", "scrollDownChangeLead",
-                                   "HOME", "selectFirst",
-                             "shift HOME", "selectFirstExtendSelection",
-                        "ctrl shift HOME", "selectFirstExtendSelection",
-                              "ctrl HOME", "selectFirstChangeLead",
-                                    "END", "selectLast",
-                              "shift END", "selectLastExtendSelection",
-                         "ctrl shift END", "selectLastExtendSelection",
-                               "ctrl END", "selectLastChangeLead",
-                                     "F2", "startEditing",
-                                 "ctrl A", "selectAll",
-                             "ctrl SLASH", "selectAll",
-                        "ctrl BACK_SLASH", "clearSelection",
-                              "ctrl LEFT", "scrollLeft",
-                           "ctrl KP_LEFT", "scrollLeft",
-                             "ctrl RIGHT", "scrollRight",
-                          "ctrl KP_RIGHT", "scrollRight",
-                                  "SPACE", "addToSelection",
-                             "ctrl SPACE", "toggleAndAnchor",
-                            "shift SPACE", "extendTo",
-                       "ctrl shift SPACE", "moveSelectionTo"
-                 }),
-            "Tree.focusInputMap.RightToLeft",
-               new UIDefaults.LazyInputMap(new Object[] {
-                                  "RIGHT", "selectParent",
-                               "KP_RIGHT", "selectParent",
-                                   "LEFT", "selectChild",
-                                "KP_LEFT", "selectChild",
-                 }),
-            "Tree.ancestorInputMap",
-               new UIDefaults.LazyInputMap(new Object[] {
-                     "ESCAPE", "cancel"
-                 }),
-            // Bind specific keys that can invoke popup on currently
-            // focused JComponent
-            "RootPane.ancestorInputMap",
-                new UIDefaults.LazyInputMap(new Object[] {
-                     "shift F10", "postPopup",
-                  "CONTEXT_MENU", "postPopup"
-                  }),
-
-            // These bindings are only enabled when there is a default
-            // button set on the rootpane.
-            "RootPane.defaultButtonWindowKeyBindings", new Object[] {
-                             "ENTER", "press",
-                    "released ENTER", "release",
-                        "ctrl ENTER", "press",
-               "ctrl released ENTER", "release"
-              },
-        };
-
-        table.putDefaults(defaults);
-    }
-
-    static int getFocusAcceleratorKeyMask() {
-        Toolkit tk = Toolkit.getDefaultToolkit();
-        if (tk instanceof SunToolkit) {
-            return ((SunToolkit)tk).getFocusAcceleratorKeyMask();
-        }
-        return ActionEvent.ALT_MASK;
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//
+//        initResourceBundle(table);
+//
+//        // *** Shared Integers
+//        Integer fiveHundred = new Integer(500);
+//
+//        // *** Shared Longs
+//        Long oneThousand = new Long(1000);
+//
+//        // *** Shared Fonts
+//        Integer twelve = new Integer(12);
+//        Integer fontPlain = new Integer(Font.PLAIN);
+//        Integer fontBold = new Integer(Font.BOLD);
+//        Object dialogPlain12 = new SwingLazyValue(
+//                          "javax.swing.plaf.FontUIResource",
+//                          null,
+//                          new Object[] {Font.DIALOG, fontPlain, twelve});
+//        Object serifPlain12 = new SwingLazyValue(
+//                          "javax.swing.plaf.FontUIResource",
+//                          null,
+//                          new Object[] {Font.SERIF, fontPlain, twelve});
+//        Object sansSerifPlain12 =  new SwingLazyValue(
+//                          "javax.swing.plaf.FontUIResource",
+//                          null,
+//                          new Object[] {Font.SANS_SERIF, fontPlain, twelve});
+//        Object monospacedPlain12 = new SwingLazyValue(
+//                          "javax.swing.plaf.FontUIResource",
+//                          null,
+//                          new Object[] {Font.MONOSPACED, fontPlain, twelve});
+//        Object dialogBold12 = new SwingLazyValue(
+//                          "javax.swing.plaf.FontUIResource",
+//                          null,
+//                          new Object[] {Font.DIALOG, fontBold, twelve});
+//
+//
+//        // *** Shared Colors
+//        ColorUIResource red = new ColorUIResource(Color.red);
+//        ColorUIResource black = new ColorUIResource(Color.black);
+//        ColorUIResource white = new ColorUIResource(Color.white);
+//        ColorUIResource yellow = new ColorUIResource(Color.yellow);
+//        ColorUIResource gray = new ColorUIResource(Color.gray);
+//        ColorUIResource lightGray = new ColorUIResource(Color.lightGray);
+//        ColorUIResource darkGray = new ColorUIResource(Color.darkGray);
+//        ColorUIResource scrollBarTrack = new ColorUIResource(224, 224, 224);
+//
+//        Color control = table.getColor("control");
+//        Color controlDkShadow = table.getColor("controlDkShadow");
+//        Color controlHighlight = table.getColor("controlHighlight");
+//        Color controlLtHighlight = table.getColor("controlLtHighlight");
+//        Color controlShadow = table.getColor("controlShadow");
+//        Color controlText = table.getColor("controlText");
+//        Color menu = table.getColor("menu");
+//        Color menuText = table.getColor("menuText");
+//        Color textHighlight = table.getColor("textHighlight");
+//        Color textHighlightText = table.getColor("textHighlightText");
+//        Color textInactiveText = table.getColor("textInactiveText");
+//        Color textText = table.getColor("textText");
+//        Color window = table.getColor("window");
+//
+//        // *** Shared Insets
+//        InsetsUIResource zeroInsets = new InsetsUIResource(0,0,0,0);
+//        InsetsUIResource twoInsets = new InsetsUIResource(2,2,2,2);
+//        InsetsUIResource threeInsets = new InsetsUIResource(3,3,3,3);
+//
+//        // *** Shared Borders
+//        Object marginBorder = new SwingLazyValue(
+//                          "javax.swing.plaf.basic.BasicBorders$MarginBorder");
+//        Object etchedBorder = new SwingLazyValue(
+//                          "javax.swing.plaf.BorderUIResource",
+//                          "getEtchedBorderUIResource");
+//        Object loweredBevelBorder = new SwingLazyValue(
+//                          "javax.swing.plaf.BorderUIResource",
+//                          "getLoweredBevelBorderUIResource");
+//
+//        Object popupMenuBorder = new SwingLazyValue(
+//                          "javax.swing.plaf.basic.BasicBorders",
+//                          "getInternalFrameBorder");
+//
+//        Object blackLineBorder = new SwingLazyValue(
+//                          "javax.swing.plaf.BorderUIResource",
+//                          "getBlackLineBorderUIResource");
+//        Object focusCellHighlightBorder = new SwingLazyValue(
+//                          "javax.swing.plaf.BorderUIResource$LineBorderUIResource",
+//                          null,
+//                          new Object[] {yellow});
+//
+//        Object noFocusBorder = new BorderUIResource.EmptyBorderUIResource(1,1,1,1);
+//
+//        Object tableHeaderBorder = new SwingLazyValue(
+//                          "javax.swing.plaf.BorderUIResource$BevelBorderUIResource",
+//                          null,
+//                          new Object[] { new Integer(BevelBorder.RAISED),
+//                                         controlLtHighlight,
+//                                         control,
+//                                         controlDkShadow,
+//                                         controlShadow });
+//
+//
+//        // *** Button value objects
+//
+//        Object buttonBorder =
+//            new SwingLazyValue(
+//                            "javax.swing.plaf.basic.BasicBorders",
+//                            "getButtonBorder");
+//
+//        Object buttonToggleBorder =
+//            new SwingLazyValue(
+//                            "javax.swing.plaf.basic.BasicBorders",
+//                            "getToggleButtonBorder");
+//
+//        Object radioButtonBorder =
+//            new SwingLazyValue(
+//                            "javax.swing.plaf.basic.BasicBorders",
+//                            "getRadioButtonBorder");
+//
+//        // *** FileChooser / FileView value objects
+//
+//        Object newFolderIcon = SwingUtilities2.makeIcon(getClass(),
+//                                                        BasicLookAndFeel.class,
+//                                                        "icons/NewFolder.gif");
+//        Object upFolderIcon = SwingUtilities2.makeIcon(getClass(),
+//                                                       BasicLookAndFeel.class,
+//                                                       "icons/UpFolder.gif");
+//        Object homeFolderIcon = SwingUtilities2.makeIcon(getClass(),
+//                                                         BasicLookAndFeel.class,
+//                                                         "icons/HomeFolder.gif");
+//        Object detailsViewIcon = SwingUtilities2.makeIcon(getClass(),
+//                                                          BasicLookAndFeel.class,
+//                                                          "icons/DetailsView.gif");
+//        Object listViewIcon = SwingUtilities2.makeIcon(getClass(),
+//                                                       BasicLookAndFeel.class,
+//                                                       "icons/ListView.gif");
+//        Object directoryIcon = SwingUtilities2.makeIcon(getClass(),
+//                                                        BasicLookAndFeel.class,
+//                                                        "icons/Directory.gif");
+//        Object fileIcon = SwingUtilities2.makeIcon(getClass(),
+//                                                   BasicLookAndFeel.class,
+//                                                   "icons/File.gif");
+//        Object computerIcon = SwingUtilities2.makeIcon(getClass(),
+//                                                       BasicLookAndFeel.class,
+//                                                       "icons/Computer.gif");
+//        Object hardDriveIcon = SwingUtilities2.makeIcon(getClass(),
+//                                                        BasicLookAndFeel.class,
+//                                                        "icons/HardDrive.gif");
+//        Object floppyDriveIcon = SwingUtilities2.makeIcon(getClass(),
+//                                                          BasicLookAndFeel.class,
+//                                                          "icons/FloppyDrive.gif");
+//
+//
+//        // *** InternalFrame value objects
+//
+//        Object internalFrameBorder = new SwingLazyValue(
+//                "javax.swing.plaf.basic.BasicBorders",
+//                "getInternalFrameBorder");
+//
+//        // *** List value objects
+//
+//        Object listCellRendererActiveValue = new UIDefaults.ActiveValue() {
+//            public Object createValue(UIDefaults table) {
+//                return new DefaultListCellRenderer.UIResource();
+//            }
+//        };
+//
+//
+//        // *** Menus value objects
+//
+//        Object menuBarBorder =
+//            new SwingLazyValue(
+//                "javax.swing.plaf.basic.BasicBorders",
+//                "getMenuBarBorder");
+//
+//        Object menuItemCheckIcon =
+//            new SwingLazyValue(
+//                "javax.swing.plaf.basic.BasicIconFactory",
+//                "getMenuItemCheckIcon");
+//
+//        Object menuItemArrowIcon =
+//            new SwingLazyValue(
+//                "javax.swing.plaf.basic.BasicIconFactory",
+//                "getMenuItemArrowIcon");
+//
+//
+//        Object menuArrowIcon =
+//            new SwingLazyValue(
+//                "javax.swing.plaf.basic.BasicIconFactory",
+//                "getMenuArrowIcon");
+//
+//        Object checkBoxIcon =
+//            new SwingLazyValue(
+//                "javax.swing.plaf.basic.BasicIconFactory",
+//                "getCheckBoxIcon");
+//
+//        Object radioButtonIcon =
+//            new SwingLazyValue(
+//                "javax.swing.plaf.basic.BasicIconFactory",
+//                "getRadioButtonIcon");
+//
+//        Object checkBoxMenuItemIcon =
+//            new SwingLazyValue(
+//                "javax.swing.plaf.basic.BasicIconFactory",
+//                "getCheckBoxMenuItemIcon");
+//
+//        Object radioButtonMenuItemIcon =
+//            new SwingLazyValue(
+//                "javax.swing.plaf.basic.BasicIconFactory",
+//                "getRadioButtonMenuItemIcon");
+//
+//        Object menuItemAcceleratorDelimiter = "+";
+//
+//        // *** OptionPane value objects
+//
+//        Object optionPaneMinimumSize = new DimensionUIResource(262, 90);
+//
+//        Integer zero =  new Integer(0);
+//        Object zeroBorder = new SwingLazyValue(
+//                           "javax.swing.plaf.BorderUIResource$EmptyBorderUIResource",
+//                           new Object[] {zero, zero, zero, zero});
+//
+//        Integer ten = new Integer(10);
+//        Object optionPaneBorder = new SwingLazyValue(
+//                           "javax.swing.plaf.BorderUIResource$EmptyBorderUIResource",
+//                           new Object[] {ten, ten, twelve, ten});
+//
+//        Object optionPaneButtonAreaBorder = new SwingLazyValue(
+//                           "javax.swing.plaf.BorderUIResource$EmptyBorderUIResource",
+//                           new Object[] {new Integer(6), zero, zero, zero});
+//
+//
+//        // *** ProgessBar value objects
+//
+//        Object progressBarBorder =
+//            new SwingLazyValue(
+//                            "javax.swing.plaf.basic.BasicBorders",
+//                            "getProgressBarBorder");
+//
+//        // ** ScrollBar value objects
+//
+//        Object minimumThumbSize = new DimensionUIResource(8,8);
+//        Object maximumThumbSize = new DimensionUIResource(4096,4096);
+//
+//        // ** Slider value objects
+//
+//        Object sliderFocusInsets = twoInsets;
+//
+//        Object toolBarSeparatorSize = new DimensionUIResource( 10, 10 );
+//
+//
+//        // *** SplitPane value objects
+//
+//        Object splitPaneBorder =
+//            new SwingLazyValue(
+//                            "javax.swing.plaf.basic.BasicBorders",
+//                            "getSplitPaneBorder");
+//        Object splitPaneDividerBorder =
+//            new SwingLazyValue(
+//                            "javax.swing.plaf.basic.BasicBorders",
+//                            "getSplitPaneDividerBorder");
+//
+//        // ** TabbedBane value objects
+//
+//        Object tabbedPaneTabInsets = new InsetsUIResource(0, 4, 1, 4);
+//
+//        Object tabbedPaneTabPadInsets = new InsetsUIResource(2, 2, 2, 1);
+//
+//        Object tabbedPaneTabAreaInsets = new InsetsUIResource(3, 2, 0, 2);
+//
+//        Object tabbedPaneContentBorderInsets = new InsetsUIResource(2, 2, 3, 3);
+//
+//
+//        // *** Text value objects
+//
+//        Object textFieldBorder =
+//            new SwingLazyValue(
+//                            "javax.swing.plaf.basic.BasicBorders",
+//                            "getTextFieldBorder");
+//
+//        Object editorMargin = threeInsets;
+//
+//        Object caretBlinkRate = fiveHundred;
+//        Integer four = new Integer(4);
+//
+//        Object[] allAuditoryCues = new Object[] {
+//                "CheckBoxMenuItem.commandSound",
+//                "InternalFrame.closeSound",
+//                "InternalFrame.maximizeSound",
+//                "InternalFrame.minimizeSound",
+//                "InternalFrame.restoreDownSound",
+//                "InternalFrame.restoreUpSound",
+//                "MenuItem.commandSound",
+//                "OptionPane.errorSound",
+//                "OptionPane.informationSound",
+//                "OptionPane.questionSound",
+//                "OptionPane.warningSound",
+//                "PopupMenu.popupSound",
+//                "RadioButtonMenuItem.commandSound"};
+//
+//        Object[] noAuditoryCues = new Object[] {"mute"};
+//
+//        // *** Component Defaults
+//
+//        Object[] defaults = {
+//            // *** Auditory Feedback
+//            "AuditoryCues.cueList", allAuditoryCues,
+//            "AuditoryCues.allAuditoryCues", allAuditoryCues,
+//            "AuditoryCues.noAuditoryCues", noAuditoryCues,
+//            // this key defines which of the various cues to render.
+//            // L&Fs that want auditory feedback NEED to override playList.
+//            "AuditoryCues.playList", null,
+//
+//            // *** Buttons
+//            "Button.defaultButtonFollowsFocus", Boolean.TRUE,
+//            "Button.font", dialogPlain12,
+//            "Button.background", control,
+//            "Button.foreground", controlText,
+//            "Button.shadow", controlShadow,
+//            "Button.darkShadow", controlDkShadow,
+//            "Button.light", controlHighlight,
+//            "Button.highlight", controlLtHighlight,
+//            "Button.border", buttonBorder,
+//            "Button.margin", new InsetsUIResource(2, 14, 2, 14),
+//            "Button.textIconGap", four,
+//            "Button.textShiftOffset", zero,
+//            "Button.focusInputMap", new UIDefaults.LazyInputMap(new Object[] {
+//                         "SPACE", "pressed",
+//                "released SPACE", "released",
+//                         "ENTER", "pressed",
+//                "released ENTER", "released"
+//              }),
+//
+//            "ToggleButton.font", dialogPlain12,
+//            "ToggleButton.background", control,
+//            "ToggleButton.foreground", controlText,
+//            "ToggleButton.shadow", controlShadow,
+//            "ToggleButton.darkShadow", controlDkShadow,
+//            "ToggleButton.light", controlHighlight,
+//            "ToggleButton.highlight", controlLtHighlight,
+//            "ToggleButton.border", buttonToggleBorder,
+//            "ToggleButton.margin", new InsetsUIResource(2, 14, 2, 14),
+//            "ToggleButton.textIconGap", four,
+//            "ToggleButton.textShiftOffset", zero,
+//            "ToggleButton.focusInputMap",
+//              new UIDefaults.LazyInputMap(new Object[] {
+//                            "SPACE", "pressed",
+//                   "released SPACE", "released"
+//                }),
+//
+//            "RadioButton.font", dialogPlain12,
+//            "RadioButton.background", control,
+//            "RadioButton.foreground", controlText,
+//            "RadioButton.shadow", controlShadow,
+//            "RadioButton.darkShadow", controlDkShadow,
+//            "RadioButton.light", controlHighlight,
+//            "RadioButton.highlight", controlLtHighlight,
+//            "RadioButton.border", radioButtonBorder,
+//            "RadioButton.margin", twoInsets,
+//            "RadioButton.textIconGap", four,
+//            "RadioButton.textShiftOffset", zero,
+//            "RadioButton.icon", radioButtonIcon,
+//            "RadioButton.focusInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                          "SPACE", "pressed",
+//                 "released SPACE", "released",
+//                         "RETURN", "pressed"
+//              }),
+//
+//            "CheckBox.font", dialogPlain12,
+//            "CheckBox.background", control,
+//            "CheckBox.foreground", controlText,
+//            "CheckBox.border", radioButtonBorder,
+//            "CheckBox.margin", twoInsets,
+//            "CheckBox.textIconGap", four,
+//            "CheckBox.textShiftOffset", zero,
+//            "CheckBox.icon", checkBoxIcon,
+//            "CheckBox.focusInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                            "SPACE", "pressed",
+//                   "released SPACE", "released"
+//                 }),
+//            "FileChooser.useSystemExtensionHiding", Boolean.FALSE,
+//
+//            // *** ColorChooser
+//            "ColorChooser.font", dialogPlain12,
+//            "ColorChooser.background", control,
+//            "ColorChooser.foreground", controlText,
+//
+//            "ColorChooser.swatchesSwatchSize", new Dimension(10, 10),
+//            "ColorChooser.swatchesRecentSwatchSize", new Dimension(10, 10),
+//            "ColorChooser.swatchesDefaultRecentColor", control,
+//
+//            // *** ComboBox
+//            "ComboBox.font", sansSerifPlain12,
+//            "ComboBox.background", window,
+//            "ComboBox.foreground", textText,
+//            "ComboBox.buttonBackground", control,
+//            "ComboBox.buttonShadow", controlShadow,
+//            "ComboBox.buttonDarkShadow", controlDkShadow,
+//            "ComboBox.buttonHighlight", controlLtHighlight,
+//            "ComboBox.selectionBackground", textHighlight,
+//            "ComboBox.selectionForeground", textHighlightText,
+//            "ComboBox.disabledBackground", control,
+//            "ComboBox.disabledForeground", textInactiveText,
+//            "ComboBox.timeFactor", oneThousand,
+//            "ComboBox.isEnterSelectablePopup", Boolean.FALSE,
+//            "ComboBox.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                      "ESCAPE", "hidePopup",
+//                     "PAGE_UP", "pageUpPassThrough",
+//                   "PAGE_DOWN", "pageDownPassThrough",
+//                        "HOME", "homePassThrough",
+//                         "END", "endPassThrough",
+//                       "ENTER", "enterPressed"
+//                 }),
+//            "ComboBox.noActionOnKeyNavigation", Boolean.FALSE,
+//
+//            // *** FileChooser
+//
+//            "FileChooser.newFolderIcon", newFolderIcon,
+//            "FileChooser.upFolderIcon", upFolderIcon,
+//            "FileChooser.homeFolderIcon", homeFolderIcon,
+//            "FileChooser.detailsViewIcon", detailsViewIcon,
+//            "FileChooser.listViewIcon", listViewIcon,
+//            "FileChooser.readOnly", Boolean.FALSE,
+//            "FileChooser.usesSingleFilePane", Boolean.FALSE,
+//            "FileChooser.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                     "ESCAPE", "cancelSelection",
+//                     "F5", "refresh",
+//                 }),
+//
+//            "FileView.directoryIcon", directoryIcon,
+//            "FileView.fileIcon", fileIcon,
+//            "FileView.computerIcon", computerIcon,
+//            "FileView.hardDriveIcon", hardDriveIcon,
+//            "FileView.floppyDriveIcon", floppyDriveIcon,
+//
+//            // *** InternalFrame
+//            "InternalFrame.titleFont", dialogBold12,
+//            "InternalFrame.borderColor", control,
+//            "InternalFrame.borderShadow", controlShadow,
+//            "InternalFrame.borderDarkShadow", controlDkShadow,
+//            "InternalFrame.borderHighlight", controlLtHighlight,
+//            "InternalFrame.borderLight", controlHighlight,
+//            "InternalFrame.border", internalFrameBorder,
+//            "InternalFrame.icon",   SwingUtilities2.makeIcon(getClass(),
+//                                                             BasicLookAndFeel.class,
+//                                                             "icons/JavaCup16.png"),
+//
+//            /* Default frame icons are undefined for Basic. */
+//            "InternalFrame.maximizeIcon",
+//            new SwingLazyValue(
+//                           "javax.swing.plaf.basic.BasicIconFactory",
+//                           "createEmptyFrameIcon"),
+//            "InternalFrame.minimizeIcon",
+//            new SwingLazyValue(
+//                           "javax.swing.plaf.basic.BasicIconFactory",
+//                           "createEmptyFrameIcon"),
+//            "InternalFrame.iconifyIcon",
+//            new SwingLazyValue(
+//                           "javax.swing.plaf.basic.BasicIconFactory",
+//                           "createEmptyFrameIcon"),
+//            "InternalFrame.closeIcon",
+//            new SwingLazyValue(
+//                           "javax.swing.plaf.basic.BasicIconFactory",
+//                           "createEmptyFrameIcon"),
+//            // InternalFrame Auditory Cue Mappings
+//            "InternalFrame.closeSound", null,
+//            "InternalFrame.maximizeSound", null,
+//            "InternalFrame.minimizeSound", null,
+//            "InternalFrame.restoreDownSound", null,
+//            "InternalFrame.restoreUpSound", null,
+//
+//            "InternalFrame.activeTitleBackground", table.get("activeCaption"),
+//            "InternalFrame.activeTitleForeground", table.get("activeCaptionText"),
+//            "InternalFrame.inactiveTitleBackground", table.get("inactiveCaption"),
+//            "InternalFrame.inactiveTitleForeground", table.get("inactiveCaptionText"),
+//            "InternalFrame.windowBindings", new Object[] {
+//              "shift ESCAPE", "showSystemMenu",
+//                "ctrl SPACE", "showSystemMenu",
+//                    "ESCAPE", "hideSystemMenu"},
+//
+//            "InternalFrameTitlePane.iconifyButtonOpacity", Boolean.TRUE,
+//            "InternalFrameTitlePane.maximizeButtonOpacity", Boolean.TRUE,
+//            "InternalFrameTitlePane.closeButtonOpacity", Boolean.TRUE,
+//
+//        "DesktopIcon.border", internalFrameBorder,
+//
+//            "Desktop.minOnScreenInsets", threeInsets,
+//            "Desktop.background", table.get("desktop"),
+//            "Desktop.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                 "ctrl F5", "restore",
+//                 "ctrl F4", "close",
+//                 "ctrl F7", "move",
+//                 "ctrl F8", "resize",
+//                   "RIGHT", "right",
+//                "KP_RIGHT", "right",
+//             "shift RIGHT", "shrinkRight",
+//          "shift KP_RIGHT", "shrinkRight",
+//                    "LEFT", "left",
+//                 "KP_LEFT", "left",
+//              "shift LEFT", "shrinkLeft",
+//           "shift KP_LEFT", "shrinkLeft",
+//                      "UP", "up",
+//                   "KP_UP", "up",
+//                "shift UP", "shrinkUp",
+//             "shift KP_UP", "shrinkUp",
+//                    "DOWN", "down",
+//                 "KP_DOWN", "down",
+//              "shift DOWN", "shrinkDown",
+//           "shift KP_DOWN", "shrinkDown",
+//                  "ESCAPE", "escape",
+//                 "ctrl F9", "minimize",
+//                "ctrl F10", "maximize",
+//                 "ctrl F6", "selectNextFrame",
+//                "ctrl TAB", "selectNextFrame",
+//             "ctrl alt F6", "selectNextFrame",
+//       "shift ctrl alt F6", "selectPreviousFrame",
+//                "ctrl F12", "navigateNext",
+//          "shift ctrl F12", "navigatePrevious"
+//              }),
+//
+//            // *** Label
+//            "Label.font", dialogPlain12,
+//            "Label.background", control,
+//            "Label.foreground", controlText,
+//            "Label.disabledForeground", white,
+//            "Label.disabledShadow", controlShadow,
+//            "Label.border", null,
+//
+//            // *** List
+//            "List.font", dialogPlain12,
+//            "List.background", window,
+//            "List.foreground", textText,
+//            "List.selectionBackground", textHighlight,
+//            "List.selectionForeground", textHighlightText,
+//            "List.noFocusBorder", noFocusBorder,
+//            "List.focusCellHighlightBorder", focusCellHighlightBorder,
+//            "List.dropLineColor", controlShadow,
+//            "List.border", null,
+//            "List.cellRenderer", listCellRendererActiveValue,
+//            "List.timeFactor", oneThousand,
+//            "List.focusInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                           "ctrl C", "copy",
+//                           "ctrl V", "paste",
+//                           "ctrl X", "cut",
+//                             "COPY", "copy",
+//                            "PASTE", "paste",
+//                              "CUT", "cut",
+//                   "control INSERT", "copy",
+//                     "shift INSERT", "paste",
+//                     "shift DELETE", "cut",
+//                               "UP", "selectPreviousRow",
+//                            "KP_UP", "selectPreviousRow",
+//                         "shift UP", "selectPreviousRowExtendSelection",
+//                      "shift KP_UP", "selectPreviousRowExtendSelection",
+//                    "ctrl shift UP", "selectPreviousRowExtendSelection",
+//                 "ctrl shift KP_UP", "selectPreviousRowExtendSelection",
+//                          "ctrl UP", "selectPreviousRowChangeLead",
+//                       "ctrl KP_UP", "selectPreviousRowChangeLead",
+//                             "DOWN", "selectNextRow",
+//                          "KP_DOWN", "selectNextRow",
+//                       "shift DOWN", "selectNextRowExtendSelection",
+//                    "shift KP_DOWN", "selectNextRowExtendSelection",
+//                  "ctrl shift DOWN", "selectNextRowExtendSelection",
+//               "ctrl shift KP_DOWN", "selectNextRowExtendSelection",
+//                        "ctrl DOWN", "selectNextRowChangeLead",
+//                     "ctrl KP_DOWN", "selectNextRowChangeLead",
+//                             "LEFT", "selectPreviousColumn",
+//                          "KP_LEFT", "selectPreviousColumn",
+//                       "shift LEFT", "selectPreviousColumnExtendSelection",
+//                    "shift KP_LEFT", "selectPreviousColumnExtendSelection",
+//                  "ctrl shift LEFT", "selectPreviousColumnExtendSelection",
+//               "ctrl shift KP_LEFT", "selectPreviousColumnExtendSelection",
+//                        "ctrl LEFT", "selectPreviousColumnChangeLead",
+//                     "ctrl KP_LEFT", "selectPreviousColumnChangeLead",
+//                            "RIGHT", "selectNextColumn",
+//                         "KP_RIGHT", "selectNextColumn",
+//                      "shift RIGHT", "selectNextColumnExtendSelection",
+//                   "shift KP_RIGHT", "selectNextColumnExtendSelection",
+//                 "ctrl shift RIGHT", "selectNextColumnExtendSelection",
+//              "ctrl shift KP_RIGHT", "selectNextColumnExtendSelection",
+//                       "ctrl RIGHT", "selectNextColumnChangeLead",
+//                    "ctrl KP_RIGHT", "selectNextColumnChangeLead",
+//                             "HOME", "selectFirstRow",
+//                       "shift HOME", "selectFirstRowExtendSelection",
+//                  "ctrl shift HOME", "selectFirstRowExtendSelection",
+//                        "ctrl HOME", "selectFirstRowChangeLead",
+//                              "END", "selectLastRow",
+//                        "shift END", "selectLastRowExtendSelection",
+//                   "ctrl shift END", "selectLastRowExtendSelection",
+//                         "ctrl END", "selectLastRowChangeLead",
+//                          "PAGE_UP", "scrollUp",
+//                    "shift PAGE_UP", "scrollUpExtendSelection",
+//               "ctrl shift PAGE_UP", "scrollUpExtendSelection",
+//                     "ctrl PAGE_UP", "scrollUpChangeLead",
+//                        "PAGE_DOWN", "scrollDown",
+//                  "shift PAGE_DOWN", "scrollDownExtendSelection",
+//             "ctrl shift PAGE_DOWN", "scrollDownExtendSelection",
+//                   "ctrl PAGE_DOWN", "scrollDownChangeLead",
+//                           "ctrl A", "selectAll",
+//                       "ctrl SLASH", "selectAll",
+//                  "ctrl BACK_SLASH", "clearSelection",
+//                            "SPACE", "addToSelection",
+//                       "ctrl SPACE", "toggleAndAnchor",
+//                      "shift SPACE", "extendTo",
+//                 "ctrl shift SPACE", "moveSelectionTo"
+//                 }),
+//            "List.focusInputMap.RightToLeft",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                             "LEFT", "selectNextColumn",
+//                          "KP_LEFT", "selectNextColumn",
+//                       "shift LEFT", "selectNextColumnExtendSelection",
+//                    "shift KP_LEFT", "selectNextColumnExtendSelection",
+//                  "ctrl shift LEFT", "selectNextColumnExtendSelection",
+//               "ctrl shift KP_LEFT", "selectNextColumnExtendSelection",
+//                        "ctrl LEFT", "selectNextColumnChangeLead",
+//                     "ctrl KP_LEFT", "selectNextColumnChangeLead",
+//                            "RIGHT", "selectPreviousColumn",
+//                         "KP_RIGHT", "selectPreviousColumn",
+//                      "shift RIGHT", "selectPreviousColumnExtendSelection",
+//                   "shift KP_RIGHT", "selectPreviousColumnExtendSelection",
+//                 "ctrl shift RIGHT", "selectPreviousColumnExtendSelection",
+//              "ctrl shift KP_RIGHT", "selectPreviousColumnExtendSelection",
+//                       "ctrl RIGHT", "selectPreviousColumnChangeLead",
+//                    "ctrl KP_RIGHT", "selectPreviousColumnChangeLead",
+//                 }),
+//
+//            // *** Menus
+//            "MenuBar.font", dialogPlain12,
+//            "MenuBar.background", menu,
+//            "MenuBar.foreground", menuText,
+//            "MenuBar.shadow", controlShadow,
+//            "MenuBar.highlight", controlLtHighlight,
+//            "MenuBar.border", menuBarBorder,
+//            "MenuBar.windowBindings", new Object[] {
+//                "F10", "takeFocus" },
+//
+//            "MenuItem.font", dialogPlain12,
+//            "MenuItem.acceleratorFont", dialogPlain12,
+//            "MenuItem.background", menu,
+//            "MenuItem.foreground", menuText,
+//            "MenuItem.selectionForeground", textHighlightText,
+//            "MenuItem.selectionBackground", textHighlight,
+//            "MenuItem.disabledForeground", null,
+//            "MenuItem.acceleratorForeground", menuText,
+//            "MenuItem.acceleratorSelectionForeground", textHighlightText,
+//            "MenuItem.acceleratorDelimiter", menuItemAcceleratorDelimiter,
+//            "MenuItem.border", marginBorder,
+//            "MenuItem.borderPainted", Boolean.FALSE,
+//            "MenuItem.margin", twoInsets,
+//            "MenuItem.checkIcon", menuItemCheckIcon,
+//            "MenuItem.arrowIcon", menuItemArrowIcon,
+//            "MenuItem.commandSound", null,
+//
+//            "RadioButtonMenuItem.font", dialogPlain12,
+//            "RadioButtonMenuItem.acceleratorFont", dialogPlain12,
+//            "RadioButtonMenuItem.background", menu,
+//            "RadioButtonMenuItem.foreground", menuText,
+//            "RadioButtonMenuItem.selectionForeground", textHighlightText,
+//            "RadioButtonMenuItem.selectionBackground", textHighlight,
+//            "RadioButtonMenuItem.disabledForeground", null,
+//            "RadioButtonMenuItem.acceleratorForeground", menuText,
+//            "RadioButtonMenuItem.acceleratorSelectionForeground", textHighlightText,
+//            "RadioButtonMenuItem.border", marginBorder,
+//            "RadioButtonMenuItem.borderPainted", Boolean.FALSE,
+//            "RadioButtonMenuItem.margin", twoInsets,
+//            "RadioButtonMenuItem.checkIcon", radioButtonMenuItemIcon,
+//            "RadioButtonMenuItem.arrowIcon", menuItemArrowIcon,
+//            "RadioButtonMenuItem.commandSound", null,
+//
+//            "CheckBoxMenuItem.font", dialogPlain12,
+//            "CheckBoxMenuItem.acceleratorFont", dialogPlain12,
+//            "CheckBoxMenuItem.background", menu,
+//            "CheckBoxMenuItem.foreground", menuText,
+//            "CheckBoxMenuItem.selectionForeground", textHighlightText,
+//            "CheckBoxMenuItem.selectionBackground", textHighlight,
+//            "CheckBoxMenuItem.disabledForeground", null,
+//            "CheckBoxMenuItem.acceleratorForeground", menuText,
+//            "CheckBoxMenuItem.acceleratorSelectionForeground", textHighlightText,
+//            "CheckBoxMenuItem.border", marginBorder,
+//            "CheckBoxMenuItem.borderPainted", Boolean.FALSE,
+//            "CheckBoxMenuItem.margin", twoInsets,
+//            "CheckBoxMenuItem.checkIcon", checkBoxMenuItemIcon,
+//            "CheckBoxMenuItem.arrowIcon", menuItemArrowIcon,
+//            "CheckBoxMenuItem.commandSound", null,
+//
+//            "Menu.font", dialogPlain12,
+//            "Menu.acceleratorFont", dialogPlain12,
+//            "Menu.background", menu,
+//            "Menu.foreground", menuText,
+//            "Menu.selectionForeground", textHighlightText,
+//            "Menu.selectionBackground", textHighlight,
+//            "Menu.disabledForeground", null,
+//            "Menu.acceleratorForeground", menuText,
+//            "Menu.acceleratorSelectionForeground", textHighlightText,
+//            "Menu.border", marginBorder,
+//            "Menu.borderPainted", Boolean.FALSE,
+//            "Menu.margin", twoInsets,
+//            "Menu.checkIcon", menuItemCheckIcon,
+//            "Menu.arrowIcon", menuArrowIcon,
+//            "Menu.menuPopupOffsetX", new Integer(0),
+//            "Menu.menuPopupOffsetY", new Integer(0),
+//            "Menu.submenuPopupOffsetX", new Integer(0),
+//            "Menu.submenuPopupOffsetY", new Integer(0),
+//            "Menu.shortcutKeys", new int[]{
+//                SwingUtilities2.getSystemMnemonicKeyMask()
+//            },
+//            "Menu.crossMenuMnemonic", Boolean.TRUE,
+//            // Menu.cancelMode affects the cancel menu action behaviour;
+//            // currently supports:
+//            // "hideLastSubmenu" (default)
+//            //     hides the last open submenu,
+//            //     and move selection one step back
+//            // "hideMenuTree"
+//            //     resets selection and
+//            //     hide the entire structure of open menu and its submenus
+//            "Menu.cancelMode", "hideLastSubmenu",
+//
+//             // Menu.preserveTopLevelSelection affects
+//             // the cancel menu action behaviour
+//             // if set to true then top level menu selection
+//             // will be preserved when the last popup was cancelled;
+//             // the menu itself will be unselect with the next cancel action
+//             "Menu.preserveTopLevelSelection", Boolean.FALSE,
+//
+//            // PopupMenu
+//            "PopupMenu.font", dialogPlain12,
+//            "PopupMenu.background", menu,
+//            "PopupMenu.foreground", menuText,
+//            "PopupMenu.border", popupMenuBorder,
+//                 // Internal Frame Auditory Cue Mappings
+//            "PopupMenu.popupSound", null,
+//            // These window InputMap bindings are used when the Menu is
+//            // selected.
+//            "PopupMenu.selectedWindowInputMapBindings", new Object[] {
+//                  "ESCAPE", "cancel",
+//                    "DOWN", "selectNext",
+//                 "KP_DOWN", "selectNext",
+//                      "UP", "selectPrevious",
+//                   "KP_UP", "selectPrevious",
+//                    "LEFT", "selectParent",
+//                 "KP_LEFT", "selectParent",
+//                   "RIGHT", "selectChild",
+//                "KP_RIGHT", "selectChild",
+//                   "ENTER", "return",
+//              "ctrl ENTER", "return",
+//                   "SPACE", "return"
+//            },
+//            "PopupMenu.selectedWindowInputMapBindings.RightToLeft", new Object[] {
+//                    "LEFT", "selectChild",
+//                 "KP_LEFT", "selectChild",
+//                   "RIGHT", "selectParent",
+//                "KP_RIGHT", "selectParent",
+//            },
+//            "PopupMenu.consumeEventOnClose", Boolean.FALSE,
+//
+//            // *** OptionPane
+//            // You can additionaly define OptionPane.messageFont which will
+//            // dictate the fonts used for the message, and
+//            // OptionPane.buttonFont, which defines the font for the buttons.
+//            "OptionPane.font", dialogPlain12,
+//            "OptionPane.background", control,
+//            "OptionPane.foreground", controlText,
+//            "OptionPane.messageForeground", controlText,
+//            "OptionPane.border", optionPaneBorder,
+//            "OptionPane.messageAreaBorder", zeroBorder,
+//            "OptionPane.buttonAreaBorder", optionPaneButtonAreaBorder,
+//            "OptionPane.minimumSize", optionPaneMinimumSize,
+//            "OptionPane.errorIcon", SwingUtilities2.makeIcon(getClass(),
+//                                                             BasicLookAndFeel.class,
+//                                                             "icons/Error.gif"),
+//            "OptionPane.informationIcon", SwingUtilities2.makeIcon(getClass(),
+//                                                                   BasicLookAndFeel.class,
+//                                                                   "icons/Inform.gif"),
+//            "OptionPane.warningIcon", SwingUtilities2.makeIcon(getClass(),
+//                                                               BasicLookAndFeel.class,
+//                                                               "icons/Warn.gif"),
+//            "OptionPane.questionIcon", SwingUtilities2.makeIcon(getClass(),
+//                                                                BasicLookAndFeel.class,
+//                                                                "icons/Question.gif"),
+//            "OptionPane.windowBindings", new Object[] {
+//                "ESCAPE", "close" },
+//                 // OptionPane Auditory Cue Mappings
+//            "OptionPane.errorSound", null,
+//            "OptionPane.informationSound", null, // Info and Plain
+//            "OptionPane.questionSound", null,
+//            "OptionPane.warningSound", null,
+//            "OptionPane.buttonClickThreshhold", fiveHundred,
+//
+//            // *** Panel
+//            "Panel.font", dialogPlain12,
+//            "Panel.background", control,
+//            "Panel.foreground", textText,
+//
+//            // *** ProgressBar
+//            "ProgressBar.font", dialogPlain12,
+//            "ProgressBar.foreground",  textHighlight,
+//            "ProgressBar.background", control,
+//            "ProgressBar.selectionForeground", control,
+//            "ProgressBar.selectionBackground", textHighlight,
+//            "ProgressBar.border", progressBarBorder,
+//            "ProgressBar.cellLength", new Integer(1),
+//            "ProgressBar.cellSpacing", zero,
+//            "ProgressBar.repaintInterval", new Integer(50),
+//            "ProgressBar.cycleTime", new Integer(3000),
+//            "ProgressBar.horizontalSize", new DimensionUIResource(146, 12),
+//            "ProgressBar.verticalSize", new DimensionUIResource(12, 146),
+//
+//           // *** Separator
+//            "Separator.shadow", controlShadow,          // DEPRECATED - DO NOT USE!
+//            "Separator.highlight", controlLtHighlight,  // DEPRECATED - DO NOT USE!
+//
+//            "Separator.background", controlLtHighlight,
+//            "Separator.foreground", controlShadow,
+//
+//            // *** ScrollBar/ScrollPane/Viewport
+//            "ScrollBar.background", scrollBarTrack,
+//            "ScrollBar.foreground", control,
+//            "ScrollBar.track", table.get("scrollbar"),
+//            "ScrollBar.trackHighlight", controlDkShadow,
+//            "ScrollBar.thumb", control,
+//            "ScrollBar.thumbHighlight", controlLtHighlight,
+//            "ScrollBar.thumbDarkShadow", controlDkShadow,
+//            "ScrollBar.thumbShadow", controlShadow,
+//            "ScrollBar.border", null,
+//            "ScrollBar.minimumThumbSize", minimumThumbSize,
+//            "ScrollBar.maximumThumbSize", maximumThumbSize,
+//            "ScrollBar.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                       "RIGHT", "positiveUnitIncrement",
+//                    "KP_RIGHT", "positiveUnitIncrement",
+//                        "DOWN", "positiveUnitIncrement",
+//                     "KP_DOWN", "positiveUnitIncrement",
+//                   "PAGE_DOWN", "positiveBlockIncrement",
+//                        "LEFT", "negativeUnitIncrement",
+//                     "KP_LEFT", "negativeUnitIncrement",
+//                          "UP", "negativeUnitIncrement",
+//                       "KP_UP", "negativeUnitIncrement",
+//                     "PAGE_UP", "negativeBlockIncrement",
+//                        "HOME", "minScroll",
+//                         "END", "maxScroll"
+//                 }),
+//            "ScrollBar.ancestorInputMap.RightToLeft",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                       "RIGHT", "negativeUnitIncrement",
+//                    "KP_RIGHT", "negativeUnitIncrement",
+//                        "LEFT", "positiveUnitIncrement",
+//                     "KP_LEFT", "positiveUnitIncrement",
+//                 }),
+//            "ScrollBar.width", new Integer(16),
+//
+//            "ScrollPane.font", dialogPlain12,
+//            "ScrollPane.background", control,
+//            "ScrollPane.foreground", controlText,
+//            "ScrollPane.border", textFieldBorder,
+//            "ScrollPane.viewportBorder", null,
+//            "ScrollPane.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                           "RIGHT", "unitScrollRight",
+//                        "KP_RIGHT", "unitScrollRight",
+//                            "DOWN", "unitScrollDown",
+//                         "KP_DOWN", "unitScrollDown",
+//                            "LEFT", "unitScrollLeft",
+//                         "KP_LEFT", "unitScrollLeft",
+//                              "UP", "unitScrollUp",
+//                           "KP_UP", "unitScrollUp",
+//                         "PAGE_UP", "scrollUp",
+//                       "PAGE_DOWN", "scrollDown",
+//                    "ctrl PAGE_UP", "scrollLeft",
+//                  "ctrl PAGE_DOWN", "scrollRight",
+//                       "ctrl HOME", "scrollHome",
+//                        "ctrl END", "scrollEnd"
+//                 }),
+//            "ScrollPane.ancestorInputMap.RightToLeft",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                    "ctrl PAGE_UP", "scrollRight",
+//                  "ctrl PAGE_DOWN", "scrollLeft",
+//                 }),
+//
+//            "Viewport.font", dialogPlain12,
+//            "Viewport.background", control,
+//            "Viewport.foreground", textText,
+//
+//            // *** Slider
+//            "Slider.font", dialogPlain12,
+//            "Slider.foreground", control,
+//            "Slider.background", control,
+//            "Slider.highlight", controlLtHighlight,
+//            "Slider.tickColor", Color.black,
+//            "Slider.shadow", controlShadow,
+//            "Slider.focus", controlDkShadow,
+//            "Slider.border", null,
+//            "Slider.horizontalSize", new Dimension(200, 21),
+//            "Slider.verticalSize", new Dimension(21, 200),
+//            "Slider.minimumHorizontalSize", new Dimension(36, 21),
+//            "Slider.minimumVerticalSize", new Dimension(21, 36),
+//            "Slider.focusInsets", sliderFocusInsets,
+//            "Slider.focusInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                       "RIGHT", "positiveUnitIncrement",
+//                    "KP_RIGHT", "positiveUnitIncrement",
+//                        "DOWN", "negativeUnitIncrement",
+//                     "KP_DOWN", "negativeUnitIncrement",
+//                   "PAGE_DOWN", "negativeBlockIncrement",
+//                        "LEFT", "negativeUnitIncrement",
+//                     "KP_LEFT", "negativeUnitIncrement",
+//                          "UP", "positiveUnitIncrement",
+//                       "KP_UP", "positiveUnitIncrement",
+//                     "PAGE_UP", "positiveBlockIncrement",
+//                        "HOME", "minScroll",
+//                         "END", "maxScroll"
+//                 }),
+//            "Slider.focusInputMap.RightToLeft",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                       "RIGHT", "negativeUnitIncrement",
+//                    "KP_RIGHT", "negativeUnitIncrement",
+//                        "LEFT", "positiveUnitIncrement",
+//                     "KP_LEFT", "positiveUnitIncrement",
+//                 }),
+//            "Slider.onlyLeftMouseButtonDrag", Boolean.TRUE,
+//
+//            // *** Spinner
+//            "Spinner.font", monospacedPlain12,
+//            "Spinner.background", control,
+//            "Spinner.foreground", control,
+//            "Spinner.border", textFieldBorder,
+//            "Spinner.arrowButtonBorder", null,
+//            "Spinner.arrowButtonInsets", null,
+//            "Spinner.arrowButtonSize", new Dimension(16, 5),
+//            "Spinner.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                               "UP", "increment",
+//                            "KP_UP", "increment",
+//                             "DOWN", "decrement",
+//                          "KP_DOWN", "decrement",
+//               }),
+//            "Spinner.editorBorderPainted", Boolean.FALSE,
+//            "Spinner.editorAlignment", JTextField.TRAILING,
+//
+//            // *** SplitPane
+//            "SplitPane.background", control,
+//            "SplitPane.highlight", controlLtHighlight,
+//            "SplitPane.shadow", controlShadow,
+//            "SplitPane.darkShadow", controlDkShadow,
+//            "SplitPane.border", splitPaneBorder,
+//            "SplitPane.dividerSize", new Integer(7),
+//            "SplitPaneDivider.border", splitPaneDividerBorder,
+//            "SplitPaneDivider.draggingColor", darkGray,
+//            "SplitPane.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                        "UP", "negativeIncrement",
+//                      "DOWN", "positiveIncrement",
+//                      "LEFT", "negativeIncrement",
+//                     "RIGHT", "positiveIncrement",
+//                     "KP_UP", "negativeIncrement",
+//                   "KP_DOWN", "positiveIncrement",
+//                   "KP_LEFT", "negativeIncrement",
+//                  "KP_RIGHT", "positiveIncrement",
+//                      "HOME", "selectMin",
+//                       "END", "selectMax",
+//                        "F8", "startResize",
+//                        "F6", "toggleFocus",
+//                  "ctrl TAB", "focusOutForward",
+//            "ctrl shift TAB", "focusOutBackward"
+//                 }),
+//
+//            // *** TabbedPane
+//            "TabbedPane.font", dialogPlain12,
+//            "TabbedPane.background", control,
+//            "TabbedPane.foreground", controlText,
+//            "TabbedPane.highlight", controlLtHighlight,
+//            "TabbedPane.light", controlHighlight,
+//            "TabbedPane.shadow", controlShadow,
+//            "TabbedPane.darkShadow", controlDkShadow,
+//            "TabbedPane.selected", null,
+//            "TabbedPane.focus", controlText,
+//            "TabbedPane.textIconGap", four,
+//
+//            // Causes tabs to be painted on top of the content area border.
+//            // The amount of overlap is then controlled by tabAreaInsets.bottom,
+//            // which is zero by default
+//            "TabbedPane.tabsOverlapBorder", Boolean.FALSE,
+//            "TabbedPane.selectionFollowsFocus", Boolean.TRUE,
+//
+//            "TabbedPane.labelShift", 1,
+//            "TabbedPane.selectedLabelShift", -1,
+//            "TabbedPane.tabInsets", tabbedPaneTabInsets,
+//            "TabbedPane.selectedTabPadInsets", tabbedPaneTabPadInsets,
+//            "TabbedPane.tabAreaInsets", tabbedPaneTabAreaInsets,
+//            "TabbedPane.contentBorderInsets", tabbedPaneContentBorderInsets,
+//            "TabbedPane.tabRunOverlay", new Integer(2),
+//            "TabbedPane.tabsOpaque", Boolean.TRUE,
+//            "TabbedPane.contentOpaque", Boolean.TRUE,
+//            "TabbedPane.focusInputMap",
+//              new UIDefaults.LazyInputMap(new Object[] {
+//                         "RIGHT", "navigateRight",
+//                      "KP_RIGHT", "navigateRight",
+//                          "LEFT", "navigateLeft",
+//                       "KP_LEFT", "navigateLeft",
+//                            "UP", "navigateUp",
+//                         "KP_UP", "navigateUp",
+//                          "DOWN", "navigateDown",
+//                       "KP_DOWN", "navigateDown",
+//                     "ctrl DOWN", "requestFocusForVisibleComponent",
+//                  "ctrl KP_DOWN", "requestFocusForVisibleComponent",
+//                }),
+//            "TabbedPane.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                   "ctrl PAGE_DOWN", "navigatePageDown",
+//                     "ctrl PAGE_UP", "navigatePageUp",
+//                          "ctrl UP", "requestFocus",
+//                       "ctrl KP_UP", "requestFocus",
+//                 }),
+//
+//
+//            // *** Table
+//            "Table.font", dialogPlain12,
+//            "Table.foreground", controlText,  // cell text color
+//            "Table.background", window,  // cell background color
+//            "Table.selectionForeground", textHighlightText,
+//            "Table.selectionBackground", textHighlight,
+//            "Table.dropLineColor", controlShadow,
+//            "Table.dropLineShortColor", black,
+//            "Table.gridColor", gray,  // grid line color
+//            "Table.focusCellBackground", window,
+//            "Table.focusCellForeground", controlText,
+//            "Table.focusCellHighlightBorder", focusCellHighlightBorder,
+//            "Table.scrollPaneBorder", loweredBevelBorder,
+//            "Table.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                               "ctrl C", "copy",
+//                               "ctrl V", "paste",
+//                               "ctrl X", "cut",
+//                                 "COPY", "copy",
+//                                "PASTE", "paste",
+//                                  "CUT", "cut",
+//                       "control INSERT", "copy",
+//                         "shift INSERT", "paste",
+//                         "shift DELETE", "cut",
+//                                "RIGHT", "selectNextColumn",
+//                             "KP_RIGHT", "selectNextColumn",
+//                          "shift RIGHT", "selectNextColumnExtendSelection",
+//                       "shift KP_RIGHT", "selectNextColumnExtendSelection",
+//                     "ctrl shift RIGHT", "selectNextColumnExtendSelection",
+//                  "ctrl shift KP_RIGHT", "selectNextColumnExtendSelection",
+//                           "ctrl RIGHT", "selectNextColumnChangeLead",
+//                        "ctrl KP_RIGHT", "selectNextColumnChangeLead",
+//                                 "LEFT", "selectPreviousColumn",
+//                              "KP_LEFT", "selectPreviousColumn",
+//                           "shift LEFT", "selectPreviousColumnExtendSelection",
+//                        "shift KP_LEFT", "selectPreviousColumnExtendSelection",
+//                      "ctrl shift LEFT", "selectPreviousColumnExtendSelection",
+//                   "ctrl shift KP_LEFT", "selectPreviousColumnExtendSelection",
+//                            "ctrl LEFT", "selectPreviousColumnChangeLead",
+//                         "ctrl KP_LEFT", "selectPreviousColumnChangeLead",
+//                                 "DOWN", "selectNextRow",
+//                              "KP_DOWN", "selectNextRow",
+//                           "shift DOWN", "selectNextRowExtendSelection",
+//                        "shift KP_DOWN", "selectNextRowExtendSelection",
+//                      "ctrl shift DOWN", "selectNextRowExtendSelection",
+//                   "ctrl shift KP_DOWN", "selectNextRowExtendSelection",
+//                            "ctrl DOWN", "selectNextRowChangeLead",
+//                         "ctrl KP_DOWN", "selectNextRowChangeLead",
+//                                   "UP", "selectPreviousRow",
+//                                "KP_UP", "selectPreviousRow",
+//                             "shift UP", "selectPreviousRowExtendSelection",
+//                          "shift KP_UP", "selectPreviousRowExtendSelection",
+//                        "ctrl shift UP", "selectPreviousRowExtendSelection",
+//                     "ctrl shift KP_UP", "selectPreviousRowExtendSelection",
+//                              "ctrl UP", "selectPreviousRowChangeLead",
+//                           "ctrl KP_UP", "selectPreviousRowChangeLead",
+//                                 "HOME", "selectFirstColumn",
+//                           "shift HOME", "selectFirstColumnExtendSelection",
+//                      "ctrl shift HOME", "selectFirstRowExtendSelection",
+//                            "ctrl HOME", "selectFirstRow",
+//                                  "END", "selectLastColumn",
+//                            "shift END", "selectLastColumnExtendSelection",
+//                       "ctrl shift END", "selectLastRowExtendSelection",
+//                             "ctrl END", "selectLastRow",
+//                              "PAGE_UP", "scrollUpChangeSelection",
+//                        "shift PAGE_UP", "scrollUpExtendSelection",
+//                   "ctrl shift PAGE_UP", "scrollLeftExtendSelection",
+//                         "ctrl PAGE_UP", "scrollLeftChangeSelection",
+//                            "PAGE_DOWN", "scrollDownChangeSelection",
+//                      "shift PAGE_DOWN", "scrollDownExtendSelection",
+//                 "ctrl shift PAGE_DOWN", "scrollRightExtendSelection",
+//                       "ctrl PAGE_DOWN", "scrollRightChangeSelection",
+//                                  "TAB", "selectNextColumnCell",
+//                            "shift TAB", "selectPreviousColumnCell",
+//                                "ENTER", "selectNextRowCell",
+//                          "shift ENTER", "selectPreviousRowCell",
+//                               "ctrl A", "selectAll",
+//                           "ctrl SLASH", "selectAll",
+//                      "ctrl BACK_SLASH", "clearSelection",
+//                               "ESCAPE", "cancel",
+//                                   "F2", "startEditing",
+//                                "SPACE", "addToSelection",
+//                           "ctrl SPACE", "toggleAndAnchor",
+//                          "shift SPACE", "extendTo",
+//                     "ctrl shift SPACE", "moveSelectionTo",
+//                                   "F8", "focusHeader"
+//                 }),
+//            "Table.ancestorInputMap.RightToLeft",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                                "RIGHT", "selectPreviousColumn",
+//                             "KP_RIGHT", "selectPreviousColumn",
+//                          "shift RIGHT", "selectPreviousColumnExtendSelection",
+//                       "shift KP_RIGHT", "selectPreviousColumnExtendSelection",
+//                     "ctrl shift RIGHT", "selectPreviousColumnExtendSelection",
+//                  "ctrl shift KP_RIGHT", "selectPreviousColumnExtendSelection",
+//                           "ctrl RIGHT", "selectPreviousColumnChangeLead",
+//                        "ctrl KP_RIGHT", "selectPreviousColumnChangeLead",
+//                                 "LEFT", "selectNextColumn",
+//                              "KP_LEFT", "selectNextColumn",
+//                           "shift LEFT", "selectNextColumnExtendSelection",
+//                        "shift KP_LEFT", "selectNextColumnExtendSelection",
+//                      "ctrl shift LEFT", "selectNextColumnExtendSelection",
+//                   "ctrl shift KP_LEFT", "selectNextColumnExtendSelection",
+//                            "ctrl LEFT", "selectNextColumnChangeLead",
+//                         "ctrl KP_LEFT", "selectNextColumnChangeLead",
+//                         "ctrl PAGE_UP", "scrollRightChangeSelection",
+//                       "ctrl PAGE_DOWN", "scrollLeftChangeSelection",
+//                   "ctrl shift PAGE_UP", "scrollRightExtendSelection",
+//                 "ctrl shift PAGE_DOWN", "scrollLeftExtendSelection",
+//                 }),
+//            "Table.ascendingSortIcon",  new SwingLazyValue(
+//                     "sun.swing.icon.SortArrowIcon",
+//                     null, new Object[] { Boolean.TRUE,
+//                                          "Table.sortIconColor" }),
+//            "Table.descendingSortIcon",  new SwingLazyValue(
+//                     "sun.swing.icon.SortArrowIcon",
+//                     null, new Object[] { Boolean.FALSE,
+//                                          "Table.sortIconColor" }),
+//            "Table.sortIconColor", controlShadow,
+//
+//            "TableHeader.font", dialogPlain12,
+//            "TableHeader.foreground", controlText, // header text color
+//            "TableHeader.background", control, // header background
+//            "TableHeader.cellBorder", tableHeaderBorder,
+//
+//            // Support for changing the background/border of the currently
+//            // selected header column when the header has the keyboard focus.
+//            "TableHeader.focusCellBackground", table.getColor("text"), // like text component bg
+//            "TableHeader.focusCellForeground", null,
+//            "TableHeader.focusCellBorder", null,
+//            "TableHeader.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                                "SPACE", "toggleSortOrder",
+//                                 "LEFT", "selectColumnToLeft",
+//                              "KP_LEFT", "selectColumnToLeft",
+//                                "RIGHT", "selectColumnToRight",
+//                             "KP_RIGHT", "selectColumnToRight",
+//                             "alt LEFT", "moveColumnLeft",
+//                          "alt KP_LEFT", "moveColumnLeft",
+//                            "alt RIGHT", "moveColumnRight",
+//                         "alt KP_RIGHT", "moveColumnRight",
+//                       "alt shift LEFT", "resizeLeft",
+//                    "alt shift KP_LEFT", "resizeLeft",
+//                      "alt shift RIGHT", "resizeRight",
+//                   "alt shift KP_RIGHT", "resizeRight",
+//                               "ESCAPE", "focusTable",
+//               }),
+//
+//            // *** Text
+//            "TextField.font", sansSerifPlain12,
+//            "TextField.background", window,
+//            "TextField.foreground", textText,
+//            "TextField.shadow", controlShadow,
+//            "TextField.darkShadow", controlDkShadow,
+//            "TextField.light", controlHighlight,
+//            "TextField.highlight", controlLtHighlight,
+//            "TextField.inactiveForeground", textInactiveText,
+//            "TextField.inactiveBackground", control,
+//            "TextField.selectionBackground", textHighlight,
+//            "TextField.selectionForeground", textHighlightText,
+//            "TextField.caretForeground", textText,
+//            "TextField.caretBlinkRate", caretBlinkRate,
+//            "TextField.border", textFieldBorder,
+//            "TextField.margin", zeroInsets,
+//
+//            "FormattedTextField.font", sansSerifPlain12,
+//            "FormattedTextField.background", window,
+//            "FormattedTextField.foreground", textText,
+//            "FormattedTextField.inactiveForeground", textInactiveText,
+//            "FormattedTextField.inactiveBackground", control,
+//            "FormattedTextField.selectionBackground", textHighlight,
+//            "FormattedTextField.selectionForeground", textHighlightText,
+//            "FormattedTextField.caretForeground", textText,
+//            "FormattedTextField.caretBlinkRate", caretBlinkRate,
+//            "FormattedTextField.border", textFieldBorder,
+//            "FormattedTextField.margin", zeroInsets,
+//            "FormattedTextField.focusInputMap",
+//              new UIDefaults.LazyInputMap(new Object[] {
+//                           "ctrl C", DefaultEditorKit.copyAction,
+//                           "ctrl V", DefaultEditorKit.pasteAction,
+//                           "ctrl X", DefaultEditorKit.cutAction,
+//                             "COPY", DefaultEditorKit.copyAction,
+//                            "PASTE", DefaultEditorKit.pasteAction,
+//                              "CUT", DefaultEditorKit.cutAction,
+//                   "control INSERT", DefaultEditorKit.copyAction,
+//                     "shift INSERT", DefaultEditorKit.pasteAction,
+//                     "shift DELETE", DefaultEditorKit.cutAction,
+//                       "shift LEFT", DefaultEditorKit.selectionBackwardAction,
+//                    "shift KP_LEFT", DefaultEditorKit.selectionBackwardAction,
+//                      "shift RIGHT", DefaultEditorKit.selectionForwardAction,
+//                   "shift KP_RIGHT", DefaultEditorKit.selectionForwardAction,
+//                        "ctrl LEFT", DefaultEditorKit.previousWordAction,
+//                     "ctrl KP_LEFT", DefaultEditorKit.previousWordAction,
+//                       "ctrl RIGHT", DefaultEditorKit.nextWordAction,
+//                    "ctrl KP_RIGHT", DefaultEditorKit.nextWordAction,
+//                  "ctrl shift LEFT", DefaultEditorKit.selectionPreviousWordAction,
+//               "ctrl shift KP_LEFT", DefaultEditorKit.selectionPreviousWordAction,
+//                 "ctrl shift RIGHT", DefaultEditorKit.selectionNextWordAction,
+//              "ctrl shift KP_RIGHT", DefaultEditorKit.selectionNextWordAction,
+//                           "ctrl A", DefaultEditorKit.selectAllAction,
+//                             "HOME", DefaultEditorKit.beginLineAction,
+//                              "END", DefaultEditorKit.endLineAction,
+//                       "shift HOME", DefaultEditorKit.selectionBeginLineAction,
+//                        "shift END", DefaultEditorKit.selectionEndLineAction,
+//                       "BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
+//                 "shift BACK_SPACE", DefaultEditorKit.deletePrevCharAction,
+//                           "ctrl H", DefaultEditorKit.deletePrevCharAction,
+//                           "DELETE", DefaultEditorKit.deleteNextCharAction,
+//                      "ctrl DELETE", DefaultEditorKit.deleteNextWordAction,
+//                  "ctrl BACK_SPACE", DefaultEditorKit.deletePrevWordAction,
+//                            "RIGHT", DefaultEditorKit.forwardAction,
+//                             "LEFT", DefaultEditorKit.backwardAction,
+//                         "KP_RIGHT", DefaultEditorKit.forwardAction,
+//                          "KP_LEFT", DefaultEditorKit.backwardAction,
+//                            "ENTER", JTextField.notifyAction,
+//                  "ctrl BACK_SLASH", "unselect",
+//                  "control shift O", "toggle-componentOrientation",
+//                           "ESCAPE", "reset-field-edit",
+//                               "UP", "increment",
+//                            "KP_UP", "increment",
+//                             "DOWN", "decrement",
+//                          "KP_DOWN", "decrement",
+//              }),
+//
+//            "PasswordField.font", monospacedPlain12,
+//            "PasswordField.background", window,
+//            "PasswordField.foreground", textText,
+//            "PasswordField.inactiveForeground", textInactiveText,
+//            "PasswordField.inactiveBackground", control,
+//            "PasswordField.selectionBackground", textHighlight,
+//            "PasswordField.selectionForeground", textHighlightText,
+//            "PasswordField.caretForeground", textText,
+//            "PasswordField.caretBlinkRate", caretBlinkRate,
+//            "PasswordField.border", textFieldBorder,
+//            "PasswordField.margin", zeroInsets,
+//            "PasswordField.echoChar", '*',
+//
+//            "TextArea.font", monospacedPlain12,
+//            "TextArea.background", window,
+//            "TextArea.foreground", textText,
+//            "TextArea.inactiveForeground", textInactiveText,
+//            "TextArea.selectionBackground", textHighlight,
+//            "TextArea.selectionForeground", textHighlightText,
+//            "TextArea.caretForeground", textText,
+//            "TextArea.caretBlinkRate", caretBlinkRate,
+//            "TextArea.border", marginBorder,
+//            "TextArea.margin", zeroInsets,
+//
+//            "TextPane.font", serifPlain12,
+//            "TextPane.background", white,
+//            "TextPane.foreground", textText,
+//            "TextPane.selectionBackground", textHighlight,
+//            "TextPane.selectionForeground", textHighlightText,
+//            "TextPane.caretForeground", textText,
+//            "TextPane.caretBlinkRate", caretBlinkRate,
+//            "TextPane.inactiveForeground", textInactiveText,
+//            "TextPane.border", marginBorder,
+//            "TextPane.margin", editorMargin,
+//
+//            "EditorPane.font", serifPlain12,
+//            "EditorPane.background", white,
+//            "EditorPane.foreground", textText,
+//            "EditorPane.selectionBackground", textHighlight,
+//            "EditorPane.selectionForeground", textHighlightText,
+//            "EditorPane.caretForeground", textText,
+//            "EditorPane.caretBlinkRate", caretBlinkRate,
+//            "EditorPane.inactiveForeground", textInactiveText,
+//            "EditorPane.border", marginBorder,
+//            "EditorPane.margin", editorMargin,
+//
+//            "html.pendingImage", SwingUtilities2.makeIcon(getClass(),
+//                                    BasicLookAndFeel.class,
+//                                    "icons/image-delayed.png"),
+//            "html.missingImage", SwingUtilities2.makeIcon(getClass(),
+//                                    BasicLookAndFeel.class,
+//                                    "icons/image-failed.png"),
+//            // *** TitledBorder
+//            "TitledBorder.font", dialogPlain12,
+//            "TitledBorder.titleColor", controlText,
+//            "TitledBorder.border", etchedBorder,
+//
+//            // *** ToolBar
+//            "ToolBar.font", dialogPlain12,
+//            "ToolBar.background", control,
+//            "ToolBar.foreground", controlText,
+//            "ToolBar.shadow", controlShadow,
+//            "ToolBar.darkShadow", controlDkShadow,
+//            "ToolBar.light", controlHighlight,
+//            "ToolBar.highlight", controlLtHighlight,
+//            "ToolBar.dockingBackground", control,
+//            "ToolBar.dockingForeground", red,
+//            "ToolBar.floatingBackground", control,
+//            "ToolBar.floatingForeground", darkGray,
+//            "ToolBar.border", etchedBorder,
+//            "ToolBar.separatorSize", toolBarSeparatorSize,
+//            "ToolBar.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                        "UP", "navigateUp",
+//                     "KP_UP", "navigateUp",
+//                      "DOWN", "navigateDown",
+//                   "KP_DOWN", "navigateDown",
+//                      "LEFT", "navigateLeft",
+//                   "KP_LEFT", "navigateLeft",
+//                     "RIGHT", "navigateRight",
+//                  "KP_RIGHT", "navigateRight"
+//                 }),
+//
+//            // *** ToolTips
+//            "ToolTip.font", sansSerifPlain12,
+//            "ToolTip.background", table.get("info"),
+//            "ToolTip.foreground", table.get("infoText"),
+//            "ToolTip.border", blackLineBorder,
+//            // ToolTips also support backgroundInactive, borderInactive,
+//            // and foregroundInactive
+//
+//        // *** ToolTipManager
+//            // ToolTipManager.enableToolTipMode currently supports:
+//            // "allWindows" (default):
+//            //     enables tool tips for all windows of all java applications,
+//            //     whether the windows are active or inactive
+//            // "activeApplication"
+//            //     enables tool tips for windows of an application only when
+//            //     the application has an active window
+//            "ToolTipManager.enableToolTipMode", "allWindows",
+//
+//        // *** Tree
+//            "Tree.paintLines", Boolean.TRUE,
+//            "Tree.lineTypeDashed", Boolean.FALSE,
+//            "Tree.font", dialogPlain12,
+//            "Tree.background", window,
+//            "Tree.foreground", textText,
+//            "Tree.hash", gray,
+//            "Tree.textForeground", textText,
+//            "Tree.textBackground", table.get("text"),
+//            "Tree.selectionForeground", textHighlightText,
+//            "Tree.selectionBackground", textHighlight,
+//            "Tree.selectionBorderColor", black,
+//            "Tree.dropLineColor", controlShadow,
+//            "Tree.editorBorder", blackLineBorder,
+//            "Tree.leftChildIndent", new Integer(7),
+//            "Tree.rightChildIndent", new Integer(13),
+//            "Tree.rowHeight", new Integer(16),
+//            "Tree.scrollsOnExpand", Boolean.TRUE,
+//            "Tree.openIcon", SwingUtilities2.makeIcon(getClass(),
+//                                                      BasicLookAndFeel.class,
+//                                                      "icons/TreeOpen.gif"),
+//            "Tree.closedIcon", SwingUtilities2.makeIcon(getClass(),
+//                                                        BasicLookAndFeel.class,
+//                                                        "icons/TreeClosed.gif"),
+//            "Tree.leafIcon", SwingUtilities2.makeIcon(getClass(),
+//                                                      BasicLookAndFeel.class,
+//                                                      "icons/TreeLeaf.gif"),
+//            "Tree.expandedIcon", null,
+//            "Tree.collapsedIcon", null,
+//            "Tree.changeSelectionWithFocus", Boolean.TRUE,
+//            "Tree.drawsFocusBorderAroundIcon", Boolean.FALSE,
+//            "Tree.timeFactor", oneThousand,
+//            "Tree.focusInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                                 "ctrl C", "copy",
+//                                 "ctrl V", "paste",
+//                                 "ctrl X", "cut",
+//                                   "COPY", "copy",
+//                                  "PASTE", "paste",
+//                                    "CUT", "cut",
+//                         "control INSERT", "copy",
+//                           "shift INSERT", "paste",
+//                           "shift DELETE", "cut",
+//                                     "UP", "selectPrevious",
+//                                  "KP_UP", "selectPrevious",
+//                               "shift UP", "selectPreviousExtendSelection",
+//                            "shift KP_UP", "selectPreviousExtendSelection",
+//                          "ctrl shift UP", "selectPreviousExtendSelection",
+//                       "ctrl shift KP_UP", "selectPreviousExtendSelection",
+//                                "ctrl UP", "selectPreviousChangeLead",
+//                             "ctrl KP_UP", "selectPreviousChangeLead",
+//                                   "DOWN", "selectNext",
+//                                "KP_DOWN", "selectNext",
+//                             "shift DOWN", "selectNextExtendSelection",
+//                          "shift KP_DOWN", "selectNextExtendSelection",
+//                        "ctrl shift DOWN", "selectNextExtendSelection",
+//                     "ctrl shift KP_DOWN", "selectNextExtendSelection",
+//                              "ctrl DOWN", "selectNextChangeLead",
+//                           "ctrl KP_DOWN", "selectNextChangeLead",
+//                                  "RIGHT", "selectChild",
+//                               "KP_RIGHT", "selectChild",
+//                                   "LEFT", "selectParent",
+//                                "KP_LEFT", "selectParent",
+//                                "PAGE_UP", "scrollUpChangeSelection",
+//                          "shift PAGE_UP", "scrollUpExtendSelection",
+//                     "ctrl shift PAGE_UP", "scrollUpExtendSelection",
+//                           "ctrl PAGE_UP", "scrollUpChangeLead",
+//                              "PAGE_DOWN", "scrollDownChangeSelection",
+//                        "shift PAGE_DOWN", "scrollDownExtendSelection",
+//                   "ctrl shift PAGE_DOWN", "scrollDownExtendSelection",
+//                         "ctrl PAGE_DOWN", "scrollDownChangeLead",
+//                                   "HOME", "selectFirst",
+//                             "shift HOME", "selectFirstExtendSelection",
+//                        "ctrl shift HOME", "selectFirstExtendSelection",
+//                              "ctrl HOME", "selectFirstChangeLead",
+//                                    "END", "selectLast",
+//                              "shift END", "selectLastExtendSelection",
+//                         "ctrl shift END", "selectLastExtendSelection",
+//                               "ctrl END", "selectLastChangeLead",
+//                                     "F2", "startEditing",
+//                                 "ctrl A", "selectAll",
+//                             "ctrl SLASH", "selectAll",
+//                        "ctrl BACK_SLASH", "clearSelection",
+//                              "ctrl LEFT", "scrollLeft",
+//                           "ctrl KP_LEFT", "scrollLeft",
+//                             "ctrl RIGHT", "scrollRight",
+//                          "ctrl KP_RIGHT", "scrollRight",
+//                                  "SPACE", "addToSelection",
+//                             "ctrl SPACE", "toggleAndAnchor",
+//                            "shift SPACE", "extendTo",
+//                       "ctrl shift SPACE", "moveSelectionTo"
+//                 }),
+//            "Tree.focusInputMap.RightToLeft",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                                  "RIGHT", "selectParent",
+//                               "KP_RIGHT", "selectParent",
+//                                   "LEFT", "selectChild",
+//                                "KP_LEFT", "selectChild",
+//                 }),
+//            "Tree.ancestorInputMap",
+//               new UIDefaults.LazyInputMap(new Object[] {
+//                     "ESCAPE", "cancel"
+//                 }),
+//            // Bind specific keys that can invoke popup on currently
+//            // focused JComponent
+//            "RootPane.ancestorInputMap",
+//                new UIDefaults.LazyInputMap(new Object[] {
+//                     "shift F10", "postPopup",
+//                  "CONTEXT_MENU", "postPopup"
+//                  }),
+//
+//            // These bindings are only enabled when there is a default
+//            // button set on the rootpane.
+//            "RootPane.defaultButtonWindowKeyBindings", new Object[] {
+//                             "ENTER", "press",
+//                    "released ENTER", "release",
+//                        "ctrl ENTER", "press",
+//               "ctrl released ENTER", "release"
+//              },
+//        };
+//
+//        table.putDefaults(defaults);
+//    }
+
+    static int getFocusAcceleratorKeyMask() {throw new RuntimeException("cf-bug");} //{
+//        Toolkit tk = Toolkit.getDefaultToolkit();
+//        if (tk instanceof SunToolkit) {
+//            return ((SunToolkit)tk).getFocusAcceleratorKeyMask();
+//        }
+//        return ActionEvent.ALT_MASK;
+//    }
 
 
 
@@ -1928,12 +1928,12 @@
      * Returns the ui that is of type <code>klass</code>, or null if
      * one can not be found.
      */
-    static Object getUIOfType(ComponentUI ui, Class klass) {
-        if (klass.isInstance(ui)) {
-            return ui;
-        }
-        return null;
-    }
+    static Object getUIOfType(ComponentUI ui, Class klass) {throw new RuntimeException("cf-bug");} //{
+//        if (klass.isInstance(ui)) {
+//            return ui;
+//        }
+//        return null;
+//    }
 
     // ********* Auditory Cue support methods and objects *********
     // also see the "AuditoryCues" section of the defaults table
@@ -1986,23 +1986,23 @@
      * @see #playSound(Action)
      * @since 1.4
      */
-    protected ActionMap getAudioActionMap() {
-        ActionMap audioActionMap = (ActionMap)UIManager.get(
-                                              "AuditoryCues.actionMap");
-        if (audioActionMap == null) {
-            Object[] acList = (Object[])UIManager.get("AuditoryCues.cueList");
-            if (acList != null) {
-                audioActionMap = new ActionMapUIResource();
-                for(int counter = acList.length-1; counter >= 0; counter--) {
-                    audioActionMap.put(acList[counter],
-                                       createAudioAction(acList[counter]));
-                }
-            }
-            UIManager.getLookAndFeelDefaults().put("AuditoryCues.actionMap",
-                                                   audioActionMap);
-        }
-        return audioActionMap;
-    }
+    protected ActionMap getAudioActionMap() {throw new RuntimeException("cf-bug");} //{
+//        ActionMap audioActionMap = (ActionMap)UIManager.get(
+//                                              "AuditoryCues.actionMap");
+//        if (audioActionMap == null) {
+//            Object[] acList = (Object[])UIManager.get("AuditoryCues.cueList");
+//            if (acList != null) {
+//                audioActionMap = new ActionMapUIResource();
+//                for(int counter = acList.length-1; counter >= 0; counter--) {
+//                    audioActionMap.put(acList[counter],
+//                                       createAudioAction(acList[counter]));
+//                }
+//            }
+//            UIManager.getLookAndFeelDefaults().put("AuditoryCues.actionMap",
+//                                                   audioActionMap);
+//        }
+//        return audioActionMap;
+//    }
 
     /**
      * Creates and returns an {@code Action} used to play a sound.
@@ -2020,15 +2020,15 @@
      * @see #playSound(Action)
      * @since 1.4
      */
-    protected Action createAudioAction(Object key) {
-        if (key != null) {
-            String audioKey = (String)key;
-            String audioValue = (String)UIManager.get(key);
-            return new AudioAction(audioKey, audioValue);
-        } else {
-            return null;
-        }
-    }
+    protected Action createAudioAction(Object key) {throw new RuntimeException("cf-bug");} //{
+//        if (key != null) {
+//            String audioKey = (String)key;
+//            String audioValue = (String)UIManager.get(key);
+//            return new AudioAction(audioKey, audioValue);
+//        } else {
+//            return null;
+//        }
+//    }
 
     /**
      * Pass the name String to the super constructor. This is used
@@ -2057,56 +2057,56 @@
             audioResource = resource;
         }
 
-        public void actionPerformed(ActionEvent e) {
-            if (audioBuffer == null) {
-                audioBuffer = loadAudioData(audioResource);
-            }
-            if (audioBuffer != null) {
-                cancelCurrentSound(null);
-                try {
-                    AudioInputStream soundStream =
-                        AudioSystem.getAudioInputStream(
-                            new ByteArrayInputStream(audioBuffer));
-                    DataLine.Info info =
-                        new DataLine.Info(Clip.class, soundStream.getFormat());
-                    Clip clip = (Clip) AudioSystem.getLine(info);
-                    clip.open(soundStream);
-                    clip.addLineListener(this);
-
-                    synchronized(audioLock) {
-                        clipPlaying = clip;
-                    }
-
-                    clip.start();
-                } catch (Exception ex) {}
-            }
-        }
-
-        public void update(LineEvent event) {
-            if (event.getType() == LineEvent.Type.STOP) {
-                cancelCurrentSound((Clip)event.getLine());
-            }
-        }
+        public void actionPerformed(ActionEvent e) {throw new RuntimeException("cf-bug");} //{
+//            if (audioBuffer == null) {
+//                audioBuffer = loadAudioData(audioResource);
+//            }
+//            if (audioBuffer != null) {
+//                cancelCurrentSound(null);
+//                try {
+//                    AudioInputStream soundStream =
+//                        AudioSystem.getAudioInputStream(
+//                            new ByteArrayInputStream(audioBuffer));
+//                    DataLine.Info info =
+//                        new DataLine.Info(Clip.class, soundStream.getFormat());
+//                    Clip clip = (Clip) AudioSystem.getLine(info);
+//                    clip.open(soundStream);
+//                    clip.addLineListener(this);
+//
+//                    synchronized(audioLock) {
+//                        clipPlaying = clip;
+//                    }
+//
+//                    clip.start();
+//                } catch (Exception ex) {}
+//            }
+//        }
+
+        public void update(LineEvent event) {throw new RuntimeException("cf-bug");} //{
+//            if (event.getType() == LineEvent.Type.STOP) {
+//                cancelCurrentSound((Clip)event.getLine());
+//            }
+//        }
 
         /**
          * If the parameter is null, or equal to the currently
          * playing sound, then cancel the currently playing sound.
          */
-        private void cancelCurrentSound(Clip clip) {
-            Clip lastClip = null;
-
-            synchronized(audioLock) {
-                if (clip == null || clip == clipPlaying) {
-                    lastClip = clipPlaying;
-                    clipPlaying = null;
-                }
-            }
-
-            if (lastClip != null) {
-                lastClip.removeLineListener(this);
-                lastClip.close();
-            }
-        }
+        private void cancelCurrentSound(Clip clip) {throw new RuntimeException("cf-bug");} //{
+//            Clip lastClip = null;
+//
+//            synchronized(audioLock) {
+//                if (clip == null || clip == clipPlaying) {
+//                    lastClip = clipPlaying;
+//                    clipPlaying = null;
+//                }
+//            }
+//
+//            if (lastClip != null) {
+//                lastClip.removeLineListener(this);
+//                lastClip.close();
+//            }
+//        }
     }
 
     /**
@@ -2121,57 +2121,57 @@
      * @return             A byte[] with audio data or null
      * @since 1.4
      */
-    private byte[] loadAudioData(final String soundFile){
-        if (soundFile == null) {
-            return null;
-        }
-        /* Copy resource into a byte array.  This is
-         * necessary because several browsers consider
-         * Class.getResource a security risk since it
-         * can be used to load additional classes.
-         * Class.getResourceAsStream just returns raw
-         * bytes, which we can convert to a sound.
-         */
-        byte[] buffer = AccessController.doPrivileged(
-                                                 new PrivilegedAction<byte[]>() {
-                public byte[] run() {
-                    try {
-                        InputStream resource = BasicLookAndFeel.this.
-                            getClass().getResourceAsStream(soundFile);
-                        if (resource == null) {
-                            return null;
-                        }
-                        BufferedInputStream in =
-                            new BufferedInputStream(resource);
-                        ByteArrayOutputStream out =
-                            new ByteArrayOutputStream(1024);
-                        byte[] buffer = new byte[1024];
-                        int n;
-                        while ((n = in.read(buffer)) > 0) {
-                            out.write(buffer, 0, n);
-                        }
-                        in.close();
-                        out.flush();
-                        buffer = out.toByteArray();
-                        return buffer;
-                    } catch (IOException ioe) {
-                        System.err.println(ioe.toString());
-                        return null;
-                    }
-                }
-            });
-        if (buffer == null) {
-            System.err.println(getClass().getName() + "/" +
-                               soundFile + " not found.");
-            return null;
-        }
-        if (buffer.length == 0) {
-            System.err.println("warning: " + soundFile +
-                               " is zero-length");
-            return null;
-        }
-        return buffer;
-    }
+    private byte[] loadAudioData(final String soundFile){throw new RuntimeException("cf-bug");} //{
+//        if (soundFile == null) {
+//            return null;
+//        }
+//        /* Copy resource into a byte array.  This is
+//         * necessary because several browsers consider
+//         * Class.getResource a security risk since it
+//         * can be used to load additional classes.
+//         * Class.getResourceAsStream just returns raw
+//         * bytes, which we can convert to a sound.
+//         */
+//        byte[] buffer = AccessController.doPrivileged(
+//                                                 new PrivilegedAction<byte[]>() {
+//                public byte[] run() {
+//                    try {
+//                        InputStream resource = BasicLookAndFeel.this.
+//                            getClass().getResourceAsStream(soundFile);
+//                        if (resource == null) {
+//                            return null;
+//                        }
+//                        BufferedInputStream in =
+//                            new BufferedInputStream(resource);
+//                        ByteArrayOutputStream out =
+//                            new ByteArrayOutputStream(1024);
+//                        byte[] buffer = new byte[1024];
+//                        int n;
+//                        while ((n = in.read(buffer)) > 0) {
+//                            out.write(buffer, 0, n);
+//                        }
+//                        in.close();
+//                        out.flush();
+//                        buffer = out.toByteArray();
+//                        return buffer;
+//                    } catch (IOException ioe) {
+//                        System.err.println(ioe.toString());
+//                        return null;
+//                    }
+//                }
+//            });
+//        if (buffer == null) {
+//            System.err.println(getClass().getName() + "/" +
+//                               soundFile + " not found.");
+//            return null;
+//        }
+//        if (buffer.length == 0) {
+//            System.err.println("warning: " + soundFile +
+//                               " is zero-length");
+//            return null;
+//        }
+//        return buffer;
+//    }
 
     /**
      * If necessary, invokes {@code actionPerformed} on
@@ -2190,39 +2190,39 @@
      *         is not an {@code Object[]}
      * @since 1.4
      */
-    protected void playSound(Action audioAction) {
-        if (audioAction != null) {
-            Object[] audioStrings = (Object[])
-                                    UIManager.get("AuditoryCues.playList");
-            if (audioStrings != null) {
-                // create a HashSet to help us decide to play or not
-                HashSet<Object> audioCues = new HashSet<Object>();
-                for (Object audioString : audioStrings) {
-                    audioCues.add(audioString);
-                }
-                // get the name of the Action
-                String actionName = (String)audioAction.getValue(Action.NAME);
-                // if the actionName is in the audioCues HashSet, play it.
-                if (audioCues.contains(actionName)) {
-                    audioAction.actionPerformed(new
-                        ActionEvent(this, ActionEvent.ACTION_PERFORMED,
-                                    actionName));
-                }
-            }
-        }
-    }
+    protected void playSound(Action audioAction) {throw new RuntimeException("cf-bug");} //{
+//        if (audioAction != null) {
+//            Object[] audioStrings = (Object[])
+//                                    UIManager.get("AuditoryCues.playList");
+//            if (audioStrings != null) {
+//                // create a HashSet to help us decide to play or not
+//                HashSet<Object> audioCues = new HashSet<Object>();
+//                for (Object audioString : audioStrings) {
+//                    audioCues.add(audioString);
+//                }
+//                // get the name of the Action
+//                String actionName = (String)audioAction.getValue(Action.NAME);
+//                // if the actionName is in the audioCues HashSet, play it.
+//                if (audioCues.contains(actionName)) {
+//                    audioAction.actionPerformed(new
+//                        ActionEvent(this, ActionEvent.ACTION_PERFORMED,
+//                                    actionName));
+//                }
+//            }
+//        }
+//    }
 
 
     /**
      * Sets the parent of the passed in ActionMap to be the audio action
      * map.
      */
-    static void installAudioActionMap(ActionMap map) {
-        LookAndFeel laf = UIManager.getLookAndFeel();
-        if (laf instanceof BasicLookAndFeel) {
-            map.setParent(((BasicLookAndFeel)laf).getAudioActionMap());
-        }
-    }
+    static void installAudioActionMap(ActionMap map) {throw new RuntimeException("cf-bug");} //{
+//        LookAndFeel laf = UIManager.getLookAndFeel();
+//        if (laf instanceof BasicLookAndFeel) {
+//            map.setParent(((BasicLookAndFeel)laf).getAudioActionMap());
+//        }
+//    }
 
 
     /**
@@ -2231,19 +2231,19 @@
      * @param c JComponent to play the sound for.
      * @param actionKey Key for the sound.
      */
-    static void playSound(JComponent c, Object actionKey) {
-        LookAndFeel laf = UIManager.getLookAndFeel();
-        if (laf instanceof BasicLookAndFeel) {
-            ActionMap map = c.getActionMap();
-            if (map != null) {
-                Action audioAction = map.get(actionKey);
-                if (audioAction != null) {
-                    // pass off firing the Action to a utility method
-                    ((BasicLookAndFeel)laf).playSound(audioAction);
-                }
-            }
-        }
-    }
+    static void playSound(JComponent c, Object actionKey) {throw new RuntimeException("cf-bug");} //{
+//        LookAndFeel laf = UIManager.getLookAndFeel();
+//        if (laf instanceof BasicLookAndFeel) {
+//            ActionMap map = c.getActionMap();
+//            if (map != null) {
+//                Action audioAction = map.get(actionKey);
+//                if (audioAction != null) {
+//                    // pass off firing the Action to a utility method
+//                    ((BasicLookAndFeel)laf).playSound(audioAction);
+//                }
+//            }
+//        }
+//    }
 
     /**
      * This class contains listener that watches for all the mouse
@@ -2255,72 +2255,72 @@
             AccessController.doPrivileged(this);
         }
 
-        public Object run() {
-            Toolkit tk = Toolkit.getDefaultToolkit();
-            if(invocator == null) {
-                tk.addAWTEventListener(this, AWTEvent.MOUSE_EVENT_MASK);
-            } else {
-                tk.removeAWTEventListener(invocator);
-            }
-            // Return value not used.
-            return null;
-        }
-
-        public void eventDispatched(AWTEvent ev) {
-            int eventID = ev.getID();
-            if((eventID & AWTEvent.MOUSE_EVENT_MASK) != 0) {
-                MouseEvent me = (MouseEvent) ev;
-                if(me.isPopupTrigger()) {
-                    MenuElement[] elems = MenuSelectionManager
-                            .defaultManager()
-                            .getSelectedPath();
-                    if(elems != null && elems.length != 0) {
-                        return;
-                        // We shall not interfere with already opened menu
-                    }
-                    Object c = me.getSource();
-                    JComponent src = null;
-                    if(c instanceof JComponent) {
-                        src = (JComponent) c;
-                    } else if(c instanceof BasicSplitPaneDivider) {
-                        // Special case - if user clicks on divider we must
-                        // invoke popup from the SplitPane
-                        src = (JComponent)
-                            ((BasicSplitPaneDivider)c).getParent();
-                    }
-                    if(src != null) {
-                        if(src.getComponentPopupMenu() != null) {
-                            Point pt = src.getPopupLocation(me);
-                            if(pt == null) {
-                                pt = me.getPoint();
-                                pt = SwingUtilities.convertPoint((Component)c,
-                                                                  pt, src);
-                            }
-                            src.getComponentPopupMenu().show(src, pt.x, pt.y);
-                            me.consume();
-                        }
-                    }
-                }
-            }
-            /* Activate a JInternalFrame if necessary. */
-            if (eventID == MouseEvent.MOUSE_PRESSED) {
-                Object object = ev.getSource();
-                if (!(object instanceof Component)) {
-                    return;
-                }
-                Component component = (Component)object;
-                if (component != null) {
-                    Component parent = component;
-                    while (parent != null && !(parent instanceof Window)) {
-                        if (parent instanceof JInternalFrame) {
-                            // Activate the frame.
-                            try { ((JInternalFrame)parent).setSelected(true); }
-                            catch (PropertyVetoException e1) { }
-                        }
-                        parent = parent.getParent();
-                    }
-                }
-            }
-        }
+        public Object run() {throw new RuntimeException("cf-bug");} //{
+//            Toolkit tk = Toolkit.getDefaultToolkit();
+//            if(invocator == null) {
+//                tk.addAWTEventListener(this, AWTEvent.MOUSE_EVENT_MASK);
+//            } else {
+//                tk.removeAWTEventListener(invocator);
+//            }
+//            // Return value not used.
+//            return null;
+//        }
+
+        public void eventDispatched(AWTEvent ev) {throw new RuntimeException("cf-bug");} //{
+//            int eventID = ev.getID();
+//            if((eventID & AWTEvent.MOUSE_EVENT_MASK) != 0) {
+//                MouseEvent me = (MouseEvent) ev;
+//                if(me.isPopupTrigger()) {
+//                    MenuElement[] elems = MenuSelectionManager
+//                            .defaultManager()
+//                            .getSelectedPath();
+//                    if(elems != null && elems.length != 0) {
+//                        return;
+//                        // We shall not interfere with already opened menu
+//                    }
+//                    Object c = me.getSource();
+//                    JComponent src = null;
+//                    if(c instanceof JComponent) {
+//                        src = (JComponent) c;
+//                    } else if(c instanceof BasicSplitPaneDivider) {
+//                        // Special case - if user clicks on divider we must
+//                        // invoke popup from the SplitPane
+//                        src = (JComponent)
+//                            ((BasicSplitPaneDivider)c).getParent();
+//                    }
+//                    if(src != null) {
+//                        if(src.getComponentPopupMenu() != null) {
+//                            Point pt = src.getPopupLocation(me);
+//                            if(pt == null) {
+//                                pt = me.getPoint();
+//                                pt = SwingUtilities.convertPoint((Component)c,
+//                                                                  pt, src);
+//                            }
+//                            src.getComponentPopupMenu().show(src, pt.x, pt.y);
+//                            me.consume();
+//                        }
+//                    }
+//                }
+//            }
+//            /* Activate a JInternalFrame if necessary. */
+//            if (eventID == MouseEvent.MOUSE_PRESSED) {
+//                Object object = ev.getSource();
+//                if (!(object instanceof Component)) {
+//                    return;
+//                }
+//                Component component = (Component)object;
+//                if (component != null) {
+//                    Component parent = component;
+//                    while (parent != null && !(parent instanceof Window)) {
+//                        if (parent instanceof JInternalFrame) {
+//                            // Activate the frame.
+//                            try { ((JInternalFrame)parent).setSelected(true); }
+//                            catch (PropertyVetoException e1) { }
+//                        }
+//                        parent = parent.getParent();
+//                    }
+//                }
+//            }
+//        }
     }
 }
--- javax/swing/plaf/basic/BasicTextFieldUI.java	2016-06-22 19:55:15.497869412 -0700
+++ javax/swing/plaf/basic/BasicTextFieldUI.java	2016-06-29 12:32:58.114682566 -0700
@@ -59,9 +59,9 @@
      * @param c the text field
      * @return the UI
      */
-    public static ComponentUI createUI(JComponent c) {
-        return new BasicTextFieldUI();
-    }
+    public static ComponentUI createUI(JComponent c) {throw new RuntimeException("cf-bug");} //{
+//        return new BasicTextFieldUI();
+//    }
 
     /**
      * Creates a new BasicTextFieldUI.
@@ -77,9 +77,9 @@
      *
      * @return the name ("TextField")
      */
-    protected String getPropertyPrefix() {
-        return "TextField";
-    }
+    protected String getPropertyPrefix() {throw new RuntimeException("cf-bug");} //{
+//        return "TextField";
+//    }
 
     /**
      * Creates a view (FieldView) based on an element.
@@ -87,24 +87,24 @@
      * @param elem the element
      * @return the view
      */
-    public View create(Element elem) {
-        Document doc = elem.getDocument();
-        Object i18nFlag = doc.getProperty("i18n"/*AbstractDocument.I18NProperty*/);
-        if (Boolean.TRUE.equals(i18nFlag)) {
-            // To support bidirectional text, we build a more heavyweight
-            // representation of the field.
-            String kind = elem.getName();
-            if (kind != null) {
-                if (kind.equals(AbstractDocument.ContentElementName)) {
-                    return new GlyphView(elem);
-                } else if (kind.equals(AbstractDocument.ParagraphElementName)) {
-                    return new I18nFieldView(elem);
-                }
-            }
-            // this shouldn't happen, should probably throw in this case.
-        }
-        return new FieldView(elem);
-    }
+    public View create(Element elem) {throw new RuntimeException("cf-bug");} //{
+//        Document doc = elem.getDocument();
+//        Object i18nFlag = doc.getProperty("i18n"/*AbstractDocument.I18NProperty*/);
+//        if (Boolean.TRUE.equals(i18nFlag)) {
+//            // To support bidirectional text, we build a more heavyweight
+//            // representation of the field.
+//            String kind = elem.getName();
+//            if (kind != null) {
+//                if (kind.equals(AbstractDocument.ContentElementName)) {
+//                    return new GlyphView(elem);
+//                } else if (kind.equals(AbstractDocument.ParagraphElementName)) {
+//                    return new I18nFieldView(elem);
+//                }
+//            }
+//            // this shouldn't happen, should probably throw in this case.
+//        }
+//        return new FieldView(elem);
+//    }
 
     /**
      * Returns the baseline.
@@ -114,38 +114,38 @@
      * @see javax.swing.JComponent#getBaseline(int, int)
      * @since 1.6
      */
-    public int getBaseline(JComponent c, int width, int height) {
-        super.getBaseline(c, width, height);
-        View rootView = getRootView((JTextComponent)c);
-        if (rootView.getViewCount() > 0) {
-            Insets insets = c.getInsets();
-            height = height - insets.top - insets.bottom;
-            if (height > 0) {
-                int baseline = insets.top;
-                View fieldView = rootView.getView(0);
-                int vspan = (int)fieldView.getPreferredSpan(View.Y_AXIS);
-                if (height != vspan) {
-                    int slop = height - vspan;
-                    baseline += slop / 2;
-                }
-                if (fieldView instanceof I18nFieldView) {
-                    int fieldBaseline = BasicHTML.getBaseline(
-                            fieldView, width - insets.left - insets.right,
-                            height);
-                    if (fieldBaseline < 0) {
-                        return -1;
-                    }
-                    baseline += fieldBaseline;
-                }
-                else {
-                    FontMetrics fm = c.getFontMetrics(c.getFont());
-                    baseline += fm.getAscent();
-                }
-                return baseline;
-            }
-        }
-        return -1;
-    }
+    public int getBaseline(JComponent c, int width, int height) {throw new RuntimeException("cf-bug");} //{
+//        super.getBaseline(c, width, height);
+//        View rootView = getRootView((JTextComponent)c);
+//        if (rootView.getViewCount() > 0) {
+//            Insets insets = c.getInsets();
+//            height = height - insets.top - insets.bottom;
+//            if (height > 0) {
+//                int baseline = insets.top;
+//                View fieldView = rootView.getView(0);
+//                int vspan = (int)fieldView.getPreferredSpan(View.Y_AXIS);
+//                if (height != vspan) {
+//                    int slop = height - vspan;
+//                    baseline += slop / 2;
+//                }
+//                if (fieldView instanceof I18nFieldView) {
+//                    int fieldBaseline = BasicHTML.getBaseline(
+//                            fieldView, width - insets.left - insets.right,
+//                            height);
+//                    if (fieldBaseline < 0) {
+//                        return -1;
+//                    }
+//                    baseline += fieldBaseline;
+//                }
+//                else {
+//                    FontMetrics fm = c.getFontMetrics(c.getFont());
+//                    baseline += fm.getAscent();
+//                }
+//                return baseline;
+//            }
+//        }
+//        return -1;
+//    }
 
     /**
      * Returns an enum indicating how the baseline of the component
@@ -156,10 +156,10 @@
      * @since 1.6
      */
     public Component.BaselineResizeBehavior getBaselineResizeBehavior(
-            JComponent c) {
-        super.getBaselineResizeBehavior(c);
-        return Component.BaselineResizeBehavior.CENTER_OFFSET;
-    }
+            JComponent c) {throw new RuntimeException("cf-bug");} //{
+//        super.getBaselineResizeBehavior(c);
+//        return Component.BaselineResizeBehavior.CENTER_OFFSET;
+//    }
 
 
     /**
@@ -178,18 +178,18 @@
          * a field since it scrolls, so this is implemented to
          * return <code>Integer.MAX_VALUE</code>.
          */
-        public int getFlowSpan(int index) {
-            return Integer.MAX_VALUE;
-        }
-
-        protected void setJustification(int j) {
-            // Justification is done in adjustAllocation(), so disable
-            // ParagraphView's justification handling by doing nothing here.
-        }
-
-        static boolean isLeftToRight( java.awt.Component c ) {
-            return c.getComponentOrientation().isLeftToRight();
-        }
+        public int getFlowSpan(int index) {throw new RuntimeException("cf-bug");} //{
+//            return Integer.MAX_VALUE;
+//        }
+
+        protected void setJustification(int j) {throw new RuntimeException("cf-bug");} //{
+//            // Justification is done in adjustAllocation(), so disable
+//            // ParagraphView's justification handling by doing nothing here.
+//        }
+
+        static boolean isLeftToRight( java.awt.Component c ) {throw new RuntimeException("cf-bug");} //{
+//            return c.getComponentOrientation().isLeftToRight();
+//        }
 
         /**
          * Adjusts the allocation given to the view
@@ -205,72 +205,72 @@
          *  to be adjusted.
          * @return the allocation that the superclass should use.
          */
-        Shape adjustAllocation(Shape a) {
-            if (a != null) {
-                Rectangle bounds = a.getBounds();
-                int vspan = (int) getPreferredSpan(Y_AXIS);
-                int hspan = (int) getPreferredSpan(X_AXIS);
-                if (bounds.height != vspan) {
-                    int slop = bounds.height - vspan;
-                    bounds.y += slop / 2;
-                    bounds.height -= slop;
-                }
-
-                // horizontal adjustments
-                Component c = getContainer();
-                if (c instanceof JTextField) {
-                    JTextField field = (JTextField) c;
-                    BoundedRangeModel vis = field.getHorizontalVisibility();
-                    int max = Math.max(hspan, bounds.width);
-                    int value = vis.getValue();
-                    int extent = Math.min(max, bounds.width - 1);
-                    if ((value + extent) > max) {
-                        value = max - extent;
-                    }
-                    vis.setRangeProperties(value, extent, vis.getMinimum(),
-                                           max, false);
-                    if (hspan < bounds.width) {
-                        // horizontally align the interior
-                        int slop = bounds.width - 1 - hspan;
-
-                        int align = ((JTextField)c).getHorizontalAlignment();
-                        if(isLeftToRight(c)) {
-                            if(align==LEADING) {
-                                align = LEFT;
-                            }
-                            else if(align==TRAILING) {
-                                align = RIGHT;
-                            }
-                        }
-                        else {
-                            if(align==LEADING) {
-                                align = RIGHT;
-                            }
-                            else if(align==TRAILING) {
-                                align = LEFT;
-                            }
-                        }
-
-                        switch (align) {
-                        case SwingConstants.CENTER:
-                            bounds.x += slop / 2;
-                            bounds.width -= slop;
-                            break;
-                        case SwingConstants.RIGHT:
-                            bounds.x += slop;
-                            bounds.width -= slop;
-                            break;
-                        }
-                    } else {
-                        // adjust the allocation to match the bounded range.
-                        bounds.width = hspan;
-                        bounds.x -= vis.getValue();
-                    }
-                }
-                return bounds;
-            }
-            return null;
-        }
+        Shape adjustAllocation(Shape a) {throw new RuntimeException("cf-bug");} //{
+//            if (a != null) {
+//                Rectangle bounds = a.getBounds();
+//                int vspan = (int) getPreferredSpan(Y_AXIS);
+//                int hspan = (int) getPreferredSpan(X_AXIS);
+//                if (bounds.height != vspan) {
+//                    int slop = bounds.height - vspan;
+//                    bounds.y += slop / 2;
+//                    bounds.height -= slop;
+//                }
+//
+//                // horizontal adjustments
+//                Component c = getContainer();
+//                if (c instanceof JTextField) {
+//                    JTextField field = (JTextField) c;
+//                    BoundedRangeModel vis = field.getHorizontalVisibility();
+//                    int max = Math.max(hspan, bounds.width);
+//                    int value = vis.getValue();
+//                    int extent = Math.min(max, bounds.width - 1);
+//                    if ((value + extent) > max) {
+//                        value = max - extent;
+//                    }
+//                    vis.setRangeProperties(value, extent, vis.getMinimum(),
+//                                           max, false);
+//                    if (hspan < bounds.width) {
+//                        // horizontally align the interior
+//                        int slop = bounds.width - 1 - hspan;
+//
+//                        int align = ((JTextField)c).getHorizontalAlignment();
+//                        if(isLeftToRight(c)) {
+//                            if(align==LEADING) {
+//                                align = LEFT;
+//                            }
+//                            else if(align==TRAILING) {
+//                                align = RIGHT;
+//                            }
+//                        }
+//                        else {
+//                            if(align==LEADING) {
+//                                align = RIGHT;
+//                            }
+//                            else if(align==TRAILING) {
+//                                align = LEFT;
+//                            }
+//                        }
+//
+//                        switch (align) {
+//                        case SwingConstants.CENTER:
+//                            bounds.x += slop / 2;
+//                            bounds.width -= slop;
+//                            break;
+//                        case SwingConstants.RIGHT:
+//                            bounds.x += slop;
+//                            bounds.width -= slop;
+//                            break;
+//                        }
+//                    } else {
+//                        // adjust the allocation to match the bounded range.
+//                        bounds.width = hspan;
+//                        bounds.x -= vis.getValue();
+//                    }
+//                }
+//                return bounds;
+//            }
+//            return null;
+//        }
 
         /**
          * Update the visibility model with the associated JTextField
@@ -280,24 +280,24 @@
          * shown the extent will be zero and we just set it to be full
          * until determined otherwise.
          */
-        void updateVisibilityModel() {
-            Component c = getContainer();
-            if (c instanceof JTextField) {
-                JTextField field = (JTextField) c;
-                BoundedRangeModel vis = field.getHorizontalVisibility();
-                int hspan = (int) getPreferredSpan(X_AXIS);
-                int extent = vis.getExtent();
-                int maximum = Math.max(hspan, extent);
-                extent = (extent == 0) ? maximum : extent;
-                int value = maximum - extent;
-                int oldValue = vis.getValue();
-                if ((oldValue + extent) > maximum) {
-                    oldValue = maximum - extent;
-                }
-                value = Math.max(0, Math.min(value, oldValue));
-                vis.setRangeProperties(value, extent, 0, maximum, false);
-            }
-        }
+        void updateVisibilityModel() {throw new RuntimeException("cf-bug");} //{
+//            Component c = getContainer();
+//            if (c instanceof JTextField) {
+//                JTextField field = (JTextField) c;
+//                BoundedRangeModel vis = field.getHorizontalVisibility();
+//                int hspan = (int) getPreferredSpan(X_AXIS);
+//                int extent = vis.getExtent();
+//                int maximum = Math.max(hspan, extent);
+//                extent = (extent == 0) ? maximum : extent;
+//                int value = maximum - extent;
+//                int oldValue = vis.getValue();
+//                if ((oldValue + extent) > maximum) {
+//                    oldValue = maximum - extent;
+//                }
+//                value = Math.max(0, Math.min(value, oldValue));
+//                vis.setRangeProperties(value, extent, 0, maximum, false);
+//            }
+//        }
 
         // --- View methods -------------------------------------------
 
@@ -311,11 +311,11 @@
          *
          * @see View#paint
          */
-        public void paint(Graphics g, Shape a) {
-            Rectangle r = (Rectangle) a;
-            g.clipRect(r.x, r.y, r.width, r.height);
-            super.paint(g, adjustAllocation(a));
-        }
+        public void paint(Graphics g, Shape a) {throw new RuntimeException("cf-bug");} //{
+//            Rectangle r = (Rectangle) a;
+//            g.clipRect(r.x, r.y, r.width, r.height);
+//            super.paint(g, adjustAllocation(a));
+//        }
 
         /**
          * Determines the resizability of the view along the
@@ -324,12 +324,12 @@
          * @param axis View.X_AXIS or View.Y_AXIS
          * @return the weight -> 1 for View.X_AXIS, else 0
          */
-        public int getResizeWeight(int axis) {
-            if (axis == View.X_AXIS) {
-                return 1;
-            }
-            return 0;
-        }
+        public int getResizeWeight(int axis) {throw new RuntimeException("cf-bug");} //{
+//            if (axis == View.X_AXIS) {
+//                return 1;
+//            }
+//            return 0;
+//        }
 
         /**
          * Provides a mapping from the document model coordinate space
@@ -342,9 +342,9 @@
          *   represent a valid location in the associated document
          * @see View#modelToView
          */
-        public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
-            return super.modelToView(pos, adjustAllocation(a), b);
-        }
+        public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {throw new RuntimeException("cf-bug");} //{
+//            return super.modelToView(pos, adjustAllocation(a), b);
+//        }
 
         /**
          * Provides a mapping from the document model coordinate space
@@ -368,9 +368,9 @@
         public Shape modelToView(int p0, Position.Bias b0,
                                  int p1, Position.Bias b1, Shape a)
             throws BadLocationException
-        {
-            return super.modelToView(p0, b0, p1, b1, adjustAllocation(a));
-        }
+        {throw new RuntimeException("cf-bug");} //{
+//            return super.modelToView(p0, b0, p1, b1, adjustAllocation(a));
+//        }
 
         /**
          * Provides a mapping from the view coordinate space to the logical
@@ -383,9 +383,9 @@
          *  given point in the view
          * @see View#viewToModel
          */
-        public int viewToModel(float fx, float fy, Shape a, Position.Bias[] bias) {
-            return super.viewToModel(fx, fy, adjustAllocation(a), bias);
-        }
+        public int viewToModel(float fx, float fy, Shape a, Position.Bias[] bias) {throw new RuntimeException("cf-bug");} //{
+//            return super.viewToModel(fx, fy, adjustAllocation(a), bias);
+//        }
 
         /**
          * Gives notification that something was inserted into the document
@@ -396,10 +396,10 @@
          * @param f the factory to use to rebuild if the view has children
          * @see View#insertUpdate
          */
-        public void insertUpdate(DocumentEvent changes, Shape a, ViewFactory f) {
-            super.insertUpdate(changes, adjustAllocation(a), f);
-            updateVisibilityModel();
-        }
+        public void insertUpdate(DocumentEvent changes, Shape a, ViewFactory f) {throw new RuntimeException("cf-bug");} //{
+//            super.insertUpdate(changes, adjustAllocation(a), f);
+//            updateVisibilityModel();
+//        }
 
         /**
          * Gives notification that something was removed from the document
@@ -410,10 +410,10 @@
          * @param f the factory to use to rebuild if the view has children
          * @see View#removeUpdate
          */
-        public void removeUpdate(DocumentEvent changes, Shape a, ViewFactory f) {
-            super.removeUpdate(changes, adjustAllocation(a), f);
-            updateVisibilityModel();
-        }
+        public void removeUpdate(DocumentEvent changes, Shape a, ViewFactory f) {throw new RuntimeException("cf-bug");} //{
+//            super.removeUpdate(changes, adjustAllocation(a), f);
+//            updateVisibilityModel();
+//        }
 
     }
 
--- javax/swing/AbstractButton.java	2016-06-27 19:19:12.651249134 -0700
+++ javax/swing/AbstractButton.java	2016-06-29 14:10:20.673420523 -0700
@@ -258,16 +258,16 @@
      *  description: Whether the text of the button should come from
      *               the <code>Action</code>.
      */
-    public void setHideActionText(boolean hideActionText) {
-        if (hideActionText != this.hideActionText) {
-            this.hideActionText = hideActionText;
-            if (getAction() != null) {
-                setTextFromAction(getAction(), false);
-            }
-            firePropertyChange("hideActionText", !hideActionText,
-                               hideActionText);
-        }
-    }
+    public void setHideActionText(boolean hideActionText) {throw new RuntimeException("cf-bug");} //{
+//        if (hideActionText != this.hideActionText) {
+//            this.hideActionText = hideActionText;
+//            if (getAction() != null) {
+//                setTextFromAction(getAction(), false);
+//            }
+//            firePropertyChange("hideActionText", !hideActionText,
+//                               hideActionText);
+//        }
+//    }
 
     /**
      * Returns the value of the <code>hideActionText</code> property, which
@@ -280,18 +280,18 @@
      *         <code>Action</code>; the default is <code>false</code>
      * @since 1.6
      */
-    public boolean getHideActionText() {
-        return hideActionText;
-    }
+    public boolean getHideActionText() {throw new RuntimeException("cf-bug");} //{
+//        return hideActionText;
+//    }
 
     /**
      * Returns the button's text.
      * @return the buttons text
      * @see #setText
      */
-    public String getText() {
-        return text;
-    }
+    public String getText() {throw new RuntimeException("cf-bug");} //{
+//        return text;
+//    }
 
     /**
      * Sets the button's text.
@@ -303,22 +303,22 @@
      *    attribute: visualUpdate true
      *  description: The button's text.
      */
-    public void setText(String text) {
-        String oldValue = this.text;
-        this.text = text;
-        firePropertyChange(TEXT_CHANGED_PROPERTY, oldValue, text);
-        updateDisplayedMnemonicIndex(text, getMnemonic());
-
-        if (accessibleContext != null) {
-            accessibleContext.firePropertyChange(
-                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                oldValue, text);
-        }
-        if (text == null || oldValue == null || !text.equals(oldValue)) {
-            revalidate();
-            repaint();
-        }
-    }
+    public void setText(String text) {throw new RuntimeException("cf-bug");} //{
+//        String oldValue = this.text;
+//        this.text = text;
+//        firePropertyChange(TEXT_CHANGED_PROPERTY, oldValue, text);
+//        updateDisplayedMnemonicIndex(text, getMnemonic());
+//
+//        if (accessibleContext != null) {
+//            accessibleContext.firePropertyChange(
+//                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                oldValue, text);
+//        }
+//        if (text == null || oldValue == null || !text.equals(oldValue)) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
 
     /**
@@ -326,9 +326,9 @@
      * toggle button is selected, false if it's not.
      * @return true if the toggle button is selected, otherwise false
      */
-    public boolean isSelected() {
-        return model.isSelected();
-    }
+    public boolean isSelected() {throw new RuntimeException("cf-bug");} //{
+//        return model.isSelected();
+//    }
 
     /**
      * Sets the state of the button. Note that this method does not
@@ -337,27 +337,27 @@
      *
      * @param b  true if the button is selected, otherwise false
      */
-    public void setSelected(boolean b) {
-        boolean oldValue = isSelected();
-
-        // TIGER - 4840653
-        // Removed code which fired an AccessibleState.SELECTED
-        // PropertyChangeEvent since this resulted in two
-        // identical events being fired since
-        // AbstractButton.fireItemStateChanged also fires the
-        // same event. This caused screen readers to speak the
-        // name of the item twice.
-
-        model.setSelected(b);
-    }
+    public void setSelected(boolean b) {throw new RuntimeException("cf-bug");} //{
+//        boolean oldValue = isSelected();
+//
+//        // TIGER - 4840653
+//        // Removed code which fired an AccessibleState.SELECTED
+//        // PropertyChangeEvent since this resulted in two
+//        // identical events being fired since
+//        // AbstractButton.fireItemStateChanged also fires the
+//        // same event. This caused screen readers to speak the
+//        // name of the item twice.
+//
+//        model.setSelected(b);
+//    }
 
     /**
      * Programmatically perform a "click". This does the same
      * thing as if the user had pressed and released the button.
      */
-    public void doClick() {
-        doClick(68);
-    }
+    public void doClick() {throw new RuntimeException("cf-bug");} //{
+//        doClick(68);
+//    }
 
     /**
      * Programmatically perform a "click". This does the same
@@ -367,18 +367,18 @@
      *
      * @param pressTime the time to "hold down" the button, in milliseconds
      */
-    public void doClick(int pressTime) {
-        Dimension size = getSize();
-        model.setArmed(true);
-        model.setPressed(true);
-        paintImmediately(new Rectangle(0,0, size.width, size.height));
-        try {
-            Thread.currentThread().sleep(pressTime);
-        } catch(InterruptedException ie) {
-        }
-        model.setPressed(false);
-        model.setArmed(false);
-    }
+    public void doClick(int pressTime) {throw new RuntimeException("cf-bug");} //{
+//        Dimension size = getSize();
+//        model.setArmed(true);
+//        model.setPressed(true);
+//        paintImmediately(new Rectangle(0,0, size.width, size.height));
+//        try {
+//            Thread.currentThread().sleep(pressTime);
+//        } catch(InterruptedException ie) {
+//        }
+//        model.setPressed(false);
+//        model.setArmed(false);
+//    }
 
     /**
      * Sets space for margin between the button's border and
@@ -397,28 +397,28 @@
      *    attribute: visualUpdate true
      *  description: The space between the button's border and the label.
      */
-    public void setMargin(Insets m) {
-        // Cache the old margin if it comes from the UI
-        if(m instanceof UIResource) {
-            defaultMargin = m;
-        } else if(margin instanceof UIResource) {
-            defaultMargin = margin;
-        }
-
-        // If the client passes in a null insets, restore the margin
-        // from the UI if possible
-        if(m == null && defaultMargin != null) {
-            m = defaultMargin;
-        }
-
-        Insets old = margin;
-        margin = m;
-        firePropertyChange(MARGIN_CHANGED_PROPERTY, old, m);
-        if (old == null || !old.equals(m)) {
-            revalidate();
-            repaint();
-        }
-    }
+    public void setMargin(Insets m) {throw new RuntimeException("cf-bug");} //{
+//        // Cache the old margin if it comes from the UI
+//        if(m instanceof UIResource) {
+//            defaultMargin = m;
+//        } else if(margin instanceof UIResource) {
+//            defaultMargin = margin;
+//        }
+//
+//        // If the client passes in a null insets, restore the margin
+//        // from the UI if possible
+//        if(m == null && defaultMargin != null) {
+//            m = defaultMargin;
+//        }
+//
+//        Insets old = margin;
+//        margin = m;
+//        firePropertyChange(MARGIN_CHANGED_PROPERTY, old, m);
+//        if (old == null || !old.equals(m)) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
     /**
      * Returns the margin between the button's border and
@@ -428,18 +428,18 @@
      *          between the botton's border and the label
      * @see #setMargin
      */
-    public Insets getMargin() {
-        return (margin == null) ? null : (Insets) margin.clone();
-    }
+    public Insets getMargin() {throw new RuntimeException("cf-bug");} //{
+//        return (margin == null) ? null : (Insets) margin.clone();
+//    }
 
     /**
      * Returns the default icon.
      * @return the default <code>Icon</code>
      * @see #setIcon
      */
-    public Icon getIcon() {
-        return defaultIcon;
-    }
+    public Icon getIcon() {throw new RuntimeException("cf-bug");} //{
+//        return defaultIcon;
+//    }
 
     /**
      * Sets the button's default icon. This icon is
@@ -454,43 +454,43 @@
      *       attribute: visualUpdate true
      *     description: The button's default icon
      */
-    public void setIcon(Icon defaultIcon) {
-        Icon oldValue = this.defaultIcon;
-        this.defaultIcon = defaultIcon;
-
-        /* If the default icon has really changed and we had
-         * generated the disabled icon for this component,
-         * (i.e. setDisabledIcon() was never called) then
-         * clear the disabledIcon field.
-         */
-        if (defaultIcon != oldValue && (disabledIcon instanceof UIResource)) {
-            disabledIcon = null;
-        }
-
-        firePropertyChange(ICON_CHANGED_PROPERTY, oldValue, defaultIcon);
-        if (accessibleContext != null) {
-            accessibleContext.firePropertyChange(
-                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                oldValue, defaultIcon);
-        }
-        if (defaultIcon != oldValue) {
-            if (defaultIcon == null || oldValue == null ||
-                defaultIcon.getIconWidth() != oldValue.getIconWidth() ||
-                defaultIcon.getIconHeight() != oldValue.getIconHeight()) {
-                revalidate();
-            }
-            repaint();
-        }
-    }
+    public void setIcon(Icon defaultIcon) {throw new RuntimeException("cf-bug");} //{
+//        Icon oldValue = this.defaultIcon;
+//        this.defaultIcon = defaultIcon;
+//
+//        /* If the default icon has really changed and we had
+//         * generated the disabled icon for this component,
+//         * (i.e. setDisabledIcon() was never called) then
+//         * clear the disabledIcon field.
+//         */
+//        if (defaultIcon != oldValue && (disabledIcon instanceof UIResource)) {
+//            disabledIcon = null;
+//        }
+//
+//        firePropertyChange(ICON_CHANGED_PROPERTY, oldValue, defaultIcon);
+//        if (accessibleContext != null) {
+//            accessibleContext.firePropertyChange(
+//                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                oldValue, defaultIcon);
+//        }
+//        if (defaultIcon != oldValue) {
+//            if (defaultIcon == null || oldValue == null ||
+//                defaultIcon.getIconWidth() != oldValue.getIconWidth() ||
+//                defaultIcon.getIconHeight() != oldValue.getIconHeight()) {
+//                revalidate();
+//            }
+//            repaint();
+//        }
+//    }
 
     /**
      * Returns the pressed icon for the button.
      * @return the <code>pressedIcon</code> property
      * @see #setPressedIcon
      */
-    public Icon getPressedIcon() {
-        return pressedIcon;
-    }
+    public Icon getPressedIcon() {throw new RuntimeException("cf-bug");} //{
+//        return pressedIcon;
+//    }
 
     /**
      * Sets the pressed icon for the button.
@@ -501,30 +501,30 @@
      *    attribute: visualUpdate true
      *  description: The pressed icon for the button.
      */
-    public void setPressedIcon(Icon pressedIcon) {
-        Icon oldValue = this.pressedIcon;
-        this.pressedIcon = pressedIcon;
-        firePropertyChange(PRESSED_ICON_CHANGED_PROPERTY, oldValue, pressedIcon);
-        if (accessibleContext != null) {
-            accessibleContext.firePropertyChange(
-                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                oldValue, pressedIcon);
-        }
-        if (pressedIcon != oldValue) {
-            if (getModel().isPressed()) {
-                repaint();
-            }
-        }
-    }
+    public void setPressedIcon(Icon pressedIcon) {throw new RuntimeException("cf-bug");} //{
+//        Icon oldValue = this.pressedIcon;
+//        this.pressedIcon = pressedIcon;
+//        firePropertyChange(PRESSED_ICON_CHANGED_PROPERTY, oldValue, pressedIcon);
+//        if (accessibleContext != null) {
+//            accessibleContext.firePropertyChange(
+//                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                oldValue, pressedIcon);
+//        }
+//        if (pressedIcon != oldValue) {
+//            if (getModel().isPressed()) {
+//                repaint();
+//            }
+//        }
+//    }
 
     /**
      * Returns the selected icon for the button.
      * @return the <code>selectedIcon</code> property
      * @see #setSelectedIcon
      */
-    public Icon getSelectedIcon() {
-        return selectedIcon;
-    }
+    public Icon getSelectedIcon() {throw new RuntimeException("cf-bug");} //{
+//        return selectedIcon;
+//    }
 
     /**
      * Sets the selected icon for the button.
@@ -535,42 +535,42 @@
      *    attribute: visualUpdate true
      *  description: The selected icon for the button.
      */
-    public void setSelectedIcon(Icon selectedIcon) {
-        Icon oldValue = this.selectedIcon;
-        this.selectedIcon = selectedIcon;
-
-        /* If the default selected icon has really changed and we had
-         * generated the disabled selected icon for this component,
-         * (i.e. setDisabledSelectedIcon() was never called) then
-         * clear the disabledSelectedIcon field.
-         */
-        if (selectedIcon != oldValue &&
-            disabledSelectedIcon instanceof UIResource) {
-
-            disabledSelectedIcon = null;
-        }
-
-        firePropertyChange(SELECTED_ICON_CHANGED_PROPERTY, oldValue, selectedIcon);
-        if (accessibleContext != null) {
-            accessibleContext.firePropertyChange(
-                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                oldValue, selectedIcon);
-        }
-        if (selectedIcon != oldValue) {
-            if (isSelected()) {
-                repaint();
-            }
-        }
-    }
+    public void setSelectedIcon(Icon selectedIcon) {throw new RuntimeException("cf-bug");} //{
+//        Icon oldValue = this.selectedIcon;
+//        this.selectedIcon = selectedIcon;
+//
+//        /* If the default selected icon has really changed and we had
+//         * generated the disabled selected icon for this component,
+//         * (i.e. setDisabledSelectedIcon() was never called) then
+//         * clear the disabledSelectedIcon field.
+//         */
+//        if (selectedIcon != oldValue &&
+//            disabledSelectedIcon instanceof UIResource) {
+//
+//            disabledSelectedIcon = null;
+//        }
+//
+//        firePropertyChange(SELECTED_ICON_CHANGED_PROPERTY, oldValue, selectedIcon);
+//        if (accessibleContext != null) {
+//            accessibleContext.firePropertyChange(
+//                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                oldValue, selectedIcon);
+//        }
+//        if (selectedIcon != oldValue) {
+//            if (isSelected()) {
+//                repaint();
+//            }
+//        }
+//    }
 
     /**
      * Returns the rollover icon for the button.
      * @return the <code>rolloverIcon</code> property
      * @see #setRolloverIcon
      */
-    public Icon getRolloverIcon() {
-        return rolloverIcon;
-    }
+    public Icon getRolloverIcon() {throw new RuntimeException("cf-bug");} //{
+//        return rolloverIcon;
+//    }
 
     /**
      * Sets the rollover icon for the button.
@@ -581,32 +581,32 @@
      *    attribute: visualUpdate true
      *  description: The rollover icon for the button.
      */
-    public void setRolloverIcon(Icon rolloverIcon) {
-        Icon oldValue = this.rolloverIcon;
-        this.rolloverIcon = rolloverIcon;
-        firePropertyChange(ROLLOVER_ICON_CHANGED_PROPERTY, oldValue, rolloverIcon);
-        if (accessibleContext != null) {
-            accessibleContext.firePropertyChange(
-                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                oldValue, rolloverIcon);
-        }
-        setRolloverEnabled(true);
-        if (rolloverIcon != oldValue) {
-            // No way to determine whether we are currently in
-            // a rollover state, so repaint regardless
-            repaint();
-        }
-
-    }
+    public void setRolloverIcon(Icon rolloverIcon) {throw new RuntimeException("cf-bug");} //{
+//        Icon oldValue = this.rolloverIcon;
+//        this.rolloverIcon = rolloverIcon;
+//        firePropertyChange(ROLLOVER_ICON_CHANGED_PROPERTY, oldValue, rolloverIcon);
+//        if (accessibleContext != null) {
+//            accessibleContext.firePropertyChange(
+//                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                oldValue, rolloverIcon);
+//        }
+//        setRolloverEnabled(true);
+//        if (rolloverIcon != oldValue) {
+//            // No way to determine whether we are currently in
+//            // a rollover state, so repaint regardless
+//            repaint();
+//        }
+//
+//    }
 
     /**
      * Returns the rollover selection icon for the button.
      * @return the <code>rolloverSelectedIcon</code> property
      * @see #setRolloverSelectedIcon
      */
-    public Icon getRolloverSelectedIcon() {
-        return rolloverSelectedIcon;
-    }
+    public Icon getRolloverSelectedIcon() {throw new RuntimeException("cf-bug");} //{
+//        return rolloverSelectedIcon;
+//    }
 
     /**
      * Sets the rollover selected icon for the button.
@@ -618,24 +618,24 @@
      *    attribute: visualUpdate true
      *  description: The rollover selected icon for the button.
      */
-    public void setRolloverSelectedIcon(Icon rolloverSelectedIcon) {
-        Icon oldValue = this.rolloverSelectedIcon;
-        this.rolloverSelectedIcon = rolloverSelectedIcon;
-        firePropertyChange(ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY, oldValue, rolloverSelectedIcon);
-        if (accessibleContext != null) {
-            accessibleContext.firePropertyChange(
-                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                oldValue, rolloverSelectedIcon);
-        }
-        setRolloverEnabled(true);
-        if (rolloverSelectedIcon != oldValue) {
-            // No way to determine whether we are currently in
-            // a rollover state, so repaint regardless
-            if (isSelected()) {
-                repaint();
-            }
-        }
-    }
+    public void setRolloverSelectedIcon(Icon rolloverSelectedIcon) {throw new RuntimeException("cf-bug");} //{
+//        Icon oldValue = this.rolloverSelectedIcon;
+//        this.rolloverSelectedIcon = rolloverSelectedIcon;
+//        firePropertyChange(ROLLOVER_SELECTED_ICON_CHANGED_PROPERTY, oldValue, rolloverSelectedIcon);
+//        if (accessibleContext != null) {
+//            accessibleContext.firePropertyChange(
+//                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                oldValue, rolloverSelectedIcon);
+//        }
+//        setRolloverEnabled(true);
+//        if (rolloverSelectedIcon != oldValue) {
+//            // No way to determine whether we are currently in
+//            // a rollover state, so repaint regardless
+//            if (isSelected()) {
+//                repaint();
+//            }
+//        }
+//    }
 
     /**
      * Returns the icon used by the button when it's disabled.
@@ -651,15 +651,15 @@
      * @see javax.swing.LookAndFeel#getDisabledIcon
      */
     @Transient
-    public Icon getDisabledIcon() {
-        if (disabledIcon == null) {
-            disabledIcon = UIManager.getLookAndFeel().getDisabledIcon(this, getIcon());
-            if (disabledIcon != null) {
-                firePropertyChange(DISABLED_ICON_CHANGED_PROPERTY, null, disabledIcon);
-            }
-        }
-        return disabledIcon;
-    }
+    public Icon getDisabledIcon() {throw new RuntimeException("cf-bug");} //{
+//        if (disabledIcon == null) {
+//            disabledIcon = UIManager.getLookAndFeel().getDisabledIcon(this, getIcon());
+//            if (disabledIcon != null) {
+//                firePropertyChange(DISABLED_ICON_CHANGED_PROPERTY, null, disabledIcon);
+//            }
+//        }
+//        return disabledIcon;
+//    }
 
     /**
      * Sets the disabled icon for the button.
@@ -670,21 +670,21 @@
      *    attribute: visualUpdate true
      *  description: The disabled icon for the button.
      */
-    public void setDisabledIcon(Icon disabledIcon) {
-        Icon oldValue = this.disabledIcon;
-        this.disabledIcon = disabledIcon;
-        firePropertyChange(DISABLED_ICON_CHANGED_PROPERTY, oldValue, disabledIcon);
-        if (accessibleContext != null) {
-            accessibleContext.firePropertyChange(
-                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                oldValue, disabledIcon);
-        }
-        if (disabledIcon != oldValue) {
-            if (!isEnabled()) {
-                repaint();
-            }
-        }
-    }
+    public void setDisabledIcon(Icon disabledIcon) {throw new RuntimeException("cf-bug");} //{
+//        Icon oldValue = this.disabledIcon;
+//        this.disabledIcon = disabledIcon;
+//        firePropertyChange(DISABLED_ICON_CHANGED_PROPERTY, oldValue, disabledIcon);
+//        if (accessibleContext != null) {
+//            accessibleContext.firePropertyChange(
+//                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                oldValue, disabledIcon);
+//        }
+//        if (disabledIcon != oldValue) {
+//            if (!isEnabled()) {
+//                repaint();
+//            }
+//        }
+//    }
 
     /**
      * Returns the icon used by the button when it's disabled and selected.
@@ -701,17 +701,17 @@
      * @see #setDisabledSelectedIcon
      * @see javax.swing.LookAndFeel#getDisabledSelectedIcon
      */
-    public Icon getDisabledSelectedIcon() {
-        if (disabledSelectedIcon == null) {
-             if (selectedIcon != null) {
-                 disabledSelectedIcon = UIManager.getLookAndFeel().
-                         getDisabledSelectedIcon(this, getSelectedIcon());
-             } else {
-                 return getDisabledIcon();
-             }
-        }
-        return disabledSelectedIcon;
-    }
+    public Icon getDisabledSelectedIcon() {throw new RuntimeException("cf-bug");} //{
+//        if (disabledSelectedIcon == null) {
+//             if (selectedIcon != null) {
+//                 disabledSelectedIcon = UIManager.getLookAndFeel().
+//                         getDisabledSelectedIcon(this, getSelectedIcon());
+//             } else {
+//                 return getDisabledIcon();
+//             }
+//        }
+//        return disabledSelectedIcon;
+//    }
 
     /**
      * Sets the disabled selection icon for the button.
@@ -723,26 +723,26 @@
      *    attribute: visualUpdate true
      *  description: The disabled selection icon for the button.
      */
-    public void setDisabledSelectedIcon(Icon disabledSelectedIcon) {
-        Icon oldValue = this.disabledSelectedIcon;
-        this.disabledSelectedIcon = disabledSelectedIcon;
-        firePropertyChange(DISABLED_SELECTED_ICON_CHANGED_PROPERTY, oldValue, disabledSelectedIcon);
-        if (accessibleContext != null) {
-            accessibleContext.firePropertyChange(
-                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                oldValue, disabledSelectedIcon);
-        }
-        if (disabledSelectedIcon != oldValue) {
-            if (disabledSelectedIcon == null || oldValue == null ||
-                disabledSelectedIcon.getIconWidth() != oldValue.getIconWidth() ||
-                disabledSelectedIcon.getIconHeight() != oldValue.getIconHeight()) {
-                revalidate();
-            }
-            if (!isEnabled() && isSelected()) {
-                repaint();
-            }
-        }
-    }
+    public void setDisabledSelectedIcon(Icon disabledSelectedIcon) {throw new RuntimeException("cf-bug");} //{
+//        Icon oldValue = this.disabledSelectedIcon;
+//        this.disabledSelectedIcon = disabledSelectedIcon;
+//        firePropertyChange(DISABLED_SELECTED_ICON_CHANGED_PROPERTY, oldValue, disabledSelectedIcon);
+//        if (accessibleContext != null) {
+//            accessibleContext.firePropertyChange(
+//                AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                oldValue, disabledSelectedIcon);
+//        }
+//        if (disabledSelectedIcon != oldValue) {
+//            if (disabledSelectedIcon == null || oldValue == null ||
+//                disabledSelectedIcon.getIconWidth() != oldValue.getIconWidth() ||
+//                disabledSelectedIcon.getIconHeight() != oldValue.getIconHeight()) {
+//                revalidate();
+//            }
+//            if (!isEnabled() && isSelected()) {
+//                repaint();
+//            }
+//        }
+//    }
 
     /**
      * Returns the vertical alignment of the text and icon.
@@ -755,9 +755,9 @@
      * <li>{@code SwingConstants.BOTTOM}
      * </ul>
      */
-    public int getVerticalAlignment() {
-        return verticalAlignment;
-    }
+    public int getVerticalAlignment() {throw new RuntimeException("cf-bug");} //{
+//        return verticalAlignment;
+//    }
 
     /**
      * Sets the vertical alignment of the icon and text.
@@ -777,12 +777,12 @@
      *    attribute: visualUpdate true
      *  description: The vertical alignment of the icon and text.
      */
-    public void setVerticalAlignment(int alignment) {
-        if (alignment == verticalAlignment) return;
-        int oldValue = verticalAlignment;
-        verticalAlignment = checkVerticalKey(alignment, "verticalAlignment");
-        firePropertyChange(VERTICAL_ALIGNMENT_CHANGED_PROPERTY, oldValue, verticalAlignment);         repaint();
-    }
+    public void setVerticalAlignment(int alignment) {throw new RuntimeException("cf-bug");} //{
+//        if (alignment == verticalAlignment) return;
+//        int oldValue = verticalAlignment;
+//        verticalAlignment = checkVerticalKey(alignment, "verticalAlignment");
+//        firePropertyChange(VERTICAL_ALIGNMENT_CHANGED_PROPERTY, oldValue, verticalAlignment);         repaint();
+//    }
 
     /**
      * Returns the horizontal alignment of the icon and text.
@@ -799,9 +799,9 @@
      *   <li>{@code SwingConstants.TRAILING}
      * </ul>
      */
-    public int getHorizontalAlignment() {
-        return horizontalAlignment;
-    }
+    public int getHorizontalAlignment() {throw new RuntimeException("cf-bug");} //{
+//        return horizontalAlignment;
+//    }
 
     /**
      * Sets the horizontal alignment of the icon and text.
@@ -828,15 +828,15 @@
      *    attribute: visualUpdate true
      *  description: The horizontal alignment of the icon and text.
      */
-    public void setHorizontalAlignment(int alignment) {
-        if (alignment == horizontalAlignment) return;
-        int oldValue = horizontalAlignment;
-        horizontalAlignment = checkHorizontalKey(alignment,
-                                                 "horizontalAlignment");
-        firePropertyChange(HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY,
-                           oldValue, horizontalAlignment);
-        repaint();
-    }
+    public void setHorizontalAlignment(int alignment) {throw new RuntimeException("cf-bug");} //{
+//        if (alignment == horizontalAlignment) return;
+//        int oldValue = horizontalAlignment;
+//        horizontalAlignment = checkHorizontalKey(alignment,
+//                                                 "horizontalAlignment");
+//        firePropertyChange(HORIZONTAL_ALIGNMENT_CHANGED_PROPERTY,
+//                           oldValue, horizontalAlignment);
+//        repaint();
+//    }
 
 
     /**
@@ -849,9 +849,9 @@
      * <li>{@code SwingConstants.BOTTOM}
      * </ul>
      */
-    public int getVerticalTextPosition() {
-        return verticalTextPosition;
-    }
+    public int getVerticalTextPosition() {throw new RuntimeException("cf-bug");} //{
+//        return verticalTextPosition;
+//    }
 
     /**
      * Sets the vertical position of the text relative to the icon.
@@ -869,14 +869,14 @@
      *    attribute: visualUpdate true
      *  description: The vertical position of the text relative to the icon.
      */
-    public void setVerticalTextPosition(int textPosition) {
-        if (textPosition == verticalTextPosition) return;
-        int oldValue = verticalTextPosition;
-        verticalTextPosition = checkVerticalKey(textPosition, "verticalTextPosition");
-        firePropertyChange(VERTICAL_TEXT_POSITION_CHANGED_PROPERTY, oldValue, verticalTextPosition);
-        revalidate();
-        repaint();
-    }
+    public void setVerticalTextPosition(int textPosition) {throw new RuntimeException("cf-bug");} //{
+//        if (textPosition == verticalTextPosition) return;
+//        int oldValue = verticalTextPosition;
+//        verticalTextPosition = checkVerticalKey(textPosition, "verticalTextPosition");
+//        firePropertyChange(VERTICAL_TEXT_POSITION_CHANGED_PROPERTY, oldValue, verticalTextPosition);
+//        revalidate();
+//        repaint();
+//    }
 
     /**
      * Returns the horizontal position of the text relative to the icon.
@@ -890,9 +890,9 @@
      * <li>{@code SwingConstants.TRAILING} (the default)
      * </ul>
      */
-    public int getHorizontalTextPosition() {
-        return horizontalTextPosition;
-    }
+    public int getHorizontalTextPosition() {throw new RuntimeException("cf-bug");} //{
+//        return horizontalTextPosition;
+//    }
 
     /**
      * Sets the horizontal position of the text relative to the icon.
@@ -916,17 +916,17 @@
      *    attribute: visualUpdate true
      *  description: The horizontal position of the text relative to the icon.
      */
-    public void setHorizontalTextPosition(int textPosition) {
-        if (textPosition == horizontalTextPosition) return;
-        int oldValue = horizontalTextPosition;
-        horizontalTextPosition = checkHorizontalKey(textPosition,
-                                                    "horizontalTextPosition");
-        firePropertyChange(HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY,
-                           oldValue,
-                           horizontalTextPosition);
-        revalidate();
-        repaint();
-    }
+    public void setHorizontalTextPosition(int textPosition) {throw new RuntimeException("cf-bug");} //{
+//        if (textPosition == horizontalTextPosition) return;
+//        int oldValue = horizontalTextPosition;
+//        horizontalTextPosition = checkHorizontalKey(textPosition,
+//                                                    "horizontalTextPosition");
+//        firePropertyChange(HORIZONTAL_TEXT_POSITION_CHANGED_PROPERTY,
+//                           oldValue,
+//                           horizontalTextPosition);
+//        revalidate();
+//        repaint();
+//    }
 
     /**
      * Returns the amount of space between the text and the icon
@@ -937,9 +937,9 @@
      * @since 1.4
      * @see #setIconTextGap
      */
-    public int getIconTextGap() {
-        return iconTextGap;
-    }
+    public int getIconTextGap() {throw new RuntimeException("cf-bug");} //{
+//        return iconTextGap;
+//    }
 
     /**
      * If both the icon and text properties are set, this property
@@ -957,16 +957,16 @@
      *  description: If both the icon and text properties are set, this
      *               property defines the space between them.
      */
-    public void setIconTextGap(int iconTextGap) {
-        int oldValue = this.iconTextGap;
-        this.iconTextGap = iconTextGap;
-        iconTextGapSet = true;
-        firePropertyChange("iconTextGap", oldValue, iconTextGap);
-        if (iconTextGap != oldValue) {
-            revalidate();
-            repaint();
-        }
-    }
+    public void setIconTextGap(int iconTextGap) {throw new RuntimeException("cf-bug");} //{
+//        int oldValue = this.iconTextGap;
+//        this.iconTextGap = iconTextGap;
+//        iconTextGapSet = true;
+//        firePropertyChange("iconTextGap", oldValue, iconTextGap);
+//        if (iconTextGap != oldValue) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
     /**
      * Verify that the {@code key} argument is a legal value for the
@@ -990,17 +990,17 @@
      * @see #setHorizontalTextPosition
      * @see #setHorizontalAlignment
      */
-    protected int checkHorizontalKey(int key, String exception) {
-        if ((key == LEFT) ||
-            (key == CENTER) ||
-            (key == RIGHT) ||
-            (key == LEADING) ||
-            (key == TRAILING)) {
-            return key;
-        } else {
-            throw new IllegalArgumentException(exception);
-        }
-    }
+    protected int checkHorizontalKey(int key, String exception) {throw new RuntimeException("cf-bug");} //{
+//        if ((key == LEFT) ||
+//            (key == CENTER) ||
+//            (key == RIGHT) ||
+//            (key == LEADING) ||
+//            (key == TRAILING)) {
+//            return key;
+//        } else {
+//            throw new IllegalArgumentException(exception);
+//        }
+//    }
 
     /**
      * Verify that the {@code key} argument is a legal value for the
@@ -1019,45 +1019,45 @@
      * @exception IllegalArgumentException if key is not one of the legal
      *            values listed above
      */
-    protected int checkVerticalKey(int key, String exception) {
-        if ((key == TOP) || (key == CENTER) || (key == BOTTOM)) {
-            return key;
-        } else {
-            throw new IllegalArgumentException(exception);
-        }
-    }
+    protected int checkVerticalKey(int key, String exception) {throw new RuntimeException("cf-bug");} //{
+//        if ((key == TOP) || (key == CENTER) || (key == BOTTOM)) {
+//            return key;
+//        } else {
+//            throw new IllegalArgumentException(exception);
+//        }
+//    }
 
     /**
      *{@inheritDoc}
      *
      * @since 1.6
      */
-    public void removeNotify() {
-        super.removeNotify();
-        if(isRolloverEnabled()) {
-            getModel().setRollover(false);
-        }
-    }
+    public void removeNotify() {throw new RuntimeException("cf-bug");} //{
+//        super.removeNotify();
+//        if(isRolloverEnabled()) {
+//            getModel().setRollover(false);
+//        }
+//    }
 
     /**
      * Sets the action command for this button.
      * @param actionCommand the action command for this button
      */
-    public void setActionCommand(String actionCommand) {
-        getModel().setActionCommand(actionCommand);
-    }
+    public void setActionCommand(String actionCommand) {throw new RuntimeException("cf-bug");} //{
+//        getModel().setActionCommand(actionCommand);
+//    }
 
     /**
      * Returns the action command for this button.
      * @return the action command for this button
      */
-    public String getActionCommand() {
-        String ac = getModel().getActionCommand();
-        if(ac == null) {
-            ac = getText();
-        }
-        return ac;
-    }
+    public String getActionCommand() {throw new RuntimeException("cf-bug");} //{
+//        String ac = getModel().getActionCommand();
+//        if(ac == null) {
+//            ac = getText();
+//        }
+//        return ac;
+//    }
 
     private Action action;
     private PropertyChangeListener actionPropertyChangeListener;
@@ -1100,39 +1100,39 @@
      *    attribute: visualUpdate true
      *  description: the Action instance connected with this ActionEvent source
      */
-    public void setAction(Action a) {
-        Action oldValue = getAction();
-        if (action==null || !action.equals(a)) {
-            action = a;
-            if (oldValue!=null) {
-                removeActionListener(oldValue);
-                oldValue.removePropertyChangeListener(actionPropertyChangeListener);
-                actionPropertyChangeListener = null;
-            }
-            configurePropertiesFromAction(action);
-            if (action!=null) {
-                // Don't add if it is already a listener
-                if (!isListener(ActionListener.class, action)) {
-                    addActionListener(action);
-                }
-                // Reverse linkage:
-                actionPropertyChangeListener = createActionPropertyChangeListener(action);
-                action.addPropertyChangeListener(actionPropertyChangeListener);
-            }
-            firePropertyChange("action", oldValue, action);
-        }
-    }
-
-    private boolean isListener(Class c, ActionListener a) {
-        boolean isListener = false;
-        Object[] listeners = listenerList.getListenerList();
-        for (int i = listeners.length-2; i>=0; i-=2) {
-            if (listeners[i]==c && listeners[i+1]==a) {
-                    isListener=true;
-            }
-        }
-        return isListener;
-    }
+    public void setAction(Action a) {throw new RuntimeException("cf-bug");} //{
+//        Action oldValue = getAction();
+//        if (action==null || !action.equals(a)) {
+//            action = a;
+//            if (oldValue!=null) {
+//                removeActionListener(oldValue);
+//                oldValue.removePropertyChangeListener(actionPropertyChangeListener);
+//                actionPropertyChangeListener = null;
+//            }
+//            configurePropertiesFromAction(action);
+//            if (action!=null) {
+//                // Don't add if it is already a listener
+//                if (!isListener(ActionListener.class, action)) {
+//                    addActionListener(action);
+//                }
+//                // Reverse linkage:
+//                actionPropertyChangeListener = createActionPropertyChangeListener(action);
+//                action.addPropertyChangeListener(actionPropertyChangeListener);
+//            }
+//            firePropertyChange("action", oldValue, action);
+//        }
+//    }
+
+    private boolean isListener(Class c, ActionListener a) {throw new RuntimeException("cf-bug");} //{
+//        boolean isListener = false;
+//        Object[] listeners = listenerList.getListenerList();
+//        for (int i = listeners.length-2; i>=0; i-=2) {
+//            if (listeners[i]==c && listeners[i+1]==a) {
+//                    isListener=true;
+//            }
+//        }
+//        return isListener;
+//    }
 
     /**
      * Returns the currently set <code>Action</code> for this
@@ -1145,9 +1145,9 @@
      * @see Action
      * @see #setAction
      */
-    public Action getAction() {
-        return action;
-    }
+    public Action getAction() {throw new RuntimeException("cf-bug");} //{
+//        return action;
+//    }
 
     /**
      * Sets the properties on this button to match those in the specified
@@ -1161,39 +1161,39 @@
      * @see Action
      * @see #setAction
      */
-    protected void configurePropertiesFromAction(Action a) {
-        setMnemonicFromAction(a);
-        setTextFromAction(a, false);
-        AbstractAction.setToolTipTextFromAction(this, a);
-        setIconFromAction(a);
-        setActionCommandFromAction(a);
-        AbstractAction.setEnabledFromAction(this, a);
-        if (AbstractAction.hasSelectedKey(a) &&
-                shouldUpdateSelectedStateFromAction()) {
-            setSelectedFromAction(a);
-        }
-        setDisplayedMnemonicIndexFromAction(a, false);
-    }
+    protected void configurePropertiesFromAction(Action a) {throw new RuntimeException("cf-bug");} //{
+//        setMnemonicFromAction(a);
+//        setTextFromAction(a, false);
+//        AbstractAction.setToolTipTextFromAction(this, a);
+//        setIconFromAction(a);
+//        setActionCommandFromAction(a);
+//        AbstractAction.setEnabledFromAction(this, a);
+//        if (AbstractAction.hasSelectedKey(a) &&
+//                shouldUpdateSelectedStateFromAction()) {
+//            setSelectedFromAction(a);
+//        }
+//        setDisplayedMnemonicIndexFromAction(a, false);
+//    }
 
     void clientPropertyChanged(Object key, Object oldValue,
-                               Object newValue) {
-        if (key == "hideActionText") {
-            boolean current = (newValue instanceof Boolean) ?
-                                (Boolean)newValue : false;
-            if (getHideActionText() != current) {
-                setHideActionText(current);
-            }
-        }
-    }
+                               Object newValue) {throw new RuntimeException("cf-bug");} //{
+//        if (key == "hideActionText") {
+//            boolean current = (newValue instanceof Boolean) ?
+//                                (Boolean)newValue : false;
+//            if (getHideActionText() != current) {
+//                setHideActionText(current);
+//            }
+//        }
+//    }
 
     /**
      * Button subclasses that support mirroring the selected state from
      * the action should override this to return true.  AbstractButton's
      * implementation returns false.
      */
-    boolean shouldUpdateSelectedStateFromAction() {
-        return false;
-    }
+    boolean shouldUpdateSelectedStateFromAction() {throw new RuntimeException("cf-bug");} //{
+//        return false;
+//    }
 
     /**
      * Updates the button's state in response to property changes in the
@@ -1214,92 +1214,92 @@
      * @see Action
      * @see #configurePropertiesFromAction
      */
-    protected void actionPropertyChanged(Action action, String propertyName) {
-        if (propertyName == Action.NAME) {
-            setTextFromAction(action, true);
-        } else if (propertyName == "enabled") {
-            AbstractAction.setEnabledFromAction(this, action);
-        } else if (propertyName == Action.SHORT_DESCRIPTION) {
-            AbstractAction.setToolTipTextFromAction(this, action);
-        } else if (propertyName == Action.SMALL_ICON) {
-            smallIconChanged(action);
-        } else if (propertyName == Action.MNEMONIC_KEY) {
-            setMnemonicFromAction(action);
-        } else if (propertyName == Action.ACTION_COMMAND_KEY) {
-            setActionCommandFromAction(action);
-        } else if (propertyName == Action.SELECTED_KEY &&
-                   AbstractAction.hasSelectedKey(action) &&
-                   shouldUpdateSelectedStateFromAction()) {
-            setSelectedFromAction(action);
-        } else if (propertyName == Action.DISPLAYED_MNEMONIC_INDEX_KEY) {
-            setDisplayedMnemonicIndexFromAction(action, true);
-        } else if (propertyName == Action.LARGE_ICON_KEY) {
-            largeIconChanged(action);
-        }
-    }
+    protected void actionPropertyChanged(Action action, String propertyName) {throw new RuntimeException("cf-bug");} //{
+//        if (propertyName == Action.NAME) {
+//            setTextFromAction(action, true);
+//        } else if (propertyName == "enabled") {
+//            AbstractAction.setEnabledFromAction(this, action);
+//        } else if (propertyName == Action.SHORT_DESCRIPTION) {
+//            AbstractAction.setToolTipTextFromAction(this, action);
+//        } else if (propertyName == Action.SMALL_ICON) {
+//            smallIconChanged(action);
+//        } else if (propertyName == Action.MNEMONIC_KEY) {
+//            setMnemonicFromAction(action);
+//        } else if (propertyName == Action.ACTION_COMMAND_KEY) {
+//            setActionCommandFromAction(action);
+//        } else if (propertyName == Action.SELECTED_KEY &&
+//                   AbstractAction.hasSelectedKey(action) &&
+//                   shouldUpdateSelectedStateFromAction()) {
+//            setSelectedFromAction(action);
+//        } else if (propertyName == Action.DISPLAYED_MNEMONIC_INDEX_KEY) {
+//            setDisplayedMnemonicIndexFromAction(action, true);
+//        } else if (propertyName == Action.LARGE_ICON_KEY) {
+//            largeIconChanged(action);
+//        }
+//    }
 
     private void setDisplayedMnemonicIndexFromAction(
-            Action a, boolean fromPropertyChange) {
-        Integer iValue = (a == null) ? null :
-                (Integer)a.getValue(Action.DISPLAYED_MNEMONIC_INDEX_KEY);
-        if (fromPropertyChange || iValue != null) {
-            int value;
-            if (iValue == null) {
-                value = -1;
-            } else {
-                value = iValue;
-                String text = getText();
-                if (text == null || value >= text.length()) {
-                    value = -1;
-                }
-            }
-            setDisplayedMnemonicIndex(value);
-        }
-    }
-
-    private void setMnemonicFromAction(Action a) {
-        Integer n = (a == null) ? null :
-                                  (Integer)a.getValue(Action.MNEMONIC_KEY);
-        setMnemonic((n == null) ? '\0' : n);
-    }
-
-    private void setTextFromAction(Action a, boolean propertyChange) {
-        boolean hideText = getHideActionText();
-        if (!propertyChange) {
-            setText((a != null && !hideText) ?
-                        (String)a.getValue(Action.NAME) : null);
-        }
-        else if (!hideText) {
-            setText((String)a.getValue(Action.NAME));
-        }
-    }
-
-    void setIconFromAction(Action a) {
-        Icon icon = null;
-        if (a != null) {
-            icon = (Icon)a.getValue(Action.LARGE_ICON_KEY);
-            if (icon == null) {
-                icon = (Icon)a.getValue(Action.SMALL_ICON);
-            }
-        }
-        setIcon(icon);
-    }
-
-    void smallIconChanged(Action a) {
-        if (a.getValue(Action.LARGE_ICON_KEY) == null) {
-            setIconFromAction(a);
-        }
-    }
-
-    void largeIconChanged(Action a) {
-        setIconFromAction(a);
-    }
-
-    private void setActionCommandFromAction(Action a) {
-        setActionCommand((a != null) ?
-                             (String)a.getValue(Action.ACTION_COMMAND_KEY) :
-                             null);
-    }
+            Action a, boolean fromPropertyChange) {throw new RuntimeException("cf-bug");} //{
+//        Integer iValue = (a == null) ? null :
+//                (Integer)a.getValue(Action.DISPLAYED_MNEMONIC_INDEX_KEY);
+//        if (fromPropertyChange || iValue != null) {
+//            int value;
+//            if (iValue == null) {
+//                value = -1;
+//            } else {
+//                value = iValue;
+//                String text = getText();
+//                if (text == null || value >= text.length()) {
+//                    value = -1;
+//                }
+//            }
+//            setDisplayedMnemonicIndex(value);
+//        }
+//    }
+
+    private void setMnemonicFromAction(Action a) {throw new RuntimeException("cf-bug");} //{
+//        Integer n = (a == null) ? null :
+//                                  (Integer)a.getValue(Action.MNEMONIC_KEY);
+//        setMnemonic((n == null) ? '\0' : n);
+//    }
+
+    private void setTextFromAction(Action a, boolean propertyChange) {throw new RuntimeException("cf-bug");} //{
+//        boolean hideText = getHideActionText();
+//        if (!propertyChange) {
+//            setText((a != null && !hideText) ?
+//                        (String)a.getValue(Action.NAME) : null);
+//        }
+//        else if (!hideText) {
+//            setText((String)a.getValue(Action.NAME));
+//        }
+//    }
+
+    void setIconFromAction(Action a) {throw new RuntimeException("cf-bug");} //{
+//        Icon icon = null;
+//        if (a != null) {
+//            icon = (Icon)a.getValue(Action.LARGE_ICON_KEY);
+//            if (icon == null) {
+//                icon = (Icon)a.getValue(Action.SMALL_ICON);
+//            }
+//        }
+//        setIcon(icon);
+//    }
+
+    void smallIconChanged(Action a) {throw new RuntimeException("cf-bug");} //{
+//        if (a.getValue(Action.LARGE_ICON_KEY) == null) {
+//            setIconFromAction(a);
+//        }
+//    }
+
+    void largeIconChanged(Action a) {throw new RuntimeException("cf-bug");} //{
+//        setIconFromAction(a);
+//    }
+
+    private void setActionCommandFromAction(Action a) {throw new RuntimeException("cf-bug");} //{
+//        setActionCommand((a != null) ?
+//                             (String)a.getValue(Action.ACTION_COMMAND_KEY) :
+//                             null);
+//    }
 
     /**
      * Sets the seleted state of the button from the action.  This is defined
@@ -1308,26 +1308,26 @@
      *
      * @param a the Action
      */
-    private void setSelectedFromAction(Action a) {
-        boolean selected = false;
-        if (a != null) {
-            selected = AbstractAction.isSelected(a);
-        }
-        if (selected != isSelected()) {
-            // This won't notify ActionListeners, but that should be
-            // ok as the change is coming from the Action.
-            setSelected(selected);
-            // Make sure the change actually took effect
-            if (!selected && isSelected()) {
-                if (getModel() instanceof DefaultButtonModel) {
-                    ButtonGroup group = ((DefaultButtonModel)getModel()).getGroup();
-                    if (group != null) {
-                        group.clearSelection();
-                    }
-                }
-            }
-        }
-    }
+    private void setSelectedFromAction(Action a) {throw new RuntimeException("cf-bug");} //{
+//        boolean selected = false;
+//        if (a != null) {
+//            selected = AbstractAction.isSelected(a);
+//        }
+//        if (selected != isSelected()) {
+//            // This won't notify ActionListeners, but that should be
+//            // ok as the change is coming from the Action.
+//            setSelected(selected);
+//            // Make sure the change actually took effect
+//            if (!selected && isSelected()) {
+//                if (getModel() instanceof DefaultButtonModel) {
+//                    ButtonGroup group = ((DefaultButtonModel)getModel()).getGroup();
+//                    if (group != null) {
+//                        group.clearSelection();
+//                    }
+//                }
+//            }
+//        }
+//    }
 
     /**
      * Creates and returns a <code>PropertyChangeListener</code> that is
@@ -1343,14 +1343,14 @@
      * @see Action
      * @see #setAction
      */
-    protected PropertyChangeListener createActionPropertyChangeListener(Action a) {
-        return createActionPropertyChangeListener0(a);
-    }
+    protected PropertyChangeListener createActionPropertyChangeListener(Action a) {throw new RuntimeException("cf-bug");} //{
+//        return createActionPropertyChangeListener0(a);
+//    }
 
 
-    PropertyChangeListener createActionPropertyChangeListener0(Action a) {
-        return new ButtonActionPropertyChangeListener(this, a);
-    }
+    PropertyChangeListener createActionPropertyChangeListener0(Action a) {throw new RuntimeException("cf-bug");} //{
+//        return new ButtonActionPropertyChangeListener(this, a);
+//    }
 
     @SuppressWarnings("serial")
     private static class ButtonActionPropertyChangeListener
@@ -1360,13 +1360,13 @@
         }
         protected void actionPropertyChanged(AbstractButton button,
                                              Action action,
-                                             PropertyChangeEvent e) {
-            if (AbstractAction.shouldReconfigure(e)) {
-                button.configurePropertiesFromAction(action);
-            } else {
-                button.actionPropertyChanged(action, e.getPropertyName());
-            }
-        }
+                                             PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//            if (AbstractAction.shouldReconfigure(e)) {
+//                button.configurePropertiesFromAction(action);
+//            } else {
+//                button.actionPropertyChanged(action, e.getPropertyName());
+//            }
+//        }
     }
 
     /**
@@ -1375,9 +1375,9 @@
      * @return the value of the <code>borderPainted</code> property
      * @see #setBorderPainted
      */
-    public boolean isBorderPainted() {
-        return paintBorder;
-    }
+    public boolean isBorderPainted() {throw new RuntimeException("cf-bug");} //{
+//        return paintBorder;
+//    }
 
     /**
      * Sets the <code>borderPainted</code> property.
@@ -1397,16 +1397,16 @@
      *    attribute: visualUpdate true
      *  description: Whether the border should be painted.
      */
-    public void setBorderPainted(boolean b) {
-        boolean oldValue = paintBorder;
-        paintBorder = b;
-        borderPaintedSet = true;
-        firePropertyChange(BORDER_PAINTED_CHANGED_PROPERTY, oldValue, paintBorder);
-        if (b != oldValue) {
-            revalidate();
-            repaint();
-        }
-    }
+    public void setBorderPainted(boolean b) {throw new RuntimeException("cf-bug");} //{
+//        boolean oldValue = paintBorder;
+//        paintBorder = b;
+//        borderPaintedSet = true;
+//        firePropertyChange(BORDER_PAINTED_CHANGED_PROPERTY, oldValue, paintBorder);
+//        if (b != oldValue) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
     /**
      * Paint the button's border if <code>BorderPainted</code>
@@ -1416,11 +1416,11 @@
      * @see #paint
      * @see #setBorder
      */
-    protected void paintBorder(Graphics g) {
-        if (isBorderPainted()) {
-            super.paintBorder(g);
-        }
-    }
+    protected void paintBorder(Graphics g) {throw new RuntimeException("cf-bug");} //{
+//        if (isBorderPainted()) {
+//            super.paintBorder(g);
+//        }
+//    }
 
     /**
      * Gets the <code>paintFocus</code> property.
@@ -1428,9 +1428,9 @@
      * @return the <code>paintFocus</code> property
      * @see #setFocusPainted
      */
-    public boolean isFocusPainted() {
-        return paintFocus;
-    }
+    public boolean isFocusPainted() {throw new RuntimeException("cf-bug");} //{
+//        return paintFocus;
+//    }
 
     /**
      * Sets the <code>paintFocus</code> property, which must
@@ -1447,15 +1447,15 @@
      *    attribute: visualUpdate true
      *  description: Whether focus should be painted
      */
-    public void setFocusPainted(boolean b) {
-        boolean oldValue = paintFocus;
-        paintFocus = b;
-        firePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY, oldValue, paintFocus);
-        if (b != oldValue && isFocusOwner()) {
-            revalidate();
-            repaint();
-        }
-    }
+    public void setFocusPainted(boolean b) {throw new RuntimeException("cf-bug");} //{
+//        boolean oldValue = paintFocus;
+//        paintFocus = b;
+//        firePropertyChange(FOCUS_PAINTED_CHANGED_PROPERTY, oldValue, paintFocus);
+//        if (b != oldValue && isFocusOwner()) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
     /**
      * Gets the <code>contentAreaFilled</code> property.
@@ -1463,9 +1463,9 @@
      * @return the <code>contentAreaFilled</code> property
      * @see #setContentAreaFilled
      */
-    public boolean isContentAreaFilled() {
-        return contentAreaFilled;
-    }
+    public boolean isContentAreaFilled() {throw new RuntimeException("cf-bug");} //{
+//        return contentAreaFilled;
+//    }
 
     /**
      * Sets the <code>contentAreaFilled</code> property.
@@ -1491,15 +1491,15 @@
      *  description: Whether the button should paint the content area
      *               or leave it transparent.
      */
-    public void setContentAreaFilled(boolean b) {
-        boolean oldValue = contentAreaFilled;
-        contentAreaFilled = b;
-        contentAreaFilledSet = true;
-        firePropertyChange(CONTENT_AREA_FILLED_CHANGED_PROPERTY, oldValue, contentAreaFilled);
-        if (b != oldValue) {
-            repaint();
-        }
-    }
+    public void setContentAreaFilled(boolean b) {throw new RuntimeException("cf-bug");} //{
+//        boolean oldValue = contentAreaFilled;
+//        contentAreaFilled = b;
+//        contentAreaFilledSet = true;
+//        firePropertyChange(CONTENT_AREA_FILLED_CHANGED_PROPERTY, oldValue, contentAreaFilled);
+//        if (b != oldValue) {
+//            repaint();
+//        }
+//    }
 
     /**
      * Gets the <code>rolloverEnabled</code> property.
@@ -1507,9 +1507,9 @@
      * @return the value of the <code>rolloverEnabled</code> property
      * @see #setRolloverEnabled
      */
-    public boolean isRolloverEnabled() {
-        return rolloverEnabled;
-    }
+    public boolean isRolloverEnabled() {throw new RuntimeException("cf-bug");} //{
+//        return rolloverEnabled;
+//    }
 
     /**
      * Sets the <code>rolloverEnabled</code> property, which
@@ -1526,23 +1526,23 @@
      *    attribute: visualUpdate true
      *  description: Whether rollover effects should be enabled.
      */
-    public void setRolloverEnabled(boolean b) {
-        boolean oldValue = rolloverEnabled;
-        rolloverEnabled = b;
-        rolloverEnabledSet = true;
-        firePropertyChange(ROLLOVER_ENABLED_CHANGED_PROPERTY, oldValue, rolloverEnabled);
-        if (b != oldValue) {
-            repaint();
-        }
-    }
+    public void setRolloverEnabled(boolean b) {throw new RuntimeException("cf-bug");} //{
+//        boolean oldValue = rolloverEnabled;
+//        rolloverEnabled = b;
+//        rolloverEnabledSet = true;
+//        firePropertyChange(ROLLOVER_ENABLED_CHANGED_PROPERTY, oldValue, rolloverEnabled);
+//        if (b != oldValue) {
+//            repaint();
+//        }
+//    }
 
     /**
      * Returns the keyboard mnemonic from the the current model.
      * @return the keyboard mnemonic from the model
      */
-    public int getMnemonic() {
-        return mnemonic;
-    }
+    public int getMnemonic() {throw new RuntimeException("cf-bug");} //{
+//        return mnemonic;
+//    }
 
     /**
      * Sets the keyboard mnemonic on the current model.
@@ -1574,11 +1574,11 @@
      *    attribute: visualUpdate true
      *  description: the keyboard character mnemonic
      */
-    public void setMnemonic(int mnemonic) {
-        int oldValue = getMnemonic();
-        model.setMnemonic(mnemonic);
-        updateMnemonicProperties();
-    }
+    public void setMnemonic(int mnemonic) {throw new RuntimeException("cf-bug");} //{
+//        int oldValue = getMnemonic();
+//        model.setMnemonic(mnemonic);
+//        updateMnemonicProperties();
+//    }
 
     /**
      * This method is now obsolete, please use <code>setMnemonic(int)</code>
@@ -1593,12 +1593,12 @@
      *    attribute: visualUpdate true
      *  description: the keyboard character mnemonic
      */
-    public void setMnemonic(char mnemonic) {
-        int vk = (int) mnemonic;
-        if(vk >= 'a' && vk <='z')
-            vk -= ('a' - 'A');
-        setMnemonic(vk);
-    }
+    public void setMnemonic(char mnemonic) {throw new RuntimeException("cf-bug");} //{
+//        int vk = (int) mnemonic;
+//        if(vk >= 'a' && vk <='z')
+//            vk -= ('a' - 'A');
+//        setMnemonic(vk);
+//    }
 
     /**
      * Provides a hint to the look and feel as to which character in the
@@ -1629,24 +1629,24 @@
      *               mnemonic at
      */
     public void setDisplayedMnemonicIndex(int index)
-                                          throws IllegalArgumentException {
-        int oldValue = mnemonicIndex;
-        if (index == -1) {
-            mnemonicIndex = -1;
-        } else {
-            String text = getText();
-            int textLength = (text == null) ? 0 : text.length();
-            if (index < -1 || index >= textLength) {  // index out of range
-                throw new IllegalArgumentException("index == " + index);
-            }
-        }
-        mnemonicIndex = index;
-        firePropertyChange("displayedMnemonicIndex", oldValue, index);
-        if (index != oldValue) {
-            revalidate();
-            repaint();
-        }
-    }
+                                          throws IllegalArgumentException {throw new RuntimeException("cf-bug");} //{
+//        int oldValue = mnemonicIndex;
+//        if (index == -1) {
+//            mnemonicIndex = -1;
+//        } else {
+//            String text = getText();
+//            int textLength = (text == null) ? 0 : text.length();
+//            if (index < -1 || index >= textLength) {  // index out of range
+//                throw new IllegalArgumentException("index == " + index);
+//            }
+//        }
+//        mnemonicIndex = index;
+//        firePropertyChange("displayedMnemonicIndex", oldValue, index);
+//        if (index != oldValue) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
     /**
      * Returns the character, as an index, that the look and feel should
@@ -1656,9 +1656,9 @@
      * @return index representing mnemonic character
      * @see #setDisplayedMnemonicIndex
      */
-    public int getDisplayedMnemonicIndex() {
-        return mnemonicIndex;
-    }
+    public int getDisplayedMnemonicIndex() {throw new RuntimeException("cf-bug");} //{
+//        return mnemonicIndex;
+//    }
 
     /**
      * Update the displayedMnemonicIndex property. This method
@@ -1666,28 +1666,28 @@
      * value of the displayedMnemonicIndex property is the index
      * of the first occurrence of mnemonic in text.
      */
-    private void updateDisplayedMnemonicIndex(String text, int mnemonic) {
-        setDisplayedMnemonicIndex(
-            SwingUtilities.findDisplayedMnemonicIndex(text, mnemonic));
-    }
+    private void updateDisplayedMnemonicIndex(String text, int mnemonic) {throw new RuntimeException("cf-bug");} //{
+//        setDisplayedMnemonicIndex(
+//            SwingUtilities.findDisplayedMnemonicIndex(text, mnemonic));
+//    }
 
     /**
      * Brings the mnemonic property in accordance with model's mnemonic.
      * This is called when model's mnemonic changes. Also updates the
      * displayedMnemonicIndex property.
      */
-    private void updateMnemonicProperties() {
-        int newMnemonic = model.getMnemonic();
-        if (mnemonic != newMnemonic) {
-            int oldValue = mnemonic;
-            mnemonic = newMnemonic;
-            firePropertyChange(MNEMONIC_CHANGED_PROPERTY,
-                               oldValue, mnemonic);
-            updateDisplayedMnemonicIndex(getText(), mnemonic);
-            revalidate();
-            repaint();
-        }
-    }
+    private void updateMnemonicProperties() {throw new RuntimeException("cf-bug");} //{
+//        int newMnemonic = model.getMnemonic();
+//        if (mnemonic != newMnemonic) {
+//            int oldValue = mnemonic;
+//            mnemonic = newMnemonic;
+//            firePropertyChange(MNEMONIC_CHANGED_PROPERTY,
+//                               oldValue, mnemonic);
+//            updateDisplayedMnemonicIndex(getText(), mnemonic);
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
     /**
      * Sets the amount of time (in milliseconds) required between
@@ -1708,12 +1708,12 @@
      * @exception   IllegalArgumentException if threshhold &lt; 0
      * @since 1.4
      */
-    public void setMultiClickThreshhold(long threshhold) {
-        if (threshhold < 0) {
-            throw new IllegalArgumentException("threshhold must be >= 0");
-        }
-        this.multiClickThreshhold = threshhold;
-    }
+    public void setMultiClickThreshhold(long threshhold) {throw new RuntimeException("cf-bug");} //{
+//        if (threshhold < 0) {
+//            throw new IllegalArgumentException("threshhold must be >= 0");
+//        }
+//        this.multiClickThreshhold = threshhold;
+//    }
 
     /**
      * Gets the amount of time (in milliseconds) required between
@@ -1725,18 +1725,18 @@
      *         to generate corresponding action events
      * @since 1.4
      */
-    public long getMultiClickThreshhold() {
-        return multiClickThreshhold;
-    }
+    public long getMultiClickThreshhold() {throw new RuntimeException("cf-bug");} //{
+//        return multiClickThreshhold;
+//    }
 
     /**
      * Returns the model that this button represents.
      * @return the <code>model</code> property
      * @see #setModel
      */
-    public ButtonModel getModel() {
-        return model;
-    }
+    public ButtonModel getModel() {throw new RuntimeException("cf-bug");} //{
+//        return model;
+//    }
 
     /**
      * Sets the model that this button represents.
@@ -1746,47 +1746,47 @@
      *        bound: true
      *  description: Model that the Button uses.
      */
-    public void setModel(ButtonModel newModel) {
-
-        ButtonModel oldModel = getModel();
-
-        if (oldModel != null) {
-            oldModel.removeChangeListener(changeListener);
-            oldModel.removeActionListener(actionListener);
-            oldModel.removeItemListener(itemListener);
-            changeListener = null;
-            actionListener = null;
-            itemListener = null;
-        }
-
-        model = newModel;
-
-        if (newModel != null) {
-            changeListener = createChangeListener();
-            actionListener = createActionListener();
-            itemListener = createItemListener();
-            newModel.addChangeListener(changeListener);
-            newModel.addActionListener(actionListener);
-            newModel.addItemListener(itemListener);
-
-            updateMnemonicProperties();
-            //We invoke setEnabled() from JComponent
-            //because setModel() can be called from a constructor
-            //when the button is not fully initialized
-            super.setEnabled(newModel.isEnabled());
-
-        } else {
-            mnemonic = '\0';
-        }
-
-        updateDisplayedMnemonicIndex(getText(), mnemonic);
-
-        firePropertyChange(MODEL_CHANGED_PROPERTY, oldModel, newModel);
-        if (newModel != oldModel) {
-            revalidate();
-            repaint();
-        }
-    }
+    public void setModel(ButtonModel newModel) {throw new RuntimeException("cf-bug");} //{
+//
+//        ButtonModel oldModel = getModel();
+//
+//        if (oldModel != null) {
+//            oldModel.removeChangeListener(changeListener);
+//            oldModel.removeActionListener(actionListener);
+//            oldModel.removeItemListener(itemListener);
+//            changeListener = null;
+//            actionListener = null;
+//            itemListener = null;
+//        }
+//
+//        model = newModel;
+//
+//        if (newModel != null) {
+//            changeListener = createChangeListener();
+//            actionListener = createActionListener();
+//            itemListener = createItemListener();
+//            newModel.addChangeListener(changeListener);
+//            newModel.addActionListener(actionListener);
+//            newModel.addItemListener(itemListener);
+//
+//            updateMnemonicProperties();
+//            //We invoke setEnabled() from JComponent
+//            //because setModel() can be called from a constructor
+//            //when the button is not fully initialized
+//            super.setEnabled(newModel.isEnabled());
+//
+//        } else {
+//            mnemonic = '\0';
+//        }
+//
+//        updateDisplayedMnemonicIndex(getText(), mnemonic);
+//
+//        firePropertyChange(MODEL_CHANGED_PROPERTY, oldModel, newModel);
+//        if (newModel != oldModel) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
 
     /**
@@ -1794,9 +1794,9 @@
      * @return the ButtonUI object
      * @see #setUI
      */
-    public ButtonUI getUI() {
-        return (ButtonUI) ui;
-    }
+    public ButtonUI getUI() {throw new RuntimeException("cf-bug");} //{
+//        return (ButtonUI) ui;
+//    }
 
 
     /**
@@ -1809,16 +1809,16 @@
      *    attribute: visualUpdate true
      *  description: The UI object that implements the LookAndFeel.
      */
-    public void setUI(ButtonUI ui) {
-        super.setUI(ui);
-        // disabled icons are generated by the LF so they should be unset here
-        if (disabledIcon instanceof UIResource) {
-            setDisabledIcon(null);
-        }
-        if (disabledSelectedIcon instanceof UIResource) {
-            setDisabledSelectedIcon(null);
-        }
-    }
+    public void setUI(ButtonUI ui) {throw new RuntimeException("cf-bug");} //{
+//        super.setUI(ui);
+//        // disabled icons are generated by the LF so they should be unset here
+//        if (disabledIcon instanceof UIResource) {
+//            setDisabledIcon(null);
+//        }
+//        if (disabledSelectedIcon instanceof UIResource) {
+//            setDisabledSelectedIcon(null);
+//        }
+//    }
 
 
     /**
@@ -1852,12 +1852,12 @@
      * @exception IllegalArgumentException if adding a window to a container
      * @since 1.5
      */
-    protected void addImpl(Component comp, Object constraints, int index) {
-        if (!setLayout) {
-            setLayout(new OverlayLayout(this));
-        }
-        super.addImpl(comp, constraints, index);
-    }
+    protected void addImpl(Component comp, Object constraints, int index) {throw new RuntimeException("cf-bug");} //{
+//        if (!setLayout) {
+//            setLayout(new OverlayLayout(this));
+//        }
+//        super.addImpl(comp, constraints, index);
+//    }
 
     /**
      * Sets the layout manager for this container, refer to
@@ -1867,26 +1867,26 @@
      * @param mgr the specified layout manager
      * @since 1.5
      */
-    public void setLayout(LayoutManager mgr) {
-        setLayout = true;
-        super.setLayout(mgr);
-    }
+    public void setLayout(LayoutManager mgr) {throw new RuntimeException("cf-bug");} //{
+//        setLayout = true;
+//        super.setLayout(mgr);
+//    }
 
     /**
      * Adds a <code>ChangeListener</code> to the button.
      * @param l the listener to be added
      */
-    public void addChangeListener(ChangeListener l) {
-        listenerList.add(ChangeListener.class, l);
-    }
+    public void addChangeListener(ChangeListener l) {throw new RuntimeException("cf-bug");} //{
+//        listenerList.add(ChangeListener.class, l);
+//    }
 
     /**
      * Removes a ChangeListener from the button.
      * @param l the listener to be removed
      */
-    public void removeChangeListener(ChangeListener l) {
-        listenerList.remove(ChangeListener.class, l);
-    }
+    public void removeChangeListener(ChangeListener l) {throw new RuntimeException("cf-bug");} //{
+//        listenerList.remove(ChangeListener.class, l);
+//    }
 
     /**
      * Returns an array of all the <code>ChangeListener</code>s added
@@ -1896,9 +1896,9 @@
      *         array if no listeners have been added
      * @since 1.4
      */
-    public ChangeListener[] getChangeListeners() {
-        return listenerList.getListeners(ChangeListener.class);
-    }
+    public ChangeListener[] getChangeListeners() {throw new RuntimeException("cf-bug");} //{
+//        return listenerList.getListeners(ChangeListener.class);
+//    }
 
     /**
      * Notifies all listeners that have registered interest for
@@ -1906,28 +1906,28 @@
      * is lazily created.
      * @see EventListenerList
      */
-    protected void fireStateChanged() {
-        // Guaranteed to return a non-null array
-        Object[] listeners = listenerList.getListenerList();
-        // Process the listeners last to first, notifying
-        // those that are interested in this event
-        for (int i = listeners.length-2; i>=0; i-=2) {
-            if (listeners[i]==ChangeListener.class) {
-                // Lazily create the event:
-                if (changeEvent == null)
-                    changeEvent = new ChangeEvent(this);
-                ((ChangeListener)listeners[i+1]).stateChanged(changeEvent);
-            }
-        }
-    }
+    protected void fireStateChanged() {throw new RuntimeException("cf-bug");} //{
+//        // Guaranteed to return a non-null array
+//        Object[] listeners = listenerList.getListenerList();
+//        // Process the listeners last to first, notifying
+//        // those that are interested in this event
+//        for (int i = listeners.length-2; i>=0; i-=2) {
+//            if (listeners[i]==ChangeListener.class) {
+//                // Lazily create the event:
+//                if (changeEvent == null)
+//                    changeEvent = new ChangeEvent(this);
+//                ((ChangeListener)listeners[i+1]).stateChanged(changeEvent);
+//            }
+//        }
+//    }
 
     /**
      * Adds an <code>ActionListener</code> to the button.
      * @param l the <code>ActionListener</code> to be added
      */
-    public void addActionListener(ActionListener l) {
-        listenerList.add(ActionListener.class, l);
-    }
+    public void addActionListener(ActionListener l) {throw new RuntimeException("cf-bug");} //{
+//        listenerList.add(ActionListener.class, l);
+//    }
 
     /**
      * Removes an <code>ActionListener</code> from the button.
@@ -1937,13 +1937,13 @@
      *
      * @param l the listener to be removed
      */
-    public void removeActionListener(ActionListener l) {
-        if ((l != null) && (getAction() == l)) {
-            setAction(null);
-        } else {
-            listenerList.remove(ActionListener.class, l);
-        }
-    }
+    public void removeActionListener(ActionListener l) {throw new RuntimeException("cf-bug");} //{
+//        if ((l != null) && (getAction() == l)) {
+//            setAction(null);
+//        } else {
+//            listenerList.remove(ActionListener.class, l);
+//        }
+//    }
 
     /**
      * Returns an array of all the <code>ActionListener</code>s added
@@ -1953,9 +1953,9 @@
      *         array if no listeners have been added
      * @since 1.4
      */
-    public ActionListener[] getActionListeners() {
-        return listenerList.getListeners(ActionListener.class);
-    }
+    public ActionListener[] getActionListeners() {throw new RuntimeException("cf-bug");} //{
+//        return listenerList.getListeners(ActionListener.class);
+//    }
 
     /**
      * Subclasses that want to handle <code>ChangeEvents</code> differently
@@ -1964,9 +1964,9 @@
      *
      * @return the new <code>ChangeListener</code>
      */
-    protected ChangeListener createChangeListener() {
-        return getHandler();
-    }
+    protected ChangeListener createChangeListener() {throw new RuntimeException("cf-bug");} //{
+//        return getHandler();
+//    }
 
     /**
      * Extends <code>ChangeListener</code> to be serializable.
@@ -1987,9 +1987,9 @@
         ButtonChangeListener() {
         }
 
-        public void stateChanged(ChangeEvent e) {
-            getHandler().stateChanged(e);
-        }
+        public void stateChanged(ChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//            getHandler().stateChanged(e);
+//        }
     }
 
 
@@ -2002,30 +2002,30 @@
      * @param event  the <code>ActionEvent</code> object
      * @see EventListenerList
      */
-    protected void fireActionPerformed(ActionEvent event) {
-        // Guaranteed to return a non-null array
-        Object[] listeners = listenerList.getListenerList();
-        ActionEvent e = null;
-        // Process the listeners last to first, notifying
-        // those that are interested in this event
-        for (int i = listeners.length-2; i>=0; i-=2) {
-            if (listeners[i]==ActionListener.class) {
-                // Lazily create the event:
-                if (e == null) {
-                      String actionCommand = event.getActionCommand();
-                      if(actionCommand == null) {
-                         actionCommand = getActionCommand();
-                      }
-                      e = new ActionEvent(AbstractButton.this,
-                                          ActionEvent.ACTION_PERFORMED,
-                                          actionCommand,
-                                          event.getWhen(),
-                                          event.getModifiers());
-                }
-                ((ActionListener)listeners[i+1]).actionPerformed(e);
-            }
-        }
-    }
+    protected void fireActionPerformed(ActionEvent event) {throw new RuntimeException("cf-bug");} //{
+//        // Guaranteed to return a non-null array
+//        Object[] listeners = listenerList.getListenerList();
+//        ActionEvent e = null;
+//        // Process the listeners last to first, notifying
+//        // those that are interested in this event
+//        for (int i = listeners.length-2; i>=0; i-=2) {
+//            if (listeners[i]==ActionListener.class) {
+//                // Lazily create the event:
+//                if (e == null) {
+//                      String actionCommand = event.getActionCommand();
+//                      if(actionCommand == null) {
+//                         actionCommand = getActionCommand();
+//                      }
+//                      e = new ActionEvent(AbstractButton.this,
+//                                          ActionEvent.ACTION_PERFORMED,
+//                                          actionCommand,
+//                                          event.getWhen(),
+//                                          event.getModifiers());
+//                }
+//                ((ActionListener)listeners[i+1]).actionPerformed(e);
+//            }
+//        }
+//    }
 
     /**
      * Notifies all listeners that have registered interest for
@@ -2035,65 +2035,65 @@
      * @param event  the <code>ItemEvent</code> object
      * @see EventListenerList
      */
-    protected void fireItemStateChanged(ItemEvent event) {
-        // Guaranteed to return a non-null array
-        Object[] listeners = listenerList.getListenerList();
-        ItemEvent e = null;
-        // Process the listeners last to first, notifying
-        // those that are interested in this event
-        for (int i = listeners.length-2; i>=0; i-=2) {
-            if (listeners[i]==ItemListener.class) {
-                // Lazily create the event:
-                if (e == null) {
-                    e = new ItemEvent(AbstractButton.this,
-                                      ItemEvent.ITEM_STATE_CHANGED,
-                                      AbstractButton.this,
-                                      event.getStateChange());
-                }
-                ((ItemListener)listeners[i+1]).itemStateChanged(e);
-            }
-        }
-        if (accessibleContext != null) {
-            if (event.getStateChange() == ItemEvent.SELECTED) {
-                accessibleContext.firePropertyChange(
-                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
-                    null, AccessibleState.SELECTED);
-                accessibleContext.firePropertyChange(
-                    AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,
-                    Integer.valueOf(0), Integer.valueOf(1));
-            } else {
-                accessibleContext.firePropertyChange(
-                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
-                    AccessibleState.SELECTED, null);
-                accessibleContext.firePropertyChange(
-                    AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,
-                    Integer.valueOf(1), Integer.valueOf(0));
-            }
-        }
-    }
-
-
-    protected ActionListener createActionListener() {
-        return getHandler();
-    }
-
-
-    protected ItemListener createItemListener() {
-        return getHandler();
-    }
+    protected void fireItemStateChanged(ItemEvent event) {throw new RuntimeException("cf-bug");} //{
+//        // Guaranteed to return a non-null array
+//        Object[] listeners = listenerList.getListenerList();
+//        ItemEvent e = null;
+//        // Process the listeners last to first, notifying
+//        // those that are interested in this event
+//        for (int i = listeners.length-2; i>=0; i-=2) {
+//            if (listeners[i]==ItemListener.class) {
+//                // Lazily create the event:
+//                if (e == null) {
+//                    e = new ItemEvent(AbstractButton.this,
+//                                      ItemEvent.ITEM_STATE_CHANGED,
+//                                      AbstractButton.this,
+//                                      event.getStateChange());
+//                }
+//                ((ItemListener)listeners[i+1]).itemStateChanged(e);
+//            }
+//        }
+//        if (accessibleContext != null) {
+//            if (event.getStateChange() == ItemEvent.SELECTED) {
+//                accessibleContext.firePropertyChange(
+//                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
+//                    null, AccessibleState.SELECTED);
+//                accessibleContext.firePropertyChange(
+//                    AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,
+//                    Integer.valueOf(0), Integer.valueOf(1));
+//            } else {
+//                accessibleContext.firePropertyChange(
+//                    AccessibleContext.ACCESSIBLE_STATE_PROPERTY,
+//                    AccessibleState.SELECTED, null);
+//                accessibleContext.firePropertyChange(
+//                    AccessibleContext.ACCESSIBLE_VALUE_PROPERTY,
+//                    Integer.valueOf(1), Integer.valueOf(0));
+//            }
+//        }
+//    }
+
+
+    protected ActionListener createActionListener() {throw new RuntimeException("cf-bug");} //{
+//        return getHandler();
+//    }
+
+
+    protected ItemListener createItemListener() {throw new RuntimeException("cf-bug");} //{
+//        return getHandler();
+//    }
 
 
     /**
      * Enables (or disables) the button.
      * @param b  true to enable the button, otherwise false
      */
-    public void setEnabled(boolean b) {
-        if (!b && model.isRollover()) {
-            model.setRollover(false);
-        }
-        super.setEnabled(b);
-        model.setEnabled(b);
-    }
+    public void setEnabled(boolean b) {throw new RuntimeException("cf-bug");} //{
+//        if (!b && model.isRollover()) {
+//            model.setRollover(false);
+//        }
+//        super.setEnabled(b);
+//        model.setEnabled(b);
+//    }
 
     // *** Deprecated java.awt.Button APIs below *** //
 
@@ -2104,9 +2104,9 @@
      * @deprecated - Replaced by <code>getText</code>
      */
     @Deprecated
-    public String getLabel() {
-        return getText();
-    }
+    public String getLabel() {throw new RuntimeException("cf-bug");} //{
+//        return getText();
+//    }
 
     /**
      * Sets the label text.
@@ -2118,25 +2118,25 @@
      *  description: Replace by setText(text)
      */
     @Deprecated
-    public void setLabel(String label) {
-        setText(label);
-    }
+    public void setLabel(String label) {throw new RuntimeException("cf-bug");} //{
+//        setText(label);
+//    }
 
     /**
      * Adds an <code>ItemListener</code> to the <code>checkbox</code>.
      * @param l  the <code>ItemListener</code> to be added
      */
-    public void addItemListener(ItemListener l) {
-        listenerList.add(ItemListener.class, l);
-    }
+    public void addItemListener(ItemListener l) {throw new RuntimeException("cf-bug");} //{
+//        listenerList.add(ItemListener.class, l);
+//    }
 
     /**
      * Removes an <code>ItemListener</code> from the button.
      * @param l the <code>ItemListener</code> to be removed
      */
-    public void removeItemListener(ItemListener l) {
-        listenerList.remove(ItemListener.class, l);
-    }
+    public void removeItemListener(ItemListener l) {throw new RuntimeException("cf-bug");} //{
+//        listenerList.remove(ItemListener.class, l);
+//    }
 
     /**
      * Returns an array of all the <code>ItemListener</code>s added
@@ -2146,9 +2146,9 @@
      *         array if no listeners have been added
      * @since 1.4
      */
-    public ItemListener[] getItemListeners() {
-        return listenerList.getListeners(ItemListener.class);
-    }
+    public ItemListener[] getItemListeners() {throw new RuntimeException("cf-bug");} //{
+//        return listenerList.getListeners(ItemListener.class);
+//    }
 
    /**
      * Returns an array (length 1) containing the label or
@@ -2157,30 +2157,30 @@
      * @return an array containing 1 Object: the text of the button,
      *         if the item is selected; otherwise <code>null</code>
      */
-    public Object[] getSelectedObjects() {
-        if (isSelected() == false) {
-            return null;
-        }
-        Object[] selectedObjects = new Object[1];
-        selectedObjects[0] = getText();
-        return selectedObjects;
-    }
-
-    protected void init(String text, Icon icon) {
-        if(text != null) {
-            setText(text);
-        }
-
-        if(icon != null) {
-            setIcon(icon);
-        }
-
-        // Set the UI
-        updateUI();
-
-        setAlignmentX(LEFT_ALIGNMENT);
-        setAlignmentY(CENTER_ALIGNMENT);
-    }
+    public Object[] getSelectedObjects() {throw new RuntimeException("cf-bug");} //{
+//        if (isSelected() == false) {
+//            return null;
+//        }
+//        Object[] selectedObjects = new Object[1];
+//        selectedObjects[0] = getText();
+//        return selectedObjects;
+//    }
+
+    protected void init(String text, Icon icon) {throw new RuntimeException("cf-bug");} //{
+//        if(text != null) {
+//            setText(text);
+//        }
+//
+//        if(icon != null) {
+//            setIcon(icon);
+//        }
+//
+//        // Set the UI
+//        updateUI();
+//
+//        setAlignmentX(LEFT_ALIGNMENT);
+//        setAlignmentY(CENTER_ALIGNMENT);
+//    }
 
 
     /**
@@ -2199,65 +2199,65 @@
      * @see     java.awt.Component#imageUpdate(java.awt.Image, int, int, int, int, int)
      */
     public boolean imageUpdate(Image img, int infoflags,
-                               int x, int y, int w, int h) {
-        Icon iconDisplayed = null;
-
-        if (!model.isEnabled()) {
-            if (model.isSelected()) {
-                iconDisplayed = getDisabledSelectedIcon();
-            } else {
-                iconDisplayed = getDisabledIcon();
-            }
-        } else if (model.isPressed() && model.isArmed()) {
-            iconDisplayed = getPressedIcon();
-        } else if (isRolloverEnabled() && model.isRollover()) {
-            if (model.isSelected()) {
-                iconDisplayed = getRolloverSelectedIcon();
-            } else {
-                iconDisplayed = getRolloverIcon();
-            }
-        } else if (model.isSelected()) {
-            iconDisplayed = getSelectedIcon();
-        }
-
-        if (iconDisplayed == null) {
-            iconDisplayed = getIcon();
-        }
-
-        if (iconDisplayed == null
-            || !SwingUtilities.doesIconReferenceImage(iconDisplayed, img)) {
-            // We don't know about this image, disable the notification so
-            // we don't keep repainting.
-            return false;
-        }
-        return super.imageUpdate(img, infoflags, x, y, w, h);
-    }
-
-    void setUIProperty(String propertyName, Object value) {
-        if (propertyName == "borderPainted") {
-            if (!borderPaintedSet) {
-                setBorderPainted(((Boolean)value).booleanValue());
-                borderPaintedSet = false;
-            }
-        } else if (propertyName == "rolloverEnabled") {
-            if (!rolloverEnabledSet) {
-                setRolloverEnabled(((Boolean)value).booleanValue());
-                rolloverEnabledSet = false;
-            }
-        } else if (propertyName == "iconTextGap") {
-            if (!iconTextGapSet) {
-                setIconTextGap(((Number)value).intValue());
-                iconTextGapSet = false;
-            }
-        } else if (propertyName == "contentAreaFilled") {
-            if (!contentAreaFilledSet) {
-                setContentAreaFilled(((Boolean)value).booleanValue());
-                contentAreaFilledSet = false;
-            }
-        } else {
-            super.setUIProperty(propertyName, value);
-        }
-    }
+                               int x, int y, int w, int h) {throw new RuntimeException("cf-bug");} //{
+//        Icon iconDisplayed = null;
+//
+//        if (!model.isEnabled()) {
+//            if (model.isSelected()) {
+//                iconDisplayed = getDisabledSelectedIcon();
+//            } else {
+//                iconDisplayed = getDisabledIcon();
+//            }
+//        } else if (model.isPressed() && model.isArmed()) {
+//            iconDisplayed = getPressedIcon();
+//        } else if (isRolloverEnabled() && model.isRollover()) {
+//            if (model.isSelected()) {
+//                iconDisplayed = getRolloverSelectedIcon();
+//            } else {
+//                iconDisplayed = getRolloverIcon();
+//            }
+//        } else if (model.isSelected()) {
+//            iconDisplayed = getSelectedIcon();
+//        }
+//
+//        if (iconDisplayed == null) {
+//            iconDisplayed = getIcon();
+//        }
+//
+//        if (iconDisplayed == null
+//            || !SwingUtilities.doesIconReferenceImage(iconDisplayed, img)) {
+//            // We don't know about this image, disable the notification so
+//            // we don't keep repainting.
+//            return false;
+//        }
+//        return super.imageUpdate(img, infoflags, x, y, w, h);
+//    }
+
+    void setUIProperty(String propertyName, Object value) {throw new RuntimeException("cf-bug");} //{
+//        if (propertyName == "borderPainted") {
+//            if (!borderPaintedSet) {
+//                setBorderPainted(((Boolean)value).booleanValue());
+//                borderPaintedSet = false;
+//            }
+//        } else if (propertyName == "rolloverEnabled") {
+//            if (!rolloverEnabledSet) {
+//                setRolloverEnabled(((Boolean)value).booleanValue());
+//                rolloverEnabledSet = false;
+//            }
+//        } else if (propertyName == "iconTextGap") {
+//            if (!iconTextGapSet) {
+//                setIconTextGap(((Number)value).intValue());
+//                iconTextGapSet = false;
+//            }
+//        } else if (propertyName == "contentAreaFilled") {
+//            if (!contentAreaFilledSet) {
+//                setContentAreaFilled(((Boolean)value).booleanValue());
+//                contentAreaFilledSet = false;
+//            }
+//        } else {
+//            super.setUIProperty(propertyName, value);
+//        }
+//    }
 
     /**
      * Returns a string representation of this <code>AbstractButton</code>.
@@ -2272,56 +2272,56 @@
      *
      * @return  a string representation of this <code>AbstractButton</code>
      */
-    protected String paramString() {
-        String defaultIconString = ((defaultIcon != null)
-                                    && (defaultIcon != this) ?
-                                    defaultIcon.toString() : "");
-        String pressedIconString = ((pressedIcon != null)
-                                    && (pressedIcon != this) ?
-                                    pressedIcon.toString() : "");
-        String disabledIconString = ((disabledIcon != null)
-                                     && (disabledIcon != this) ?
-                                     disabledIcon.toString() : "");
-        String selectedIconString = ((selectedIcon != null)
-                                     && (selectedIcon != this) ?
-                                     selectedIcon.toString() : "");
-        String disabledSelectedIconString = ((disabledSelectedIcon != null) &&
-                                             (disabledSelectedIcon != this) ?
-                                             disabledSelectedIcon.toString()
-                                             : "");
-        String rolloverIconString = ((rolloverIcon != null)
-                                     && (rolloverIcon != this) ?
-                                     rolloverIcon.toString() : "");
-        String rolloverSelectedIconString = ((rolloverSelectedIcon != null) &&
-                                             (rolloverSelectedIcon != this) ?
-                                             rolloverSelectedIcon.toString()
-                                             : "");
-        String paintBorderString = (paintBorder ? "true" : "false");
-        String paintFocusString = (paintFocus ? "true" : "false");
-        String rolloverEnabledString = (rolloverEnabled ? "true" : "false");
-
-        return super.paramString() +
-        ",defaultIcon=" + defaultIconString +
-        ",disabledIcon=" + disabledIconString +
-        ",disabledSelectedIcon=" + disabledSelectedIconString +
-        ",margin=" + margin +
-        ",paintBorder=" + paintBorderString +
-        ",paintFocus=" + paintFocusString +
-        ",pressedIcon=" + pressedIconString +
-        ",rolloverEnabled=" + rolloverEnabledString +
-        ",rolloverIcon=" + rolloverIconString +
-        ",rolloverSelectedIcon=" + rolloverSelectedIconString +
-        ",selectedIcon=" + selectedIconString +
-        ",text=" + text;
-    }
-
-
-    private Handler getHandler() {
-        if (handler == null) {
-            handler = new Handler();
-        }
-        return handler;
-    }
+    protected String paramString() {throw new RuntimeException("cf-bug");} //{
+//        String defaultIconString = ((defaultIcon != null)
+//                                    && (defaultIcon != this) ?
+//                                    defaultIcon.toString() : "");
+//        String pressedIconString = ((pressedIcon != null)
+//                                    && (pressedIcon != this) ?
+//                                    pressedIcon.toString() : "");
+//        String disabledIconString = ((disabledIcon != null)
+//                                     && (disabledIcon != this) ?
+//                                     disabledIcon.toString() : "");
+//        String selectedIconString = ((selectedIcon != null)
+//                                     && (selectedIcon != this) ?
+//                                     selectedIcon.toString() : "");
+//        String disabledSelectedIconString = ((disabledSelectedIcon != null) &&
+//                                             (disabledSelectedIcon != this) ?
+//                                             disabledSelectedIcon.toString()
+//                                             : "");
+//        String rolloverIconString = ((rolloverIcon != null)
+//                                     && (rolloverIcon != this) ?
+//                                     rolloverIcon.toString() : "");
+//        String rolloverSelectedIconString = ((rolloverSelectedIcon != null) &&
+//                                             (rolloverSelectedIcon != this) ?
+//                                             rolloverSelectedIcon.toString()
+//                                             : "");
+//        String paintBorderString = (paintBorder ? "true" : "false");
+//        String paintFocusString = (paintFocus ? "true" : "false");
+//        String rolloverEnabledString = (rolloverEnabled ? "true" : "false");
+//
+//        return super.paramString() +
+//        ",defaultIcon=" + defaultIconString +
+//        ",disabledIcon=" + disabledIconString +
+//        ",disabledSelectedIcon=" + disabledSelectedIconString +
+//        ",margin=" + margin +
+//        ",paintBorder=" + paintBorderString +
+//        ",paintFocus=" + paintFocusString +
+//        ",pressedIcon=" + pressedIconString +
+//        ",rolloverEnabled=" + rolloverEnabledString +
+//        ",rolloverIcon=" + rolloverIconString +
+//        ",rolloverSelectedIcon=" + rolloverSelectedIconString +
+//        ",selectedIcon=" + selectedIconString +
+//        ",text=" + text;
+//    }
+
+
+    private Handler getHandler() {throw new RuntimeException("cf-bug");} //{
+//        if (handler == null) {
+//            handler = new Handler();
+//        }
+//        return handler;
+//    }
 
 
     //
@@ -2333,41 +2333,41 @@
         //
         // ChangeListener
         //
-        public void stateChanged(ChangeEvent e) {
-            Object source = e.getSource();
-
-            updateMnemonicProperties();
-            if (isEnabled() != model.isEnabled()) {
-                setEnabled(model.isEnabled());
-            }
-            fireStateChanged();
-            repaint();
-        }
+        public void stateChanged(ChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//            Object source = e.getSource();
+//
+//            updateMnemonicProperties();
+//            if (isEnabled() != model.isEnabled()) {
+//                setEnabled(model.isEnabled());
+//            }
+//            fireStateChanged();
+//            repaint();
+//        }
 
         //
         // ActionListener
         //
-        public void actionPerformed(ActionEvent event) {
-            fireActionPerformed(event);
-        }
+        public void actionPerformed(ActionEvent event) {throw new RuntimeException("cf-bug");} //{
+//            fireActionPerformed(event);
+//        }
 
         //
         // ItemListener
         //
-        public void itemStateChanged(ItemEvent event) {
-            fireItemStateChanged(event);
-            if (shouldUpdateSelectedStateFromAction()) {
-                Action action = getAction();
-                if (action != null && AbstractAction.hasSelectedKey(action)) {
-                    boolean selected = isSelected();
-                    boolean isActionSelected = AbstractAction.isSelected(
-                              action);
-                    if (isActionSelected != selected) {
-                        action.putValue(Action.SELECTED_KEY, selected);
-                    }
-                }
-            }
-        }
+        public void itemStateChanged(ItemEvent event) {throw new RuntimeException("cf-bug");} //{
+//            fireItemStateChanged(event);
+//            if (shouldUpdateSelectedStateFromAction()) {
+//                Action action = getAction();
+//                if (action != null && AbstractAction.hasSelectedKey(action)) {
+//                    boolean selected = isSelected();
+//                    boolean isActionSelected = AbstractAction.isSelected(
+//                              action);
+//                    if (isActionSelected != selected) {
+//                        action.putValue(Action.SELECTED_KEY, selected);
+//                    }
+//                }
+//            }
+//        }
     }
 
 ///////////////////
@@ -2400,38 +2400,38 @@
          *              <code>null</code> if this
          *              object does not have a name
          */
-        public String getAccessibleName() {
-            String name = accessibleName;
-
-            if (name == null) {
-                name = (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);
-            }
-            if (name == null) {
-                name = AbstractButton.this.getText();
-            }
-            if (name == null) {
-                name = super.getAccessibleName();
-            }
-            return name;
-        }
+        public String getAccessibleName() {throw new RuntimeException("cf-bug");} //{
+//            String name = accessibleName;
+//
+//            if (name == null) {
+//                name = (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);
+//            }
+//            if (name == null) {
+//                name = AbstractButton.this.getText();
+//            }
+//            if (name == null) {
+//                name = super.getAccessibleName();
+//            }
+//            return name;
+//        }
 
         /**
          * Get the AccessibleIcons associated with this object if one
          * or more exist.  Otherwise return null.
          * @since 1.3
          */
-        public AccessibleIcon [] getAccessibleIcon() {
-            Icon defaultIcon = getIcon();
-
-            if (defaultIcon instanceof Accessible) {
-                AccessibleContext ac =
-                    ((Accessible)defaultIcon).getAccessibleContext();
-                if (ac != null && ac instanceof AccessibleIcon) {
-                    return new AccessibleIcon[] { (AccessibleIcon)ac };
-                }
-            }
-            return null;
-        }
+        public AccessibleIcon [] getAccessibleIcon() {throw new RuntimeException("cf-bug");} //{
+//            Icon defaultIcon = getIcon();
+//
+//            if (defaultIcon instanceof Accessible) {
+//                AccessibleContext ac =
+//                    ((Accessible)defaultIcon).getAccessibleContext();
+//                if (ac != null && ac instanceof AccessibleIcon) {
+//                    return new AccessibleIcon[] { (AccessibleIcon)ac };
+//                }
+//            }
+//            return null;
+//        }
 
         /**
          * Get the state set of this object.
@@ -2440,22 +2440,22 @@
          * of the object
          * @see AccessibleState
          */
-        public AccessibleStateSet getAccessibleStateSet() {
-        AccessibleStateSet states = super.getAccessibleStateSet();
-            if (getModel().isArmed()) {
-                states.add(AccessibleState.ARMED);
-            }
-            if (isFocusOwner()) {
-                states.add(AccessibleState.FOCUSED);
-            }
-            if (getModel().isPressed()) {
-                states.add(AccessibleState.PRESSED);
-            }
-            if (isSelected()) {
-                states.add(AccessibleState.CHECKED);
-            }
-            return states;
-        }
+        public AccessibleStateSet getAccessibleStateSet() {throw new RuntimeException("cf-bug");} //{
+//        AccessibleStateSet states = super.getAccessibleStateSet();
+//            if (getModel().isArmed()) {
+//                states.add(AccessibleState.ARMED);
+//            }
+//            if (isFocusOwner()) {
+//                states.add(AccessibleState.FOCUSED);
+//            }
+//            if (getModel().isPressed()) {
+//                states.add(AccessibleState.PRESSED);
+//            }
+//            if (isSelected()) {
+//                states.add(AccessibleState.CHECKED);
+//            }
+//            return states;
+//        }
 
         /**
          * Get the AccessibleRelationSet associated with this object if one
@@ -2463,38 +2463,38 @@
          * @see AccessibleRelation
          * @since 1.3
          */
-        public AccessibleRelationSet getAccessibleRelationSet() {
-
-            // Check where the AccessibleContext's relation
-            // set already contains a MEMBER_OF relation.
-            AccessibleRelationSet relationSet
-                = super.getAccessibleRelationSet();
-
-            if (!relationSet.contains(AccessibleRelation.MEMBER_OF)) {
-                // get the members of the button group if one exists
-                ButtonModel model = getModel();
-                if (model != null && model instanceof DefaultButtonModel) {
-                    ButtonGroup group = ((DefaultButtonModel)model).getGroup();
-                    if (group != null) {
-                        // set the target of the MEMBER_OF relation to be
-                        // the members of the button group.
-                        int len = group.getButtonCount();
-                        Object [] target = new Object[len];
-                        Enumeration<AbstractButton> elem = group.getElements();
-                        for (int i = 0; i < len; i++) {
-                            if (elem.hasMoreElements()) {
-                                target[i] = elem.nextElement();
-                            }
-                        }
-                        AccessibleRelation relation =
-                            new AccessibleRelation(AccessibleRelation.MEMBER_OF);
-                        relation.setTarget(target);
-                        relationSet.add(relation);
-                    }
-                }
-            }
-            return relationSet;
-        }
+        public AccessibleRelationSet getAccessibleRelationSet() {throw new RuntimeException("cf-bug");} //{
+//
+//            // Check where the AccessibleContext's relation
+//            // set already contains a MEMBER_OF relation.
+//            AccessibleRelationSet relationSet
+//                = super.getAccessibleRelationSet();
+//
+//            if (!relationSet.contains(AccessibleRelation.MEMBER_OF)) {
+//                // get the members of the button group if one exists
+//                ButtonModel model = getModel();
+//                if (model != null && model instanceof DefaultButtonModel) {
+//                    ButtonGroup group = ((DefaultButtonModel)model).getGroup();
+//                    if (group != null) {
+//                        // set the target of the MEMBER_OF relation to be
+//                        // the members of the button group.
+//                        int len = group.getButtonCount();
+//                        Object [] target = new Object[len];
+//                        Enumeration<AbstractButton> elem = group.getElements();
+//                        for (int i = 0; i < len; i++) {
+//                            if (elem.hasMoreElements()) {
+//                                target[i] = elem.nextElement();
+//                            }
+//                        }
+//                        AccessibleRelation relation =
+//                            new AccessibleRelation(AccessibleRelation.MEMBER_OF);
+//                        relation.setTarget(target);
+//                        relationSet.add(relation);
+//                    }
+//                }
+//            }
+//            return relationSet;
+//        }
 
         /**
          * Get the AccessibleAction associated with this object.  In the
@@ -2504,9 +2504,9 @@
          *
          * @return this object
          */
-        public AccessibleAction getAccessibleAction() {
-            return this;
-        }
+        public AccessibleAction getAccessibleAction() {throw new RuntimeException("cf-bug");} //{
+//            return this;
+//        }
 
         /**
          * Get the AccessibleValue associated with this object.  In the
@@ -2516,9 +2516,9 @@
          *
          * @return this object
          */
-        public AccessibleValue getAccessibleValue() {
-            return this;
-        }
+        public AccessibleValue getAccessibleValue() {throw new RuntimeException("cf-bug");} //{
+//            return this;
+//        }
 
         /**
          * Returns the number of Actions available in this object.  The
@@ -2527,22 +2527,22 @@
          *
          * @return 1, the number of Actions in this object
          */
-        public int getAccessibleActionCount() {
-            return 1;
-        }
+        public int getAccessibleActionCount() {throw new RuntimeException("cf-bug");} //{
+//            return 1;
+//        }
 
         /**
          * Return a description of the specified action of the object.
          *
          * @param i zero-based index of the actions
          */
-        public String getAccessibleActionDescription(int i) {
-            if (i == 0) {
-                return UIManager.getString("AbstractButton.clickText");
-            } else {
-                return null;
-            }
-        }
+        public String getAccessibleActionDescription(int i) {throw new RuntimeException("cf-bug");} //{
+//            if (i == 0) {
+//                return UIManager.getString("AbstractButton.clickText");
+//            } else {
+//                return null;
+//            }
+//        }
 
         /**
          * Perform the specified Action on the object
@@ -2550,14 +2550,14 @@
          * @param i zero-based index of actions
          * @return true if the the action was performed; else false.
          */
-        public boolean doAccessibleAction(int i) {
-            if (i == 0) {
-                doClick();
-                return true;
-            } else {
-                return false;
-            }
-        }
+        public boolean doAccessibleAction(int i) {throw new RuntimeException("cf-bug");} //{
+//            if (i == 0) {
+//                doClick();
+//                return true;
+//            } else {
+//                return false;
+//            }
+//        }
 
         /**
          * Get the value of this object as a Number.
@@ -2566,62 +2566,62 @@
          * this is selected.
          * @see AbstractButton#isSelected
          */
-        public Number getCurrentAccessibleValue() {
-            if (isSelected()) {
-                return Integer.valueOf(1);
-            } else {
-                return Integer.valueOf(0);
-            }
-        }
+        public Number getCurrentAccessibleValue() {throw new RuntimeException("cf-bug");} //{
+//            if (isSelected()) {
+//                return Integer.valueOf(1);
+//            } else {
+//                return Integer.valueOf(0);
+//            }
+//        }
 
         /**
          * Set the value of this object as a Number.
          *
          * @return True if the value was set.
          */
-        public boolean setCurrentAccessibleValue(Number n) {
-            // TIGER - 4422535
-            if (n == null) {
-                return false;
-            }
-            int i = n.intValue();
-            if (i == 0) {
-                setSelected(false);
-            } else {
-                setSelected(true);
-            }
-            return true;
-        }
+        public boolean setCurrentAccessibleValue(Number n) {throw new RuntimeException("cf-bug");} //{
+//            // TIGER - 4422535
+//            if (n == null) {
+//                return false;
+//            }
+//            int i = n.intValue();
+//            if (i == 0) {
+//                setSelected(false);
+//            } else {
+//                setSelected(true);
+//            }
+//            return true;
+//        }
 
         /**
          * Get the minimum value of this object as a Number.
          *
          * @return an Integer of 0.
          */
-        public Number getMinimumAccessibleValue() {
-            return Integer.valueOf(0);
-        }
+        public Number getMinimumAccessibleValue() {throw new RuntimeException("cf-bug");} //{
+//            return Integer.valueOf(0);
+//        }
 
         /**
          * Get the maximum value of this object as a Number.
          *
          * @return An Integer of 1.
          */
-        public Number getMaximumAccessibleValue() {
-            return Integer.valueOf(1);
-        }
+        public Number getMaximumAccessibleValue() {throw new RuntimeException("cf-bug");} //{
+//            return Integer.valueOf(1);
+//        }
 
 
         /* AccessibleText ---------- */
 
-        public AccessibleText getAccessibleText() {
-            View view = (View)AbstractButton.this.getClientProperty("html");
-            if (view != null) {
-                return this;
-            } else {
-                return null;
-            }
-        }
+        public AccessibleText getAccessibleText() {throw new RuntimeException("cf-bug");} //{
+//            View view = (View)AbstractButton.this.getClientProperty("html");
+//            if (view != null) {
+//                return this;
+//            } else {
+//                return null;
+//            }
+//        }
 
         /**
          * Given a point in local coordinates, return the zero-based index
@@ -2638,21 +2638,21 @@
          * Point is invalid returns -1.
          * @since 1.3
          */
-        public int getIndexAtPoint(Point p) {
-            View view = (View) AbstractButton.this.getClientProperty("html");
-            if (view != null) {
-                Rectangle r = getTextRectangle();
-                if (r == null) {
-                    return -1;
-                }
-                Rectangle2D.Float shape =
-                    new Rectangle2D.Float(r.x, r.y, r.width, r.height);
-                Position.Bias bias[] = new Position.Bias[1];
-                return view.viewToModel(p.x, p.y, shape, bias);
-            } else {
-                return -1;
-            }
-        }
+        public int getIndexAtPoint(Point p) {throw new RuntimeException("cf-bug");} //{
+//            View view = (View) AbstractButton.this.getClientProperty("html");
+//            if (view != null) {
+//                Rectangle r = getTextRectangle();
+//                if (r == null) {
+//                    return -1;
+//                }
+//                Rectangle2D.Float shape =
+//                    new Rectangle2D.Float(r.x, r.y, r.width, r.height);
+//                Position.Bias bias[] = new Position.Bias[1];
+//                return view.viewToModel(p.x, p.y, shape, bias);
+//            } else {
+//                return -1;
+//            }
+//        }
 
         /**
          * Determine the bounding box of the character at the given
@@ -2670,26 +2670,26 @@
          * if index is invalid returns an empty rectangle.
          * @since 1.3
          */
-        public Rectangle getCharacterBounds(int i) {
-            View view = (View) AbstractButton.this.getClientProperty("html");
-            if (view != null) {
-                Rectangle r = getTextRectangle();
-                if (r == null) {
-                    return null;
-                }
-                Rectangle2D.Float shape =
-                    new Rectangle2D.Float(r.x, r.y, r.width, r.height);
-                try {
-                    Shape charShape =
-                        view.modelToView(i, shape, Position.Bias.Forward);
-                    return charShape.getBounds();
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            } else {
-                return null;
-            }
-        }
+        public Rectangle getCharacterBounds(int i) {throw new RuntimeException("cf-bug");} //{
+//            View view = (View) AbstractButton.this.getClientProperty("html");
+//            if (view != null) {
+//                Rectangle r = getTextRectangle();
+//                if (r == null) {
+//                    return null;
+//                }
+//                Rectangle2D.Float shape =
+//                    new Rectangle2D.Float(r.x, r.y, r.width, r.height);
+//                try {
+//                    Shape charShape =
+//                        view.modelToView(i, shape, Position.Bias.Forward);
+//                    return charShape.getBounds();
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            } else {
+//                return null;
+//            }
+//        }
 
         /**
          * Return the number of characters (valid indicies)
@@ -2697,17 +2697,17 @@
          * @return the number of characters
          * @since 1.3
          */
-        public int getCharCount() {
-            View view = (View) AbstractButton.this.getClientProperty("html");
-            if (view != null) {
-                Document d = view.getDocument();
-                if (d instanceof StyledDocument) {
-                    StyledDocument doc = (StyledDocument)d;
-                    return doc.getLength();
-                }
-            }
-            return accessibleContext.getAccessibleName().length();
-        }
+        public int getCharCount() {throw new RuntimeException("cf-bug");} //{
+//            View view = (View) AbstractButton.this.getClientProperty("html");
+//            if (view != null) {
+//                Document d = view.getDocument();
+//                if (d instanceof StyledDocument) {
+//                    StyledDocument doc = (StyledDocument)d;
+//                    return doc.getLength();
+//                }
+//            }
+//            return accessibleContext.getAccessibleName().length();
+//        }
 
         /**
          * Return the zero-based offset of the caret.
@@ -2717,10 +2717,10 @@
          * @return the zero-based offset of the caret.
          * @since 1.3
          */
-        public int getCaretPosition() {
-            // There is no caret.
-            return -1;
-        }
+        public int getCaretPosition() {throw new RuntimeException("cf-bug");} //{
+//            // There is no caret.
+//            return -1;
+//        }
 
         /**
          * Returns the String at a given index.
@@ -2732,42 +2732,42 @@
          *   null for an invalid index or part
          * @since 1.3
          */
-        public String getAtIndex(int part, int index) {
-            if (index < 0 || index >= getCharCount()) {
-                return null;
-            }
-            switch (part) {
-            case AccessibleText.CHARACTER:
-                try {
-                    return getText(index, 1);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.WORD:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
-                    words.setText(s);
-                    int end = words.following(index);
-                    return s.substring(words.previous(), end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.SENTENCE:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator sentence =
-                        BreakIterator.getSentenceInstance(getLocale());
-                    sentence.setText(s);
-                    int end = sentence.following(index);
-                    return s.substring(sentence.previous(), end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            default:
-                return null;
-            }
-        }
+        public String getAtIndex(int part, int index) {throw new RuntimeException("cf-bug");} //{
+//            if (index < 0 || index >= getCharCount()) {
+//                return null;
+//            }
+//            switch (part) {
+//            case AccessibleText.CHARACTER:
+//                try {
+//                    return getText(index, 1);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.WORD:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
+//                    words.setText(s);
+//                    int end = words.following(index);
+//                    return s.substring(words.previous(), end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.SENTENCE:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator sentence =
+//                        BreakIterator.getSentenceInstance(getLocale());
+//                    sentence.setText(s);
+//                    int end = sentence.following(index);
+//                    return s.substring(sentence.previous(), end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            default:
+//                return null;
+//            }
+//        }
 
         /**
          * Returns the String after a given index.
@@ -2779,59 +2779,59 @@
          *  index or part
          * @since 1.3
          */
-        public String getAfterIndex(int part, int index) {
-            if (index < 0 || index >= getCharCount()) {
-                return null;
-            }
-            switch (part) {
-            case AccessibleText.CHARACTER:
-                if (index+1 >= getCharCount()) {
-                   return null;
-                }
-                try {
-                    return getText(index+1, 1);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.WORD:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
-                    words.setText(s);
-                    int start = words.following(index);
-                    if (start == BreakIterator.DONE || start >= s.length()) {
-                        return null;
-                    }
-                    int end = words.following(start);
-                    if (end == BreakIterator.DONE || end >= s.length()) {
-                        return null;
-                    }
-                    return s.substring(start, end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.SENTENCE:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator sentence =
-                        BreakIterator.getSentenceInstance(getLocale());
-                    sentence.setText(s);
-                    int start = sentence.following(index);
-                    if (start == BreakIterator.DONE || start > s.length()) {
-                        return null;
-                    }
-                    int end = sentence.following(start);
-                    if (end == BreakIterator.DONE || end > s.length()) {
-                        return null;
-                    }
-                    return s.substring(start, end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            default:
-                return null;
-            }
-        }
+        public String getAfterIndex(int part, int index) {throw new RuntimeException("cf-bug");} //{
+//            if (index < 0 || index >= getCharCount()) {
+//                return null;
+//            }
+//            switch (part) {
+//            case AccessibleText.CHARACTER:
+//                if (index+1 >= getCharCount()) {
+//                   return null;
+//                }
+//                try {
+//                    return getText(index+1, 1);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.WORD:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
+//                    words.setText(s);
+//                    int start = words.following(index);
+//                    if (start == BreakIterator.DONE || start >= s.length()) {
+//                        return null;
+//                    }
+//                    int end = words.following(start);
+//                    if (end == BreakIterator.DONE || end >= s.length()) {
+//                        return null;
+//                    }
+//                    return s.substring(start, end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.SENTENCE:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator sentence =
+//                        BreakIterator.getSentenceInstance(getLocale());
+//                    sentence.setText(s);
+//                    int start = sentence.following(index);
+//                    if (start == BreakIterator.DONE || start > s.length()) {
+//                        return null;
+//                    }
+//                    int end = sentence.following(start);
+//                    if (end == BreakIterator.DONE || end > s.length()) {
+//                        return null;
+//                    }
+//                    return s.substring(start, end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            default:
+//                return null;
+//            }
+//        }
 
         /**
          * Returns the String before a given index.
@@ -2843,55 +2843,55 @@
          *  or part
          * @since 1.3
          */
-        public String getBeforeIndex(int part, int index) {
-            if (index < 0 || index > getCharCount()-1) {
-                return null;
-            }
-            switch (part) {
-            case AccessibleText.CHARACTER:
-                if (index == 0) {
-                    return null;
-                }
-                try {
-                    return getText(index-1, 1);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.WORD:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
-                    words.setText(s);
-                    int end = words.following(index);
-                    end = words.previous();
-                    int start = words.previous();
-                    if (start == BreakIterator.DONE) {
-                        return null;
-                    }
-                    return s.substring(start, end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.SENTENCE:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator sentence =
-                        BreakIterator.getSentenceInstance(getLocale());
-                    sentence.setText(s);
-                    int end = sentence.following(index);
-                    end = sentence.previous();
-                    int start = sentence.previous();
-                    if (start == BreakIterator.DONE) {
-                        return null;
-                    }
-                    return s.substring(start, end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            default:
-                return null;
-            }
-        }
+        public String getBeforeIndex(int part, int index) {throw new RuntimeException("cf-bug");} //{
+//            if (index < 0 || index > getCharCount()-1) {
+//                return null;
+//            }
+//            switch (part) {
+//            case AccessibleText.CHARACTER:
+//                if (index == 0) {
+//                    return null;
+//                }
+//                try {
+//                    return getText(index-1, 1);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.WORD:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
+//                    words.setText(s);
+//                    int end = words.following(index);
+//                    end = words.previous();
+//                    int start = words.previous();
+//                    if (start == BreakIterator.DONE) {
+//                        return null;
+//                    }
+//                    return s.substring(start, end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.SENTENCE:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator sentence =
+//                        BreakIterator.getSentenceInstance(getLocale());
+//                    sentence.setText(s);
+//                    int end = sentence.following(index);
+//                    end = sentence.previous();
+//                    int start = sentence.previous();
+//                    if (start == BreakIterator.DONE) {
+//                        return null;
+//                    }
+//                    return s.substring(start, end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            default:
+//                return null;
+//            }
+//        }
 
         /**
          * Return the AttributeSet for a given character at a given index
@@ -2900,20 +2900,20 @@
          * @return the AttributeSet of the character
          * @since 1.3
          */
-        public AttributeSet getCharacterAttribute(int i) {
-            View view = (View) AbstractButton.this.getClientProperty("html");
-            if (view != null) {
-                Document d = view.getDocument();
-                if (d instanceof StyledDocument) {
-                    StyledDocument doc = (StyledDocument)d;
-                    Element elem = doc.getCharacterElement(i);
-                    if (elem != null) {
-                        return elem.getAttributes();
-                    }
-                }
-            }
-            return null;
-        }
+        public AttributeSet getCharacterAttribute(int i) {throw new RuntimeException("cf-bug");} //{
+//            View view = (View) AbstractButton.this.getClientProperty("html");
+//            if (view != null) {
+//                Document d = view.getDocument();
+//                if (d instanceof StyledDocument) {
+//                    StyledDocument doc = (StyledDocument)d;
+//                    Element elem = doc.getCharacterElement(i);
+//                    if (elem != null) {
+//                        return elem.getAttributes();
+//                    }
+//                }
+//            }
+//            return null;
+//        }
 
         /**
          * Returns the start offset within the selected text.
@@ -2923,10 +2923,10 @@
          * @return the index into the text of the start of the selection
          * @since 1.3
          */
-        public int getSelectionStart() {
-            // Text cannot be selected.
-            return -1;
-        }
+        public int getSelectionStart() {throw new RuntimeException("cf-bug");} //{
+//            // Text cannot be selected.
+//            return -1;
+//        }
 
         /**
          * Returns the end offset within the selected text.
@@ -2936,10 +2936,10 @@
          * @return the index into the text of the end of the selection
          * @since 1.3
          */
-        public int getSelectionEnd() {
-            // Text cannot be selected.
-            return -1;
-        }
+        public int getSelectionEnd() {throw new RuntimeException("cf-bug");} //{
+//            // Text cannot be selected.
+//            return -1;
+//        }
 
         /**
          * Returns the portion of the text that is selected.
@@ -2947,68 +2947,68 @@
          * @return the String portion of the text that is selected
          * @since 1.3
          */
-        public String getSelectedText() {
-            // Text cannot be selected.
-            return null;
-        }
+        public String getSelectedText() {throw new RuntimeException("cf-bug");} //{
+//            // Text cannot be selected.
+//            return null;
+//        }
 
         /*
          * Returns the text substring starting at the specified
          * offset with the specified length.
          */
         private String getText(int offset, int length)
-            throws BadLocationException {
-
-            View view = (View) AbstractButton.this.getClientProperty("html");
-            if (view != null) {
-                Document d = view.getDocument();
-                if (d instanceof StyledDocument) {
-                    StyledDocument doc = (StyledDocument)d;
-                    return doc.getText(offset, length);
-                }
-            }
-            return null;
-        }
+            throws BadLocationException {throw new RuntimeException("cf-bug");} //{
+//
+//            View view = (View) AbstractButton.this.getClientProperty("html");
+//            if (view != null) {
+//                Document d = view.getDocument();
+//                if (d instanceof StyledDocument) {
+//                    StyledDocument doc = (StyledDocument)d;
+//                    return doc.getText(offset, length);
+//                }
+//            }
+//            return null;
+//        }
 
         /*
          * Returns the bounding rectangle for the component text.
          */
-        private Rectangle getTextRectangle() {
-
-            String text = AbstractButton.this.getText();
-            Icon icon = (AbstractButton.this.isEnabled()) ? AbstractButton.this.getIcon() : AbstractButton.this.getDisabledIcon();
-
-            if ((icon == null) && (text == null)) {
-                return null;
-            }
-
-            Rectangle paintIconR = new Rectangle();
-            Rectangle paintTextR = new Rectangle();
-            Rectangle paintViewR = new Rectangle();
-            Insets paintViewInsets = new Insets(0, 0, 0, 0);
-
-            paintViewInsets = AbstractButton.this.getInsets(paintViewInsets);
-            paintViewR.x = paintViewInsets.left;
-            paintViewR.y = paintViewInsets.top;
-            paintViewR.width = AbstractButton.this.getWidth() - (paintViewInsets.left + paintViewInsets.right);
-            paintViewR.height = AbstractButton.this.getHeight() - (paintViewInsets.top + paintViewInsets.bottom);
-
-            String clippedText = SwingUtilities.layoutCompoundLabel(
-                AbstractButton.this,
-                getFontMetrics(getFont()),
-                text,
-                icon,
-                AbstractButton.this.getVerticalAlignment(),
-                AbstractButton.this.getHorizontalAlignment(),
-                AbstractButton.this.getVerticalTextPosition(),
-                AbstractButton.this.getHorizontalTextPosition(),
-                paintViewR,
-                paintIconR,
-                paintTextR,
-                0);
-
-            return paintTextR;
-        }
+        private Rectangle getTextRectangle() {throw new RuntimeException("cf-bug");} //{
+//
+//            String text = AbstractButton.this.getText();
+//            Icon icon = (AbstractButton.this.isEnabled()) ? AbstractButton.this.getIcon() : AbstractButton.this.getDisabledIcon();
+//
+//            if ((icon == null) && (text == null)) {
+//                return null;
+//            }
+//
+//            Rectangle paintIconR = new Rectangle();
+//            Rectangle paintTextR = new Rectangle();
+//            Rectangle paintViewR = new Rectangle();
+//            Insets paintViewInsets = new Insets(0, 0, 0, 0);
+//
+//            paintViewInsets = AbstractButton.this.getInsets(paintViewInsets);
+//            paintViewR.x = paintViewInsets.left;
+//            paintViewR.y = paintViewInsets.top;
+//            paintViewR.width = AbstractButton.this.getWidth() - (paintViewInsets.left + paintViewInsets.right);
+//            paintViewR.height = AbstractButton.this.getHeight() - (paintViewInsets.top + paintViewInsets.bottom);
+//
+//            String clippedText = SwingUtilities.layoutCompoundLabel(
+//                AbstractButton.this,
+//                getFontMetrics(getFont()),
+//                text,
+//                icon,
+//                AbstractButton.this.getVerticalAlignment(),
+//                AbstractButton.this.getHorizontalAlignment(),
+//                AbstractButton.this.getVerticalTextPosition(),
+//                AbstractButton.this.getHorizontalTextPosition(),
+//                paintViewR,
+//                paintIconR,
+//                paintTextR,
+//                0);
+//
+//            return paintTextR;
+//        }
 
         // ----- AccessibleExtendedComponent
 
@@ -3017,9 +3017,9 @@
          *
          * @return the AccessibleExtendedComponent
          */
-        AccessibleExtendedComponent getAccessibleExtendedComponent() {
-            return this;
-        }
+        AccessibleExtendedComponent getAccessibleExtendedComponent() {throw new RuntimeException("cf-bug");} //{
+//            return this;
+//        }
 
         /**
          * Returns the tool tip text
@@ -3028,9 +3028,9 @@
          * otherwise, null
          * @since 1.4
          */
-        public String getToolTipText() {
-            return AbstractButton.this.getToolTipText();
-        }
+        public String getToolTipText() {throw new RuntimeException("cf-bug");} //{
+//            return AbstractButton.this.getToolTipText();
+//        }
 
         /**
          * Returns the titled border text
@@ -3039,9 +3039,9 @@
          * otherwise, null
          * @since 1.4
          */
-        public String getTitledBorderText() {
-            return super.getTitledBorderText();
-        }
+        public String getTitledBorderText() {throw new RuntimeException("cf-bug");} //{
+//            return super.getTitledBorderText();
+//        }
 
         /**
          * Returns key bindings associated with this object
@@ -3051,13 +3051,13 @@
          * @see AccessibleKeyBinding
          * @since 1.4
          */
-        public AccessibleKeyBinding getAccessibleKeyBinding() {
-            int mnemonic = AbstractButton.this.getMnemonic();
-            if (mnemonic == 0) {
-                return null;
-            }
-            return new ButtonKeyBinding(mnemonic);
-        }
+        public AccessibleKeyBinding getAccessibleKeyBinding() {throw new RuntimeException("cf-bug");} //{
+//            int mnemonic = AbstractButton.this.getMnemonic();
+//            if (mnemonic == 0) {
+//                return null;
+//            }
+//            return new ButtonKeyBinding(mnemonic);
+//        }
 
         class ButtonKeyBinding implements AccessibleKeyBinding {
             int mnemonic;
@@ -3071,9 +3071,9 @@
              *
              * @return the zero-based number of key bindings for this object
              */
-            public int getAccessibleKeyBindingCount() {
-                return 1;
-            }
+            public int getAccessibleKeyBindingCount() {throw new RuntimeException("cf-bug");} //{
+//                return 1;
+//            }
 
             /**
              * Returns a key binding for this object.  The value returned is an
@@ -3100,12 +3100,12 @@
              * out of bounds
              * @see #getAccessibleKeyBindingCount
              */
-            public java.lang.Object getAccessibleKeyBinding(int i) {
-                if (i != 0) {
-                    throw new IllegalArgumentException();
-                }
-                return KeyStroke.getKeyStroke(mnemonic, 0);
-            }
+            public java.lang.Object getAccessibleKeyBinding(int i) {throw new RuntimeException("cf-bug");} //{
+//                if (i != 0) {
+//                    throw new IllegalArgumentException();
+//                }
+//                return KeyStroke.getKeyStroke(mnemonic, 0);
+//            }
         }
     }
 }
--- javax/swing/SwingUtilities.java	2016-06-27 19:26:28.326426212 -0700
+++ javax/swing/SwingUtilities.java	2016-06-29 12:30:44.435082581 -0700
@@ -79,51 +79,51 @@
      * Returns true if <code>setTransferHandler</code> should change the
      * <code>DropTarget</code>.
      */
-    private static boolean getSuppressDropTarget() {
-        if (!checkedSuppressDropSupport) {
-            suppressDropSupport = Boolean.valueOf(
-                AccessController.doPrivileged(
-                    new GetPropertyAction("suppressSwingDropSupport")));
-            checkedSuppressDropSupport = true;
-        }
-        return suppressDropSupport;
-    }
+    private static boolean getSuppressDropTarget() {throw new RuntimeException("cf-bug");} //{
+//        if (!checkedSuppressDropSupport) {
+//            suppressDropSupport = Boolean.valueOf(
+//                AccessController.doPrivileged(
+//                    new GetPropertyAction("suppressSwingDropSupport")));
+//            checkedSuppressDropSupport = true;
+//        }
+//        return suppressDropSupport;
+//    }
 
     /**
      * Installs a {@code DropTarget} on the component as necessary for a
      * {@code TransferHandler} change.
      */
     static void installSwingDropTargetAsNecessary(Component c,
-                                                         TransferHandler t) {
-
-        if (!getSuppressDropTarget()) {
-            DropTarget dropHandler = c.getDropTarget();
-            if ((dropHandler == null) || (dropHandler instanceof UIResource)) {
-                if (t == null) {
-                    c.setDropTarget(null);
-                } else if (!GraphicsEnvironment.isHeadless()) {
-                    c.setDropTarget(new TransferHandler.SwingDropTarget(c));
-                }
-            }
-        }
-    }
+                                                         TransferHandler t) {throw new RuntimeException("cf-bug");} //{
+//
+//        if (!getSuppressDropTarget()) {
+//            DropTarget dropHandler = c.getDropTarget();
+//            if ((dropHandler == null) || (dropHandler instanceof UIResource)) {
+//                if (t == null) {
+//                    c.setDropTarget(null);
+//                } else if (!GraphicsEnvironment.isHeadless()) {
+//                    c.setDropTarget(new TransferHandler.SwingDropTarget(c));
+//                }
+//            }
+//        }
+//    }
 
     /**
      * Return true if <code>a</code> contains <code>b</code>
      */
-    public static final boolean isRectangleContainingRectangle(Rectangle a,Rectangle b) {
-        return b.x >= a.x && (b.x + b.width) <= (a.x + a.width) &&
-                b.y >= a.y && (b.y + b.height) <= (a.y + a.height);
-    }
+    public static final boolean isRectangleContainingRectangle(Rectangle a,Rectangle b) {throw new RuntimeException("cf-bug");} //{
+//        return b.x >= a.x && (b.x + b.width) <= (a.x + a.width) &&
+//                b.y >= a.y && (b.y + b.height) <= (a.y + a.height);
+//    }
 
     /**
      * Return the rectangle (0,0,bounds.width,bounds.height) for the component <code>aComponent</code>
      */
-    public static Rectangle getLocalBounds(Component aComponent) {
-        Rectangle b = new Rectangle(aComponent.getBounds());
-        b.x = b.y = 0;
-        return b;
-    }
+    public static Rectangle getLocalBounds(Component aComponent) {throw new RuntimeException("cf-bug");} //{
+//        Rectangle b = new Rectangle(aComponent.getBounds());
+//        b.x = b.y = 0;
+//        return b;
+//    }
 
 
     /**
@@ -137,30 +137,30 @@
      *         <code>Window</code>.
      * @since 1.3
      */
-    public static Window getWindowAncestor(Component c) {
-        for(Container p = c.getParent(); p != null; p = p.getParent()) {
-            if (p instanceof Window) {
-                return (Window)p;
-            }
-        }
-        return null;
-    }
+    public static Window getWindowAncestor(Component c) {throw new RuntimeException("cf-bug");} //{
+//        for(Container p = c.getParent(); p != null; p = p.getParent()) {
+//            if (p instanceof Window) {
+//                return (Window)p;
+//            }
+//        }
+//        return null;
+//    }
 
     /**
      * Converts the location <code>x</code> <code>y</code> to the
      * parents coordinate system, returning the location.
      */
-    static Point convertScreenLocationToParent(Container parent,int x, int y) {
-        for (Container p = parent; p != null; p = p.getParent()) {
-            if (p instanceof Window) {
-                Point point = new Point(x, y);
-
-                SwingUtilities.convertPointFromScreen(point, parent);
-                return point;
-            }
-        }
-        throw new Error("convertScreenLocationToParent: no window ancestor");
-    }
+    static Point convertScreenLocationToParent(Container parent,int x, int y) {throw new RuntimeException("cf-bug");} //{
+//        for (Container p = parent; p != null; p = p.getParent()) {
+//            if (p instanceof Window) {
+//                Point point = new Point(x, y);
+//
+//                SwingUtilities.convertPointFromScreen(point, parent);
+//                return point;
+//            }
+//        }
+//        throw new Error("convertScreenLocationToParent: no window ancestor");
+//    }
 
     /**
      * Convert a <code>aPoint</code> in <code>source</code> coordinate system to
@@ -172,26 +172,26 @@
      * If both <code>source</code> and <code>destination</code> are {@code null}, return <code>aPoint</code>
      * without any conversion.
      */
-    public static Point convertPoint(Component source,Point aPoint,Component destination) {
-        Point p;
-
-        if(source == null && destination == null)
-            return aPoint;
-        if(source == null) {
-            source = getWindowAncestor(destination);
-            if(source == null)
-                throw new Error("Source component not connected to component tree hierarchy");
-        }
-        p = new Point(aPoint);
-        convertPointToScreen(p,source);
-        if(destination == null) {
-            destination = getWindowAncestor(source);
-            if(destination == null)
-                throw new Error("Destination component not connected to component tree hierarchy");
-        }
-        convertPointFromScreen(p,destination);
-        return p;
-    }
+    public static Point convertPoint(Component source,Point aPoint,Component destination) {throw new RuntimeException("cf-bug");} //{
+//        Point p;
+//
+//        if(source == null && destination == null)
+//            return aPoint;
+//        if(source == null) {
+//            source = getWindowAncestor(destination);
+//            if(source == null)
+//                throw new Error("Source component not connected to component tree hierarchy");
+//        }
+//        p = new Point(aPoint);
+//        convertPointToScreen(p,source);
+//        if(destination == null) {
+//            destination = getWindowAncestor(source);
+//            if(destination == null)
+//                throw new Error("Destination component not connected to component tree hierarchy");
+//        }
+//        convertPointFromScreen(p,destination);
+//        return p;
+//    }
 
     /**
      * Convert the point <code>(x,y)</code> in <code>source</code> coordinate system to
@@ -203,10 +203,10 @@
      * If both <code>source</code> and <code>destination</code> are {@code null}, return <code>(x,y)</code>
      * without any conversion.
      */
-    public static Point convertPoint(Component source,int x, int y,Component destination) {
-        Point point = new Point(x,y);
-        return convertPoint(source,point,destination);
-    }
+    public static Point convertPoint(Component source,int x, int y,Component destination) {throw new RuntimeException("cf-bug");} //{
+//        Point point = new Point(x,y);
+//        return convertPoint(source,point,destination);
+//    }
 
     /**
      * Convert the rectangle <code>aRectangle</code> in <code>source</code> coordinate system to
@@ -218,11 +218,11 @@
      * If both <code>source</code> and <code>destination</code> are {@code null}, return <code>aRectangle</code>
      * without any conversion.
      */
-    public static Rectangle convertRectangle(Component source,Rectangle aRectangle,Component destination) {
-        Point point = new Point(aRectangle.x,aRectangle.y);
-        point =  convertPoint(source,point,destination);
-        return new Rectangle(point.x,point.y,aRectangle.width,aRectangle.height);
-    }
+    public static Rectangle convertRectangle(Component source,Rectangle aRectangle,Component destination) {throw new RuntimeException("cf-bug");} //{
+//        Point point = new Point(aRectangle.x,aRectangle.y);
+//        point =  convertPoint(source,point,destination);
+//        return new Rectangle(point.x,point.y,aRectangle.width,aRectangle.height);
+//    }
 
     /**
      * Convenience method for searching above <code>comp</code> in the
@@ -230,30 +230,30 @@
      * finds. Can return {@code null}, if a class <code>c</code> cannot be found.
      */
     public static Container getAncestorOfClass(Class<?> c, Component comp)
-    {
-        if(comp == null || c == null)
-            return null;
-
-        Container parent = comp.getParent();
-        while(parent != null && !(c.isInstance(parent)))
-            parent = parent.getParent();
-        return parent;
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        if(comp == null || c == null)
+//            return null;
+//
+//        Container parent = comp.getParent();
+//        while(parent != null && !(c.isInstance(parent)))
+//            parent = parent.getParent();
+//        return parent;
+//    }
 
     /**
      * Convenience method for searching above <code>comp</code> in the
      * component hierarchy and returns the first object of <code>name</code> it
      * finds. Can return {@code null}, if <code>name</code> cannot be found.
      */
-    public static Container getAncestorNamed(String name, Component comp) {
-        if(comp == null || name == null)
-            return null;
-
-        Container parent = comp.getParent();
-        while(parent != null && !(name.equals(parent.getName())))
-            parent = parent.getParent();
-        return parent;
-    }
+    public static Container getAncestorNamed(String name, Component comp) {throw new RuntimeException("cf-bug");} //{
+//        if(comp == null || name == null)
+//            return null;
+//
+//        Container parent = comp.getParent();
+//        while(parent != null && !(name.equals(parent.getName())))
+//            parent = parent.getParent();
+//        return parent;
+//    }
 
     /**
      * Returns the deepest visible descendent Component of <code>parent</code>
@@ -267,28 +267,28 @@
      * @param x the x target location
      * @param y the y target location
      */
-    public static Component getDeepestComponentAt(Component parent, int x, int y) {
-        if (!parent.contains(x, y)) {
-            return null;
-        }
-        if (parent instanceof Container) {
-            Component components[] = ((Container)parent).getComponents();
-            for (Component comp : components) {
-                if (comp != null && comp.isVisible()) {
-                    Point loc = comp.getLocation();
-                    if (comp instanceof Container) {
-                        comp = getDeepestComponentAt(comp, x - loc.x, y - loc.y);
-                    } else {
-                        comp = comp.getComponentAt(x - loc.x, y - loc.y);
-                    }
-                    if (comp != null && comp.isVisible()) {
-                        return comp;
-                    }
-                }
-            }
-        }
-        return parent;
-    }
+    public static Component getDeepestComponentAt(Component parent, int x, int y) {throw new RuntimeException("cf-bug");} //{
+//        if (!parent.contains(x, y)) {
+//            return null;
+//        }
+//        if (parent instanceof Container) {
+//            Component components[] = ((Container)parent).getComponents();
+//            for (Component comp : components) {
+//                if (comp != null && comp.isVisible()) {
+//                    Point loc = comp.getLocation();
+//                    if (comp instanceof Container) {
+//                        comp = getDeepestComponentAt(comp, x - loc.x, y - loc.y);
+//                    } else {
+//                        comp = comp.getComponentAt(x - loc.x, y - loc.y);
+//                    }
+//                    if (comp != null && comp.isVisible()) {
+//                        return comp;
+//                    }
+//                }
+//            }
+//        }
+//        return parent;
+//    }
 
 
     /**
@@ -306,64 +306,64 @@
      */
     public static MouseEvent convertMouseEvent(Component source,
                                                MouseEvent sourceEvent,
-                                               Component destination) {
-        Point p = convertPoint(source,new Point(sourceEvent.getX(),
-                                                sourceEvent.getY()),
-                               destination);
-        Component newSource;
-
-        if(destination != null)
-            newSource = destination;
-        else
-            newSource = source;
-
-        MouseEvent newEvent;
-        if (sourceEvent instanceof MouseWheelEvent) {
-            MouseWheelEvent sourceWheelEvent = (MouseWheelEvent)sourceEvent;
-            newEvent = new MouseWheelEvent(newSource,
-                                           sourceWheelEvent.getID(),
-                                           sourceWheelEvent.getWhen(),
-                                           sourceWheelEvent.getModifiers()
-                                                   | sourceWheelEvent.getModifiersEx(),
-                                           p.x,p.y,
-                                           sourceWheelEvent.getXOnScreen(),
-                                           sourceWheelEvent.getYOnScreen(),
-                                           sourceWheelEvent.getClickCount(),
-                                           sourceWheelEvent.isPopupTrigger(),
-                                           sourceWheelEvent.getScrollType(),
-                                           sourceWheelEvent.getScrollAmount(),
-                                           sourceWheelEvent.getWheelRotation());
-        }
-        else if (sourceEvent instanceof MenuDragMouseEvent) {
-            MenuDragMouseEvent sourceMenuDragEvent = (MenuDragMouseEvent)sourceEvent;
-            newEvent = new MenuDragMouseEvent(newSource,
-                                              sourceMenuDragEvent.getID(),
-                                              sourceMenuDragEvent.getWhen(),
-                                              sourceMenuDragEvent.getModifiers()
-                                                      | sourceMenuDragEvent.getModifiersEx(),
-                                              p.x,p.y,
-                                              sourceMenuDragEvent.getXOnScreen(),
-                                              sourceMenuDragEvent.getYOnScreen(),
-                                              sourceMenuDragEvent.getClickCount(),
-                                              sourceMenuDragEvent.isPopupTrigger(),
-                                              sourceMenuDragEvent.getPath(),
-                                              sourceMenuDragEvent.getMenuSelectionManager());
-        }
-        else {
-            newEvent = new MouseEvent(newSource,
-                                      sourceEvent.getID(),
-                                      sourceEvent.getWhen(),
-                                      sourceEvent.getModifiers()
-                                              | sourceEvent.getModifiersEx(),
-                                      p.x,p.y,
-                                      sourceEvent.getXOnScreen(),
-                                      sourceEvent.getYOnScreen(),
-                                      sourceEvent.getClickCount(),
-                                      sourceEvent.isPopupTrigger(),
-                                      sourceEvent.getButton());
-        }
-        return newEvent;
-    }
+                                               Component destination) {throw new RuntimeException("cf-bug");} //{
+//        Point p = convertPoint(source,new Point(sourceEvent.getX(),
+//                                                sourceEvent.getY()),
+//                               destination);
+//        Component newSource;
+//
+//        if(destination != null)
+//            newSource = destination;
+//        else
+//            newSource = source;
+//
+//        MouseEvent newEvent;
+//        if (sourceEvent instanceof MouseWheelEvent) {
+//            MouseWheelEvent sourceWheelEvent = (MouseWheelEvent)sourceEvent;
+//            newEvent = new MouseWheelEvent(newSource,
+//                                           sourceWheelEvent.getID(),
+//                                           sourceWheelEvent.getWhen(),
+//                                           sourceWheelEvent.getModifiers()
+//                                                   | sourceWheelEvent.getModifiersEx(),
+//                                           p.x,p.y,
+//                                           sourceWheelEvent.getXOnScreen(),
+//                                           sourceWheelEvent.getYOnScreen(),
+//                                           sourceWheelEvent.getClickCount(),
+//                                           sourceWheelEvent.isPopupTrigger(),
+//                                           sourceWheelEvent.getScrollType(),
+//                                           sourceWheelEvent.getScrollAmount(),
+//                                           sourceWheelEvent.getWheelRotation());
+//        }
+//        else if (sourceEvent instanceof MenuDragMouseEvent) {
+//            MenuDragMouseEvent sourceMenuDragEvent = (MenuDragMouseEvent)sourceEvent;
+//            newEvent = new MenuDragMouseEvent(newSource,
+//                                              sourceMenuDragEvent.getID(),
+//                                              sourceMenuDragEvent.getWhen(),
+//                                              sourceMenuDragEvent.getModifiers()
+//                                                      | sourceMenuDragEvent.getModifiersEx(),
+//                                              p.x,p.y,
+//                                              sourceMenuDragEvent.getXOnScreen(),
+//                                              sourceMenuDragEvent.getYOnScreen(),
+//                                              sourceMenuDragEvent.getClickCount(),
+//                                              sourceMenuDragEvent.isPopupTrigger(),
+//                                              sourceMenuDragEvent.getPath(),
+//                                              sourceMenuDragEvent.getMenuSelectionManager());
+//        }
+//        else {
+//            newEvent = new MouseEvent(newSource,
+//                                      sourceEvent.getID(),
+//                                      sourceEvent.getWhen(),
+//                                      sourceEvent.getModifiers()
+//                                              | sourceEvent.getModifiersEx(),
+//                                      p.x,p.y,
+//                                      sourceEvent.getXOnScreen(),
+//                                      sourceEvent.getYOnScreen(),
+//                                      sourceEvent.getClickCount(),
+//                                      sourceEvent.isPopupTrigger(),
+//                                      sourceEvent.getButton());
+//        }
+//        return newEvent;
+//    }
 
 
     /**
@@ -373,37 +373,37 @@
      * @param p  a Point object (converted to the new coordinate system)
      * @param c  a Component object
      */
-    public static void convertPointToScreen(Point p,Component c) {
-            Rectangle b;
-            int x,y;
-
-            do {
-                if(c instanceof JComponent) {
-                    x = c.getX();
-                    y = c.getY();
-                } else if(c instanceof java.applet.Applet ||
-                          c instanceof java.awt.Window) {
-                    try {
-                        Point pp = c.getLocationOnScreen();
-                        x = pp.x;
-                        y = pp.y;
-                    } catch (IllegalComponentStateException icse) {
-                        x = c.getX();
-                        y = c.getY();
-                    }
-                } else {
-                    x = c.getX();
-                    y = c.getY();
-                }
-
-                p.x += x;
-                p.y += y;
-
-                if(c instanceof java.awt.Window || c instanceof java.applet.Applet)
-                    break;
-                c = c.getParent();
-            } while(c != null);
-        }
+    public static void convertPointToScreen(Point p,Component c) {throw new RuntimeException("cf-bug");} //{
+//            Rectangle b;
+//            int x,y;
+//
+//            do {
+//                if(c instanceof JComponent) {
+//                    x = c.getX();
+//                    y = c.getY();
+//                } else if(c instanceof java.applet.Applet ||
+//                          c instanceof java.awt.Window) {
+//                    try {
+//                        Point pp = c.getLocationOnScreen();
+//                        x = pp.x;
+//                        y = pp.y;
+//                    } catch (IllegalComponentStateException icse) {
+//                        x = c.getX();
+//                        y = c.getY();
+//                    }
+//                } else {
+//                    x = c.getX();
+//                    y = c.getY();
+//                }
+//
+//                p.x += x;
+//                p.y += y;
+//
+//                if(c instanceof java.awt.Window || c instanceof java.applet.Applet)
+//                    break;
+//                c = c.getParent();
+//            } while(c != null);
+//        }
 
     /**
      * Convert a point from a screen coordinates to a component's
@@ -412,37 +412,37 @@
      * @param p  a Point object (converted to the new coordinate system)
      * @param c  a Component object
      */
-    public static void convertPointFromScreen(Point p,Component c) {
-        Rectangle b;
-        int x,y;
-
-        do {
-            if(c instanceof JComponent) {
-                x = c.getX();
-                y = c.getY();
-            }  else if(c instanceof java.applet.Applet ||
-                       c instanceof java.awt.Window) {
-                try {
-                    Point pp = c.getLocationOnScreen();
-                    x = pp.x;
-                    y = pp.y;
-                } catch (IllegalComponentStateException icse) {
-                    x = c.getX();
-                    y = c.getY();
-                }
-            } else {
-                x = c.getX();
-                y = c.getY();
-            }
-
-            p.x -= x;
-            p.y -= y;
-
-            if(c instanceof java.awt.Window || c instanceof java.applet.Applet)
-                break;
-            c = c.getParent();
-        } while(c != null);
-    }
+    public static void convertPointFromScreen(Point p,Component c) {throw new RuntimeException("cf-bug");} //{
+//        Rectangle b;
+//        int x,y;
+//
+//        do {
+//            if(c instanceof JComponent) {
+//                x = c.getX();
+//                y = c.getY();
+//            }  else if(c instanceof java.applet.Applet ||
+//                       c instanceof java.awt.Window) {
+//                try {
+//                    Point pp = c.getLocationOnScreen();
+//                    x = pp.x;
+//                    y = pp.y;
+//                } catch (IllegalComponentStateException icse) {
+//                    x = c.getX();
+//                    y = c.getY();
+//                }
+//            } else {
+//                x = c.getX();
+//                y = c.getY();
+//            }
+//
+//            p.x -= x;
+//            p.y -= y;
+//
+//            if(c instanceof java.awt.Window || c instanceof java.applet.Applet)
+//                break;
+//            c = c.getParent();
+//        } while(c != null);
+//    }
 
     /**
      * Returns the first <code>Window </code> ancestor of <code>c</code>, or
@@ -457,21 +457,21 @@
      *         {@code null} if <code>c</code> is not contained inside a
      *         <code>Window</code>.
      */
-    public static Window windowForComponent(Component c) {
-        return getWindowAncestor(c);
-    }
+    public static Window windowForComponent(Component c) {throw new RuntimeException("cf-bug");} //{
+//        return getWindowAncestor(c);
+//    }
 
     /**
      * Return <code>true</code> if a component <code>a</code> descends from a component <code>b</code>
      */
-    public static boolean isDescendingFrom(Component a,Component b) {
-        if(a == b)
-            return true;
-        for(Container p = a.getParent();p!=null;p=p.getParent())
-            if(p == b)
-                return true;
-        return false;
-    }
+    public static boolean isDescendingFrom(Component a,Component b) {throw new RuntimeException("cf-bug");} //{
+//        if(a == b)
+//            return true;
+//        for(Container p = a.getParent();p!=null;p=p.getParent())
+//            if(p == b)
+//                return true;
+//        return false;
+//    }
 
 
     /**
@@ -489,24 +489,24 @@
      *
      * @return <code>dest</code>, modified to specify the intersection
      */
-    public static Rectangle computeIntersection(int x,int y,int width,int height,Rectangle dest) {
-        int x1 = (x > dest.x) ? x : dest.x;
-        int x2 = ((x+width) < (dest.x + dest.width)) ? (x+width) : (dest.x + dest.width);
-        int y1 = (y > dest.y) ? y : dest.y;
-        int y2 = ((y + height) < (dest.y + dest.height) ? (y+height) : (dest.y + dest.height));
-
-        dest.x = x1;
-        dest.y = y1;
-        dest.width = x2 - x1;
-        dest.height = y2 - y1;
-
-        // If rectangles don't intersect, return zero'd intersection.
-        if (dest.width < 0 || dest.height < 0) {
-            dest.x = dest.y = dest.width = dest.height = 0;
-        }
-
-        return dest;
-    }
+    public static Rectangle computeIntersection(int x,int y,int width,int height,Rectangle dest) {throw new RuntimeException("cf-bug");} //{
+//        int x1 = (x > dest.x) ? x : dest.x;
+//        int x2 = ((x+width) < (dest.x + dest.width)) ? (x+width) : (dest.x + dest.width);
+//        int y1 = (y > dest.y) ? y : dest.y;
+//        int y2 = ((y + height) < (dest.y + dest.height) ? (y+height) : (dest.y + dest.height));
+//
+//        dest.x = x1;
+//        dest.y = y1;
+//        dest.width = x2 - x1;
+//        dest.height = y2 - y1;
+//
+//        // If rectangles don't intersect, return zero'd intersection.
+//        if (dest.width < 0 || dest.height < 0) {
+//            dest.x = dest.y = dest.width = dest.height = 0;
+//        }
+//
+//        return dest;
+//    }
 
     /**
      * Convenience method that calculates the union of two rectangles
@@ -520,277 +520,277 @@
      *    of the two rectangles is returned in this rectangle
      * @return the <code>dest</code> <code>Rectangle</code>
      */
-    public static Rectangle computeUnion(int x,int y,int width,int height,Rectangle dest) {
-        int x1 = (x < dest.x) ? x : dest.x;
-        int x2 = ((x+width) > (dest.x + dest.width)) ? (x+width) : (dest.x + dest.width);
-        int y1 = (y < dest.y) ? y : dest.y;
-        int y2 = ((y+height) > (dest.y + dest.height)) ? (y+height) : (dest.y + dest.height);
-
-        dest.x = x1;
-        dest.y = y1;
-        dest.width = (x2 - x1);
-        dest.height= (y2 - y1);
-        return dest;
-    }
+    public static Rectangle computeUnion(int x,int y,int width,int height,Rectangle dest) {throw new RuntimeException("cf-bug");} //{
+//        int x1 = (x < dest.x) ? x : dest.x;
+//        int x2 = ((x+width) > (dest.x + dest.width)) ? (x+width) : (dest.x + dest.width);
+//        int y1 = (y < dest.y) ? y : dest.y;
+//        int y2 = ((y+height) > (dest.y + dest.height)) ? (y+height) : (dest.y + dest.height);
+//
+//        dest.x = x1;
+//        dest.y = y1;
+//        dest.width = (x2 - x1);
+//        dest.height= (y2 - y1);
+//        return dest;
+//    }
 
     /**
      * Convenience returning an array of rect representing the regions within
      * <code>rectA</code> that do not overlap with <code>rectB</code>. If the
      * two Rects do not overlap, returns an empty array
      */
-    public static Rectangle[] computeDifference(Rectangle rectA,Rectangle rectB) {
-        if (rectB == null || !rectA.intersects(rectB) || isRectangleContainingRectangle(rectB,rectA)) {
-            return new Rectangle[0];
-        }
-
-        Rectangle t = new Rectangle();
-        Rectangle a=null,b=null,c=null,d=null;
-        Rectangle result[];
-        int rectCount = 0;
-
-        /* rectA contains rectB */
-        if (isRectangleContainingRectangle(rectA,rectB)) {
-            t.x = rectA.x; t.y = rectA.y; t.width = rectB.x - rectA.x; t.height = rectA.height;
-            if(t.width > 0 && t.height > 0) {
-                a = new Rectangle(t);
-                rectCount++;
-            }
-
-            t.x = rectB.x; t.y = rectA.y; t.width = rectB.width; t.height = rectB.y - rectA.y;
-            if(t.width > 0 && t.height > 0) {
-                b = new Rectangle(t);
-                rectCount++;
-            }
-
-            t.x = rectB.x; t.y = rectB.y + rectB.height; t.width = rectB.width;
-            t.height = rectA.y + rectA.height - (rectB.y + rectB.height);
-            if(t.width > 0 && t.height > 0) {
-                c = new Rectangle(t);
-                rectCount++;
-            }
-
-            t.x = rectB.x + rectB.width; t.y = rectA.y; t.width = rectA.x + rectA.width - (rectB.x + rectB.width);
-            t.height = rectA.height;
-            if(t.width > 0 && t.height > 0) {
-                d = new Rectangle(t);
-                rectCount++;
-            }
-        } else {
-            /* 1 */
-            if (rectB.x <= rectA.x && rectB.y <= rectA.y) {
-                if ((rectB.x + rectB.width) > (rectA.x + rectA.width)) {
-
-                    t.x = rectA.x; t.y = rectB.y + rectB.height;
-                    t.width = rectA.width; t.height = rectA.y + rectA.height - (rectB.y + rectB.height);
-                    if(t.width > 0 && t.height > 0) {
-                        a = t;
-                        rectCount++;
-                    }
-                } else if ((rectB.y + rectB.height) > (rectA.y + rectA.height)) {
-                    t.setBounds((rectB.x + rectB.width), rectA.y,
-                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
-                    if(t.width > 0 && t.height > 0) {
-                        a = t;
-                        rectCount++;
-                    }
-                } else {
-                    t.setBounds((rectB.x + rectB.width), rectA.y,
-                                (rectA.x + rectA.width) - (rectB.x + rectB.width),
-                                (rectB.y + rectB.height) - rectA.y);
-                    if(t.width > 0 && t.height > 0) {
-                        a = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,
-                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
-                    if(t.width > 0 && t.height > 0) {
-                        b = new Rectangle(t);
-                        rectCount++;
-                    }
-                }
-            } else if (rectB.x <= rectA.x && (rectB.y + rectB.height) >= (rectA.y + rectA.height)) {
-                if ((rectB.x + rectB.width) > (rectA.x + rectA.width)) {
-                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
-                    if(t.width > 0 && t.height > 0) {
-                        a = t;
-                        rectCount++;
-                    }
-                } else {
-                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
-                    if(t.width > 0 && t.height > 0) {
-                        a = new Rectangle(t);
-                        rectCount++;
-                    }
-                    t.setBounds((rectB.x + rectB.width), rectB.y,
-                                (rectA.x + rectA.width) - (rectB.x + rectB.width),
-                                (rectA.y + rectA.height) - rectB.y);
-                    if(t.width > 0 && t.height > 0) {
-                        b = new Rectangle(t);
-                        rectCount++;
-                    }
-                }
-            } else if (rectB.x <= rectA.x) {
-                if ((rectB.x + rectB.width) >= (rectA.x + rectA.width)) {
-                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
-                    if(t.width>0 && t.height > 0) {
-                        a = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,
-                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
-                    if(t.width > 0 && t.height > 0) {
-                        b = new Rectangle(t);
-                        rectCount++;
-                    }
-                } else {
-                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
-                    if(t.width > 0 && t.height > 0) {
-                        a = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds((rectB.x + rectB.width), rectB.y,
-                                (rectA.x + rectA.width) - (rectB.x + rectB.width),
-                                rectB.height);
-                    if(t.width > 0 && t.height > 0) {
-                        b = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,
-                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
-                    if(t.width > 0 && t.height > 0) {
-                        c = new Rectangle(t);
-                        rectCount++;
-                    }
-                }
-            } else if (rectB.x <= (rectA.x + rectA.width) && (rectB.x + rectB.width) > (rectA.x + rectA.width)) {
-                if (rectB.y <= rectA.y && (rectB.y + rectB.height) > (rectA.y + rectA.height)) {
-                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);
-                    if(t.width > 0 && t.height > 0) {
-                        a = t;
-                        rectCount++;
-                    }
-                } else if (rectB.y <= rectA.y) {
-                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x,
-                                (rectB.y + rectB.height) - rectA.y);
-                    if(t.width > 0 && t.height > 0) {
-                        a = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,
-                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
-                    if(t.width > 0 && t.height > 0) {
-                        b = new Rectangle(t);
-                        rectCount++;
-                    }
-                } else if ((rectB.y + rectB.height) > (rectA.y + rectA.height)) {
-                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
-                    if(t.width > 0 && t.height > 0) {
-                        a = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds(rectA.x, rectB.y, rectB.x - rectA.x,
-                                (rectA.y + rectA.height) - rectB.y);
-                    if(t.width > 0 && t.height > 0) {
-                        b = new Rectangle(t);
-                        rectCount++;
-                    }
-                } else {
-                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
-                    if(t.width > 0 && t.height > 0) {
-                        a = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds(rectA.x, rectB.y, rectB.x - rectA.x,
-                                rectB.height);
-                    if(t.width > 0 && t.height > 0) {
-                        b = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,
-                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
-                    if(t.width > 0 && t.height > 0) {
-                        c = new Rectangle(t);
-                        rectCount++;
-                    }
-                }
-            } else if (rectB.x >= rectA.x && (rectB.x + rectB.width) <= (rectA.x + rectA.width)) {
-                if (rectB.y <= rectA.y && (rectB.y + rectB.height) > (rectA.y + rectA.height)) {
-                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);
-                    if(t.width > 0 && t.height > 0) {
-                        a = new Rectangle(t);
-                        rectCount++;
-                    }
-                    t.setBounds((rectB.x + rectB.width), rectA.y,
-                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
-                    if(t.width > 0 && t.height > 0) {
-                        b = new Rectangle(t);
-                        rectCount++;
-                    }
-                } else if (rectB.y <= rectA.y) {
-                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);
-                    if(t.width > 0 && t.height > 0) {
-                        a = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds(rectB.x, (rectB.y + rectB.height),
-                                rectB.width,
-                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
-                    if(t.width > 0 && t.height > 0) {
-                        b = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds((rectB.x + rectB.width), rectA.y,
-                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
-                    if(t.width > 0 && t.height > 0) {
-                        c = new Rectangle(t);
-                        rectCount++;
-                    }
-                } else {
-                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);
-                    if(t.width > 0 && t.height > 0) {
-                        a = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds(rectB.x, rectA.y, rectB.width,
-                                rectB.y - rectA.y);
-                    if(t.width > 0 && t.height > 0) {
-                        b = new Rectangle(t);
-                        rectCount++;
-                    }
-
-                    t.setBounds((rectB.x + rectB.width), rectA.y,
-                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
-                    if(t.width > 0 && t.height > 0) {
-                        c = new Rectangle(t);
-                        rectCount++;
-                    }
-                }
-            }
-        }
-
-        result = new Rectangle[rectCount];
-        rectCount = 0;
-        if(a != null)
-            result[rectCount++] = a;
-        if(b != null)
-            result[rectCount++] = b;
-        if(c != null)
-            result[rectCount++] = c;
-        if(d != null)
-            result[rectCount++] = d;
-        return result;
-    }
+    public static Rectangle[] computeDifference(Rectangle rectA,Rectangle rectB) {throw new RuntimeException("cf-bug");} //{
+//        if (rectB == null || !rectA.intersects(rectB) || isRectangleContainingRectangle(rectB,rectA)) {
+//            return new Rectangle[0];
+//        }
+//
+//        Rectangle t = new Rectangle();
+//        Rectangle a=null,b=null,c=null,d=null;
+//        Rectangle result[];
+//        int rectCount = 0;
+//
+//        /* rectA contains rectB */
+//        if (isRectangleContainingRectangle(rectA,rectB)) {
+//            t.x = rectA.x; t.y = rectA.y; t.width = rectB.x - rectA.x; t.height = rectA.height;
+//            if(t.width > 0 && t.height > 0) {
+//                a = new Rectangle(t);
+//                rectCount++;
+//            }
+//
+//            t.x = rectB.x; t.y = rectA.y; t.width = rectB.width; t.height = rectB.y - rectA.y;
+//            if(t.width > 0 && t.height > 0) {
+//                b = new Rectangle(t);
+//                rectCount++;
+//            }
+//
+//            t.x = rectB.x; t.y = rectB.y + rectB.height; t.width = rectB.width;
+//            t.height = rectA.y + rectA.height - (rectB.y + rectB.height);
+//            if(t.width > 0 && t.height > 0) {
+//                c = new Rectangle(t);
+//                rectCount++;
+//            }
+//
+//            t.x = rectB.x + rectB.width; t.y = rectA.y; t.width = rectA.x + rectA.width - (rectB.x + rectB.width);
+//            t.height = rectA.height;
+//            if(t.width > 0 && t.height > 0) {
+//                d = new Rectangle(t);
+//                rectCount++;
+//            }
+//        } else {
+//            /* 1 */
+//            if (rectB.x <= rectA.x && rectB.y <= rectA.y) {
+//                if ((rectB.x + rectB.width) > (rectA.x + rectA.width)) {
+//
+//                    t.x = rectA.x; t.y = rectB.y + rectB.height;
+//                    t.width = rectA.width; t.height = rectA.y + rectA.height - (rectB.y + rectB.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = t;
+//                        rectCount++;
+//                    }
+//                } else if ((rectB.y + rectB.height) > (rectA.y + rectA.height)) {
+//                    t.setBounds((rectB.x + rectB.width), rectA.y,
+//                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = t;
+//                        rectCount++;
+//                    }
+//                } else {
+//                    t.setBounds((rectB.x + rectB.width), rectA.y,
+//                                (rectA.x + rectA.width) - (rectB.x + rectB.width),
+//                                (rectB.y + rectB.height) - rectA.y);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,
+//                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
+//                    if(t.width > 0 && t.height > 0) {
+//                        b = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                }
+//            } else if (rectB.x <= rectA.x && (rectB.y + rectB.height) >= (rectA.y + rectA.height)) {
+//                if ((rectB.x + rectB.width) > (rectA.x + rectA.width)) {
+//                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = t;
+//                        rectCount++;
+//                    }
+//                } else {
+//                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                    t.setBounds((rectB.x + rectB.width), rectB.y,
+//                                (rectA.x + rectA.width) - (rectB.x + rectB.width),
+//                                (rectA.y + rectA.height) - rectB.y);
+//                    if(t.width > 0 && t.height > 0) {
+//                        b = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                }
+//            } else if (rectB.x <= rectA.x) {
+//                if ((rectB.x + rectB.width) >= (rectA.x + rectA.width)) {
+//                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
+//                    if(t.width>0 && t.height > 0) {
+//                        a = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,
+//                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
+//                    if(t.width > 0 && t.height > 0) {
+//                        b = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                } else {
+//                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds((rectB.x + rectB.width), rectB.y,
+//                                (rectA.x + rectA.width) - (rectB.x + rectB.width),
+//                                rectB.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        b = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,
+//                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
+//                    if(t.width > 0 && t.height > 0) {
+//                        c = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                }
+//            } else if (rectB.x <= (rectA.x + rectA.width) && (rectB.x + rectB.width) > (rectA.x + rectA.width)) {
+//                if (rectB.y <= rectA.y && (rectB.y + rectB.height) > (rectA.y + rectA.height)) {
+//                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = t;
+//                        rectCount++;
+//                    }
+//                } else if (rectB.y <= rectA.y) {
+//                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x,
+//                                (rectB.y + rectB.height) - rectA.y);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,
+//                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
+//                    if(t.width > 0 && t.height > 0) {
+//                        b = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                } else if ((rectB.y + rectB.height) > (rectA.y + rectA.height)) {
+//                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds(rectA.x, rectB.y, rectB.x - rectA.x,
+//                                (rectA.y + rectA.height) - rectB.y);
+//                    if(t.width > 0 && t.height > 0) {
+//                        b = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                } else {
+//                    t.setBounds(rectA.x, rectA.y, rectA.width, rectB.y - rectA.y);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds(rectA.x, rectB.y, rectB.x - rectA.x,
+//                                rectB.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        b = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds(rectA.x, (rectB.y + rectB.height), rectA.width,
+//                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
+//                    if(t.width > 0 && t.height > 0) {
+//                        c = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                }
+//            } else if (rectB.x >= rectA.x && (rectB.x + rectB.width) <= (rectA.x + rectA.width)) {
+//                if (rectB.y <= rectA.y && (rectB.y + rectB.height) > (rectA.y + rectA.height)) {
+//                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                    t.setBounds((rectB.x + rectB.width), rectA.y,
+//                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        b = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                } else if (rectB.y <= rectA.y) {
+//                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds(rectB.x, (rectB.y + rectB.height),
+//                                rectB.width,
+//                                (rectA.y + rectA.height) - (rectB.y + rectB.height));
+//                    if(t.width > 0 && t.height > 0) {
+//                        b = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds((rectB.x + rectB.width), rectA.y,
+//                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        c = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                } else {
+//                    t.setBounds(rectA.x, rectA.y, rectB.x - rectA.x, rectA.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        a = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds(rectB.x, rectA.y, rectB.width,
+//                                rectB.y - rectA.y);
+//                    if(t.width > 0 && t.height > 0) {
+//                        b = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//
+//                    t.setBounds((rectB.x + rectB.width), rectA.y,
+//                                (rectA.x + rectA.width) - (rectB.x + rectB.width), rectA.height);
+//                    if(t.width > 0 && t.height > 0) {
+//                        c = new Rectangle(t);
+//                        rectCount++;
+//                    }
+//                }
+//            }
+//        }
+//
+//        result = new Rectangle[rectCount];
+//        rectCount = 0;
+//        if(a != null)
+//            result[rectCount++] = a;
+//        if(b != null)
+//            result[rectCount++] = b;
+//        if(c != null)
+//            result[rectCount++] = c;
+//        if(d != null)
+//            result[rectCount++] = d;
+//        return result;
+//    }
 
     /**
      * Returns true if the mouse event specifies the left mouse button.
@@ -798,10 +798,10 @@
      * @param anEvent  a MouseEvent object
      * @return true if the left mouse button was active
      */
-    public static boolean isLeftMouseButton(MouseEvent anEvent) {
-         return ((anEvent.getModifiersEx() & InputEvent.BUTTON1_DOWN_MASK) != 0 ||
-                 anEvent.getButton() == MouseEvent.BUTTON1);
-    }
+    public static boolean isLeftMouseButton(MouseEvent anEvent) {throw new RuntimeException("cf-bug");} //{
+//         return ((anEvent.getModifiersEx() & InputEvent.BUTTON1_DOWN_MASK) != 0 ||
+//                 anEvent.getButton() == MouseEvent.BUTTON1);
+//    }
 
     /**
      * Returns true if the mouse event specifies the middle mouse button.
@@ -809,10 +809,10 @@
      * @param anEvent  a MouseEvent object
      * @return true if the middle mouse button was active
      */
-    public static boolean isMiddleMouseButton(MouseEvent anEvent) {
-        return ((anEvent.getModifiersEx() & InputEvent.BUTTON2_DOWN_MASK) != 0 ||
-                anEvent.getButton() == MouseEvent.BUTTON2);
-    }
+    public static boolean isMiddleMouseButton(MouseEvent anEvent) {throw new RuntimeException("cf-bug");} //{
+//        return ((anEvent.getModifiersEx() & InputEvent.BUTTON2_DOWN_MASK) != 0 ||
+//                anEvent.getButton() == MouseEvent.BUTTON2);
+//    }
 
     /**
      * Returns true if the mouse event specifies the right mouse button.
@@ -820,10 +820,10 @@
      * @param anEvent  a MouseEvent object
      * @return true if the right mouse button was active
      */
-    public static boolean isRightMouseButton(MouseEvent anEvent) {
-        return ((anEvent.getModifiersEx() & InputEvent.BUTTON3_DOWN_MASK) != 0 ||
-                anEvent.getButton() == MouseEvent.BUTTON3);
-    }
+    public static boolean isRightMouseButton(MouseEvent anEvent) {throw new RuntimeException("cf-bug");} //{
+//        return ((anEvent.getModifiersEx() & InputEvent.BUTTON3_DOWN_MASK) != 0 ||
+//                anEvent.getButton() == MouseEvent.BUTTON3);
+//    }
 
     /**
      * Compute the width of the string using a font with the specified
@@ -833,12 +833,12 @@
      * @param str  the String to compute
      * @return an int containing the string width
      */
-    public static int computeStringWidth(FontMetrics fm,String str) {
-        // You can't assume that a string's width is the sum of its
-        // characters' widths in Java2D -- it may be smaller due to
-        // kerning, etc.
-        return SwingUtilities2.stringWidth(null, fm, str);
-    }
+    public static int computeStringWidth(FontMetrics fm,String str) {throw new RuntimeException("cf-bug");} //{
+//        // You can't assume that a string's width is the sum of its
+//        // characters' widths in Java2D -- it may be smaller due to
+//        // kerning, etc.
+//        return SwingUtilities2.stringWidth(null, fm, str);
+//    }
 
     /**
      * Compute and return the location of the icons origin, the
@@ -860,52 +860,52 @@
                                              Rectangle iconR,
                                              Rectangle textR,
                                              int textIconGap)
-    {
-        boolean orientationIsLeftToRight = true;
-        int     hAlign = horizontalAlignment;
-        int     hTextPos = horizontalTextPosition;
-
-        if (c != null) {
-            if (!(c.getComponentOrientation().isLeftToRight())) {
-                orientationIsLeftToRight = false;
-            }
-        }
-
-        // Translate LEADING/TRAILING values in horizontalAlignment
-        // to LEFT/RIGHT values depending on the components orientation
-        switch (horizontalAlignment) {
-        case LEADING:
-            hAlign = (orientationIsLeftToRight) ? LEFT : RIGHT;
-            break;
-        case TRAILING:
-            hAlign = (orientationIsLeftToRight) ? RIGHT : LEFT;
-            break;
-        }
-
-        // Translate LEADING/TRAILING values in horizontalTextPosition
-        // to LEFT/RIGHT values depending on the components orientation
-        switch (horizontalTextPosition) {
-        case LEADING:
-            hTextPos = (orientationIsLeftToRight) ? LEFT : RIGHT;
-            break;
-        case TRAILING:
-            hTextPos = (orientationIsLeftToRight) ? RIGHT : LEFT;
-            break;
-        }
-
-        return layoutCompoundLabelImpl(c,
-                                       fm,
-                                       text,
-                                       icon,
-                                       verticalAlignment,
-                                       hAlign,
-                                       verticalTextPosition,
-                                       hTextPos,
-                                       viewR,
-                                       iconR,
-                                       textR,
-                                       textIconGap);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        boolean orientationIsLeftToRight = true;
+//        int     hAlign = horizontalAlignment;
+//        int     hTextPos = horizontalTextPosition;
+//
+//        if (c != null) {
+//            if (!(c.getComponentOrientation().isLeftToRight())) {
+//                orientationIsLeftToRight = false;
+//            }
+//        }
+//
+//        // Translate LEADING/TRAILING values in horizontalAlignment
+//        // to LEFT/RIGHT values depending on the components orientation
+//        switch (horizontalAlignment) {
+//        case LEADING:
+//            hAlign = (orientationIsLeftToRight) ? LEFT : RIGHT;
+//            break;
+//        case TRAILING:
+//            hAlign = (orientationIsLeftToRight) ? RIGHT : LEFT;
+//            break;
+//        }
+//
+//        // Translate LEADING/TRAILING values in horizontalTextPosition
+//        // to LEFT/RIGHT values depending on the components orientation
+//        switch (horizontalTextPosition) {
+//        case LEADING:
+//            hTextPos = (orientationIsLeftToRight) ? LEFT : RIGHT;
+//            break;
+//        case TRAILING:
+//            hTextPos = (orientationIsLeftToRight) ? RIGHT : LEFT;
+//            break;
+//        }
+//
+//        return layoutCompoundLabelImpl(c,
+//                                       fm,
+//                                       text,
+//                                       icon,
+//                                       verticalAlignment,
+//                                       hAlign,
+//                                       verticalTextPosition,
+//                                       hTextPos,
+//                                       viewR,
+//                                       iconR,
+//                                       textR,
+//                                       textIconGap);
+//    }
 
     /**
      * Compute and return the location of the icons origin, the
@@ -929,14 +929,14 @@
         Rectangle iconR,
         Rectangle textR,
         int textIconGap)
-    {
-        return layoutCompoundLabelImpl(null, fm, text, icon,
-                                       verticalAlignment,
-                                       horizontalAlignment,
-                                       verticalTextPosition,
-                                       horizontalTextPosition,
-                                       viewR, iconR, textR, textIconGap);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        return layoutCompoundLabelImpl(null, fm, text, icon,
+//                                       verticalAlignment,
+//                                       horizontalAlignment,
+//                                       verticalTextPosition,
+//                                       horizontalTextPosition,
+//                                       viewR, iconR, textR, textIconGap);
+//    }
 
     /**
      * Compute and return the location of the icons origin, the
@@ -961,175 +961,175 @@
         Rectangle iconR,
         Rectangle textR,
         int textIconGap)
-    {
-        /* Initialize the icon bounds rectangle iconR.
-         */
-
-        if (icon != null) {
-            iconR.width = icon.getIconWidth();
-            iconR.height = icon.getIconHeight();
-        }
-        else {
-            iconR.width = iconR.height = 0;
-        }
-
-        /* Initialize the text bounds rectangle textR.  If a null
-         * or and empty String was specified we substitute "" here
-         * and use 0,0,0,0 for textR.
-         */
-
-        boolean textIsEmpty = (text == null) || text.equals("");
-        int lsb = 0;
-        int rsb = 0;
-        /* Unless both text and icon are non-null, we effectively ignore
-         * the value of textIconGap.
-         */
-        int gap;
-
-        View v;
-        if (textIsEmpty) {
-            textR.width = textR.height = 0;
-            text = "";
-            gap = 0;
-        }
-        else {
-            int availTextWidth;
-            gap = (icon == null) ? 0 : textIconGap;
-
-            if (horizontalTextPosition == CENTER) {
-                availTextWidth = viewR.width;
-            }
-            else {
-                availTextWidth = viewR.width - (iconR.width + gap);
-            }
-            v = (c != null) ? (View) c.getClientProperty("html") : null;
-            if (v != null) {
-                textR.width = Math.min(availTextWidth,
-                                       (int) v.getPreferredSpan(View.X_AXIS));
-                textR.height = (int) v.getPreferredSpan(View.Y_AXIS);
-            } else {
-                textR.width = SwingUtilities2.stringWidth(c, fm, text);
-                lsb = SwingUtilities2.getLeftSideBearing(c, fm, text);
-                if (lsb < 0) {
-                    // If lsb is negative, add it to the width and later
-                    // adjust the x location. This gives more space than is
-                    // actually needed.
-                    // This is done like this for two reasons:
-                    // 1. If we set the width to the actual bounds all
-                    //    callers would have to account for negative lsb
-                    //    (pref size calculations ONLY look at width of
-                    //    textR)
-                    // 2. You can do a drawString at the returned location
-                    //    and the text won't be clipped.
-                    textR.width -= lsb;
-                }
-                if (textR.width > availTextWidth) {
-                    text = SwingUtilities2.clipString(c, fm, text,
-                                                      availTextWidth);
-                    textR.width = SwingUtilities2.stringWidth(c, fm, text);
-                }
-                textR.height = fm.getHeight();
-            }
-        }
-
-
-        /* Compute textR.x,y given the verticalTextPosition and
-         * horizontalTextPosition properties
-         */
-
-        if (verticalTextPosition == TOP) {
-            if (horizontalTextPosition != CENTER) {
-                textR.y = 0;
-            }
-            else {
-                textR.y = -(textR.height + gap);
-            }
-        }
-        else if (verticalTextPosition == CENTER) {
-            textR.y = (iconR.height / 2) - (textR.height / 2);
-        }
-        else { // (verticalTextPosition == BOTTOM)
-            if (horizontalTextPosition != CENTER) {
-                textR.y = iconR.height - textR.height;
-            }
-            else {
-                textR.y = (iconR.height + gap);
-            }
-        }
-
-        if (horizontalTextPosition == LEFT) {
-            textR.x = -(textR.width + gap);
-        }
-        else if (horizontalTextPosition == CENTER) {
-            textR.x = (iconR.width / 2) - (textR.width / 2);
-        }
-        else { // (horizontalTextPosition == RIGHT)
-            textR.x = (iconR.width + gap);
-        }
-
-        // WARNING: DefaultTreeCellEditor uses a shortened version of
-        // this algorithm to position it's Icon. If you change how this
-        // is calculated, be sure and update DefaultTreeCellEditor too.
-
-        /* labelR is the rectangle that contains iconR and textR.
-         * Move it to its proper position given the labelAlignment
-         * properties.
-         *
-         * To avoid actually allocating a Rectangle, Rectangle.union
-         * has been inlined below.
-         */
-        int labelR_x = Math.min(iconR.x, textR.x);
-        int labelR_width = Math.max(iconR.x + iconR.width,
-                                    textR.x + textR.width) - labelR_x;
-        int labelR_y = Math.min(iconR.y, textR.y);
-        int labelR_height = Math.max(iconR.y + iconR.height,
-                                     textR.y + textR.height) - labelR_y;
-
-        int dx, dy;
-
-        if (verticalAlignment == TOP) {
-            dy = viewR.y - labelR_y;
-        }
-        else if (verticalAlignment == CENTER) {
-            dy = (viewR.y + (viewR.height / 2)) - (labelR_y + (labelR_height / 2));
-        }
-        else { // (verticalAlignment == BOTTOM)
-            dy = (viewR.y + viewR.height) - (labelR_y + labelR_height);
-        }
-
-        if (horizontalAlignment == LEFT) {
-            dx = viewR.x - labelR_x;
-        }
-        else if (horizontalAlignment == RIGHT) {
-            dx = (viewR.x + viewR.width) - (labelR_x + labelR_width);
-        }
-        else { // (horizontalAlignment == CENTER)
-            dx = (viewR.x + (viewR.width / 2)) -
-                 (labelR_x + (labelR_width / 2));
-        }
-
-        /* Translate textR and glypyR by dx,dy.
-         */
-
-        textR.x += dx;
-        textR.y += dy;
-
-        iconR.x += dx;
-        iconR.y += dy;
-
-        if (lsb < 0) {
-            // lsb is negative. Shift the x location so that the text is
-            // visually drawn at the right location.
-            textR.x -= lsb;
-
-            textR.width += lsb;
-        }
-        if (rsb > 0) {
-            textR.width -= rsb;
-        }
-
-        return text;
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        /* Initialize the icon bounds rectangle iconR.
+//         */
+//
+//        if (icon != null) {
+//            iconR.width = icon.getIconWidth();
+//            iconR.height = icon.getIconHeight();
+//        }
+//        else {
+//            iconR.width = iconR.height = 0;
+//        }
+//
+//        /* Initialize the text bounds rectangle textR.  If a null
+//         * or and empty String was specified we substitute "" here
+//         * and use 0,0,0,0 for textR.
+//         */
+//
+//        boolean textIsEmpty = (text == null) || text.equals("");
+//        int lsb = 0;
+//        int rsb = 0;
+//        /* Unless both text and icon are non-null, we effectively ignore
+//         * the value of textIconGap.
+//         */
+//        int gap;
+//
+//        View v;
+//        if (textIsEmpty) {
+//            textR.width = textR.height = 0;
+//            text = "";
+//            gap = 0;
+//        }
+//        else {
+//            int availTextWidth;
+//            gap = (icon == null) ? 0 : textIconGap;
+//
+//            if (horizontalTextPosition == CENTER) {
+//                availTextWidth = viewR.width;
+//            }
+//            else {
+//                availTextWidth = viewR.width - (iconR.width + gap);
+//            }
+//            v = (c != null) ? (View) c.getClientProperty("html") : null;
+//            if (v != null) {
+//                textR.width = Math.min(availTextWidth,
+//                                       (int) v.getPreferredSpan(View.X_AXIS));
+//                textR.height = (int) v.getPreferredSpan(View.Y_AXIS);
+//            } else {
+//                textR.width = SwingUtilities2.stringWidth(c, fm, text);
+//                lsb = SwingUtilities2.getLeftSideBearing(c, fm, text);
+//                if (lsb < 0) {
+//                    // If lsb is negative, add it to the width and later
+//                    // adjust the x location. This gives more space than is
+//                    // actually needed.
+//                    // This is done like this for two reasons:
+//                    // 1. If we set the width to the actual bounds all
+//                    //    callers would have to account for negative lsb
+//                    //    (pref size calculations ONLY look at width of
+//                    //    textR)
+//                    // 2. You can do a drawString at the returned location
+//                    //    and the text won't be clipped.
+//                    textR.width -= lsb;
+//                }
+//                if (textR.width > availTextWidth) {
+//                    text = SwingUtilities2.clipString(c, fm, text,
+//                                                      availTextWidth);
+//                    textR.width = SwingUtilities2.stringWidth(c, fm, text);
+//                }
+//                textR.height = fm.getHeight();
+//            }
+//        }
+//
+//
+//        /* Compute textR.x,y given the verticalTextPosition and
+//         * horizontalTextPosition properties
+//         */
+//
+//        if (verticalTextPosition == TOP) {
+//            if (horizontalTextPosition != CENTER) {
+//                textR.y = 0;
+//            }
+//            else {
+//                textR.y = -(textR.height + gap);
+//            }
+//        }
+//        else if (verticalTextPosition == CENTER) {
+//            textR.y = (iconR.height / 2) - (textR.height / 2);
+//        }
+//        else { // (verticalTextPosition == BOTTOM)
+//            if (horizontalTextPosition != CENTER) {
+//                textR.y = iconR.height - textR.height;
+//            }
+//            else {
+//                textR.y = (iconR.height + gap);
+//            }
+//        }
+//
+//        if (horizontalTextPosition == LEFT) {
+//            textR.x = -(textR.width + gap);
+//        }
+//        else if (horizontalTextPosition == CENTER) {
+//            textR.x = (iconR.width / 2) - (textR.width / 2);
+//        }
+//        else { // (horizontalTextPosition == RIGHT)
+//            textR.x = (iconR.width + gap);
+//        }
+//
+//        // WARNING: DefaultTreeCellEditor uses a shortened version of
+//        // this algorithm to position it's Icon. If you change how this
+//        // is calculated, be sure and update DefaultTreeCellEditor too.
+//
+//        /* labelR is the rectangle that contains iconR and textR.
+//         * Move it to its proper position given the labelAlignment
+//         * properties.
+//         *
+//         * To avoid actually allocating a Rectangle, Rectangle.union
+//         * has been inlined below.
+//         */
+//        int labelR_x = Math.min(iconR.x, textR.x);
+//        int labelR_width = Math.max(iconR.x + iconR.width,
+//                                    textR.x + textR.width) - labelR_x;
+//        int labelR_y = Math.min(iconR.y, textR.y);
+//        int labelR_height = Math.max(iconR.y + iconR.height,
+//                                     textR.y + textR.height) - labelR_y;
+//
+//        int dx, dy;
+//
+//        if (verticalAlignment == TOP) {
+//            dy = viewR.y - labelR_y;
+//        }
+//        else if (verticalAlignment == CENTER) {
+//            dy = (viewR.y + (viewR.height / 2)) - (labelR_y + (labelR_height / 2));
+//        }
+//        else { // (verticalAlignment == BOTTOM)
+//            dy = (viewR.y + viewR.height) - (labelR_y + labelR_height);
+//        }
+//
+//        if (horizontalAlignment == LEFT) {
+//            dx = viewR.x - labelR_x;
+//        }
+//        else if (horizontalAlignment == RIGHT) {
+//            dx = (viewR.x + viewR.width) - (labelR_x + labelR_width);
+//        }
+//        else { // (horizontalAlignment == CENTER)
+//            dx = (viewR.x + (viewR.width / 2)) -
+//                 (labelR_x + (labelR_width / 2));
+//        }
+//
+//        /* Translate textR and glypyR by dx,dy.
+//         */
+//
+//        textR.x += dx;
+//        textR.y += dy;
+//
+//        iconR.x += dx;
+//        iconR.y += dy;
+//
+//        if (lsb < 0) {
+//            // lsb is negative. Shift the x location so that the text is
+//            // visually drawn at the right location.
+//            textR.x -= lsb;
+//
+//            textR.width += lsb;
+//        }
+//        if (rsb > 0) {
+//            textR.width -= rsb;
+//        }
+//
+//        return text;
+//    }
 
 
     /**
@@ -1179,9 +1179,9 @@
      * @see CellRendererPane
      * @see java.awt.Component#isLightweight
      */
-    public static void paintComponent(Graphics g, Component c, Container p, int x, int y, int w, int h) {
-        getCellRendererPane(c, p).paintComponent(g, c, p, x, y, w, h,false);
-    }
+    public static void paintComponent(Graphics g, Component c, Container p, int x, int y, int w, int h) {throw new RuntimeException("cf-bug");} //{
+//        getCellRendererPane(c, p).paintComponent(g, c, p, x, y, w, h,false);
+//    }
 
     /**
      * Paints a component to the specified <code>Graphics</code>.  This
@@ -1197,9 +1197,9 @@
      * @see #paintComponent(Graphics,Component,Container,int,int,int,int)
      * @see CellRendererPane
      */
-    public static void paintComponent(Graphics g, Component c, Container p, Rectangle r) {
-        paintComponent(g, c, p, r.x, r.y, r.width, r.height);
-    }
+    public static void paintComponent(Graphics g, Component c, Container p, Rectangle r) {throw new RuntimeException("cf-bug");} //{
+//        paintComponent(g, c, p, r.x, r.y, r.width, r.height);
+//    }
 
 
     /*
@@ -1207,54 +1207,54 @@
      * <code>ComponentShell</code> parent and that
      * the shell's parent is p.
      */
-    private static CellRendererPane getCellRendererPane(Component c, Container p) {
-        Container shell = c.getParent();
-        if (shell instanceof CellRendererPane) {
-            if (shell.getParent() != p) {
-                p.add(shell);
-            }
-        } else {
-            shell = new CellRendererPane();
-            shell.add(c);
-            p.add(shell);
-        }
-        return (CellRendererPane)shell;
-    }
+    private static CellRendererPane getCellRendererPane(Component c, Container p) {throw new RuntimeException("cf-bug");} //{
+//        Container shell = c.getParent();
+//        if (shell instanceof CellRendererPane) {
+//            if (shell.getParent() != p) {
+//                p.add(shell);
+//            }
+//        } else {
+//            shell = new CellRendererPane();
+//            shell.add(c);
+//            p.add(shell);
+//        }
+//        return (CellRendererPane)shell;
+//    }
 
     /**
      * A simple minded look and feel change: ask each node in the tree
      * to <code>updateUI()</code> -- that is, to initialize its UI property
      * with the current look and feel.
      */
-    public static void updateComponentTreeUI(Component c) {
-        updateComponentTreeUI0(c);
-        c.invalidate();
-        c.validate();
-        c.repaint();
-    }
-
-    private static void updateComponentTreeUI0(Component c) {
-        if (c instanceof JComponent) {
-            JComponent jc = (JComponent) c;
-            jc.updateUI();
-            JPopupMenu jpm =jc.getComponentPopupMenu();
-            if(jpm != null) {
-                updateComponentTreeUI(jpm);
-            }
-        }
-        Component[] children = null;
-        if (c instanceof JMenu) {
-            children = ((JMenu)c).getMenuComponents();
-        }
-        else if (c instanceof Container) {
-            children = ((Container)c).getComponents();
-        }
-        if (children != null) {
-            for (Component child : children) {
-                updateComponentTreeUI0(child);
-            }
-        }
-    }
+    public static void updateComponentTreeUI(Component c) {throw new RuntimeException("cf-bug");} //{
+//        updateComponentTreeUI0(c);
+//        c.invalidate();
+//        c.validate();
+//        c.repaint();
+//    }
+
+    private static void updateComponentTreeUI0(Component c) {throw new RuntimeException("cf-bug");} //{
+//        if (c instanceof JComponent) {
+//            JComponent jc = (JComponent) c;
+//            jc.updateUI();
+//            JPopupMenu jpm =jc.getComponentPopupMenu();
+//            if(jpm != null) {
+//                updateComponentTreeUI(jpm);
+//            }
+//        }
+//        Component[] children = null;
+//        if (c instanceof JMenu) {
+//            children = ((JMenu)c).getMenuComponents();
+//        }
+//        else if (c instanceof Container) {
+//            children = ((Container)c).getComponents();
+//        }
+//        if (children != null) {
+//            for (Component child : children) {
+//                updateComponentTreeUI0(child);
+//            }
+//        }
+//    }
 
 
     /**
@@ -1292,9 +1292,9 @@
      *
      * @see #invokeAndWait
      */
-    public static @SafeEffect void invokeLater(@UI Runnable doRun) {
-        EventQueue.invokeLater(doRun);
-    }
+    public static @SafeEffect void invokeLater(@UI Runnable doRun) {throw new RuntimeException("cf-bug");} //{
+//        EventQueue.invokeLater(doRun);
+//    }
 
 
     /**
@@ -1350,9 +1350,9 @@
      */
     public static @SafeEffect void invokeAndWait(final @UI Runnable doRun)
         throws InterruptedException, InvocationTargetException
-    {
-        EventQueue.invokeAndWait(doRun);
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        EventQueue.invokeAndWait(doRun);
+//    }
 
     /**
      * Returns true if the current thread is an AWT event dispatching thread.
@@ -1363,9 +1363,9 @@
      * @return true if the current thread is an AWT event dispatching thread
      */
     public static boolean isEventDispatchThread()
-    {
-        return EventQueue.isDispatchThread();
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        return EventQueue.isDispatchThread();
+//    }
 
 
     /*
@@ -1383,9 +1383,9 @@
      * @return -1 of this object does not have an accessible parent.
      * Otherwise, the index of the child in its accessible parent.
      */
-    public static int getAccessibleIndexInParent(Component c) {
-        return c.getAccessibleContext().getAccessibleIndexInParent();
-    }
+    public static int getAccessibleIndexInParent(Component c) {throw new RuntimeException("cf-bug");} //{
+//        return c.getAccessibleContext().getAccessibleIndexInParent();
+//    }
 
     /**
      * Returns the <code>Accessible</code> child contained at the
@@ -1395,40 +1395,40 @@
      * @return the <code>Accessible</code> at the specified location,
      *    if it exists; otherwise <code>null</code>
      */
-    public static Accessible getAccessibleAt(Component c, Point p) {
-        if (c instanceof Container) {
-            return c.getAccessibleContext().getAccessibleComponent().getAccessibleAt(p);
-        } else if (c instanceof Accessible) {
-            Accessible a = (Accessible) c;
-            if (a != null) {
-                AccessibleContext ac = a.getAccessibleContext();
-                if (ac != null) {
-                    AccessibleComponent acmp;
-                    Point location;
-                    int nchildren = ac.getAccessibleChildrenCount();
-                    for (int i=0; i < nchildren; i++) {
-                        a = ac.getAccessibleChild(i);
-                        if ((a != null)) {
-                            ac = a.getAccessibleContext();
-                            if (ac != null) {
-                                acmp = ac.getAccessibleComponent();
-                                if ((acmp != null) && (acmp.isShowing())) {
-                                    location = acmp.getLocation();
-                                    Point np = new Point(p.x-location.x,
-                                                         p.y-location.y);
-                                    if (acmp.contains(np)){
-                                        return a;
-                                    }
-                                }
-                            }
-                        }
-                    }
-                }
-            }
-            return (Accessible) c;
-        }
-        return null;
-    }
+    public static Accessible getAccessibleAt(Component c, Point p) {throw new RuntimeException("cf-bug");} //{
+//        if (c instanceof Container) {
+//            return c.getAccessibleContext().getAccessibleComponent().getAccessibleAt(p);
+//        } else if (c instanceof Accessible) {
+//            Accessible a = (Accessible) c;
+//            if (a != null) {
+//                AccessibleContext ac = a.getAccessibleContext();
+//                if (ac != null) {
+//                    AccessibleComponent acmp;
+//                    Point location;
+//                    int nchildren = ac.getAccessibleChildrenCount();
+//                    for (int i=0; i < nchildren; i++) {
+//                        a = ac.getAccessibleChild(i);
+//                        if ((a != null)) {
+//                            ac = a.getAccessibleContext();
+//                            if (ac != null) {
+//                                acmp = ac.getAccessibleComponent();
+//                                if ((acmp != null) && (acmp.isShowing())) {
+//                                    location = acmp.getLocation();
+//                                    Point np = new Point(p.x-location.x,
+//                                                         p.y-location.y);
+//                                    if (acmp.contains(np)){
+//                                        return a;
+//                                    }
+//                                }
+//                            }
+//                        }
+//                    }
+//                }
+//            }
+//            return (Accessible) c;
+//        }
+//        return null;
+//    }
 
     /**
      * Get the state of this object. <p>
@@ -1441,9 +1441,9 @@
      * set of the object
      * @see AccessibleState
      */
-    public static AccessibleStateSet getAccessibleStateSet(Component c) {
-        return c.getAccessibleContext().getAccessibleStateSet();
-    }
+    public static AccessibleStateSet getAccessibleStateSet(Component c) {throw new RuntimeException("cf-bug");} //{
+//        return c.getAccessibleContext().getAccessibleStateSet();
+//    }
 
     /**
      * Returns the number of accessible children in the object.  If all
@@ -1456,9 +1456,9 @@
      *
      * @return the number of accessible children in the object.
      */
-    public static int getAccessibleChildrenCount(Component c) {
-        return c.getAccessibleContext().getAccessibleChildrenCount();
-    }
+    public static int getAccessibleChildrenCount(Component c) {throw new RuntimeException("cf-bug");} //{
+//        return c.getAccessibleContext().getAccessibleChildrenCount();
+//    }
 
     /**
      * Return the nth Accessible child of the object. <p>
@@ -1470,9 +1470,9 @@
      * @param i zero-based index of child
      * @return the nth Accessible child of the object
      */
-    public static Accessible getAccessibleChild(Component c, int i) {
-        return c.getAccessibleContext().getAccessibleChild(i);
-    }
+    public static Accessible getAccessibleChild(Component c, int i) {throw new RuntimeException("cf-bug");} //{
+//        return c.getAccessibleContext().getAccessibleChild(i);
+//    }
 
     /**
      * Return the child <code>Component</code> of the specified
@@ -1489,67 +1489,67 @@
      *   <code>KeyboardFocusManager.getFocusOwner()</code>.
      */
     @Deprecated
-    public static Component findFocusOwner(Component c) {
-        Component focusOwner = KeyboardFocusManager.
-            getCurrentKeyboardFocusManager().getFocusOwner();
-
-        // verify focusOwner is a descendant of c
-        for (Component temp = focusOwner; temp != null;
-             temp = (temp instanceof Window) ? null : temp.getParent())
-        {
-            if (temp == c) {
-                return focusOwner;
-            }
-        }
-
-        return null;
-    }
+    public static Component findFocusOwner(Component c) {throw new RuntimeException("cf-bug");} //{
+//        Component focusOwner = KeyboardFocusManager.
+//            getCurrentKeyboardFocusManager().getFocusOwner();
+//
+//        // verify focusOwner is a descendant of c
+//        for (Component temp = focusOwner; temp != null;
+//             temp = (temp instanceof Window) ? null : temp.getParent())
+//        {
+//            if (temp == c) {
+//                return focusOwner;
+//            }
+//        }
+//
+//        return null;
+//    }
 
     /**
      * If c is a JRootPane descendant return its JRootPane ancestor.
      * If c is a RootPaneContainer then return its JRootPane.
      * @return the JRootPane for Component c or {@code null}.
      */
-    public static JRootPane getRootPane(Component c) {
-        if (c instanceof RootPaneContainer) {
-            return ((RootPaneContainer)c).getRootPane();
-        }
-        for( ; c != null; c = c.getParent()) {
-            if (c instanceof JRootPane) {
-                return (JRootPane)c;
-            }
-        }
-        return null;
-    }
+    public static JRootPane getRootPane(Component c) {throw new RuntimeException("cf-bug");} //{
+//        if (c instanceof RootPaneContainer) {
+//            return ((RootPaneContainer)c).getRootPane();
+//        }
+//        for( ; c != null; c = c.getParent()) {
+//            if (c instanceof JRootPane) {
+//                return (JRootPane)c;
+//            }
+//        }
+//        return null;
+//    }
 
 
     /**
      * Returns the root component for the current component tree.
      * @return the first ancestor of c that's a Window or the last Applet ancestor
      */
-    public static Component getRoot(Component c) {
-        Component applet = null;
-        for(Component p = c; p != null; p = p.getParent()) {
-            if (p instanceof Window) {
-                return p;
-            }
-            if (p instanceof Applet) {
-                applet = p;
-            }
-        }
-        return applet;
-    }
-
-    static JComponent getPaintingOrigin(JComponent c) {
-        Container p = c;
-        while ((p = p.getParent()) instanceof JComponent) {
-            JComponent jp = (JComponent) p;
-            if (jp.isPaintingOrigin()) {
-                return jp;
-            }
-        }
-        return null;
-    }
+    public static Component getRoot(Component c) {throw new RuntimeException("cf-bug");} //{
+//        Component applet = null;
+//        for(Component p = c; p != null; p = p.getParent()) {
+//            if (p instanceof Window) {
+//                return p;
+//            }
+//            if (p instanceof Applet) {
+//                applet = p;
+//            }
+//        }
+//        return applet;
+//    }
+
+    static JComponent getPaintingOrigin(JComponent c) {throw new RuntimeException("cf-bug");} //{
+//        Container p = c;
+//        while ((p = p.getParent()) instanceof JComponent) {
+//            JComponent jp = (JComponent) p;
+//            if (jp.isPaintingOrigin()) {
+//                return jp;
+//            }
+//        }
+//        return null;
+//    }
 
     /**
      * Process the key bindings for the <code>Component</code> associated with
@@ -1567,45 +1567,45 @@
      * @return true if a binding has found and processed
      * @since 1.4
      */
-    public static boolean processKeyBindings(KeyEvent event) {
-        if (event != null) {
-            if (event.isConsumed()) {
-                return false;
-            }
-
-            Component component = event.getComponent();
-            boolean pressed = (event.getID() == KeyEvent.KEY_PRESSED);
-
-            if (!isValidKeyEventForKeyBindings(event)) {
-                return false;
-            }
-            // Find the first JComponent in the ancestor hierarchy, and
-            // invoke processKeyBindings on it
-            while (component != null) {
-                if (component instanceof JComponent) {
-                    return ((JComponent)component).processKeyBindings(
-                                                   event, pressed);
-                }
-                if ((component instanceof Applet) ||
-                    (component instanceof Window)) {
-                    // No JComponents, if Window or Applet parent, process
-                    // WHEN_IN_FOCUSED_WINDOW bindings.
-                    return JComponent.processKeyBindingsForAllComponents(
-                                  event, (Container)component, pressed);
-                }
-                component = component.getParent();
-            }
-        }
-        return false;
-    }
+    public static boolean processKeyBindings(KeyEvent event) {throw new RuntimeException("cf-bug");} //{
+//        if (event != null) {
+//            if (event.isConsumed()) {
+//                return false;
+//            }
+//
+//            Component component = event.getComponent();
+//            boolean pressed = (event.getID() == KeyEvent.KEY_PRESSED);
+//
+//            if (!isValidKeyEventForKeyBindings(event)) {
+//                return false;
+//            }
+//            // Find the first JComponent in the ancestor hierarchy, and
+//            // invoke processKeyBindings on it
+//            while (component != null) {
+//                if (component instanceof JComponent) {
+//                    return ((JComponent)component).processKeyBindings(
+//                                                   event, pressed);
+//                }
+//                if ((component instanceof Applet) ||
+//                    (component instanceof Window)) {
+//                    // No JComponents, if Window or Applet parent, process
+//                    // WHEN_IN_FOCUSED_WINDOW bindings.
+//                    return JComponent.processKeyBindingsForAllComponents(
+//                                  event, (Container)component, pressed);
+//                }
+//                component = component.getParent();
+//            }
+//        }
+//        return false;
+//    }
 
     /**
      * Returns true if the <code>e</code> is a valid KeyEvent to use in
      * processing the key bindings associated with JComponents.
      */
-    static boolean isValidKeyEventForKeyBindings(KeyEvent e) {
-        return true;
-    }
+    static boolean isValidKeyEventForKeyBindings(KeyEvent e) {throw new RuntimeException("cf-bug");} //{
+//        return true;
+//    }
 
     /**
      * Invokes <code>actionPerformed</code> on <code>action</code> if
@@ -1626,51 +1626,51 @@
      */
     public static boolean notifyAction(Action action, KeyStroke ks,
                                        KeyEvent event, Object sender,
-                                       int modifiers) {
-        if (action == null) {
-            return false;
-        }
-        if (action instanceof UIAction) {
-            if (!((UIAction)action).isEnabled(sender)) {
-                return false;
-            }
-        }
-        else if (!action.isEnabled()) {
-            return false;
-        }
-        Object commandO;
-        boolean stayNull;
-
-        // Get the command object.
-        commandO = action.getValue(Action.ACTION_COMMAND_KEY);
-        if (commandO == null && (action instanceof JComponent.ActionStandin)) {
-            // ActionStandin is used for historical reasons to support
-            // registerKeyboardAction with a null value.
-            stayNull = true;
-        }
-        else {
-            stayNull = false;
-        }
-
-        // Convert it to a string.
-        String command;
-
-        if (commandO != null) {
-            command = commandO.toString();
-        }
-        else if (!stayNull && event.getKeyChar() != KeyEvent.CHAR_UNDEFINED) {
-            command = String.valueOf(event.getKeyChar());
-        }
-        else {
-            // Do null for undefined chars, or if registerKeyboardAction
-            // was called with a null.
-            command = null;
-        }
-        action.actionPerformed(new ActionEvent(sender,
-                        ActionEvent.ACTION_PERFORMED, command, event.getWhen(),
-                        modifiers));
-        return true;
-    }
+                                       int modifiers) {throw new RuntimeException("cf-bug");} //{
+//        if (action == null) {
+//            return false;
+//        }
+//        if (action instanceof UIAction) {
+//            if (!((UIAction)action).isEnabled(sender)) {
+//                return false;
+//            }
+//        }
+//        else if (!action.isEnabled()) {
+//            return false;
+//        }
+//        Object commandO;
+//        boolean stayNull;
+//
+//        // Get the command object.
+//        commandO = action.getValue(Action.ACTION_COMMAND_KEY);
+//        if (commandO == null && (action instanceof JComponent.ActionStandin)) {
+//            // ActionStandin is used for historical reasons to support
+//            // registerKeyboardAction with a null value.
+//            stayNull = true;
+//        }
+//        else {
+//            stayNull = false;
+//        }
+//
+//        // Convert it to a string.
+//        String command;
+//
+//        if (commandO != null) {
+//            command = commandO.toString();
+//        }
+//        else if (!stayNull && event.getKeyChar() != KeyEvent.CHAR_UNDEFINED) {
+//            command = String.valueOf(event.getKeyChar());
+//        }
+//        else {
+//            // Do null for undefined chars, or if registerKeyboardAction
+//            // was called with a null.
+//            command = null;
+//        }
+//        action.actionPerformed(new ActionEvent(sender,
+//                        ActionEvent.ACTION_PERFORMED, command, event.getWhen(),
+//                        modifiers));
+//        return true;
+//    }
 
 
     /**
@@ -1681,18 +1681,18 @@
      * @since 1.3
      */
     public static void replaceUIInputMap(JComponent component, int type,
-                                         InputMap uiInputMap) {
-        InputMap map = component.getInputMap(type, (uiInputMap != null));
-
-        while (map != null) {
-            InputMap parent = map.getParent();
-            if (parent == null || (parent instanceof UIResource)) {
-                map.setParent(uiInputMap);
-                return;
-            }
-            map = parent;
-        }
-    }
+                                         InputMap uiInputMap) {throw new RuntimeException("cf-bug");} //{
+//        InputMap map = component.getInputMap(type, (uiInputMap != null));
+//
+//        while (map != null) {
+//            InputMap parent = map.getParent();
+//            if (parent == null || (parent instanceof UIResource)) {
+//                map.setParent(uiInputMap);
+//                return;
+//            }
+//            map = parent;
+//        }
+//    }
 
 
     /**
@@ -1703,18 +1703,18 @@
      * @since 1.3
      */
     public static void replaceUIActionMap(JComponent component,
-                                          ActionMap uiActionMap) {
-        ActionMap map = component.getActionMap((uiActionMap != null));
-
-        while (map != null) {
-            ActionMap parent = map.getParent();
-            if (parent == null || (parent instanceof UIResource)) {
-                map.setParent(uiActionMap);
-                return;
-            }
-            map = parent;
-        }
-    }
+                                          ActionMap uiActionMap) {throw new RuntimeException("cf-bug");} //{
+//        ActionMap map = component.getActionMap((uiActionMap != null));
+//
+//        while (map != null) {
+//            ActionMap parent = map.getParent();
+//            if (parent == null || (parent instanceof UIResource)) {
+//                map.setParent(uiActionMap);
+//                return;
+//            }
+//            map = parent;
+//        }
+//    }
 
 
     /**
@@ -1725,17 +1725,17 @@
      *
      * @since 1.3
      */
-    public static InputMap getUIInputMap(JComponent component, int condition) {
-        InputMap map = component.getInputMap(condition, false);
-        while (map != null) {
-            InputMap parent = map.getParent();
-            if (parent instanceof UIResource) {
-                return parent;
-            }
-            map = parent;
-        }
-        return null;
-    }
+    public static InputMap getUIInputMap(JComponent component, int condition) {throw new RuntimeException("cf-bug");} //{
+//        InputMap map = component.getInputMap(condition, false);
+//        while (map != null) {
+//            InputMap parent = map.getParent();
+//            if (parent instanceof UIResource) {
+//                return parent;
+//            }
+//            map = parent;
+//        }
+//        return null;
+//    }
 
     /**
      * Returns the ActionMap provided by the UI
@@ -1744,17 +1744,17 @@
      *
      * @since 1.3
      */
-    public static ActionMap getUIActionMap(JComponent component) {
-        ActionMap map = component.getActionMap(false);
-        while (map != null) {
-            ActionMap parent = map.getParent();
-            if (parent instanceof UIResource) {
-                return parent;
-            }
-            map = parent;
-        }
-        return null;
-    }
+    public static ActionMap getUIActionMap(JComponent component) {throw new RuntimeException("cf-bug");} //{
+//        ActionMap map = component.getActionMap(false);
+//        while (map != null) {
+//            ActionMap parent = map.getParent();
+//            if (parent instanceof UIResource) {
+//                return parent;
+//            }
+//            map = parent;
+//        }
+//        return null;
+//    }
 
 
     // Don't use String, as it's not guaranteed to be unique in a Hashtable.
@@ -1762,42 +1762,42 @@
        new StringBuffer("SwingUtilities.sharedOwnerFrame");
 
     static class SharedOwnerFrame extends Frame implements WindowListener {
-        public void addNotify() {
-            super.addNotify();
-            installListeners();
-        }
+        public void addNotify() {throw new RuntimeException("cf-bug");} //{
+//            super.addNotify();
+//            installListeners();
+//        }
 
         /**
          * Install window listeners on owned windows to watch for displayability changes
          */
-        void installListeners() {
-            Window[] windows = getOwnedWindows();
-            for (Window window : windows) {
-                if (window != null) {
-                    window.removeWindowListener(this);
-                    window.addWindowListener(this);
-                }
-            }
-        }
+        void installListeners() {throw new RuntimeException("cf-bug");} //{
+//            Window[] windows = getOwnedWindows();
+//            for (Window window : windows) {
+//                if (window != null) {
+//                    window.removeWindowListener(this);
+//                    window.addWindowListener(this);
+//                }
+//            }
+//        }
 
         /**
          * Watches for displayability changes and disposes shared instance if there are no
          * displayable children left.
          */
-        public void windowClosed(WindowEvent e) {
-            synchronized(getTreeLock()) {
-                Window[] windows = getOwnedWindows();
-                for (Window window : windows) {
-                    if (window != null) {
-                        if (window.isDisplayable()) {
-                            return;
-                        }
-                        window.removeWindowListener(this);
-                    }
-                }
-                dispose();
-            }
-        }
+        public void windowClosed(WindowEvent e) {throw new RuntimeException("cf-bug");} //{
+//            synchronized(getTreeLock()) {
+//                Window[] windows = getOwnedWindows();
+//                for (Window window : windows) {
+//                    if (window != null) {
+//                        if (window.isDisplayable()) {
+//                            return;
+//                        }
+//                        window.removeWindowListener(this);
+//                    }
+//                }
+//                dispose();
+//            }
+//        }
         public void windowOpened(WindowEvent e) {
         }
         public void windowClosing(WindowEvent e) {
@@ -1814,14 +1814,14 @@
         public void show() {
             // This frame can never be shown
         }
-        public void dispose() {
-            try {
-                getToolkit().getSystemEventQueue();
-                super.dispose();
-            } catch (Exception e) {
-                // untrusted code not allowed to dispose
-            }
-        }
+        public void dispose() {throw new RuntimeException("cf-bug");} //{
+//            try {
+//                getToolkit().getSystemEventQueue();
+//                super.dispose();
+//            } catch (Exception e) {
+//                // untrusted code not allowed to dispose
+//            }
+//        }
     }
 
     /**
@@ -1832,16 +1832,16 @@
      * returns true.
      * @see java.awt.GraphicsEnvironment#isHeadless
      */
-    static Frame getSharedOwnerFrame() throws HeadlessException {
-        Frame sharedOwnerFrame =
-            (Frame)SwingUtilities.appContextGet(sharedOwnerFrameKey);
-        if (sharedOwnerFrame == null) {
-            sharedOwnerFrame = new SharedOwnerFrame();
-            SwingUtilities.appContextPut(sharedOwnerFrameKey,
-                                         sharedOwnerFrame);
-        }
-        return sharedOwnerFrame;
-    }
+    static Frame getSharedOwnerFrame() throws HeadlessException {throw new RuntimeException("cf-bug");} //{
+//        Frame sharedOwnerFrame =
+//            (Frame)SwingUtilities.appContextGet(sharedOwnerFrameKey);
+//        if (sharedOwnerFrame == null) {
+//            sharedOwnerFrame = new SharedOwnerFrame();
+//            SwingUtilities.appContextPut(sharedOwnerFrameKey,
+//                                         sharedOwnerFrame);
+//        }
+//        return sharedOwnerFrame;
+//    }
 
     /**
      * Returns a SharedOwnerFrame's shutdown listener to dispose the SharedOwnerFrame
@@ -1850,10 +1850,10 @@
      * returns true.
      * @see java.awt.GraphicsEnvironment#isHeadless
      */
-    static WindowListener getSharedOwnerFrameShutdownListener() throws HeadlessException {
-        Frame sharedOwnerFrame = getSharedOwnerFrame();
-        return (WindowListener)sharedOwnerFrame;
-    }
+    static WindowListener getSharedOwnerFrameShutdownListener() throws HeadlessException {throw new RuntimeException("cf-bug");} //{
+//        Frame sharedOwnerFrame = getSharedOwnerFrame();
+//        return (WindowListener)sharedOwnerFrame;
+//    }
 
     /* Don't make these AppContext accessors public or protected --
      * since AppContext is in sun.awt in 1.2, we shouldn't expose it
@@ -1862,33 +1862,33 @@
     // REMIND(aim): phase out use of 4 methods below since they
     // are just private covers for AWT methods (?)
 
-    static Object appContextGet(Object key) {
-        return AppContext.getAppContext().get(key);
-    }
-
-    static void appContextPut(Object key, Object value) {
-        AppContext.getAppContext().put(key, value);
-    }
-
-    static void appContextRemove(Object key) {
-        AppContext.getAppContext().remove(key);
-    }
-
-
-    static Class<?> loadSystemClass(String className) throws ClassNotFoundException {
-        ReflectUtil.checkPackageAccess(className);
-        return Class.forName(className, true, Thread.currentThread().
-                             getContextClassLoader());
-    }
+    static Object appContextGet(Object key) {throw new RuntimeException("cf-bug");} //{
+//        return AppContext.getAppContext().get(key);
+//    }
+
+    static void appContextPut(Object key, Object value) {throw new RuntimeException("cf-bug");} //{
+//        AppContext.getAppContext().put(key, value);
+//    }
+
+    static void appContextRemove(Object key) {throw new RuntimeException("cf-bug");} //{
+//        AppContext.getAppContext().remove(key);
+//    }
+
+
+    static Class<?> loadSystemClass(String className) throws ClassNotFoundException {throw new RuntimeException("cf-bug");} //{
+//        ReflectUtil.checkPackageAccess(className);
+//        return Class.forName(className, true, Thread.currentThread().
+//                             getContextClassLoader());
+//    }
 
 
    /*
      * Convenience function for determining ComponentOrientation.  Helps us
      * avoid having Munge directives throughout the code.
      */
-    static boolean isLeftToRight( Component c ) {
-        return c.getComponentOrientation().isLeftToRight();
-    }
+    static boolean isLeftToRight( Component c ) {throw new RuntimeException("cf-bug");} //{
+//        return c.getComponentOrientation().isLeftToRight();
+//    }
     private SwingUtilities() {
         throw new Error("SwingUtilities is just a container for static methods");
     }
@@ -1897,11 +1897,11 @@
      * Returns true if the Icon <code>icon</code> is an instance of
      * ImageIcon, and the image it contains is the same as <code>image</code>.
      */
-    static boolean doesIconReferenceImage(Icon icon, Image image) {
-        Image iconImage = (icon != null && (icon instanceof ImageIcon)) ?
-                           ((ImageIcon)icon).getImage() : null;
-        return (iconImage == image);
-    }
+    static boolean doesIconReferenceImage(Icon icon, Image image) {throw new RuntimeException("cf-bug");} //{
+//        Image iconImage = (icon != null && (icon instanceof ImageIcon)) ?
+//                           ((ImageIcon)icon).getImage() : null;
+//        return (iconImage == image);
+//    }
 
     /**
      * Returns index of the first occurrence of <code>mnemonic</code>
@@ -1912,25 +1912,25 @@
      * @param mnemonic The mnemonic to find the character for.
      * @return index into the string if exists, otherwise -1
      */
-    static int findDisplayedMnemonicIndex(String text, int mnemonic) {
-        if (text == null || mnemonic == '\0') {
-            return -1;
-        }
-
-        char uc = Character.toUpperCase((char)mnemonic);
-        char lc = Character.toLowerCase((char)mnemonic);
-
-        int uci = text.indexOf(uc);
-        int lci = text.indexOf(lc);
-
-        if (uci == -1) {
-            return lci;
-        } else if(lci == -1) {
-            return uci;
-        } else {
-            return (lci < uci) ? lci : uci;
-        }
-    }
+    static int findDisplayedMnemonicIndex(String text, int mnemonic) {throw new RuntimeException("cf-bug");} //{
+//        if (text == null || mnemonic == '\0') {
+//            return -1;
+//        }
+//
+//        char uc = Character.toUpperCase((char)mnemonic);
+//        char lc = Character.toLowerCase((char)mnemonic);
+//
+//        int uci = text.indexOf(uc);
+//        int lci = text.indexOf(lc);
+//
+//        if (uci == -1) {
+//            return lci;
+//        } else if(lci == -1) {
+//            return uci;
+//        } else {
+//            return (lci < uci) ? lci : uci;
+//        }
+//    }
 
     /**
      * Stores the position and size of
@@ -1950,43 +1950,43 @@
      *
      * @since 1.4
      */
-    public static Rectangle calculateInnerArea(JComponent c, Rectangle r) {
-        if (c == null) {
-            return null;
-        }
-        Rectangle rect = r;
-        Insets insets = c.getInsets();
-
-        if (rect == null) {
-            rect = new Rectangle();
-        }
-
-        rect.x = insets.left;
-        rect.y = insets.top;
-        rect.width = c.getWidth() - insets.left - insets.right;
-        rect.height = c.getHeight() - insets.top - insets.bottom;
-
-        return rect;
-    }
-
-    static void updateRendererOrEditorUI(Object rendererOrEditor) {
-        if (rendererOrEditor == null) {
-            return;
-        }
-
-        Component component = null;
-
-        if (rendererOrEditor instanceof Component) {
-            component = (Component)rendererOrEditor;
-        }
-        if (rendererOrEditor instanceof DefaultCellEditor) {
-            component = ((DefaultCellEditor)rendererOrEditor).getComponent();
-        }
-
-        if (component != null) {
-            SwingUtilities.updateComponentTreeUI(component);
-        }
-    }
+    public static Rectangle calculateInnerArea(JComponent c, Rectangle r) {throw new RuntimeException("cf-bug");} //{
+//        if (c == null) {
+//            return null;
+//        }
+//        Rectangle rect = r;
+//        Insets insets = c.getInsets();
+//
+//        if (rect == null) {
+//            rect = new Rectangle();
+//        }
+//
+//        rect.x = insets.left;
+//        rect.y = insets.top;
+//        rect.width = c.getWidth() - insets.left - insets.right;
+//        rect.height = c.getHeight() - insets.top - insets.bottom;
+//
+//        return rect;
+//    }
+
+    static void updateRendererOrEditorUI(Object rendererOrEditor) {throw new RuntimeException("cf-bug");} //{
+//        if (rendererOrEditor == null) {
+//            return;
+//        }
+//
+//        Component component = null;
+//
+//        if (rendererOrEditor instanceof Component) {
+//            component = (Component)rendererOrEditor;
+//        }
+//        if (rendererOrEditor instanceof DefaultCellEditor) {
+//            component = ((DefaultCellEditor)rendererOrEditor).getComponent();
+//        }
+//
+//        if (component != null) {
+//            SwingUtilities.updateComponentTreeUI(component);
+//        }
+//    }
 
     /**
      * Returns the first ancestor of the {@code component}
@@ -2004,13 +2004,13 @@
      *
      * @since 1.7
      */
-    public static Container getUnwrappedParent(Component component) {
-        Container parent = component.getParent();
-        while(parent instanceof JLayer) {
-            parent = parent.getParent();
-        }
-        return parent;
-    }
+    public static Container getUnwrappedParent(Component component) {throw new RuntimeException("cf-bug");} //{
+//        Container parent = component.getParent();
+//        while(parent instanceof JLayer) {
+//            parent = parent.getParent();
+//        }
+//        return parent;
+//    }
 
     /**
      * Returns the first {@code JViewport}'s descendant
@@ -2035,13 +2035,13 @@
      *
      * @since 1.7
      */
-    public static Component getUnwrappedView(JViewport viewport) {
-        Component view = viewport.getView();
-        while (view instanceof JLayer) {
-            view = ((JLayer)view).getView();
-        }
-        return view;
-    }
+    public static Component getUnwrappedView(JViewport viewport) {throw new RuntimeException("cf-bug");} //{
+//        Component view = viewport.getView();
+//        while (view instanceof JLayer) {
+//            view = ((JLayer)view).getView();
+//        }
+//        return view;
+//    }
 
    /**
      * Retrieves the validate root of a given container.
@@ -2063,33 +2063,33 @@
      * @see java.awt.Component#isVisible()
      * @since 1.7
      */
-    static Container getValidateRoot(Container c, boolean visibleOnly) {
-        Container root = null;
-
-        for (; c != null; c = c.getParent())
-        {
-            if (!c.isDisplayable() || c instanceof CellRendererPane) {
-                return null;
-            }
-            if (c.isValidateRoot()) {
-                root = c;
-                break;
-            }
-        }
-
-        if (root == null) {
-            return null;
-        }
-
-        for (; c != null; c = c.getParent()) {
-            if (!c.isDisplayable() || (visibleOnly && !c.isVisible())) {
-                return null;
-            }
-            if (c instanceof Window || c instanceof Applet) {
-                return root;
-            }
-        }
-
-        return null;
-    }
+    static Container getValidateRoot(Container c, boolean visibleOnly) {throw new RuntimeException("cf-bug");} //{
+//        Container root = null;
+//
+//        for (; c != null; c = c.getParent())
+//        {
+//            if (!c.isDisplayable() || c instanceof CellRendererPane) {
+//                return null;
+//            }
+//            if (c.isValidateRoot()) {
+//                root = c;
+//                break;
+//            }
+//        }
+//
+//        if (root == null) {
+//            return null;
+//        }
+//
+//        for (; c != null; c = c.getParent()) {
+//            if (!c.isDisplayable() || (visibleOnly && !c.isVisible())) {
+//                return null;
+//            }
+//            if (c instanceof Window || c instanceof Applet) {
+//                return root;
+//            }
+//        }
+//
+//        return null;
+//    }
 }
--- javax/swing/JLabel.java	2016-06-22 19:55:09.862841629 -0700
+++ javax/swing/JLabel.java	2016-06-29 12:22:39.927916181 -0700
@@ -241,9 +241,9 @@
      *
      * @return LabelUI object
      */
-    public LabelUI getUI() {
-        return (LabelUI)ui;
-    }
+    public LabelUI getUI() {throw new RuntimeException("cf-bug");} //{
+//        return (LabelUI)ui;
+//    }
 
 
     /**
@@ -257,13 +257,13 @@
      *    attribute: visualUpdate true
      *  description: The UI object that implements the Component's LookAndFeel.
      */
-    public void setUI(LabelUI ui) {
-        super.setUI(ui);
-        // disabled icon is generated by LF so it should be unset here
-        if (!disabledIconSet && disabledIcon != null) {
-            setDisabledIcon(null);
-        }
-    }
+    public void setUI(LabelUI ui) {throw new RuntimeException("cf-bug");} //{
+//        super.setUI(ui);
+//        // disabled icon is generated by LF so it should be unset here
+//        if (!disabledIconSet && disabledIcon != null) {
+//            setDisabledIcon(null);
+//        }
+//    }
 
 
     /**
@@ -271,9 +271,9 @@
      *
      * @see JComponent#updateUI
      */
-    public void updateUI() {
-        setUI((LabelUI)UIManager.getUI(this));
-    }
+    public void updateUI() {throw new RuntimeException("cf-bug");} //{
+//        setUI((LabelUI)UIManager.getUI(this));
+//    }
 
 
     /**
@@ -285,9 +285,9 @@
      * @see JComponent#getUIClassID
      * @see UIDefaults#getUI
      */
-    public String getUIClassID() {
-        return uiClassID;
-    }
+    public String getUIClassID() {throw new RuntimeException("cf-bug");} //{
+//        return uiClassID;
+//    }
 
 
     /**
@@ -296,9 +296,9 @@
      * @return a String
      * @see #setText
      */
-    public String getText() {
-        return text;
-    }
+    public String getText() {throw new RuntimeException("cf-bug");} //{
+//        return text;
+//    }
 
 
     /**
@@ -318,33 +318,33 @@
      *    attribute: visualUpdate true
      *  description: Defines the single line of text this component will display.
      */
-    public void setText(String text) {
-
-        String oldAccessibleName = null;
-        if (accessibleContext != null) {
-            oldAccessibleName = accessibleContext.getAccessibleName();
-        }
-
-        String oldValue = this.text;
-        this.text = text;
-        firePropertyChange("text", oldValue, text);
-
-        setDisplayedMnemonicIndex(
-                      SwingUtilities.findDisplayedMnemonicIndex(
-                                          text, getDisplayedMnemonic()));
-
-        if ((accessibleContext != null)
-            && (accessibleContext.getAccessibleName() != oldAccessibleName)) {
-                accessibleContext.firePropertyChange(
-                        AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                        oldAccessibleName,
-                        accessibleContext.getAccessibleName());
-        }
-        if (text == null || oldValue == null || !text.equals(oldValue)) {
-            revalidate();
-            repaint();
-        }
-    }
+    public void setText(String text) {throw new RuntimeException("cf-bug");} //{
+//
+//        String oldAccessibleName = null;
+//        if (accessibleContext != null) {
+//            oldAccessibleName = accessibleContext.getAccessibleName();
+//        }
+//
+//        String oldValue = this.text;
+//        this.text = text;
+//        firePropertyChange("text", oldValue, text);
+//
+//        setDisplayedMnemonicIndex(
+//                      SwingUtilities.findDisplayedMnemonicIndex(
+//                                          text, getDisplayedMnemonic()));
+//
+//        if ((accessibleContext != null)
+//            && (accessibleContext.getAccessibleName() != oldAccessibleName)) {
+//                accessibleContext.firePropertyChange(
+//                        AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                        oldAccessibleName,
+//                        accessibleContext.getAccessibleName());
+//        }
+//        if (text == null || oldValue == null || !text.equals(oldValue)) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
 
     /**
@@ -353,9 +353,9 @@
      * @return an Icon
      * @see #setIcon
      */
-    public Icon getIcon() {
-        return defaultIcon;
-    }
+    public Icon getIcon() {throw new RuntimeException("cf-bug");} //{
+//        return defaultIcon;
+//    }
 
     /**
      * Defines the icon this component will display.  If
@@ -374,41 +374,41 @@
      *    attribute: visualUpdate true
      *  description: The icon this component will display.
      */
-    public void setIcon(Icon icon) {
-        Icon oldValue = defaultIcon;
-        defaultIcon = icon;
-
-        /* If the default icon has really changed and we had
-         * generated the disabled icon for this component
-         * (in other words, setDisabledIcon() was never called), then
-         * clear the disabledIcon field.
-         */
-        if ((defaultIcon != oldValue) && !disabledIconSet) {
-            disabledIcon = null;
-        }
-
-        firePropertyChange("icon", oldValue, defaultIcon);
-
-        if ((accessibleContext != null) && (oldValue != defaultIcon)) {
-                accessibleContext.firePropertyChange(
-                        AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                        oldValue, defaultIcon);
-        }
-
-        /* If the default icon has changed and the new one is
-         * a different size, then revalidate.   Repaint if the
-         * default icon has changed.
-         */
-        if (defaultIcon != oldValue) {
-            if ((defaultIcon == null) ||
-                (oldValue == null) ||
-                (defaultIcon.getIconWidth() != oldValue.getIconWidth()) ||
-                (defaultIcon.getIconHeight() != oldValue.getIconHeight())) {
-                revalidate();
-            }
-            repaint();
-        }
-    }
+    public void setIcon(Icon icon) {throw new RuntimeException("cf-bug");} //{
+//        Icon oldValue = defaultIcon;
+//        defaultIcon = icon;
+//
+//        /* If the default icon has really changed and we had
+//         * generated the disabled icon for this component
+//         * (in other words, setDisabledIcon() was never called), then
+//         * clear the disabledIcon field.
+//         */
+//        if ((defaultIcon != oldValue) && !disabledIconSet) {
+//            disabledIcon = null;
+//        }
+//
+//        firePropertyChange("icon", oldValue, defaultIcon);
+//
+//        if ((accessibleContext != null) && (oldValue != defaultIcon)) {
+//                accessibleContext.firePropertyChange(
+//                        AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                        oldValue, defaultIcon);
+//        }
+//
+//        /* If the default icon has changed and the new one is
+//         * a different size, then revalidate.   Repaint if the
+//         * default icon has changed.
+//         */
+//        if (defaultIcon != oldValue) {
+//            if ((defaultIcon == null) ||
+//                (oldValue == null) ||
+//                (defaultIcon.getIconWidth() != oldValue.getIconWidth()) ||
+//                (defaultIcon.getIconHeight() != oldValue.getIconHeight())) {
+//                revalidate();
+//            }
+//            repaint();
+//        }
+//    }
 
 
     /**
@@ -425,15 +425,15 @@
      * @see ImageIcon
      */
     @Transient
-    public Icon getDisabledIcon() {
-        if (!disabledIconSet && disabledIcon == null && defaultIcon != null) {
-            disabledIcon = UIManager.getLookAndFeel().getDisabledIcon(this, defaultIcon);
-            if (disabledIcon != null) {
-                firePropertyChange("disabledIcon", null, disabledIcon);
-            }
-        }
-        return disabledIcon;
-    }
+    public Icon getDisabledIcon() {throw new RuntimeException("cf-bug");} //{
+//        if (!disabledIconSet && disabledIcon == null && defaultIcon != null) {
+//            disabledIcon = UIManager.getLookAndFeel().getDisabledIcon(this, defaultIcon);
+//            if (disabledIcon != null) {
+//                firePropertyChange("disabledIcon", null, disabledIcon);
+//            }
+//        }
+//        return disabledIcon;
+//    }
 
 
     /**
@@ -450,22 +450,22 @@
      *    attribute: visualUpdate true
      *  description: The icon to display if the label is disabled.
      */
-    public void setDisabledIcon(Icon disabledIcon) {
-        Icon oldValue = this.disabledIcon;
-        this.disabledIcon = disabledIcon;
-        disabledIconSet = (disabledIcon != null);
-        firePropertyChange("disabledIcon", oldValue, disabledIcon);
-        if (disabledIcon != oldValue) {
-            if (disabledIcon == null || oldValue == null ||
-                disabledIcon.getIconWidth() != oldValue.getIconWidth() ||
-                disabledIcon.getIconHeight() != oldValue.getIconHeight()) {
-                revalidate();
-            }
-            if (!isEnabled()) {
-                repaint();
-            }
-        }
-    }
+    public void setDisabledIcon(Icon disabledIcon) {throw new RuntimeException("cf-bug");} //{
+//        Icon oldValue = this.disabledIcon;
+//        this.disabledIcon = disabledIcon;
+//        disabledIconSet = (disabledIcon != null);
+//        firePropertyChange("disabledIcon", oldValue, disabledIcon);
+//        if (disabledIcon != oldValue) {
+//            if (disabledIcon == null || oldValue == null ||
+//                disabledIcon.getIconWidth() != oldValue.getIconWidth() ||
+//                disabledIcon.getIconHeight() != oldValue.getIconHeight()) {
+//                revalidate();
+//            }
+//            if (!isEnabled()) {
+//                repaint();
+//            }
+//        }
+//    }
 
 
     /**
@@ -482,19 +482,19 @@
      *    attribute: visualUpdate true
      *  description: The mnemonic keycode.
      */
-    public void setDisplayedMnemonic(int key) {
-        int oldKey = mnemonic;
-        mnemonic = key;
-        firePropertyChange("displayedMnemonic", oldKey, mnemonic);
-
-        setDisplayedMnemonicIndex(
-            SwingUtilities.findDisplayedMnemonicIndex(getText(), mnemonic));
-
-        if (key != oldKey) {
-            revalidate();
-            repaint();
-        }
-    }
+    public void setDisplayedMnemonic(int key) {throw new RuntimeException("cf-bug");} //{
+//        int oldKey = mnemonic;
+//        mnemonic = key;
+//        firePropertyChange("displayedMnemonic", oldKey, mnemonic);
+//
+//        setDisplayedMnemonicIndex(
+//            SwingUtilities.findDisplayedMnemonicIndex(getText(), mnemonic));
+//
+//        if (key != oldKey) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
 
     /**
@@ -503,12 +503,12 @@
      * @param aChar  a char specifying the mnemonic to display
      * @see #setDisplayedMnemonic(int)
      */
-    public void setDisplayedMnemonic(char aChar) {
-        int vk = java.awt.event.KeyEvent.getExtendedKeyCodeForChar(aChar);
-        if (vk != java.awt.event.KeyEvent.VK_UNDEFINED) {
-            setDisplayedMnemonic(vk);
-        }
-    }
+    public void setDisplayedMnemonic(char aChar) {throw new RuntimeException("cf-bug");} //{
+//        int vk = java.awt.event.KeyEvent.getExtendedKeyCodeForChar(aChar);
+//        if (vk != java.awt.event.KeyEvent.VK_UNDEFINED) {
+//            setDisplayedMnemonic(vk);
+//        }
+//    }
 
 
     /**
@@ -523,9 +523,9 @@
      * @see #getLabelFor
      * @see #setLabelFor
      */
-    public int getDisplayedMnemonic() {
-        return mnemonic;
-    }
+    public int getDisplayedMnemonic() {throw new RuntimeException("cf-bug");} //{
+//        return mnemonic;
+//    }
 
     /**
      * Provides a hint to the look and feel as to which character in the
@@ -555,24 +555,24 @@
      *               mnemonic at
      */
     public void setDisplayedMnemonicIndex(int index)
-                                             throws IllegalArgumentException {
-        int oldValue = mnemonicIndex;
-        if (index == -1) {
-            mnemonicIndex = -1;
-        } else {
-            String text = getText();
-            int textLength = (text == null) ? 0 : text.length();
-            if (index < -1 || index >= textLength) {  // index out of range
-                throw new IllegalArgumentException("index == " + index);
-            }
-        }
-        mnemonicIndex = index;
-        firePropertyChange("displayedMnemonicIndex", oldValue, index);
-        if (index != oldValue) {
-            revalidate();
-            repaint();
-        }
-    }
+                                             throws IllegalArgumentException {throw new RuntimeException("cf-bug");} //{
+//        int oldValue = mnemonicIndex;
+//        if (index == -1) {
+//            mnemonicIndex = -1;
+//        } else {
+//            String text = getText();
+//            int textLength = (text == null) ? 0 : text.length();
+//            if (index < -1 || index >= textLength) {  // index out of range
+//                throw new IllegalArgumentException("index == " + index);
+//            }
+//        }
+//        mnemonicIndex = index;
+//        firePropertyChange("displayedMnemonicIndex", oldValue, index);
+//        if (index != oldValue) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
     /**
      * Returns the character, as an index, that the look and feel should
@@ -582,9 +582,9 @@
      * @return index representing mnemonic character
      * @see #setDisplayedMnemonicIndex
      */
-    public int getDisplayedMnemonicIndex() {
-        return mnemonicIndex;
-    }
+    public int getDisplayedMnemonicIndex() {throw new RuntimeException("cf-bug");} //{
+//        return mnemonicIndex;
+//    }
 
     /**
      * Verify that key is a legal value for the horizontalAlignment properties.
@@ -596,18 +596,18 @@
      * @see #setHorizontalTextPosition
      * @see #setHorizontalAlignment
      */
-    protected int checkHorizontalKey(int key, String message) {
-        if ((key == LEFT) ||
-            (key == CENTER) ||
-            (key == RIGHT) ||
-            (key == LEADING) ||
-            (key == TRAILING)) {
-            return key;
-        }
-        else {
-            throw new IllegalArgumentException(message);
-        }
-    }
+    protected int checkHorizontalKey(int key, String message) {throw new RuntimeException("cf-bug");} //{
+//        if ((key == LEFT) ||
+//            (key == CENTER) ||
+//            (key == RIGHT) ||
+//            (key == LEADING) ||
+//            (key == TRAILING)) {
+//            return key;
+//        }
+//        else {
+//            throw new IllegalArgumentException(message);
+//        }
+//    }
 
 
     /**
@@ -620,14 +620,14 @@
      * @see #setVerticalAlignment
      * @see #setVerticalTextPosition
      */
-    protected int checkVerticalKey(int key, String message) {
-        if ((key == TOP) || (key == CENTER) || (key == BOTTOM)) {
-            return key;
-        }
-        else {
-            throw new IllegalArgumentException(message);
-        }
-    }
+    protected int checkVerticalKey(int key, String message) {throw new RuntimeException("cf-bug");} //{
+//        if ((key == TOP) || (key == CENTER) || (key == BOTTOM)) {
+//            return key;
+//        }
+//        else {
+//            throw new IllegalArgumentException(message);
+//        }
+//    }
 
 
     /**
@@ -638,9 +638,9 @@
      *         and the icon.
      * @see #setIconTextGap
      */
-    public int getIconTextGap() {
-        return iconTextGap;
-    }
+    public int getIconTextGap() {throw new RuntimeException("cf-bug");} //{
+//        return iconTextGap;
+//    }
 
 
     /**
@@ -658,15 +658,15 @@
      *  description: If both the icon and text properties are set, this
      *               property defines the space between them.
      */
-    public void setIconTextGap(int iconTextGap) {
-        int oldValue = this.iconTextGap;
-        this.iconTextGap = iconTextGap;
-        firePropertyChange("iconTextGap", oldValue, iconTextGap);
-        if (iconTextGap != oldValue) {
-            revalidate();
-            repaint();
-        }
-    }
+    public void setIconTextGap(int iconTextGap) {throw new RuntimeException("cf-bug");} //{
+//        int oldValue = this.iconTextGap;
+//        this.iconTextGap = iconTextGap;
+//        firePropertyChange("iconTextGap", oldValue, iconTextGap);
+//        if (iconTextGap != oldValue) {
+//            revalidate();
+//            repaint();
+//        }
+//    }
 
 
 
@@ -682,9 +682,9 @@
      * @see SwingConstants
      * @see #setVerticalAlignment
      */
-    public int getVerticalAlignment() {
-        return verticalAlignment;
-    }
+    public int getVerticalAlignment() {throw new RuntimeException("cf-bug");} //{
+//        return verticalAlignment;
+//    }
 
 
     /**
@@ -708,13 +708,13 @@
      *    attribute: visualUpdate true
      *  description: The alignment of the label's contents along the Y axis.
      */
-    public void setVerticalAlignment(int alignment) {
-        if (alignment == verticalAlignment) return;
-        int oldValue = verticalAlignment;
-        verticalAlignment = checkVerticalKey(alignment, "verticalAlignment");
-        firePropertyChange("verticalAlignment", oldValue, verticalAlignment);
-        repaint();
-    }
+    public void setVerticalAlignment(int alignment) {throw new RuntimeException("cf-bug");} //{
+//        if (alignment == verticalAlignment) return;
+//        int oldValue = verticalAlignment;
+//        verticalAlignment = checkVerticalKey(alignment, "verticalAlignment");
+//        firePropertyChange("verticalAlignment", oldValue, verticalAlignment);
+//        repaint();
+//    }
 
 
     /**
@@ -731,9 +731,9 @@
      * @see #setHorizontalAlignment
      * @see SwingConstants
      */
-    public int getHorizontalAlignment() {
-        return horizontalAlignment;
-    }
+    public int getHorizontalAlignment() {throw new RuntimeException("cf-bug");} //{
+//        return horizontalAlignment;
+//    }
 
     /**
      * Sets the alignment of the label's contents along the X axis.
@@ -760,15 +760,15 @@
      *    attribute: visualUpdate true
      *  description: The alignment of the label's content along the X axis.
      */
-    public void setHorizontalAlignment(int alignment) {
-        if (alignment == horizontalAlignment) return;
-        int oldValue = horizontalAlignment;
-        horizontalAlignment = checkHorizontalKey(alignment,
-                                                 "horizontalAlignment");
-        firePropertyChange("horizontalAlignment",
-                           oldValue, horizontalAlignment);
-        repaint();
-    }
+    public void setHorizontalAlignment(int alignment) {throw new RuntimeException("cf-bug");} //{
+//        if (alignment == horizontalAlignment) return;
+//        int oldValue = horizontalAlignment;
+//        horizontalAlignment = checkHorizontalKey(alignment,
+//                                                 "horizontalAlignment");
+//        firePropertyChange("horizontalAlignment",
+//                           oldValue, horizontalAlignment);
+//        repaint();
+//    }
 
 
     /**
@@ -784,9 +784,9 @@
      * @see #setVerticalTextPosition
      * @see SwingConstants
      */
-    public int getVerticalTextPosition() {
-        return verticalTextPosition;
-    }
+    public int getVerticalTextPosition() {throw new RuntimeException("cf-bug");} //{
+//        return verticalTextPosition;
+//    }
 
 
     /**
@@ -814,15 +814,15 @@
      *    attribute: visualUpdate true
      *  description: The vertical position of the text relative to it's image.
      */
-    public void setVerticalTextPosition(int textPosition) {
-        if (textPosition == verticalTextPosition) return;
-        int old = verticalTextPosition;
-        verticalTextPosition = checkVerticalKey(textPosition,
-                                                "verticalTextPosition");
-        firePropertyChange("verticalTextPosition", old, verticalTextPosition);
-        revalidate();
-        repaint();
-    }
+    public void setVerticalTextPosition(int textPosition) {throw new RuntimeException("cf-bug");} //{
+//        if (textPosition == verticalTextPosition) return;
+//        int old = verticalTextPosition;
+//        verticalTextPosition = checkVerticalKey(textPosition,
+//                                                "verticalTextPosition");
+//        firePropertyChange("verticalTextPosition", old, verticalTextPosition);
+//        revalidate();
+//        repaint();
+//    }
 
 
     /**
@@ -839,9 +839,9 @@
      *
      * @see SwingConstants
      */
-    public int getHorizontalTextPosition() {
-        return horizontalTextPosition;
-    }
+    public int getHorizontalTextPosition() {throw new RuntimeException("cf-bug");} //{
+//        return horizontalTextPosition;
+//    }
 
 
     /**
@@ -870,15 +870,15 @@
      *  description: The horizontal position of the label's text,
      *               relative to its image.
      */
-    public void setHorizontalTextPosition(int textPosition) {
-        int old = horizontalTextPosition;
-        this.horizontalTextPosition = checkHorizontalKey(textPosition,
-                                                "horizontalTextPosition");
-        firePropertyChange("horizontalTextPosition",
-                           old, horizontalTextPosition);
-        revalidate();
-        repaint();
-    }
+    public void setHorizontalTextPosition(int textPosition) {throw new RuntimeException("cf-bug");} //{
+//        int old = horizontalTextPosition;
+//        this.horizontalTextPosition = checkHorizontalKey(textPosition,
+//                                                "horizontalTextPosition");
+//        firePropertyChange("horizontalTextPosition",
+//                           old, horizontalTextPosition);
+//        revalidate();
+//        repaint();
+//    }
 
 
     /**
@@ -889,33 +889,33 @@
      * @see     java.awt.Component#imageUpdate(java.awt.Image, int, int, int, int, int)
      */
     public boolean imageUpdate(Image img, int infoflags,
-                               int x, int y, int w, int h) {
-        // Don't use getDisabledIcon, will trigger creation of icon if icon
-        // not set.
-        if (!isShowing() ||
-            !SwingUtilities.doesIconReferenceImage(getIcon(), img) &&
-            !SwingUtilities.doesIconReferenceImage(disabledIcon, img)) {
-
-            return false;
-        }
-        return super.imageUpdate(img, infoflags, x, y, w, h);
-    }
+                               int x, int y, int w, int h) {throw new RuntimeException("cf-bug");} //{
+//        // Don't use getDisabledIcon, will trigger creation of icon if icon
+//        // not set.
+//        if (!isShowing() ||
+//            !SwingUtilities.doesIconReferenceImage(getIcon(), img) &&
+//            !SwingUtilities.doesIconReferenceImage(disabledIcon, img)) {
+//
+//            return false;
+//        }
+//        return super.imageUpdate(img, infoflags, x, y, w, h);
+//    }
 
 
     /**
      * See readObject() and writeObject() in JComponent for more
      * information about serialization in Swing.
      */
-    private void writeObject(ObjectOutputStream s) throws IOException {
-        s.defaultWriteObject();
-        if (getUIClassID().equals(uiClassID)) {
-            byte count = JComponent.getWriteObjCounter(this);
-            JComponent.setWriteObjCounter(this, --count);
-            if (count == 0 && ui != null) {
-                ui.installUI(this);
-            }
-        }
-    }
+    private void writeObject(ObjectOutputStream s) throws IOException {throw new RuntimeException("cf-bug");} //{
+//        s.defaultWriteObject();
+//        if (getUIClassID().equals(uiClassID)) {
+//            byte count = JComponent.getWriteObjCounter(this);
+//            JComponent.setWriteObjCounter(this, --count);
+//            if (count == 0 && ui != null) {
+//                ui.installUI(this);
+//            }
+//        }
+//    }
 
 
     /**
@@ -927,69 +927,69 @@
      *
      * @return  a string representation of this JLabel.
      */
-    protected String paramString() {
-        String textString = (text != null ?
-                             text : "");
-        String defaultIconString = ((defaultIcon != null)
-                                    && (defaultIcon != this)  ?
-                                    defaultIcon.toString() : "");
-        String disabledIconString = ((disabledIcon != null)
-                                     && (disabledIcon != this) ?
-                                     disabledIcon.toString() : "");
-        String labelForString = (labelFor  != null ?
-                                 labelFor.toString() : "");
-        String verticalAlignmentString;
-        if (verticalAlignment == TOP) {
-            verticalAlignmentString = "TOP";
-        } else if (verticalAlignment == CENTER) {
-            verticalAlignmentString = "CENTER";
-        } else if (verticalAlignment == BOTTOM) {
-            verticalAlignmentString = "BOTTOM";
-        } else verticalAlignmentString = "";
-        String horizontalAlignmentString;
-        if (horizontalAlignment == LEFT) {
-            horizontalAlignmentString = "LEFT";
-        } else if (horizontalAlignment == CENTER) {
-            horizontalAlignmentString = "CENTER";
-        } else if (horizontalAlignment == RIGHT) {
-            horizontalAlignmentString = "RIGHT";
-        } else if (horizontalAlignment == LEADING) {
-            horizontalAlignmentString = "LEADING";
-        } else if (horizontalAlignment == TRAILING) {
-            horizontalAlignmentString = "TRAILING";
-        } else horizontalAlignmentString = "";
-        String verticalTextPositionString;
-        if (verticalTextPosition == TOP) {
-            verticalTextPositionString = "TOP";
-        } else if (verticalTextPosition == CENTER) {
-            verticalTextPositionString = "CENTER";
-        } else if (verticalTextPosition == BOTTOM) {
-            verticalTextPositionString = "BOTTOM";
-        } else verticalTextPositionString = "";
-        String horizontalTextPositionString;
-        if (horizontalTextPosition == LEFT) {
-            horizontalTextPositionString = "LEFT";
-        } else if (horizontalTextPosition == CENTER) {
-            horizontalTextPositionString = "CENTER";
-        } else if (horizontalTextPosition == RIGHT) {
-            horizontalTextPositionString = "RIGHT";
-        } else if (horizontalTextPosition == LEADING) {
-            horizontalTextPositionString = "LEADING";
-        } else if (horizontalTextPosition == TRAILING) {
-            horizontalTextPositionString = "TRAILING";
-        } else horizontalTextPositionString = "";
-
-        return super.paramString() +
-        ",defaultIcon=" + defaultIconString +
-        ",disabledIcon=" + disabledIconString +
-        ",horizontalAlignment=" + horizontalAlignmentString +
-        ",horizontalTextPosition=" + horizontalTextPositionString +
-        ",iconTextGap=" + iconTextGap +
-        ",labelFor=" + labelForString +
-        ",text=" + textString +
-        ",verticalAlignment=" + verticalAlignmentString +
-        ",verticalTextPosition=" + verticalTextPositionString;
-    }
+    protected String paramString() {throw new RuntimeException("cf-bug");} //{
+//        String textString = (text != null ?
+//                             text : "");
+//        String defaultIconString = ((defaultIcon != null)
+//                                    && (defaultIcon != this)  ?
+//                                    defaultIcon.toString() : "");
+//        String disabledIconString = ((disabledIcon != null)
+//                                     && (disabledIcon != this) ?
+//                                     disabledIcon.toString() : "");
+//        String labelForString = (labelFor  != null ?
+//                                 labelFor.toString() : "");
+//        String verticalAlignmentString;
+//        if (verticalAlignment == TOP) {
+//            verticalAlignmentString = "TOP";
+//        } else if (verticalAlignment == CENTER) {
+//            verticalAlignmentString = "CENTER";
+//        } else if (verticalAlignment == BOTTOM) {
+//            verticalAlignmentString = "BOTTOM";
+//        } else verticalAlignmentString = "";
+//        String horizontalAlignmentString;
+//        if (horizontalAlignment == LEFT) {
+//            horizontalAlignmentString = "LEFT";
+//        } else if (horizontalAlignment == CENTER) {
+//            horizontalAlignmentString = "CENTER";
+//        } else if (horizontalAlignment == RIGHT) {
+//            horizontalAlignmentString = "RIGHT";
+//        } else if (horizontalAlignment == LEADING) {
+//            horizontalAlignmentString = "LEADING";
+//        } else if (horizontalAlignment == TRAILING) {
+//            horizontalAlignmentString = "TRAILING";
+//        } else horizontalAlignmentString = "";
+//        String verticalTextPositionString;
+//        if (verticalTextPosition == TOP) {
+//            verticalTextPositionString = "TOP";
+//        } else if (verticalTextPosition == CENTER) {
+//            verticalTextPositionString = "CENTER";
+//        } else if (verticalTextPosition == BOTTOM) {
+//            verticalTextPositionString = "BOTTOM";
+//        } else verticalTextPositionString = "";
+//        String horizontalTextPositionString;
+//        if (horizontalTextPosition == LEFT) {
+//            horizontalTextPositionString = "LEFT";
+//        } else if (horizontalTextPosition == CENTER) {
+//            horizontalTextPositionString = "CENTER";
+//        } else if (horizontalTextPosition == RIGHT) {
+//            horizontalTextPositionString = "RIGHT";
+//        } else if (horizontalTextPosition == LEADING) {
+//            horizontalTextPositionString = "LEADING";
+//        } else if (horizontalTextPosition == TRAILING) {
+//            horizontalTextPositionString = "TRAILING";
+//        } else horizontalTextPositionString = "";
+//
+//        return super.paramString() +
+//        ",defaultIcon=" + defaultIconString +
+//        ",disabledIcon=" + disabledIconString +
+//        ",horizontalAlignment=" + horizontalAlignmentString +
+//        ",horizontalTextPosition=" + horizontalTextPositionString +
+//        ",iconTextGap=" + iconTextGap +
+//        ",labelFor=" + labelForString +
+//        ",text=" + textString +
+//        ",verticalAlignment=" + verticalAlignmentString +
+//        ",verticalTextPosition=" + verticalTextPositionString;
+//    }
 
     /**
      * --- Accessibility Support ---
@@ -1007,9 +1007,9 @@
      * @see #getDisplayedMnemonic
      * @see #setDisplayedMnemonic
      */
-    public Component getLabelFor() {
-        return labelFor;
-    }
+    public Component getLabelFor() {throw new RuntimeException("cf-bug");} //{
+//        return labelFor;
+//    }
 
     /**
      * Set the component this is labelling.  Can be null if this does not
@@ -1028,18 +1028,18 @@
      *        bound: true
      *  description: The component this is labelling.
      */
-    public void setLabelFor(Component c) {
-        Component oldC = labelFor;
-        labelFor = c;
-        firePropertyChange("labelFor", oldC, c);
-
-        if (oldC instanceof JComponent) {
-            ((JComponent)oldC).putClientProperty(LABELED_BY_PROPERTY, null);
-        }
-        if (c instanceof JComponent) {
-            ((JComponent)c).putClientProperty(LABELED_BY_PROPERTY, this);
-        }
-    }
+    public void setLabelFor(Component c) {throw new RuntimeException("cf-bug");} //{
+//        Component oldC = labelFor;
+//        labelFor = c;
+//        firePropertyChange("labelFor", oldC, c);
+//
+//        if (oldC instanceof JComponent) {
+//            ((JComponent)oldC).putClientProperty(LABELED_BY_PROPERTY, null);
+//        }
+//        if (c instanceof JComponent) {
+//            ((JComponent)c).putClientProperty(LABELED_BY_PROPERTY, this);
+//        }
+//    }
 
     /**
      * Get the AccessibleContext of this object
@@ -1049,12 +1049,12 @@
      *       expert: true
      *  description: The AccessibleContext associated with this Label.
      */
-    public AccessibleContext getAccessibleContext() {
-        if (accessibleContext == null) {
-            accessibleContext = new AccessibleJLabel();
-        }
-        return accessibleContext;
-    }
+    public AccessibleContext getAccessibleContext() {throw new RuntimeException("cf-bug");} //{
+//        if (accessibleContext == null) {
+//            accessibleContext = new AccessibleJLabel();
+//        }
+//        return accessibleContext;
+//    }
 
     /**
      * The class used to obtain the accessible role for this object.
@@ -1079,20 +1079,20 @@
          * object does not have a name
          * @see AccessibleContext#setAccessibleName
          */
-        public String getAccessibleName() {
-            String name = accessibleName;
-
-            if (name == null) {
-                name = (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);
-            }
-            if (name == null) {
-                name = JLabel.this.getText();
-            }
-            if (name == null) {
-                name = super.getAccessibleName();
-            }
-            return name;
-        }
+        public String getAccessibleName() {throw new RuntimeException("cf-bug");} //{
+//            String name = accessibleName;
+//
+//            if (name == null) {
+//                name = (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);
+//            }
+//            if (name == null) {
+//                name = JLabel.this.getText();
+//            }
+//            if (name == null) {
+//                name = super.getAccessibleName();
+//            }
+//            return name;
+//        }
 
         /**
          * Get the role of this object.
@@ -1101,26 +1101,26 @@
          * object
          * @see AccessibleRole
          */
-        public AccessibleRole getAccessibleRole() {
-            return AccessibleRole.LABEL;
-        }
+        public AccessibleRole getAccessibleRole() {throw new RuntimeException("cf-bug");} //{
+//            return AccessibleRole.LABEL;
+//        }
 
         /**
          * Get the AccessibleIcons associated with this object if one
          * or more exist.  Otherwise return null.
          * @since 1.3
          */
-        public AccessibleIcon [] getAccessibleIcon() {
-            Icon icon = getIcon();
-            if (icon instanceof Accessible) {
-                AccessibleContext ac =
-                ((Accessible)icon).getAccessibleContext();
-                if (ac != null && ac instanceof AccessibleIcon) {
-                    return new AccessibleIcon[] { (AccessibleIcon)ac };
-                }
-            }
-            return null;
-        }
+        public AccessibleIcon [] getAccessibleIcon() {throw new RuntimeException("cf-bug");} //{
+//            Icon icon = getIcon();
+//            if (icon instanceof Accessible) {
+//                AccessibleContext ac =
+//                ((Accessible)icon).getAccessibleContext();
+//                if (ac != null && ac instanceof AccessibleIcon) {
+//                    return new AccessibleIcon[] { (AccessibleIcon)ac };
+//                }
+//            }
+//            return null;
+//        }
 
         /**
          * Get the AccessibleRelationSet associated with this object if one
@@ -1128,35 +1128,35 @@
          * @see AccessibleRelation
          * @since 1.3
          */
-        public AccessibleRelationSet getAccessibleRelationSet() {
-            // Check where the AccessibleContext's relation
-            // set already contains a LABEL_FOR relation.
-            AccessibleRelationSet relationSet
-                = super.getAccessibleRelationSet();
-
-            if (!relationSet.contains(AccessibleRelation.LABEL_FOR)) {
-                Component c = JLabel.this.getLabelFor();
-                if (c != null) {
-                    AccessibleRelation relation
-                        = new AccessibleRelation(AccessibleRelation.LABEL_FOR);
-                    relation.setTarget(c);
-                    relationSet.add(relation);
-                }
-            }
-            return relationSet;
-        }
+        public AccessibleRelationSet getAccessibleRelationSet() {throw new RuntimeException("cf-bug");} //{
+//            // Check where the AccessibleContext's relation
+//            // set already contains a LABEL_FOR relation.
+//            AccessibleRelationSet relationSet
+//                = super.getAccessibleRelationSet();
+//
+//            if (!relationSet.contains(AccessibleRelation.LABEL_FOR)) {
+//                Component c = JLabel.this.getLabelFor();
+//                if (c != null) {
+//                    AccessibleRelation relation
+//                        = new AccessibleRelation(AccessibleRelation.LABEL_FOR);
+//                    relation.setTarget(c);
+//                    relationSet.add(relation);
+//                }
+//            }
+//            return relationSet;
+//        }
 
 
         /* AccessibleText ---------- */
 
-        public AccessibleText getAccessibleText() {
-            View view = (View)JLabel.this.getClientProperty("html");
-            if (view != null) {
-                return this;
-            } else {
-                return null;
-            }
-        }
+        public AccessibleText getAccessibleText() {throw new RuntimeException("cf-bug");} //{
+//            View view = (View)JLabel.this.getClientProperty("html");
+//            if (view != null) {
+//                return this;
+//            } else {
+//                return null;
+//            }
+//        }
 
         /**
          * Given a point in local coordinates, return the zero-based index
@@ -1168,21 +1168,21 @@
          * Point is invalid returns -1.
          * @since 1.3
          */
-        public int getIndexAtPoint(Point p) {
-            View view = (View) JLabel.this.getClientProperty("html");
-            if (view != null) {
-                Rectangle r = getTextRectangle();
-                if (r == null) {
-                    return -1;
-                }
-                Rectangle2D.Float shape =
-                    new Rectangle2D.Float(r.x, r.y, r.width, r.height);
-                Position.Bias bias[] = new Position.Bias[1];
-                return view.viewToModel(p.x, p.y, shape, bias);
-            } else {
-                return -1;
-            }
-        }
+        public int getIndexAtPoint(Point p) {throw new RuntimeException("cf-bug");} //{
+//            View view = (View) JLabel.this.getClientProperty("html");
+//            if (view != null) {
+//                Rectangle r = getTextRectangle();
+//                if (r == null) {
+//                    return -1;
+//                }
+//                Rectangle2D.Float shape =
+//                    new Rectangle2D.Float(r.x, r.y, r.width, r.height);
+//                Position.Bias bias[] = new Position.Bias[1];
+//                return view.viewToModel(p.x, p.y, shape, bias);
+//            } else {
+//                return -1;
+//            }
+//        }
 
         /**
          * Returns the bounding box of the character at the given
@@ -1194,26 +1194,26 @@
          * If the index is invalid, <code>null</code> is returned.
          * @since 1.3
          */
-        public Rectangle getCharacterBounds(int i) {
-            View view = (View) JLabel.this.getClientProperty("html");
-            if (view != null) {
-                Rectangle r = getTextRectangle();
-        if (r == null) {
-            return null;
-        }
-                Rectangle2D.Float shape =
-                    new Rectangle2D.Float(r.x, r.y, r.width, r.height);
-                try {
-                    Shape charShape =
-                        view.modelToView(i, shape, Position.Bias.Forward);
-                    return charShape.getBounds();
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            } else {
-                return null;
-            }
-        }
+        public Rectangle getCharacterBounds(int i) {throw new RuntimeException("cf-bug");} //{
+//            View view = (View) JLabel.this.getClientProperty("html");
+//            if (view != null) {
+//                Rectangle r = getTextRectangle();
+//        if (r == null) {
+//            return null;
+//        }
+//                Rectangle2D.Float shape =
+//                    new Rectangle2D.Float(r.x, r.y, r.width, r.height);
+//                try {
+//                    Shape charShape =
+//                        view.modelToView(i, shape, Position.Bias.Forward);
+//                    return charShape.getBounds();
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            } else {
+//                return null;
+//            }
+//        }
 
         /**
          * Return the number of characters (valid indicies)
@@ -1221,17 +1221,17 @@
          * @return the number of characters
          * @since 1.3
          */
-        public int getCharCount() {
-            View view = (View) JLabel.this.getClientProperty("html");
-            if (view != null) {
-                Document d = view.getDocument();
-                if (d instanceof StyledDocument) {
-                    StyledDocument doc = (StyledDocument)d;
-                    return doc.getLength();
-                }
-            }
-            return accessibleContext.getAccessibleName().length();
-        }
+        public int getCharCount() {throw new RuntimeException("cf-bug");} //{
+//            View view = (View) JLabel.this.getClientProperty("html");
+//            if (view != null) {
+//                Document d = view.getDocument();
+//                if (d instanceof StyledDocument) {
+//                    StyledDocument doc = (StyledDocument)d;
+//                    return doc.getLength();
+//                }
+//            }
+//            return accessibleContext.getAccessibleName().length();
+//        }
 
         /**
          * Return the zero-based offset of the caret.
@@ -1241,10 +1241,10 @@
          * @return the zero-based offset of the caret.
          * @since 1.3
          */
-        public int getCaretPosition() {
-            // There is no caret.
-            return -1;
-        }
+        public int getCaretPosition() {throw new RuntimeException("cf-bug");} //{
+//            // There is no caret.
+//            return -1;
+//        }
 
         /**
          * Returns the String at a given index.
@@ -1256,42 +1256,42 @@
          *   null for an invalid index or part
          * @since 1.3
          */
-        public String getAtIndex(int part, int index) {
-            if (index < 0 || index >= getCharCount()) {
-                return null;
-            }
-            switch (part) {
-            case AccessibleText.CHARACTER:
-                try {
-                    return getText(index, 1);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.WORD:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
-                    words.setText(s);
-                    int end = words.following(index);
-                    return s.substring(words.previous(), end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.SENTENCE:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator sentence =
-                        BreakIterator.getSentenceInstance(getLocale());
-                    sentence.setText(s);
-                    int end = sentence.following(index);
-                    return s.substring(sentence.previous(), end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            default:
-                return null;
-            }
-        }
+        public String getAtIndex(int part, int index) {throw new RuntimeException("cf-bug");} //{
+//            if (index < 0 || index >= getCharCount()) {
+//                return null;
+//            }
+//            switch (part) {
+//            case AccessibleText.CHARACTER:
+//                try {
+//                    return getText(index, 1);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.WORD:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
+//                    words.setText(s);
+//                    int end = words.following(index);
+//                    return s.substring(words.previous(), end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.SENTENCE:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator sentence =
+//                        BreakIterator.getSentenceInstance(getLocale());
+//                    sentence.setText(s);
+//                    int end = sentence.following(index);
+//                    return s.substring(sentence.previous(), end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            default:
+//                return null;
+//            }
+//        }
 
         /**
          * Returns the String after a given index.
@@ -1303,59 +1303,59 @@
          *  index or part
          * @since 1.3
          */
-        public String getAfterIndex(int part, int index) {
-            if (index < 0 || index >= getCharCount()) {
-                return null;
-            }
-            switch (part) {
-            case AccessibleText.CHARACTER:
-                if (index+1 >= getCharCount()) {
-                   return null;
-                }
-                try {
-                    return getText(index+1, 1);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.WORD:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
-                    words.setText(s);
-                    int start = words.following(index);
-                    if (start == BreakIterator.DONE || start >= s.length()) {
-                        return null;
-                    }
-                    int end = words.following(start);
-                    if (end == BreakIterator.DONE || end >= s.length()) {
-                        return null;
-                    }
-                    return s.substring(start, end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.SENTENCE:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator sentence =
-                        BreakIterator.getSentenceInstance(getLocale());
-                    sentence.setText(s);
-                    int start = sentence.following(index);
-                    if (start == BreakIterator.DONE || start > s.length()) {
-                        return null;
-                    }
-                    int end = sentence.following(start);
-                    if (end == BreakIterator.DONE || end > s.length()) {
-                        return null;
-                    }
-                    return s.substring(start, end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            default:
-                return null;
-            }
-        }
+        public String getAfterIndex(int part, int index) {throw new RuntimeException("cf-bug");} //{
+//            if (index < 0 || index >= getCharCount()) {
+//                return null;
+//            }
+//            switch (part) {
+//            case AccessibleText.CHARACTER:
+//                if (index+1 >= getCharCount()) {
+//                   return null;
+//                }
+//                try {
+//                    return getText(index+1, 1);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.WORD:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
+//                    words.setText(s);
+//                    int start = words.following(index);
+//                    if (start == BreakIterator.DONE || start >= s.length()) {
+//                        return null;
+//                    }
+//                    int end = words.following(start);
+//                    if (end == BreakIterator.DONE || end >= s.length()) {
+//                        return null;
+//                    }
+//                    return s.substring(start, end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.SENTENCE:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator sentence =
+//                        BreakIterator.getSentenceInstance(getLocale());
+//                    sentence.setText(s);
+//                    int start = sentence.following(index);
+//                    if (start == BreakIterator.DONE || start > s.length()) {
+//                        return null;
+//                    }
+//                    int end = sentence.following(start);
+//                    if (end == BreakIterator.DONE || end > s.length()) {
+//                        return null;
+//                    }
+//                    return s.substring(start, end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            default:
+//                return null;
+//            }
+//        }
 
         /**
          * Returns the String before a given index.
@@ -1367,55 +1367,55 @@
          *  or part
          * @since 1.3
          */
-        public String getBeforeIndex(int part, int index) {
-            if (index < 0 || index > getCharCount()-1) {
-                return null;
-            }
-            switch (part) {
-            case AccessibleText.CHARACTER:
-                if (index == 0) {
-                    return null;
-                }
-                try {
-                    return getText(index-1, 1);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.WORD:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
-                    words.setText(s);
-                    int end = words.following(index);
-                    end = words.previous();
-                    int start = words.previous();
-                    if (start == BreakIterator.DONE) {
-                        return null;
-                    }
-                    return s.substring(start, end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            case AccessibleText.SENTENCE:
-                try {
-                    String s = getText(0, getCharCount());
-                    BreakIterator sentence =
-                        BreakIterator.getSentenceInstance(getLocale());
-                    sentence.setText(s);
-                    int end = sentence.following(index);
-                    end = sentence.previous();
-                    int start = sentence.previous();
-                    if (start == BreakIterator.DONE) {
-                        return null;
-                    }
-                    return s.substring(start, end);
-                } catch (BadLocationException e) {
-                    return null;
-                }
-            default:
-                return null;
-            }
-        }
+        public String getBeforeIndex(int part, int index) {throw new RuntimeException("cf-bug");} //{
+//            if (index < 0 || index > getCharCount()-1) {
+//                return null;
+//            }
+//            switch (part) {
+//            case AccessibleText.CHARACTER:
+//                if (index == 0) {
+//                    return null;
+//                }
+//                try {
+//                    return getText(index-1, 1);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.WORD:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator words = BreakIterator.getWordInstance(getLocale());
+//                    words.setText(s);
+//                    int end = words.following(index);
+//                    end = words.previous();
+//                    int start = words.previous();
+//                    if (start == BreakIterator.DONE) {
+//                        return null;
+//                    }
+//                    return s.substring(start, end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            case AccessibleText.SENTENCE:
+//                try {
+//                    String s = getText(0, getCharCount());
+//                    BreakIterator sentence =
+//                        BreakIterator.getSentenceInstance(getLocale());
+//                    sentence.setText(s);
+//                    int end = sentence.following(index);
+//                    end = sentence.previous();
+//                    int start = sentence.previous();
+//                    if (start == BreakIterator.DONE) {
+//                        return null;
+//                    }
+//                    return s.substring(start, end);
+//                } catch (BadLocationException e) {
+//                    return null;
+//                }
+//            default:
+//                return null;
+//            }
+//        }
 
         /**
          * Return the AttributeSet for a given character at a given index
@@ -1424,20 +1424,20 @@
          * @return the AttributeSet of the character
          * @since 1.3
          */
-        public AttributeSet getCharacterAttribute(int i) {
-            View view = (View) JLabel.this.getClientProperty("html");
-            if (view != null) {
-                Document d = view.getDocument();
-                if (d instanceof StyledDocument) {
-                    StyledDocument doc = (StyledDocument)d;
-                    Element elem = doc.getCharacterElement(i);
-                    if (elem != null) {
-                        return elem.getAttributes();
-                    }
-                }
-            }
-            return null;
-        }
+        public AttributeSet getCharacterAttribute(int i) {throw new RuntimeException("cf-bug");} //{
+//            View view = (View) JLabel.this.getClientProperty("html");
+//            if (view != null) {
+//                Document d = view.getDocument();
+//                if (d instanceof StyledDocument) {
+//                    StyledDocument doc = (StyledDocument)d;
+//                    Element elem = doc.getCharacterElement(i);
+//                    if (elem != null) {
+//                        return elem.getAttributes();
+//                    }
+//                }
+//            }
+//            return null;
+//        }
 
         /**
          * Returns the start offset within the selected text.
@@ -1447,10 +1447,10 @@
          * @return the index into the text of the start of the selection
          * @since 1.3
          */
-        public int getSelectionStart() {
-            // Text cannot be selected.
-            return -1;
-        }
+        public int getSelectionStart() {throw new RuntimeException("cf-bug");} //{
+//            // Text cannot be selected.
+//            return -1;
+//        }
 
         /**
          * Returns the end offset within the selected text.
@@ -1460,10 +1460,10 @@
          * @return the index into the text of the end of the selection
          * @since 1.3
          */
-        public int getSelectionEnd() {
-            // Text cannot be selected.
-            return -1;
-        }
+        public int getSelectionEnd() {throw new RuntimeException("cf-bug");} //{
+//            // Text cannot be selected.
+//            return -1;
+//        }
 
         /**
          * Returns the portion of the text that is selected.
@@ -1471,68 +1471,68 @@
          * @return the String portion of the text that is selected
          * @since 1.3
          */
-        public String getSelectedText() {
-            // Text cannot be selected.
-            return null;
-        }
+        public String getSelectedText() {throw new RuntimeException("cf-bug");} //{
+//            // Text cannot be selected.
+//            return null;
+//        }
 
         /*
          * Returns the text substring starting at the specified
          * offset with the specified length.
          */
         private String getText(int offset, int length)
-            throws BadLocationException {
-
-            View view = (View) JLabel.this.getClientProperty("html");
-            if (view != null) {
-                Document d = view.getDocument();
-                if (d instanceof StyledDocument) {
-                    StyledDocument doc = (StyledDocument)d;
-                    return doc.getText(offset, length);
-                }
-            }
-            return null;
-        }
+            throws BadLocationException {throw new RuntimeException("cf-bug");} //{
+//
+//            View view = (View) JLabel.this.getClientProperty("html");
+//            if (view != null) {
+//                Document d = view.getDocument();
+//                if (d instanceof StyledDocument) {
+//                    StyledDocument doc = (StyledDocument)d;
+//                    return doc.getText(offset, length);
+//                }
+//            }
+//            return null;
+//        }
 
         /*
          * Returns the bounding rectangle for the component text.
          */
-        private Rectangle getTextRectangle() {
-
-            String text = JLabel.this.getText();
-            Icon icon = (JLabel.this.isEnabled()) ? JLabel.this.getIcon() : JLabel.this.getDisabledIcon();
-
-            if ((icon == null) && (text == null)) {
-                return null;
-            }
-
-            Rectangle paintIconR = new Rectangle();
-            Rectangle paintTextR = new Rectangle();
-            Rectangle paintViewR = new Rectangle();
-            Insets paintViewInsets = new Insets(0, 0, 0, 0);
-
-            paintViewInsets = JLabel.this.getInsets(paintViewInsets);
-            paintViewR.x = paintViewInsets.left;
-            paintViewR.y = paintViewInsets.top;
-            paintViewR.width = JLabel.this.getWidth() - (paintViewInsets.left + paintViewInsets.right);
-            paintViewR.height = JLabel.this.getHeight() - (paintViewInsets.top + paintViewInsets.bottom);
-
-            String clippedText = SwingUtilities.layoutCompoundLabel(
-                (JComponent)JLabel.this,
-                getFontMetrics(getFont()),
-                text,
-                icon,
-                JLabel.this.getVerticalAlignment(),
-                JLabel.this.getHorizontalAlignment(),
-                JLabel.this.getVerticalTextPosition(),
-                JLabel.this.getHorizontalTextPosition(),
-                paintViewR,
-                paintIconR,
-                paintTextR,
-                JLabel.this.getIconTextGap());
-
-            return paintTextR;
-        }
+        private Rectangle getTextRectangle() {throw new RuntimeException("cf-bug");} //{
+//
+//            String text = JLabel.this.getText();
+//            Icon icon = (JLabel.this.isEnabled()) ? JLabel.this.getIcon() : JLabel.this.getDisabledIcon();
+//
+//            if ((icon == null) && (text == null)) {
+//                return null;
+//            }
+//
+//            Rectangle paintIconR = new Rectangle();
+//            Rectangle paintTextR = new Rectangle();
+//            Rectangle paintViewR = new Rectangle();
+//            Insets paintViewInsets = new Insets(0, 0, 0, 0);
+//
+//            paintViewInsets = JLabel.this.getInsets(paintViewInsets);
+//            paintViewR.x = paintViewInsets.left;
+//            paintViewR.y = paintViewInsets.top;
+//            paintViewR.width = JLabel.this.getWidth() - (paintViewInsets.left + paintViewInsets.right);
+//            paintViewR.height = JLabel.this.getHeight() - (paintViewInsets.top + paintViewInsets.bottom);
+//
+//            String clippedText = SwingUtilities.layoutCompoundLabel(
+//                (JComponent)JLabel.this,
+//                getFontMetrics(getFont()),
+//                text,
+//                icon,
+//                JLabel.this.getVerticalAlignment(),
+//                JLabel.this.getHorizontalAlignment(),
+//                JLabel.this.getVerticalTextPosition(),
+//                JLabel.this.getHorizontalTextPosition(),
+//                paintViewR,
+//                paintIconR,
+//                paintTextR,
+//                JLabel.this.getIconTextGap());
+//
+//            return paintTextR;
+//        }
 
         // ----- AccessibleExtendedComponent
 
@@ -1541,9 +1541,9 @@
          *
          * @return the AccessibleExtendedComponent
          */
-        AccessibleExtendedComponent getAccessibleExtendedComponent() {
-            return this;
-        }
+        AccessibleExtendedComponent getAccessibleExtendedComponent() {throw new RuntimeException("cf-bug");} //{
+//            return this;
+//        }
 
         /**
          * Returns the tool tip text
@@ -1552,9 +1552,9 @@
          * otherwise, null
          * @since 1.4
          */
-        public String getToolTipText() {
-            return JLabel.this.getToolTipText();
-        }
+        public String getToolTipText() {throw new RuntimeException("cf-bug");} //{
+//            return JLabel.this.getToolTipText();
+//        }
 
         /**
          * Returns the titled border text
@@ -1563,9 +1563,9 @@
          * otherwise, null
          * @since 1.4
          */
-        public String getTitledBorderText() {
-            return super.getTitledBorderText();
-        }
+        public String getTitledBorderText() {throw new RuntimeException("cf-bug");} //{
+//            return super.getTitledBorderText();
+//        }
 
         /**
          * Returns key bindings associated with this object
@@ -1575,13 +1575,13 @@
          * @see AccessibleKeyBinding
          * @since 1.4
          */
-        public AccessibleKeyBinding getAccessibleKeyBinding() {
-            int mnemonic = JLabel.this.getDisplayedMnemonic();
-            if (mnemonic == 0) {
-                return null;
-            }
-            return new LabelKeyBinding(mnemonic);
-        }
+        public AccessibleKeyBinding getAccessibleKeyBinding() {throw new RuntimeException("cf-bug");} //{
+//            int mnemonic = JLabel.this.getDisplayedMnemonic();
+//            if (mnemonic == 0) {
+//                return null;
+//            }
+//            return new LabelKeyBinding(mnemonic);
+//        }
 
         class LabelKeyBinding implements AccessibleKeyBinding {
             int mnemonic;
@@ -1595,9 +1595,9 @@
              *
              * @return the zero-based number of key bindings for this object
              */
-            public int getAccessibleKeyBindingCount() {
-                return 1;
-            }
+            public int getAccessibleKeyBindingCount() {throw new RuntimeException("cf-bug");} //{
+//                return 1;
+//            }
 
             /**
              * Returns a key binding for this object.  The value returned is an
@@ -1624,12 +1624,12 @@
              * out of bounds
              * @see #getAccessibleKeyBindingCount
              */
-            public java.lang.Object getAccessibleKeyBinding(int i) {
-                if (i != 0) {
-                    throw new IllegalArgumentException();
-                }
-                return KeyStroke.getKeyStroke(mnemonic, 0);
-            }
+            public java.lang.Object getAccessibleKeyBinding(int i) {throw new RuntimeException("cf-bug");} //{
+//                if (i != 0) {
+//                    throw new IllegalArgumentException();
+//                }
+//                return KeyStroke.getKeyStroke(mnemonic, 0);
+//            }
         }
 
     }  // AccessibleJComponent
--- javax/swing/SwingWorker.java	2016-06-22 19:55:11.259848517 -0700
+++ javax/swing/SwingWorker.java	2016-06-29 12:24:32.788416485 -0700
@@ -330,9 +330,9 @@
      * Sets this {@code Future} to the result of computation unless
      * it has been cancelled.
      */
-    public final void run() {
-        future.run();
-    }
+    public final void run() {throw new RuntimeException("cf-bug");} //{
+//        future.run();
+//    }
 
     /**
      * Sends data chunks to the {@link #process} method. This method is to be
@@ -405,23 +405,23 @@
      */
     @SafeVarargs
     @SuppressWarnings("varargs") // Passing chunks to add is safe
-    protected final void publish(V... chunks) {
-        synchronized (this) {
-            if (doProcess == null) {
-                doProcess = new AccumulativeRunnable<V>() {
-                    @Override
-                    public void run(List<V> args) {
-                        process(args);
-                    }
-                    @Override
-                    protected void submit() {
-                        doSubmit.add(this);
-                    }
-                };
-            }
-        }
-        doProcess.add(chunks);
-    }
+    protected final void publish(V... chunks) {throw new RuntimeException("cf-bug");} //{
+//        synchronized (this) {
+//            if (doProcess == null) {
+//                doProcess = new AccumulativeRunnable<V>() {
+//                    @Override
+//                    public void run(List<V> args) {
+//                        process(args);
+//                    }
+//                    @Override
+//                    protected void submit() {
+//                        doSubmit.add(this);
+//                    }
+//                };
+//            }
+//        }
+//        doProcess.add(chunks);
+//    }
 
     /**
      * Receives data chunks from the {@code publish} method asynchronously on the
@@ -480,46 +480,46 @@
      * @param progress the progress value to set
      * @throws IllegalArgumentException is value not from 0 to 100
      */
-    protected final void setProgress(int progress) {
-        if (progress < 0 || progress > 100) {
-            throw new IllegalArgumentException("the value should be from 0 to 100");
-        }
-        if (this.progress == progress) {
-            return;
-        }
-        int oldProgress = this.progress;
-        this.progress = progress;
-        if (! getPropertyChangeSupport().hasListeners("progress")) {
-            return;
-        }
-        synchronized (this) {
-            if (doNotifyProgressChange == null) {
-                doNotifyProgressChange =
-                    new AccumulativeRunnable<Integer>() {
-                        @Override
-                        public void run(List<Integer> args) {
-                            firePropertyChange("progress",
-                               args.get(0),
-                               args.get(args.size() - 1));
-                        }
-                        @Override
-                        protected void submit() {
-                            doSubmit.add(this);
-                        }
-                    };
-            }
-        }
-        doNotifyProgressChange.add(oldProgress, progress);
-    }
+    protected final void setProgress(int progress) {throw new RuntimeException("cf-bug");} //{
+//        if (progress < 0 || progress > 100) {
+//            throw new IllegalArgumentException("the value should be from 0 to 100");
+//        }
+//        if (this.progress == progress) {
+//            return;
+//        }
+//        int oldProgress = this.progress;
+//        this.progress = progress;
+//        if (! getPropertyChangeSupport().hasListeners("progress")) {
+//            return;
+//        }
+//        synchronized (this) {
+//            if (doNotifyProgressChange == null) {
+//                doNotifyProgressChange =
+//                    new AccumulativeRunnable<Integer>() {
+//                        @Override
+//                        public void run(List<Integer> args) {
+//                            firePropertyChange("progress",
+//                               args.get(0),
+//                               args.get(args.size() - 1));
+//                        }
+//                        @Override
+//                        protected void submit() {
+//                            doSubmit.add(this);
+//                        }
+//                    };
+//            }
+//        }
+//        doNotifyProgressChange.add(oldProgress, progress);
+//    }
 
     /**
      * Returns the {@code progress} bound property.
      *
      * @return the progress bound property.
      */
-    public final int getProgress() {
-        return progress;
-    }
+    public final int getProgress() {throw new RuntimeException("cf-bug");} //{
+//        return progress;
+//    }
 
     /**
      * Schedules this {@code SwingWorker} for execution on a <i>worker</i>
@@ -534,31 +534,31 @@
      * {@code SwingWorker} more than once will not result in invoking the
      * {@code doInBackground} method twice.
      */
-    public final void execute() {
-        getWorkersExecutorService().execute(this);
-    }
+    public final void execute() {throw new RuntimeException("cf-bug");} //{
+//        getWorkersExecutorService().execute(this);
+//    }
 
     // Future methods START
     /**
      * {@inheritDoc}
      */
-    public final boolean cancel(boolean mayInterruptIfRunning) {
-        return future.cancel(mayInterruptIfRunning);
-    }
+    public final boolean cancel(boolean mayInterruptIfRunning) {throw new RuntimeException("cf-bug");} //{
+//        return future.cancel(mayInterruptIfRunning);
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public final boolean isCancelled() {
-        return future.isCancelled();
-    }
+    public final boolean isCancelled() {throw new RuntimeException("cf-bug");} //{
+//        return future.isCancelled();
+//    }
 
     /**
      * {@inheritDoc}
      */
-    public final boolean isDone() {
-        return future.isDone();
-    }
+    public final boolean isDone() {throw new RuntimeException("cf-bug");} //{
+//        return future.isDone();
+//    }
 
     /**
      * {@inheritDoc}
@@ -598,9 +598,9 @@
      * dialog.setVisible(true);
      * </pre>
      */
-    public final T get() throws InterruptedException, ExecutionException {
-        return future.get();
-    }
+    public final T get() throws InterruptedException, ExecutionException {throw new RuntimeException("cf-bug");} //{
+//        return future.get();
+//    }
 
     /**
      * {@inheritDoc}
@@ -608,9 +608,9 @@
      * Please refer to {@link #get} for more details.
      */
     public final T get(long timeout, TimeUnit unit) throws InterruptedException,
-            ExecutionException, TimeoutException {
-        return future.get(timeout, unit);
-    }
+            ExecutionException, TimeoutException {throw new RuntimeException("cf-bug");} //{
+//        return future.get(timeout, unit);
+//    }
 
     // Future methods END
 
@@ -627,9 +627,9 @@
      *
      * @param listener the {@code PropertyChangeListener} to be added
      */
-    public final void addPropertyChangeListener(PropertyChangeListener listener) {
-        getPropertyChangeSupport().addPropertyChangeListener(listener);
-    }
+    public final void addPropertyChangeListener(PropertyChangeListener listener) {throw new RuntimeException("cf-bug");} //{
+//        getPropertyChangeSupport().addPropertyChangeListener(listener);
+//    }
 
     /**
      * Removes a {@code PropertyChangeListener} from the listener list. This
@@ -645,9 +645,9 @@
      *
      * @param listener the {@code PropertyChangeListener} to be removed
      */
-    public final void removePropertyChangeListener(PropertyChangeListener listener) {
-        getPropertyChangeSupport().removePropertyChangeListener(listener);
-    }
+    public final void removePropertyChangeListener(PropertyChangeListener listener) {throw new RuntimeException("cf-bug");} //{
+//        getPropertyChangeSupport().removePropertyChangeListener(listener);
+//    }
 
     /**
      * Reports a bound property update to any registered listeners. No event is
@@ -672,10 +672,10 @@
      * @param newValue the new value of the property
      */
     public final void firePropertyChange(String propertyName, Object oldValue,
-            Object newValue) {
-        getPropertyChangeSupport().firePropertyChange(propertyName,
-            oldValue, newValue);
-    }
+            Object newValue) {throw new RuntimeException("cf-bug");} //{
+//        getPropertyChangeSupport().firePropertyChange(propertyName,
+//            oldValue, newValue);
+//    }
 
     /**
      * Returns the {@code PropertyChangeSupport} for this {@code SwingWorker}.
@@ -694,9 +694,9 @@
      *
      * @return {@code PropertyChangeSupport} for this {@code SwingWorker}
      */
-    public final PropertyChangeSupport getPropertyChangeSupport() {
-        return propertyChangeSupport;
-    }
+    public final PropertyChangeSupport getPropertyChangeSupport() {throw new RuntimeException("cf-bug");} //{
+//        return propertyChangeSupport;
+//    }
 
     // PropertyChangeSupports methods END
 
@@ -705,44 +705,44 @@
      *
      * @return the current state
      */
-    public final StateValue getState() {
-        /*
-         * DONE is a speacial case
-         * to keep getState and isDone is sync
-         */
-        if (isDone()) {
-            return StateValue.DONE;
-        } else {
-            return state;
-        }
-    }
+    public final StateValue getState() {throw new RuntimeException("cf-bug");} //{
+//        /*
+//         * DONE is a speacial case
+//         * to keep getState and isDone is sync
+//         */
+//        if (isDone()) {
+//            return StateValue.DONE;
+//        } else {
+//            return state;
+//        }
+//    }
 
     /**
      * Sets this {@code SwingWorker} state bound property.
      * @param state the state to set
      */
-    private void setState(StateValue state) {
-        StateValue old = this.state;
-        this.state = state;
-        firePropertyChange("state", old, state);
-    }
+    private void setState(StateValue state) {throw new RuntimeException("cf-bug");} //{
+//        StateValue old = this.state;
+//        this.state = state;
+//        firePropertyChange("state", old, state);
+//    }
 
     /**
      * Invokes {@code done} on the EDT.
      */
-    private void doneEDT() {
-        Runnable doDone =
-            new Runnable() {
-                public void run() {
-                    done();
-                }
-            };
-        if (SwingUtilities.isEventDispatchThread()) {
-            doDone.run();
-        } else {
-            doSubmit.add(doDone);
-        }
-    }
+    private void doneEDT() {throw new RuntimeException("cf-bug");} //{
+//        Runnable doDone =
+//            new Runnable() {
+//                public void run() {
+//                    done();
+//                }
+//            };
+//        if (SwingUtilities.isEventDispatchThread()) {
+//            doDone.run();
+//        } else {
+//            doSubmit.add(doDone);
+//        }
+//    }
 
 
     /**
@@ -753,94 +753,94 @@
      *
      * @return ExecutorService for the {@code SwingWorkers}
      */
-    private static synchronized ExecutorService getWorkersExecutorService() {
-        final AppContext appContext = AppContext.getAppContext();
-        ExecutorService executorService =
-            (ExecutorService) appContext.get(SwingWorker.class);
-        if (executorService == null) {
-            //this creates daemon threads.
-            ThreadFactory threadFactory =
-                new ThreadFactory() {
-                    final ThreadFactory defaultFactory =
-                        Executors.defaultThreadFactory();
-                    public Thread newThread(final Runnable r) {
-                        Thread thread =
-                            defaultFactory.newThread(r);
-                        thread.setName("SwingWorker-"
-                            + thread.getName());
-                        thread.setDaemon(true);
-                        return thread;
-                    }
-                };
-
-            executorService =
-                new ThreadPoolExecutor(MAX_WORKER_THREADS, MAX_WORKER_THREADS,
-                                       10L, TimeUnit.MINUTES,
-                                       new LinkedBlockingQueue<Runnable>(),
-                                       threadFactory);
-            appContext.put(SwingWorker.class, executorService);
-
-            // Don't use ShutdownHook here as it's not enough. We should track
-            // AppContext disposal instead of JVM shutdown, see 6799345 for details
-            final ExecutorService es = executorService;
-            appContext.addPropertyChangeListener(AppContext.DISPOSED_PROPERTY_NAME,
-                new PropertyChangeListener() {
-                    @Override
-                    public void propertyChange(PropertyChangeEvent pce) {
-                        boolean disposed = (Boolean)pce.getNewValue();
-                        if (disposed) {
-                            final WeakReference<ExecutorService> executorServiceRef =
-                                new WeakReference<ExecutorService>(es);
-                            final ExecutorService executorService =
-                                executorServiceRef.get();
-                            if (executorService != null) {
-                                AccessController.doPrivileged(
-                                    new PrivilegedAction<Void>() {
-                                        public Void run() {
-                                            executorService.shutdown();
-                                            return null;
-                                        }
-                                    }
-                                );
-                            }
-                        }
-                    }
-                }
-            );
-        }
-        return executorService;
-    }
+    private static synchronized ExecutorService getWorkersExecutorService() {throw new RuntimeException("cf-bug");} //{
+//        final AppContext appContext = AppContext.getAppContext();
+//        ExecutorService executorService =
+//            (ExecutorService) appContext.get(SwingWorker.class);
+//        if (executorService == null) {
+//            //this creates daemon threads.
+//            ThreadFactory threadFactory =
+//                new ThreadFactory() {
+//                    final ThreadFactory defaultFactory =
+//                        Executors.defaultThreadFactory();
+//                    public Thread newThread(final Runnable r) {
+//                        Thread thread =
+//                            defaultFactory.newThread(r);
+//                        thread.setName("SwingWorker-"
+//                            + thread.getName());
+//                        thread.setDaemon(true);
+//                        return thread;
+//                    }
+//                };
+//
+//            executorService =
+//                new ThreadPoolExecutor(MAX_WORKER_THREADS, MAX_WORKER_THREADS,
+//                                       10L, TimeUnit.MINUTES,
+//                                       new LinkedBlockingQueue<Runnable>(),
+//                                       threadFactory);
+//            appContext.put(SwingWorker.class, executorService);
+//
+//            // Don't use ShutdownHook here as it's not enough. We should track
+//            // AppContext disposal instead of JVM shutdown, see 6799345 for details
+//            final ExecutorService es = executorService;
+//            appContext.addPropertyChangeListener(AppContext.DISPOSED_PROPERTY_NAME,
+//                new PropertyChangeListener() {
+//                    @Override
+//                    public void propertyChange(PropertyChangeEvent pce) {
+//                        boolean disposed = (Boolean)pce.getNewValue();
+//                        if (disposed) {
+//                            final WeakReference<ExecutorService> executorServiceRef =
+//                                new WeakReference<ExecutorService>(es);
+//                            final ExecutorService executorService =
+//                                executorServiceRef.get();
+//                            if (executorService != null) {
+//                                AccessController.doPrivileged(
+//                                    new PrivilegedAction<Void>() {
+//                                        public Void run() {
+//                                            executorService.shutdown();
+//                                            return null;
+//                                        }
+//                                    }
+//                                );
+//                            }
+//                        }
+//                    }
+//                }
+//            );
+//        }
+//        return executorService;
+//    }
 
     private static final Object DO_SUBMIT_KEY = new StringBuilder("doSubmit");
-    private static AccumulativeRunnable<Runnable> getDoSubmit() {
-        synchronized (DO_SUBMIT_KEY) {
-            final AppContext appContext = AppContext.getAppContext();
-            Object doSubmit = appContext.get(DO_SUBMIT_KEY);
-            if (doSubmit == null) {
-                doSubmit = new DoSubmitAccumulativeRunnable();
-                appContext.put(DO_SUBMIT_KEY, doSubmit);
-            }
-            return (AccumulativeRunnable<Runnable>) doSubmit;
-        }
-    }
+    private static AccumulativeRunnable<Runnable> getDoSubmit() {throw new RuntimeException("cf-bug");} //{
+//        synchronized (DO_SUBMIT_KEY) {
+//            final AppContext appContext = AppContext.getAppContext();
+//            Object doSubmit = appContext.get(DO_SUBMIT_KEY);
+//            if (doSubmit == null) {
+//                doSubmit = new DoSubmitAccumulativeRunnable();
+//                appContext.put(DO_SUBMIT_KEY, doSubmit);
+//            }
+//            return (AccumulativeRunnable<Runnable>) doSubmit;
+//        }
+//    }
     private static class DoSubmitAccumulativeRunnable
           extends AccumulativeRunnable<Runnable> implements ActionListener {
         private final static int DELAY = 1000 / 30;
         @Override
-        protected void run(List<Runnable> args) {
-            for (Runnable runnable : args) {
-                runnable.run();
-            }
-        }
+        protected void run(List<Runnable> args) {throw new RuntimeException("cf-bug");} //{
+//            for (Runnable runnable : args) {
+//                runnable.run();
+//            }
+//        }
         @Override
-        protected void submit() {
-            Timer timer = new Timer(DELAY, this);
-            timer.setRepeats(false);
-            timer.start();
-        }
-        public void actionPerformed(ActionEvent event) {
-            run();
-        }
+        protected void submit() {throw new RuntimeException("cf-bug");} //{
+//            Timer timer = new Timer(DELAY, this);
+//            timer.setRepeats(false);
+//            timer.start();
+//        }
+        public void actionPerformed(ActionEvent event) {throw new RuntimeException("cf-bug");} //{
+//            run();
+//        }
     }
 
     private class SwingWorkerPropertyChangeSupport
@@ -849,18 +849,18 @@
             super(source);
         }
         @Override
-        public void firePropertyChange(final PropertyChangeEvent evt) {
-            if (SwingUtilities.isEventDispatchThread()) {
-                super.firePropertyChange(evt);
-            } else {
-                doSubmit.add(
-                    new Runnable() {
-                        public void run() {
-                            SwingWorkerPropertyChangeSupport.this
-                                .firePropertyChange(evt);
-                        }
-                    });
-            }
-        }
+        public void firePropertyChange(final PropertyChangeEvent evt) {throw new RuntimeException("cf-bug");} //{
+//            if (SwingUtilities.isEventDispatchThread()) {
+//                super.firePropertyChange(evt);
+//            } else {
+//                doSubmit.add(
+//                    new Runnable() {
+//                        public void run() {
+//                            SwingWorkerPropertyChangeSupport.this
+//                                .firePropertyChange(evt);
+//                        }
+//                    });
+//            }
+//        }
     }
 }
--- javax/swing/text/FieldView.java	2016-06-22 19:55:21.646899728 -0700
+++ javax/swing/text/FieldView.java	2016-06-29 12:35:05.474249881 -0700
@@ -57,10 +57,10 @@
      *
      * @return the metrics
      */
-    protected FontMetrics getFontMetrics() {
-        Component c = getContainer();
-        return c.getFontMetrics(c.getFont());
-    }
+    protected FontMetrics getFontMetrics() {throw new RuntimeException("cf-bug");} //{
+//        Component c = getContainer();
+//        return c.getFontMetrics(c.getFont());
+//    }
 
     /**
      * Adjusts the allocation given to the view
@@ -76,72 +76,72 @@
      *  to be adjusted.
      * @return the allocation that the superclass should use.
      */
-    protected Shape adjustAllocation(Shape a) {
-        if (a != null) {
-            Rectangle bounds = a.getBounds();
-            int vspan = (int) getPreferredSpan(Y_AXIS);
-            int hspan = (int) getPreferredSpan(X_AXIS);
-            if (bounds.height != vspan) {
-                int slop = bounds.height - vspan;
-                bounds.y += slop / 2;
-                bounds.height -= slop;
-            }
-
-            // horizontal adjustments
-            Component c = getContainer();
-            if (c instanceof JTextField) {
-                JTextField field = (JTextField) c;
-                BoundedRangeModel vis = field.getHorizontalVisibility();
-                int max = Math.max(hspan, bounds.width);
-                int value = vis.getValue();
-                int extent = Math.min(max, bounds.width - 1);
-                if ((value + extent) > max) {
-                    value = max - extent;
-                }
-                vis.setRangeProperties(value, extent, vis.getMinimum(),
-                                       max, false);
-                if (hspan < bounds.width) {
-                    // horizontally align the interior
-                    int slop = bounds.width - 1 - hspan;
-
-                    int align = ((JTextField)c).getHorizontalAlignment();
-                    if(Utilities.isLeftToRight(c)) {
-                        if(align==LEADING) {
-                            align = LEFT;
-                        }
-                        else if(align==TRAILING) {
-                            align = RIGHT;
-                        }
-                    }
-                    else {
-                        if(align==LEADING) {
-                            align = RIGHT;
-                        }
-                        else if(align==TRAILING) {
-                            align = LEFT;
-                        }
-                    }
-
-                    switch (align) {
-                    case SwingConstants.CENTER:
-                        bounds.x += slop / 2;
-                        bounds.width -= slop;
-                        break;
-                    case SwingConstants.RIGHT:
-                        bounds.x += slop;
-                        bounds.width -= slop;
-                        break;
-                    }
-                } else {
-                    // adjust the allocation to match the bounded range.
-                    bounds.width = hspan;
-                    bounds.x -= vis.getValue();
-                }
-            }
-            return bounds;
-        }
-        return null;
-    }
+    protected Shape adjustAllocation(Shape a) {throw new RuntimeException("cf-bug");} //{
+//        if (a != null) {
+//            Rectangle bounds = a.getBounds();
+//            int vspan = (int) getPreferredSpan(Y_AXIS);
+//            int hspan = (int) getPreferredSpan(X_AXIS);
+//            if (bounds.height != vspan) {
+//                int slop = bounds.height - vspan;
+//                bounds.y += slop / 2;
+//                bounds.height -= slop;
+//            }
+//
+//            // horizontal adjustments
+//            Component c = getContainer();
+//            if (c instanceof JTextField) {
+//                JTextField field = (JTextField) c;
+//                BoundedRangeModel vis = field.getHorizontalVisibility();
+//                int max = Math.max(hspan, bounds.width);
+//                int value = vis.getValue();
+//                int extent = Math.min(max, bounds.width - 1);
+//                if ((value + extent) > max) {
+//                    value = max - extent;
+//                }
+//                vis.setRangeProperties(value, extent, vis.getMinimum(),
+//                                       max, false);
+//                if (hspan < bounds.width) {
+//                    // horizontally align the interior
+//                    int slop = bounds.width - 1 - hspan;
+//
+//                    int align = ((JTextField)c).getHorizontalAlignment();
+//                    if(Utilities.isLeftToRight(c)) {
+//                        if(align==LEADING) {
+//                            align = LEFT;
+//                        }
+//                        else if(align==TRAILING) {
+//                            align = RIGHT;
+//                        }
+//                    }
+//                    else {
+//                        if(align==LEADING) {
+//                            align = RIGHT;
+//                        }
+//                        else if(align==TRAILING) {
+//                            align = LEFT;
+//                        }
+//                    }
+//
+//                    switch (align) {
+//                    case SwingConstants.CENTER:
+//                        bounds.x += slop / 2;
+//                        bounds.width -= slop;
+//                        break;
+//                    case SwingConstants.RIGHT:
+//                        bounds.x += slop;
+//                        bounds.width -= slop;
+//                        break;
+//                    }
+//                } else {
+//                    // adjust the allocation to match the bounded range.
+//                    bounds.width = hspan;
+//                    bounds.x -= vis.getValue();
+//                }
+//            }
+//            return bounds;
+//        }
+//        return null;
+//    }
 
     /**
      * Update the visibility model with the associated JTextField
@@ -151,24 +151,24 @@
      * shown the extent will be zero and we just set it to be full
      * until determined otherwise.
      */
-    void updateVisibilityModel() {
-        Component c = getContainer();
-        if (c instanceof JTextField) {
-            JTextField field = (JTextField) c;
-            BoundedRangeModel vis = field.getHorizontalVisibility();
-            int hspan = (int) getPreferredSpan(X_AXIS);
-            int extent = vis.getExtent();
-            int maximum = Math.max(hspan, extent);
-            extent = (extent == 0) ? maximum : extent;
-            int value = maximum - extent;
-            int oldValue = vis.getValue();
-            if ((oldValue + extent) > maximum) {
-                oldValue = maximum - extent;
-            }
-            value = Math.max(0, Math.min(value, oldValue));
-            vis.setRangeProperties(value, extent, 0, maximum, false);
-        }
-    }
+    void updateVisibilityModel() {throw new RuntimeException("cf-bug");} //{
+//        Component c = getContainer();
+//        if (c instanceof JTextField) {
+//            JTextField field = (JTextField) c;
+//            BoundedRangeModel vis = field.getHorizontalVisibility();
+//            int hspan = (int) getPreferredSpan(X_AXIS);
+//            int extent = vis.getExtent();
+//            int maximum = Math.max(hspan, extent);
+//            extent = (extent == 0) ? maximum : extent;
+//            int value = maximum - extent;
+//            int oldValue = vis.getValue();
+//            if ((oldValue + extent) > maximum) {
+//                oldValue = maximum - extent;
+//            }
+//            value = Math.max(0, Math.min(value, oldValue));
+//            vis.setRangeProperties(value, extent, 0, maximum, false);
+//        }
+//    }
 
     // --- View methods -------------------------------------------
 
@@ -182,18 +182,18 @@
      *
      * @see View#paint
      */
-    public void paint(Graphics g, Shape a) {
-        Rectangle r = (Rectangle) a;
-        g.clipRect(r.x, r.y, r.width, r.height);
-        super.paint(g, a);
-    }
+    public void paint(Graphics g, Shape a) {throw new RuntimeException("cf-bug");} //{
+//        Rectangle r = (Rectangle) a;
+//        g.clipRect(r.x, r.y, r.width, r.height);
+//        super.paint(g, a);
+//    }
 
     /**
      * Adjusts <code>a</code> based on the visible region and returns it.
      */
-    Shape adjustPaintRegion(Shape a) {
-        return adjustAllocation(a);
-    }
+    Shape adjustPaintRegion(Shape a) {throw new RuntimeException("cf-bug");} //{
+//        return adjustAllocation(a);
+//    }
 
     /**
      * Determines the preferred span for this view along an
@@ -205,36 +205,36 @@
      *           that is returned, although there is no guarantee.
      *           The parent may choose to resize or break the view.
      */
-    public float getPreferredSpan(int axis) {
-        switch (axis) {
-        case View.X_AXIS:
-            Segment buff = SegmentCache.getSharedSegment();
-            Document doc = getDocument();
-            int width;
-            try {
-                FontMetrics fm = getFontMetrics();
-                doc.getText(0, doc.getLength(), buff);
-                width = Utilities.getTabbedTextWidth(buff, fm, 0, this, 0);
-                if (buff.count > 0) {
-                    Component c = getContainer();
-                    firstLineOffset = sun.swing.SwingUtilities2.
-                        getLeftSideBearing((c instanceof JComponent) ?
-                                           (JComponent)c : null, fm,
-                                           buff.array[buff.offset]);
-                    firstLineOffset = Math.max(0, -firstLineOffset);
-                }
-                else {
-                    firstLineOffset = 0;
-                }
-            } catch (BadLocationException bl) {
-                width = 0;
-            }
-            SegmentCache.releaseSharedSegment(buff);
-            return width + firstLineOffset;
-        default:
-            return super.getPreferredSpan(axis);
-        }
-    }
+    public float getPreferredSpan(int axis) {throw new RuntimeException("cf-bug");} //{
+//        switch (axis) {
+//        case View.X_AXIS:
+//            Segment buff = SegmentCache.getSharedSegment();
+//            Document doc = getDocument();
+//            int width;
+//            try {
+//                FontMetrics fm = getFontMetrics();
+//                doc.getText(0, doc.getLength(), buff);
+//                width = Utilities.getTabbedTextWidth(buff, fm, 0, this, 0);
+//                if (buff.count > 0) {
+//                    Component c = getContainer();
+//                    firstLineOffset = sun.swing.SwingUtilities2.
+//                        getLeftSideBearing((c instanceof JComponent) ?
+//                                           (JComponent)c : null, fm,
+//                                           buff.array[buff.offset]);
+//                    firstLineOffset = Math.max(0, -firstLineOffset);
+//                }
+//                else {
+//                    firstLineOffset = 0;
+//                }
+//            } catch (BadLocationException bl) {
+//                width = 0;
+//            }
+//            SegmentCache.releaseSharedSegment(buff);
+//            return width + firstLineOffset;
+//        default:
+//            return super.getPreferredSpan(axis);
+//        }
+//    }
 
     /**
      * Determines the resizability of the view along the
@@ -243,12 +243,12 @@
      * @param axis View.X_AXIS or View.Y_AXIS
      * @return the weight -&gt; 1 for View.X_AXIS, else 0
      */
-    public int getResizeWeight(int axis) {
-        if (axis == View.X_AXIS) {
-            return 1;
-        }
-        return 0;
-    }
+    public int getResizeWeight(int axis) {throw new RuntimeException("cf-bug");} //{
+//        if (axis == View.X_AXIS) {
+//            return 1;
+//        }
+//        return 0;
+//    }
 
     /**
      * Provides a mapping from the document model coordinate space
@@ -261,9 +261,9 @@
      *   represent a valid location in the associated document
      * @see View#modelToView
      */
-    public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {
-        return super.modelToView(pos, adjustAllocation(a), b);
-    }
+    public Shape modelToView(int pos, Shape a, Position.Bias b) throws BadLocationException {throw new RuntimeException("cf-bug");} //{
+//        return super.modelToView(pos, adjustAllocation(a), b);
+//    }
 
     /**
      * Provides a mapping from the view coordinate space to the logical
@@ -276,9 +276,9 @@
      *  given point in the view
      * @see View#viewToModel
      */
-    public int viewToModel(float fx, float fy, Shape a, Position.Bias[] bias) {
-        return super.viewToModel(fx, fy, adjustAllocation(a), bias);
-    }
+    public int viewToModel(float fx, float fy, Shape a, Position.Bias[] bias) {throw new RuntimeException("cf-bug");} //{
+//        return super.viewToModel(fx, fy, adjustAllocation(a), bias);
+//    }
 
     /**
      * Gives notification that something was inserted into the document
@@ -289,10 +289,10 @@
      * @param f the factory to use to rebuild if the view has children
      * @see View#insertUpdate
      */
-    public void insertUpdate(DocumentEvent changes, Shape a, ViewFactory f) {
-        super.insertUpdate(changes, adjustAllocation(a), f);
-        updateVisibilityModel();
-    }
+    public void insertUpdate(DocumentEvent changes, Shape a, ViewFactory f) {throw new RuntimeException("cf-bug");} //{
+//        super.insertUpdate(changes, adjustAllocation(a), f);
+//        updateVisibilityModel();
+//    }
 
     /**
      * Gives notification that something was removed from the document
@@ -303,9 +303,9 @@
      * @param f the factory to use to rebuild if the view has children
      * @see View#removeUpdate
      */
-    public void removeUpdate(DocumentEvent changes, Shape a, ViewFactory f) {
-        super.removeUpdate(changes, adjustAllocation(a), f);
-        updateVisibilityModel();
-    }
+    public void removeUpdate(DocumentEvent changes, Shape a, ViewFactory f) {throw new RuntimeException("cf-bug");} //{
+//        super.removeUpdate(changes, adjustAllocation(a), f);
+//        updateVisibilityModel();
+//    }
 
 }
--- javax/swing/JTable.java	2016-06-22 19:55:10.147843034 -0700
+++ javax/swing/JTable.java	2016-06-29 12:19:27.423070935 -0700
@@ -483,9 +483,9 @@
          *
          * @return the drop row
          */
-        public int getRow() {
-            return row;
-        }
+        public int getRow() {throw new RuntimeException("cf-bug");} //{
+//            return row;
+//        }
 
         /**
          * Returns the column index where a dropped item should be placed in the
@@ -501,9 +501,9 @@
          *
          * @return the drop row
          */
-        public int getColumn() {
-            return col;
-        }
+        public int getColumn() {throw new RuntimeException("cf-bug");} //{
+//            return col;
+//        }
 
         /**
          * Returns whether or not this location represents an insert
@@ -511,9 +511,9 @@
          *
          * @return whether or not this is an insert row
          */
-        public boolean isInsertRow() {
-            return isInsertRow;
-        }
+        public boolean isInsertRow() {throw new RuntimeException("cf-bug");} //{
+//            return isInsertRow;
+//        }
 
         /**
          * Returns whether or not this location represents an insert
@@ -521,9 +521,9 @@
          *
          * @return whether or not this is an insert column
          */
-        public boolean isInsertColumn() {
-            return isInsertCol;
-        }
+        public boolean isInsertColumn() {throw new RuntimeException("cf-bug");} //{
+//            return isInsertCol;
+//        }
 
         /**
          * Returns a string representation of this drop location.
@@ -533,14 +533,14 @@
          *
          * @return a string representation of this drop location
          */
-        public String toString() {
-            return getClass().getName()
-                   + "[dropPoint=" + getDropPoint() + ","
-                   + "row=" + row + ","
-                   + "column=" + col + ","
-                   + "insertRow=" + isInsertRow + ","
-                   + "insertColumn=" + isInsertCol + "]";
-        }
+        public String toString() {throw new RuntimeException("cf-bug");} //{
+//            return getClass().getName()
+//                   + "[dropPoint=" + getDropPoint() + ","
+//                   + "row=" + row + ","
+//                   + "column=" + col + ","
+//                   + "insertRow=" + isInsertRow + ","
+//                   + "insertColumn=" + isInsertCol + "]";
+//        }
     }
 
 //
@@ -699,10 +699,10 @@
      *
      * @see #configureEnclosingScrollPane
      */
-    public void addNotify() {
-        super.addNotify();
-        configureEnclosingScrollPane();
-    }
+    public void addNotify() {throw new RuntimeException("cf-bug");} //{
+//        super.addNotify();
+//        configureEnclosingScrollPane();
+//    }
 
     /**
      * If this <code>JTable</code> is the <code>viewportView</code> of an enclosing <code>JScrollPane</code>
@@ -717,27 +717,27 @@
      *
      * @see #addNotify
      */
-    protected void configureEnclosingScrollPane() {
-        Container parent = SwingUtilities.getUnwrappedParent(this);
-        if (parent instanceof JViewport) {
-            JViewport port = (JViewport) parent;
-            Container gp = port.getParent();
-            if (gp instanceof JScrollPane) {
-                JScrollPane scrollPane = (JScrollPane)gp;
-                // Make certain we are the viewPort's view and not, for
-                // example, the rowHeaderView of the scrollPane -
-                // an implementor of fixed columns might do this.
-                JViewport viewport = scrollPane.getViewport();
-                if (viewport == null ||
-                        SwingUtilities.getUnwrappedView(viewport) != this) {
-                    return;
-                }
-                scrollPane.setColumnHeaderView(getTableHeader());
-                // configure the scrollpane for any LAF dependent settings
-                configureEnclosingScrollPaneUI();
-            }
-        }
-    }
+    protected void configureEnclosingScrollPane() {throw new RuntimeException("cf-bug");} //{
+//        Container parent = SwingUtilities.getUnwrappedParent(this);
+//        if (parent instanceof JViewport) {
+//            JViewport port = (JViewport) parent;
+//            Container gp = port.getParent();
+//            if (gp instanceof JScrollPane) {
+//                JScrollPane scrollPane = (JScrollPane)gp;
+//                // Make certain we are the viewPort's view and not, for
+//                // example, the rowHeaderView of the scrollPane -
+//                // an implementor of fixed columns might do this.
+//                JViewport viewport = scrollPane.getViewport();
+//                if (viewport == null ||
+//                        SwingUtilities.getUnwrappedView(viewport) != this) {
+//                    return;
+//                }
+//                scrollPane.setColumnHeaderView(getTableHeader());
+//                // configure the scrollpane for any LAF dependent settings
+//                configureEnclosingScrollPaneUI();
+//            }
+//        }
+//    }
 
     /**
      * This is a sub-part of configureEnclosingScrollPane() that configures
@@ -751,60 +751,60 @@
      * it out in this way configureEnclosingScrollPaneUI() can be called both
      * from configureEnclosingScrollPane() and updateUI() in a safe manor.
      */
-    private void configureEnclosingScrollPaneUI() {
-        Container parent = SwingUtilities.getUnwrappedParent(this);
-        if (parent instanceof JViewport) {
-            JViewport port = (JViewport) parent;
-            Container gp = port.getParent();
-            if (gp instanceof JScrollPane) {
-                JScrollPane scrollPane = (JScrollPane)gp;
-                // Make certain we are the viewPort's view and not, for
-                // example, the rowHeaderView of the scrollPane -
-                // an implementor of fixed columns might do this.
-                JViewport viewport = scrollPane.getViewport();
-                if (viewport == null ||
-                        SwingUtilities.getUnwrappedView(viewport) != this) {
-                    return;
-                }
-                //  scrollPane.getViewport().setBackingStoreEnabled(true);
-                Border border = scrollPane.getBorder();
-                if (border == null || border instanceof UIResource) {
-                    Border scrollPaneBorder =
-                        UIManager.getBorder("Table.scrollPaneBorder");
-                    if (scrollPaneBorder != null) {
-                        scrollPane.setBorder(scrollPaneBorder);
-                    }
-                }
-                // add JScrollBar corner component if available from LAF and not already set by the user
-                Component corner =
-                        scrollPane.getCorner(JScrollPane.UPPER_TRAILING_CORNER);
-                if (corner == null || corner instanceof UIResource){
-                    corner = null;
-                    try {
-                        corner = (Component) UIManager.get(
-                                "Table.scrollPaneCornerComponent");
-                    } catch (Exception e) {
-                        // just ignore and don't set corner
-                    }
-                    scrollPane.setCorner(JScrollPane.UPPER_TRAILING_CORNER,
-                            corner);
-                }
-            }
-        }
-    }
+    private void configureEnclosingScrollPaneUI() {throw new RuntimeException("cf-bug");} //{
+//        Container parent = SwingUtilities.getUnwrappedParent(this);
+//        if (parent instanceof JViewport) {
+//            JViewport port = (JViewport) parent;
+//            Container gp = port.getParent();
+//            if (gp instanceof JScrollPane) {
+//                JScrollPane scrollPane = (JScrollPane)gp;
+//                // Make certain we are the viewPort's view and not, for
+//                // example, the rowHeaderView of the scrollPane -
+//                // an implementor of fixed columns might do this.
+//                JViewport viewport = scrollPane.getViewport();
+//                if (viewport == null ||
+//                        SwingUtilities.getUnwrappedView(viewport) != this) {
+//                    return;
+//                }
+//                //  scrollPane.getViewport().setBackingStoreEnabled(true);
+//                Border border = scrollPane.getBorder();
+//                if (border == null || border instanceof UIResource) {
+//                    Border scrollPaneBorder =
+//                        UIManager.getBorder("Table.scrollPaneBorder");
+//                    if (scrollPaneBorder != null) {
+//                        scrollPane.setBorder(scrollPaneBorder);
+//                    }
+//                }
+//                // add JScrollBar corner component if available from LAF and not already set by the user
+//                Component corner =
+//                        scrollPane.getCorner(JScrollPane.UPPER_TRAILING_CORNER);
+//                if (corner == null || corner instanceof UIResource){
+//                    corner = null;
+//                    try {
+//                        corner = (Component) UIManager.get(
+//                                "Table.scrollPaneCornerComponent");
+//                    } catch (Exception e) {
+//                        // just ignore and don't set corner
+//                    }
+//                    scrollPane.setCorner(JScrollPane.UPPER_TRAILING_CORNER,
+//                            corner);
+//                }
+//            }
+//        }
+//    }
 
     /**
      * Calls the <code>unconfigureEnclosingScrollPane</code> method.
      *
      * @see #unconfigureEnclosingScrollPane
      */
-    public void removeNotify() {
-        KeyboardFocusManager.getCurrentKeyboardFocusManager().
-            removePropertyChangeListener("permanentFocusOwner", editorRemover);
-        editorRemover = null;
-        unconfigureEnclosingScrollPane();
-        super.removeNotify();
-    }
+    public void removeNotify() {throw new RuntimeException("cf-bug");} //{
+//        KeyboardFocusManager.getCurrentKeyboardFocusManager().
+//            removePropertyChangeListener("permanentFocusOwner", editorRemover);
+//        editorRemover = null;
+//        unconfigureEnclosingScrollPane();
+//        super.removeNotify();
+//    }
 
     /**
      * Reverses the effect of <code>configureEnclosingScrollPane</code>
@@ -818,43 +818,43 @@
      * @see #configureEnclosingScrollPane
      * @since 1.3
      */
-    protected void unconfigureEnclosingScrollPane() {
-        Container parent = SwingUtilities.getUnwrappedParent(this);
-        if (parent instanceof JViewport) {
-            JViewport port = (JViewport) parent;
-            Container gp = port.getParent();
-            if (gp instanceof JScrollPane) {
-                JScrollPane scrollPane = (JScrollPane)gp;
-                // Make certain we are the viewPort's view and not, for
-                // example, the rowHeaderView of the scrollPane -
-                // an implementor of fixed columns might do this.
-                JViewport viewport = scrollPane.getViewport();
-                if (viewport == null ||
-                        SwingUtilities.getUnwrappedView(viewport) != this) {
-                    return;
-                }
-                scrollPane.setColumnHeaderView(null);
-                // remove ScrollPane corner if one was added by the LAF
-                Component corner =
-                        scrollPane.getCorner(JScrollPane.UPPER_TRAILING_CORNER);
-                if (corner instanceof UIResource){
-                    scrollPane.setCorner(JScrollPane.UPPER_TRAILING_CORNER,
-                            null);
-                }
-            }
-        }
-    }
-
-    void setUIProperty(String propertyName, Object value) {
-        if (propertyName == "rowHeight") {
-            if (!isRowHeightSet) {
-                setRowHeight(((Number)value).intValue());
-                isRowHeightSet = false;
-            }
-            return;
-        }
-        super.setUIProperty(propertyName, value);
-    }
+    protected void unconfigureEnclosingScrollPane() {throw new RuntimeException("cf-bug");} //{
+//        Container parent = SwingUtilities.getUnwrappedParent(this);
+//        if (parent instanceof JViewport) {
+//            JViewport port = (JViewport) parent;
+//            Container gp = port.getParent();
+//            if (gp instanceof JScrollPane) {
+//                JScrollPane scrollPane = (JScrollPane)gp;
+//                // Make certain we are the viewPort's view and not, for
+//                // example, the rowHeaderView of the scrollPane -
+//                // an implementor of fixed columns might do this.
+//                JViewport viewport = scrollPane.getViewport();
+//                if (viewport == null ||
+//                        SwingUtilities.getUnwrappedView(viewport) != this) {
+//                    return;
+//                }
+//                scrollPane.setColumnHeaderView(null);
+//                // remove ScrollPane corner if one was added by the LAF
+//                Component corner =
+//                        scrollPane.getCorner(JScrollPane.UPPER_TRAILING_CORNER);
+//                if (corner instanceof UIResource){
+//                    scrollPane.setCorner(JScrollPane.UPPER_TRAILING_CORNER,
+//                            null);
+//                }
+//            }
+//        }
+//    }
+
+    void setUIProperty(String propertyName, Object value) {throw new RuntimeException("cf-bug");} //{
+//        if (propertyName == "rowHeight") {
+//            if (!isRowHeightSet) {
+//                setRowHeight(((Number)value).intValue());
+//                isRowHeightSet = false;
+//            }
+//            return;
+//        }
+//        super.setUIProperty(propertyName, value);
+//    }
 
 //
 // Static Methods
@@ -867,9 +867,9 @@
      * replaced by <code>new JScrollPane(aTable)</code>.
      */
     @Deprecated
-    static public JScrollPane createScrollPaneForTable(JTable aTable) {
-        return new JScrollPane(aTable);
-    }
+    static public JScrollPane createScrollPaneForTable(JTable aTable) {throw new RuntimeException("cf-bug");} //{
+//        return new JScrollPane(aTable);
+//    }
 
 //
 // Table Attributes
@@ -885,20 +885,20 @@
      *  bound: true
      *  description: The JTableHeader instance which renders the column headers.
      */
-    public void setTableHeader(JTableHeader tableHeader) {
-        if (this.tableHeader != tableHeader) {
-            JTableHeader old = this.tableHeader;
-            // Release the old header
-            if (old != null) {
-                old.setTable(null);
-            }
-            this.tableHeader = tableHeader;
-            if (tableHeader != null) {
-                tableHeader.setTable(this);
-            }
-            firePropertyChange("tableHeader", old, tableHeader);
-        }
-    }
+    public void setTableHeader(JTableHeader tableHeader) {throw new RuntimeException("cf-bug");} //{
+//        if (this.tableHeader != tableHeader) {
+//            JTableHeader old = this.tableHeader;
+//            // Release the old header
+//            if (old != null) {
+//                old.setTable(null);
+//            }
+//            this.tableHeader = tableHeader;
+//            if (tableHeader != null) {
+//                tableHeader.setTable(this);
+//            }
+//            firePropertyChange("tableHeader", old, tableHeader);
+//        }
+//    }
 
     /**
      * Returns the <code>tableHeader</code> used by this <code>JTable</code>.
@@ -906,9 +906,9 @@
      * @return  the <code>tableHeader</code> used by this table
      * @see     #setTableHeader
      */
-    public JTableHeader getTableHeader() {
-        return tableHeader;
-    }
+    public JTableHeader getTableHeader() {throw new RuntimeException("cf-bug");} //{
+//        return tableHeader;
+//    }
 
     /**
      * Sets the height, in pixels, of all cells to <code>rowHeight</code>,
@@ -924,20 +924,20 @@
      *  bound: true
      *  description: The height of the specified row.
      */
-    public void setRowHeight(int rowHeight) {
-        if (rowHeight <= 0) {
-            throw new IllegalArgumentException("New row height less than 1");
-        }
-        int old = this.rowHeight;
-        this.rowHeight = rowHeight;
-        rowModel = null;
-        if (sortManager != null) {
-            sortManager.modelRowSizes = null;
-        }
-        isRowHeightSet = true;
-        resizeAndRepaint();
-        firePropertyChange("rowHeight", old, rowHeight);
-    }
+    public void setRowHeight(int rowHeight) {throw new RuntimeException("cf-bug");} //{
+//        if (rowHeight <= 0) {
+//            throw new IllegalArgumentException("New row height less than 1");
+//        }
+//        int old = this.rowHeight;
+//        this.rowHeight = rowHeight;
+//        rowModel = null;
+//        if (sortManager != null) {
+//            sortManager.modelRowSizes = null;
+//        }
+//        isRowHeightSet = true;
+//        resizeAndRepaint();
+//        firePropertyChange("rowHeight", old, rowHeight);
+//    }
 
     /**
      * Returns the height of a table row, in pixels.
@@ -945,16 +945,16 @@
      * @return  the height in pixels of a table row
      * @see     #setRowHeight
      */
-    public int getRowHeight() {
-        return rowHeight;
-    }
-
-    private SizeSequence getRowModel() {
-        if (rowModel == null) {
-            rowModel = new SizeSequence(getRowCount(), getRowHeight());
-        }
-        return rowModel;
-    }
+    public int getRowHeight() {throw new RuntimeException("cf-bug");} //{
+//        return rowHeight;
+//    }
+
+    private SizeSequence getRowModel() {throw new RuntimeException("cf-bug");} //{
+//        if (rowModel == null) {
+//            rowModel = new SizeSequence(getRowCount(), getRowHeight());
+//        }
+//        return rowModel;
+//    }
 
     /**
      * Sets the height for <code>row</code> to <code>rowHeight</code>,
@@ -971,16 +971,16 @@
      *  description: The height in pixels of the cells in <code>row</code>
      * @since 1.3
      */
-    public void setRowHeight(int row, int rowHeight) {
-        if (rowHeight <= 0) {
-            throw new IllegalArgumentException("New row height less than 1");
-        }
-        getRowModel().setSize(row, rowHeight);
-        if (sortManager != null) {
-            sortManager.setViewRowHeight(row, rowHeight);
-        }
-        resizeAndRepaint();
-    }
+    public void setRowHeight(int row, int rowHeight) {throw new RuntimeException("cf-bug");} //{
+//        if (rowHeight <= 0) {
+//            throw new IllegalArgumentException("New row height less than 1");
+//        }
+//        getRowModel().setSize(row, rowHeight);
+//        if (sortManager != null) {
+//            sortManager.setViewRowHeight(row, rowHeight);
+//        }
+//        resizeAndRepaint();
+//    }
 
     /**
      * Returns the height, in pixels, of the cells in <code>row</code>.
@@ -988,9 +988,9 @@
      * @return the height, in pixels, of the cells in the row
      * @since 1.3
      */
-    public int getRowHeight(int row) {
-        return (rowModel == null) ? getRowHeight() : rowModel.getSize(row);
-    }
+    public int getRowHeight(int row) {throw new RuntimeException("cf-bug");} //{
+//        return (rowModel == null) ? getRowHeight() : rowModel.getSize(row);
+//    }
 
     /**
      * Sets the amount of empty space between cells in adjacent rows.
@@ -1001,12 +1001,12 @@
      *  bound: true
      *  description: The amount of space between cells.
      */
-    public void setRowMargin(int rowMargin) {
-        int old = this.rowMargin;
-        this.rowMargin = rowMargin;
-        resizeAndRepaint();
-        firePropertyChange("rowMargin", old, rowMargin);
-    }
+    public void setRowMargin(int rowMargin) {throw new RuntimeException("cf-bug");} //{
+//        int old = this.rowMargin;
+//        this.rowMargin = rowMargin;
+//        resizeAndRepaint();
+//        firePropertyChange("rowMargin", old, rowMargin);
+//    }
 
     /**
      * Gets the amount of empty space, in pixels, between cells. Equivalent to:
@@ -1015,9 +1015,9 @@
      *
      * @see     #setRowMargin
      */
-    public int getRowMargin() {
-        return rowMargin;
-    }
+    public int getRowMargin() {throw new RuntimeException("cf-bug");} //{
+//        return rowMargin;
+//    }
 
     /**
      * Sets the <code>rowMargin</code> and the <code>columnMargin</code> --
@@ -1032,13 +1032,13 @@
      *  description: The spacing between the cells,
      *               drawn in the background color of the JTable.
      */
-    public void setIntercellSpacing(Dimension intercellSpacing) {
-        // Set the rowMargin here and columnMargin in the TableColumnModel
-        setRowMargin(intercellSpacing.height);
-        getColumnModel().setColumnMargin(intercellSpacing.width);
-
-        resizeAndRepaint();
-    }
+    public void setIntercellSpacing(Dimension intercellSpacing) {throw new RuntimeException("cf-bug");} //{
+//        // Set the rowMargin here and columnMargin in the TableColumnModel
+//        setRowMargin(intercellSpacing.height);
+//        getColumnModel().setColumnMargin(intercellSpacing.width);
+//
+//        resizeAndRepaint();
+//    }
 
     /**
      * Returns the horizontal and vertical space between cells.
@@ -1047,9 +1047,9 @@
      * @return  the horizontal and vertical spacing between cells
      * @see     #setIntercellSpacing
      */
-    public Dimension getIntercellSpacing() {
-        return new Dimension(getColumnModel().getColumnMargin(), rowMargin);
-    }
+    public Dimension getIntercellSpacing() {throw new RuntimeException("cf-bug");} //{
+//        return new Dimension(getColumnModel().getColumnMargin(), rowMargin);
+//    }
 
     /**
      * Sets the color used to draw grid lines to <code>gridColor</code> and redisplays.
@@ -1062,16 +1062,16 @@
      *  bound: true
      *  description: The grid color.
      */
-    public void setGridColor(Color gridColor) {
-        if (gridColor == null) {
-            throw new IllegalArgumentException("New color is null");
-        }
-        Color old = this.gridColor;
-        this.gridColor = gridColor;
-        firePropertyChange("gridColor", old, gridColor);
-        // Redraw
-        repaint();
-    }
+    public void setGridColor(Color gridColor) {throw new RuntimeException("cf-bug");} //{
+//        if (gridColor == null) {
+//            throw new IllegalArgumentException("New color is null");
+//        }
+//        Color old = this.gridColor;
+//        this.gridColor = gridColor;
+//        firePropertyChange("gridColor", old, gridColor);
+//        // Redraw
+//        repaint();
+//    }
 
     /**
      * Returns the color used to draw grid lines.
@@ -1080,9 +1080,9 @@
      * @return  the color used to draw grid lines
      * @see     #setGridColor
      */
-    public Color getGridColor() {
-        return gridColor;
-    }
+    public Color getGridColor() {throw new RuntimeException("cf-bug");} //{
+//        return gridColor;
+//    }
 
     /**
      *  Sets whether the table draws grid lines around cells.
@@ -1098,13 +1098,13 @@
      * @beaninfo
      *  description: The color used to draw the grid lines.
      */
-    public void setShowGrid(boolean showGrid) {
-        setShowHorizontalLines(showGrid);
-        setShowVerticalLines(showGrid);
-
-        // Redraw
-        repaint();
-    }
+    public void setShowGrid(boolean showGrid) {throw new RuntimeException("cf-bug");} //{
+//        setShowHorizontalLines(showGrid);
+//        setShowVerticalLines(showGrid);
+//
+//        // Redraw
+//        repaint();
+//    }
 
     /**
      *  Sets whether the table draws horizontal lines between cells.
@@ -1118,14 +1118,14 @@
      *  bound: true
      *  description: Whether horizontal lines should be drawn in between the cells.
      */
-    public void setShowHorizontalLines(boolean showHorizontalLines) {
-        boolean old = this.showHorizontalLines;
-        this.showHorizontalLines = showHorizontalLines;
-        firePropertyChange("showHorizontalLines", old, showHorizontalLines);
-
-        // Redraw
-        repaint();
-    }
+    public void setShowHorizontalLines(boolean showHorizontalLines) {throw new RuntimeException("cf-bug");} //{
+//        boolean old = this.showHorizontalLines;
+//        this.showHorizontalLines = showHorizontalLines;
+//        firePropertyChange("showHorizontalLines", old, showHorizontalLines);
+//
+//        // Redraw
+//        repaint();
+//    }
 
     /**
      *  Sets whether the table draws vertical lines between cells.
@@ -1139,13 +1139,13 @@
      *  bound: true
      *  description: Whether vertical lines should be drawn in between the cells.
      */
-    public void setShowVerticalLines(boolean showVerticalLines) {
-        boolean old = this.showVerticalLines;
-        this.showVerticalLines = showVerticalLines;
-        firePropertyChange("showVerticalLines", old, showVerticalLines);
-        // Redraw
-        repaint();
-    }
+    public void setShowVerticalLines(boolean showVerticalLines) {throw new RuntimeException("cf-bug");} //{
+//        boolean old = this.showVerticalLines;
+//        this.showVerticalLines = showVerticalLines;
+//        firePropertyChange("showVerticalLines", old, showVerticalLines);
+//        // Redraw
+//        repaint();
+//    }
 
     /**
      * Returns true if the table draws horizontal lines between cells, false if it
@@ -1155,9 +1155,9 @@
      *          doesn't
      * @see     #setShowHorizontalLines
      */
-    public boolean getShowHorizontalLines() {
-        return showHorizontalLines;
-    }
+    public boolean getShowHorizontalLines() {throw new RuntimeException("cf-bug");} //{
+//        return showHorizontalLines;
+//    }
 
     /**
      * Returns true if the table draws vertical lines between cells, false if it
@@ -1167,9 +1167,9 @@
      *          doesn't
      * @see     #setShowVerticalLines
      */
-    public boolean getShowVerticalLines() {
-        return showVerticalLines;
-    }
+    public boolean getShowVerticalLines() {throw new RuntimeException("cf-bug");} //{
+//        return showVerticalLines;
+//    }
 
     /**
      * Sets the table's auto resize mode when the table is resized.  For further
@@ -1194,21 +1194,21 @@
      *              AUTO_RESIZE_LAST_COLUMN        JTable.AUTO_RESIZE_LAST_COLUMN
      *              AUTO_RESIZE_ALL_COLUMNS        JTable.AUTO_RESIZE_ALL_COLUMNS
      */
-    public void setAutoResizeMode(int mode) {
-        if ((mode == AUTO_RESIZE_OFF) ||
-            (mode == AUTO_RESIZE_NEXT_COLUMN) ||
-            (mode == AUTO_RESIZE_SUBSEQUENT_COLUMNS) ||
-            (mode == AUTO_RESIZE_LAST_COLUMN) ||
-            (mode == AUTO_RESIZE_ALL_COLUMNS)) {
-            int old = autoResizeMode;
-            autoResizeMode = mode;
-            resizeAndRepaint();
-            if (tableHeader != null) {
-                tableHeader.resizeAndRepaint();
-            }
-            firePropertyChange("autoResizeMode", old, autoResizeMode);
-        }
-    }
+    public void setAutoResizeMode(int mode) {throw new RuntimeException("cf-bug");} //{
+//        if ((mode == AUTO_RESIZE_OFF) ||
+//            (mode == AUTO_RESIZE_NEXT_COLUMN) ||
+//            (mode == AUTO_RESIZE_SUBSEQUENT_COLUMNS) ||
+//            (mode == AUTO_RESIZE_LAST_COLUMN) ||
+//            (mode == AUTO_RESIZE_ALL_COLUMNS)) {
+//            int old = autoResizeMode;
+//            autoResizeMode = mode;
+//            resizeAndRepaint();
+//            if (tableHeader != null) {
+//                tableHeader.resizeAndRepaint();
+//            }
+//            firePropertyChange("autoResizeMode", old, autoResizeMode);
+//        }
+//    }
 
     /**
      * Returns the auto resize mode of the table.  The default mode
@@ -1219,9 +1219,9 @@
      * @see     #setAutoResizeMode
      * @see     #doLayout
      */
-    public int getAutoResizeMode() {
-        return autoResizeMode;
-    }
+    public int getAutoResizeMode() {throw new RuntimeException("cf-bug");} //{
+//        return autoResizeMode;
+//    }
 
     /**
      * Sets this table's <code>autoCreateColumnsFromModel</code> flag.
@@ -1235,16 +1235,16 @@
      *  bound: true
      *  description: Automatically populates the columnModel when a new TableModel is submitted.
      */
-    public void setAutoCreateColumnsFromModel(boolean autoCreateColumnsFromModel) {
-        if (this.autoCreateColumnsFromModel != autoCreateColumnsFromModel) {
-            boolean old = this.autoCreateColumnsFromModel;
-            this.autoCreateColumnsFromModel = autoCreateColumnsFromModel;
-            if (autoCreateColumnsFromModel) {
-                createDefaultColumnsFromModel();
-            }
-            firePropertyChange("autoCreateColumnsFromModel", old, autoCreateColumnsFromModel);
-        }
-    }
+    public void setAutoCreateColumnsFromModel(boolean autoCreateColumnsFromModel) {throw new RuntimeException("cf-bug");} //{
+//        if (this.autoCreateColumnsFromModel != autoCreateColumnsFromModel) {
+//            boolean old = this.autoCreateColumnsFromModel;
+//            this.autoCreateColumnsFromModel = autoCreateColumnsFromModel;
+//            if (autoCreateColumnsFromModel) {
+//                createDefaultColumnsFromModel();
+//            }
+//            firePropertyChange("autoCreateColumnsFromModel", old, autoCreateColumnsFromModel);
+//        }
+//    }
 
     /**
      * Determines whether the table will create default columns from the model.
@@ -1258,9 +1258,9 @@
      * @see     #setAutoCreateColumnsFromModel
      * @see     #createDefaultColumnsFromModel
      */
-    public boolean getAutoCreateColumnsFromModel() {
-        return autoCreateColumnsFromModel;
-    }
+    public boolean getAutoCreateColumnsFromModel() {throw new RuntimeException("cf-bug");} //{
+//        return autoCreateColumnsFromModel;
+//    }
 
     /**
      * Creates default columns for the table from
@@ -1272,22 +1272,22 @@
      *
      * @see     #getAutoCreateColumnsFromModel
      */
-    public void createDefaultColumnsFromModel() {
-        TableModel m = getModel();
-        if (m != null) {
-            // Remove any current columns
-            TableColumnModel cm = getColumnModel();
-            while (cm.getColumnCount() > 0) {
-                cm.removeColumn(cm.getColumn(0));
-            }
-
-            // Create new columns from the data model info
-            for (int i = 0; i < m.getColumnCount(); i++) {
-                TableColumn newColumn = new TableColumn(i);
-                addColumn(newColumn);
-            }
-        }
-    }
+    public void createDefaultColumnsFromModel() {throw new RuntimeException("cf-bug");} //{
+//        TableModel m = getModel();
+//        if (m != null) {
+//            // Remove any current columns
+//            TableColumnModel cm = getColumnModel();
+//            while (cm.getColumnCount() > 0) {
+//                cm.removeColumn(cm.getColumn(0));
+//            }
+//
+//            // Create new columns from the data model info
+//            for (int i = 0; i < m.getColumnCount(); i++) {
+//                TableColumn newColumn = new TableColumn(i);
+//                addColumn(newColumn);
+//            }
+//        }
+//    }
 
     /**
      * Sets a default cell renderer to be used if no renderer has been set in
@@ -1300,14 +1300,14 @@
      * @see     #getDefaultRenderer
      * @see     #setDefaultEditor
      */
-    public void setDefaultRenderer(Class<?> columnClass, TableCellRenderer renderer) {
-        if (renderer != null) {
-            defaultRenderersByColumnClass.put(columnClass, renderer);
-        }
-        else {
-            defaultRenderersByColumnClass.remove(columnClass);
-        }
-    }
+    public void setDefaultRenderer(Class<?> columnClass, TableCellRenderer renderer) {throw new RuntimeException("cf-bug");} //{
+//        if (renderer != null) {
+//            defaultRenderersByColumnClass.put(columnClass, renderer);
+//        }
+//        else {
+//            defaultRenderersByColumnClass.remove(columnClass);
+//        }
+//    }
 
     /**
      * Returns the cell renderer to be used when no renderer has been set in
@@ -1324,24 +1324,24 @@
      * @see     #setDefaultRenderer
      * @see     #getColumnClass
      */
-    public TableCellRenderer getDefaultRenderer(Class<?> columnClass) {
-        if (columnClass == null) {
-            return null;
-        }
-        else {
-            Object renderer = defaultRenderersByColumnClass.get(columnClass);
-            if (renderer != null) {
-                return (TableCellRenderer)renderer;
-            }
-            else {
-                Class c = columnClass.getSuperclass();
-                if (c == null && columnClass != Object.class) {
-                    c = Object.class;
-                }
-                return getDefaultRenderer(c);
-            }
-        }
-    }
+    public TableCellRenderer getDefaultRenderer(Class<?> columnClass) {throw new RuntimeException("cf-bug");} //{
+//        if (columnClass == null) {
+//            return null;
+//        }
+//        else {
+//            Object renderer = defaultRenderersByColumnClass.get(columnClass);
+//            if (renderer != null) {
+//                return (TableCellRenderer)renderer;
+//            }
+//            else {
+//                Class c = columnClass.getSuperclass();
+//                if (c == null && columnClass != Object.class) {
+//                    c = Object.class;
+//                }
+//                return getDefaultRenderer(c);
+//            }
+//        }
+//    }
 
     /**
      * Sets a default cell editor to be used if no editor has been set in
@@ -1358,14 +1358,14 @@
      * @see     #getDefaultEditor
      * @see     #setDefaultRenderer
      */
-    public void setDefaultEditor(Class<?> columnClass, TableCellEditor editor) {
-        if (editor != null) {
-            defaultEditorsByColumnClass.put(columnClass, editor);
-        }
-        else {
-            defaultEditorsByColumnClass.remove(columnClass);
-        }
-    }
+    public void setDefaultEditor(Class<?> columnClass, TableCellEditor editor) {throw new RuntimeException("cf-bug");} //{
+//        if (editor != null) {
+//            defaultEditorsByColumnClass.put(columnClass, editor);
+//        }
+//        else {
+//            defaultEditorsByColumnClass.remove(columnClass);
+//        }
+//    }
 
     /**
      * Returns the editor to be used when no editor has been set in
@@ -1381,20 +1381,20 @@
      * @see     #setDefaultEditor
      * @see     #getColumnClass
      */
-    public TableCellEditor getDefaultEditor(Class<?> columnClass) {
-        if (columnClass == null) {
-            return null;
-        }
-        else {
-            Object editor = defaultEditorsByColumnClass.get(columnClass);
-            if (editor != null) {
-                return (TableCellEditor)editor;
-            }
-            else {
-                return getDefaultEditor(columnClass.getSuperclass());
-            }
-        }
-    }
+    public TableCellEditor getDefaultEditor(Class<?> columnClass) {throw new RuntimeException("cf-bug");} //{
+//        if (columnClass == null) {
+//            return null;
+//        }
+//        else {
+//            Object editor = defaultEditorsByColumnClass.get(columnClass);
+//            if (editor != null) {
+//                return (TableCellEditor)editor;
+//            }
+//            else {
+//                return getDefaultEditor(columnClass.getSuperclass());
+//            }
+//        }
+//    }
 
     /**
      * Turns on or off automatic drag handling. In order to enable automatic
@@ -1430,12 +1430,12 @@
      *  description: determines whether automatic drag handling is enabled
      *        bound: false
      */
-    public void setDragEnabled(boolean b) {
-        if (b && GraphicsEnvironment.isHeadless()) {
-            throw new HeadlessException();
-        }
-        dragEnabled = b;
-    }
+    public void setDragEnabled(boolean b) {throw new RuntimeException("cf-bug");} //{
+//        if (b && GraphicsEnvironment.isHeadless()) {
+//            throw new HeadlessException();
+//        }
+//        dragEnabled = b;
+//    }
 
     /**
      * Returns whether or not automatic drag handling is enabled.
@@ -1444,9 +1444,9 @@
      * @see #setDragEnabled
      * @since 1.4
      */
-    public boolean getDragEnabled() {
-        return dragEnabled;
-    }
+    public boolean getDragEnabled() {throw new RuntimeException("cf-bug");} //{
+//        return dragEnabled;
+//    }
 
     /**
      * Sets the drop mode for this component. For backward compatibility,
@@ -1480,24 +1480,24 @@
      * @see TransferHandler
      * @since 1.6
      */
-    public final void setDropMode(DropMode dropMode) {
-        if (dropMode != null) {
-            switch (dropMode) {
-                case USE_SELECTION:
-                case ON:
-                case INSERT:
-                case INSERT_ROWS:
-                case INSERT_COLS:
-                case ON_OR_INSERT:
-                case ON_OR_INSERT_ROWS:
-                case ON_OR_INSERT_COLS:
-                    this.dropMode = dropMode;
-                    return;
-            }
-        }
-
-        throw new IllegalArgumentException(dropMode + ": Unsupported drop mode for table");
-    }
+    public final void setDropMode(DropMode dropMode) {throw new RuntimeException("cf-bug");} //{
+//        if (dropMode != null) {
+//            switch (dropMode) {
+//                case USE_SELECTION:
+//                case ON:
+//                case INSERT:
+//                case INSERT_ROWS:
+//                case INSERT_COLS:
+//                case ON_OR_INSERT:
+//                case ON_OR_INSERT_ROWS:
+//                case ON_OR_INSERT_COLS:
+//                    this.dropMode = dropMode;
+//                    return;
+//            }
+//        }
+//
+//        throw new IllegalArgumentException(dropMode + ": Unsupported drop mode for table");
+//    }
 
     /**
      * Returns the drop mode for this component.
@@ -1506,9 +1506,9 @@
      * @see #setDropMode
      * @since 1.6
      */
-    public final DropMode getDropMode() {
-        return dropMode;
-    }
+    public final DropMode getDropMode() {throw new RuntimeException("cf-bug");} //{
+//        return dropMode;
+//    }
 
     /**
      * Calculates a drop location in this component, representing where a
@@ -1517,181 +1517,181 @@
      * @param p the point to calculate a drop location for
      * @return the drop location, or <code>null</code>
      */
-    DropLocation dropLocationForPoint(Point p) {
-        DropLocation location = null;
-
-        int row = rowAtPoint(p);
-        int col = columnAtPoint(p);
-        boolean outside = Boolean.TRUE == getClientProperty("Table.isFileList")
-                          && SwingUtilities2.pointOutsidePrefSize(this, row, col, p);
-
-        Rectangle rect = getCellRect(row, col, true);
-        Section xSection, ySection;
-        boolean between = false;
-        boolean ltr = getComponentOrientation().isLeftToRight();
-
-        switch(dropMode) {
-            case USE_SELECTION:
-            case ON:
-                if (row == -1 || col == -1 || outside) {
-                    location = new DropLocation(p, -1, -1, false, false);
-                } else {
-                    location = new DropLocation(p, row, col, false, false);
-                }
-                break;
-            case INSERT:
-                if (row == -1 && col == -1) {
-                    location = new DropLocation(p, 0, 0, true, true);
-                    break;
-                }
-
-                xSection = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);
-
-                if (row == -1) {
-                    if (xSection == LEADING) {
-                        location = new DropLocation(p, getRowCount(), col, true, true);
-                    } else if (xSection == TRAILING) {
-                        location = new DropLocation(p, getRowCount(), col + 1, true, true);
-                    } else {
-                        location = new DropLocation(p, getRowCount(), col, true, false);
-                    }
-                } else if (xSection == LEADING || xSection == TRAILING) {
-                    ySection = SwingUtilities2.liesInVertical(rect, p, true);
-                    if (ySection == LEADING) {
-                        between = true;
-                    } else if (ySection == TRAILING) {
-                        row++;
-                        between = true;
-                    }
-
-                    location = new DropLocation(p, row,
-                                                xSection == TRAILING ? col + 1 : col,
-                                                between, true);
-                } else {
-                    if (SwingUtilities2.liesInVertical(rect, p, false) == TRAILING) {
-                        row++;
-                    }
-
-                    location = new DropLocation(p, row, col, true, false);
-                }
-
-                break;
-            case INSERT_ROWS:
-                if (row == -1 && col == -1) {
-                    location = new DropLocation(p, -1, -1, false, false);
-                    break;
-                }
-
-                if (row == -1) {
-                    location = new DropLocation(p, getRowCount(), col, true, false);
-                    break;
-                }
-
-                if (SwingUtilities2.liesInVertical(rect, p, false) == TRAILING) {
-                    row++;
-                }
-
-                location = new DropLocation(p, row, col, true, false);
-                break;
-            case ON_OR_INSERT_ROWS:
-                if (row == -1 && col == -1) {
-                    location = new DropLocation(p, -1, -1, false, false);
-                    break;
-                }
-
-                if (row == -1) {
-                    location = new DropLocation(p, getRowCount(), col, true, false);
-                    break;
-                }
-
-                ySection = SwingUtilities2.liesInVertical(rect, p, true);
-                if (ySection == LEADING) {
-                    between = true;
-                } else if (ySection == TRAILING) {
-                    row++;
-                    between = true;
-                }
-
-                location = new DropLocation(p, row, col, between, false);
-                break;
-            case INSERT_COLS:
-                if (row == -1) {
-                    location = new DropLocation(p, -1, -1, false, false);
-                    break;
-                }
-
-                if (col == -1) {
-                    location = new DropLocation(p, getColumnCount(), col, false, true);
-                    break;
-                }
-
-                if (SwingUtilities2.liesInHorizontal(rect, p, ltr, false) == TRAILING) {
-                    col++;
-                }
-
-                location = new DropLocation(p, row, col, false, true);
-                break;
-            case ON_OR_INSERT_COLS:
-                if (row == -1) {
-                    location = new DropLocation(p, -1, -1, false, false);
-                    break;
-                }
-
-                if (col == -1) {
-                    location = new DropLocation(p, row, getColumnCount(), false, true);
-                    break;
-                }
-
-                xSection = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);
-                if (xSection == LEADING) {
-                    between = true;
-                } else if (xSection == TRAILING) {
-                    col++;
-                    between = true;
-                }
-
-                location = new DropLocation(p, row, col, false, between);
-                break;
-            case ON_OR_INSERT:
-                if (row == -1 && col == -1) {
-                    location = new DropLocation(p, 0, 0, true, true);
-                    break;
-                }
-
-                xSection = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);
-
-                if (row == -1) {
-                    if (xSection == LEADING) {
-                        location = new DropLocation(p, getRowCount(), col, true, true);
-                    } else if (xSection == TRAILING) {
-                        location = new DropLocation(p, getRowCount(), col + 1, true, true);
-                    } else {
-                        location = new DropLocation(p, getRowCount(), col, true, false);
-                    }
-
-                    break;
-                }
-
-                ySection = SwingUtilities2.liesInVertical(rect, p, true);
-                if (ySection == LEADING) {
-                    between = true;
-                } else if (ySection == TRAILING) {
-                    row++;
-                    between = true;
-                }
-
-                location = new DropLocation(p, row,
-                                            xSection == TRAILING ? col + 1 : col,
-                                            between,
-                                            xSection != MIDDLE);
-
-                break;
-            default:
-                assert false : "Unexpected drop mode";
-        }
-
-        return location;
-    }
+    DropLocation dropLocationForPoint(Point p) {throw new RuntimeException("cf-bug");} //{
+//        DropLocation location = null;
+//
+//        int row = rowAtPoint(p);
+//        int col = columnAtPoint(p);
+//        boolean outside = Boolean.TRUE == getClientProperty("Table.isFileList")
+//                          && SwingUtilities2.pointOutsidePrefSize(this, row, col, p);
+//
+//        Rectangle rect = getCellRect(row, col, true);
+//        Section xSection, ySection;
+//        boolean between = false;
+//        boolean ltr = getComponentOrientation().isLeftToRight();
+//
+//        switch(dropMode) {
+//            case USE_SELECTION:
+//            case ON:
+//                if (row == -1 || col == -1 || outside) {
+//                    location = new DropLocation(p, -1, -1, false, false);
+//                } else {
+//                    location = new DropLocation(p, row, col, false, false);
+//                }
+//                break;
+//            case INSERT:
+//                if (row == -1 && col == -1) {
+//                    location = new DropLocation(p, 0, 0, true, true);
+//                    break;
+//                }
+//
+//                xSection = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);
+//
+//                if (row == -1) {
+//                    if (xSection == LEADING) {
+//                        location = new DropLocation(p, getRowCount(), col, true, true);
+//                    } else if (xSection == TRAILING) {
+//                        location = new DropLocation(p, getRowCount(), col + 1, true, true);
+//                    } else {
+//                        location = new DropLocation(p, getRowCount(), col, true, false);
+//                    }
+//                } else if (xSection == LEADING || xSection == TRAILING) {
+//                    ySection = SwingUtilities2.liesInVertical(rect, p, true);
+//                    if (ySection == LEADING) {
+//                        between = true;
+//                    } else if (ySection == TRAILING) {
+//                        row++;
+//                        between = true;
+//                    }
+//
+//                    location = new DropLocation(p, row,
+//                                                xSection == TRAILING ? col + 1 : col,
+//                                                between, true);
+//                } else {
+//                    if (SwingUtilities2.liesInVertical(rect, p, false) == TRAILING) {
+//                        row++;
+//                    }
+//
+//                    location = new DropLocation(p, row, col, true, false);
+//                }
+//
+//                break;
+//            case INSERT_ROWS:
+//                if (row == -1 && col == -1) {
+//                    location = new DropLocation(p, -1, -1, false, false);
+//                    break;
+//                }
+//
+//                if (row == -1) {
+//                    location = new DropLocation(p, getRowCount(), col, true, false);
+//                    break;
+//                }
+//
+//                if (SwingUtilities2.liesInVertical(rect, p, false) == TRAILING) {
+//                    row++;
+//                }
+//
+//                location = new DropLocation(p, row, col, true, false);
+//                break;
+//            case ON_OR_INSERT_ROWS:
+//                if (row == -1 && col == -1) {
+//                    location = new DropLocation(p, -1, -1, false, false);
+//                    break;
+//                }
+//
+//                if (row == -1) {
+//                    location = new DropLocation(p, getRowCount(), col, true, false);
+//                    break;
+//                }
+//
+//                ySection = SwingUtilities2.liesInVertical(rect, p, true);
+//                if (ySection == LEADING) {
+//                    between = true;
+//                } else if (ySection == TRAILING) {
+//                    row++;
+//                    between = true;
+//                }
+//
+//                location = new DropLocation(p, row, col, between, false);
+//                break;
+//            case INSERT_COLS:
+//                if (row == -1) {
+//                    location = new DropLocation(p, -1, -1, false, false);
+//                    break;
+//                }
+//
+//                if (col == -1) {
+//                    location = new DropLocation(p, getColumnCount(), col, false, true);
+//                    break;
+//                }
+//
+//                if (SwingUtilities2.liesInHorizontal(rect, p, ltr, false) == TRAILING) {
+//                    col++;
+//                }
+//
+//                location = new DropLocation(p, row, col, false, true);
+//                break;
+//            case ON_OR_INSERT_COLS:
+//                if (row == -1) {
+//                    location = new DropLocation(p, -1, -1, false, false);
+//                    break;
+//                }
+//
+//                if (col == -1) {
+//                    location = new DropLocation(p, row, getColumnCount(), false, true);
+//                    break;
+//                }
+//
+//                xSection = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);
+//                if (xSection == LEADING) {
+//                    between = true;
+//                } else if (xSection == TRAILING) {
+//                    col++;
+//                    between = true;
+//                }
+//
+//                location = new DropLocation(p, row, col, false, between);
+//                break;
+//            case ON_OR_INSERT:
+//                if (row == -1 && col == -1) {
+//                    location = new DropLocation(p, 0, 0, true, true);
+//                    break;
+//                }
+//
+//                xSection = SwingUtilities2.liesInHorizontal(rect, p, ltr, true);
+//
+//                if (row == -1) {
+//                    if (xSection == LEADING) {
+//                        location = new DropLocation(p, getRowCount(), col, true, true);
+//                    } else if (xSection == TRAILING) {
+//                        location = new DropLocation(p, getRowCount(), col + 1, true, true);
+//                    } else {
+//                        location = new DropLocation(p, getRowCount(), col, true, false);
+//                    }
+//
+//                    break;
+//                }
+//
+//                ySection = SwingUtilities2.liesInVertical(rect, p, true);
+//                if (ySection == LEADING) {
+//                    between = true;
+//                } else if (ySection == TRAILING) {
+//                    row++;
+//                    between = true;
+//                }
+//
+//                location = new DropLocation(p, row,
+//                                            xSection == TRAILING ? col + 1 : col,
+//                                            between,
+//                                            xSection != MIDDLE);
+//
+//                break;
+//            default:
+//                assert false : "Unexpected drop mode";
+//        }
+//
+//        return location;
+//    }
 
     /**
      * Called to set or clear the drop location during a DnD operation.
@@ -1728,69 +1728,69 @@
      */
     Object setDropLocation(TransferHandler.DropLocation location,
                            Object state,
-                           boolean forDrop) {
-
-        Object retVal = null;
-        DropLocation tableLocation = (DropLocation)location;
-
-        if (dropMode == DropMode.USE_SELECTION) {
-            if (tableLocation == null) {
-                if (!forDrop && state != null) {
-                    clearSelection();
-
-                    int[] rows = ((int[][])state)[0];
-                    int[] cols = ((int[][])state)[1];
-                    int[] anchleads = ((int[][])state)[2];
-
-                    for (int row : rows) {
-                        addRowSelectionInterval(row, row);
-                    }
-
-                    for (int col : cols) {
-                        addColumnSelectionInterval(col, col);
-                    }
-
-                    SwingUtilities2.setLeadAnchorWithoutSelection(
-                            getSelectionModel(), anchleads[1], anchleads[0]);
-
-                    SwingUtilities2.setLeadAnchorWithoutSelection(
-                            getColumnModel().getSelectionModel(),
-                            anchleads[3], anchleads[2]);
-                }
-            } else {
-                if (dropLocation == null) {
-                    retVal = new int[][]{
-                        getSelectedRows(),
-                        getSelectedColumns(),
-                        {getAdjustedIndex(getSelectionModel()
-                             .getAnchorSelectionIndex(), true),
-                         getAdjustedIndex(getSelectionModel()
-                             .getLeadSelectionIndex(), true),
-                         getAdjustedIndex(getColumnModel().getSelectionModel()
-                             .getAnchorSelectionIndex(), false),
-                         getAdjustedIndex(getColumnModel().getSelectionModel()
-                             .getLeadSelectionIndex(), false)}};
-                } else {
-                    retVal = state;
-                }
-
-                if (tableLocation.getRow() == -1) {
-                    clearSelectionAndLeadAnchor();
-                } else {
-                    setRowSelectionInterval(tableLocation.getRow(),
-                                            tableLocation.getRow());
-                    setColumnSelectionInterval(tableLocation.getColumn(),
-                                               tableLocation.getColumn());
-                }
-            }
-        }
-
-        DropLocation old = dropLocation;
-        dropLocation = tableLocation;
-        firePropertyChange("dropLocation", old, dropLocation);
-
-        return retVal;
-    }
+                           boolean forDrop) {throw new RuntimeException("cf-bug");} //{
+//
+//        Object retVal = null;
+//        DropLocation tableLocation = (DropLocation)location;
+//
+//        if (dropMode == DropMode.USE_SELECTION) {
+//            if (tableLocation == null) {
+//                if (!forDrop && state != null) {
+//                    clearSelection();
+//
+//                    int[] rows = ((int[][])state)[0];
+//                    int[] cols = ((int[][])state)[1];
+//                    int[] anchleads = ((int[][])state)[2];
+//
+//                    for (int row : rows) {
+//                        addRowSelectionInterval(row, row);
+//                    }
+//
+//                    for (int col : cols) {
+//                        addColumnSelectionInterval(col, col);
+//                    }
+//
+//                    SwingUtilities2.setLeadAnchorWithoutSelection(
+//                            getSelectionModel(), anchleads[1], anchleads[0]);
+//
+//                    SwingUtilities2.setLeadAnchorWithoutSelection(
+//                            getColumnModel().getSelectionModel(),
+//                            anchleads[3], anchleads[2]);
+//                }
+//            } else {
+//                if (dropLocation == null) {
+//                    retVal = new int[][]{
+//                        getSelectedRows(),
+//                        getSelectedColumns(),
+//                        {getAdjustedIndex(getSelectionModel()
+//                             .getAnchorSelectionIndex(), true),
+//                         getAdjustedIndex(getSelectionModel()
+//                             .getLeadSelectionIndex(), true),
+//                         getAdjustedIndex(getColumnModel().getSelectionModel()
+//                             .getAnchorSelectionIndex(), false),
+//                         getAdjustedIndex(getColumnModel().getSelectionModel()
+//                             .getLeadSelectionIndex(), false)}};
+//                } else {
+//                    retVal = state;
+//                }
+//
+//                if (tableLocation.getRow() == -1) {
+//                    clearSelectionAndLeadAnchor();
+//                } else {
+//                    setRowSelectionInterval(tableLocation.getRow(),
+//                                            tableLocation.getRow());
+//                    setColumnSelectionInterval(tableLocation.getColumn(),
+//                                               tableLocation.getColumn());
+//                }
+//            }
+//        }
+//
+//        DropLocation old = dropLocation;
+//        dropLocation = tableLocation;
+//        firePropertyChange("dropLocation", old, dropLocation);
+//
+//        return retVal;
+//    }
 
     /**
      * Returns the location that this component should visually indicate
@@ -1810,9 +1810,9 @@
      * @see TransferHandler#canImport(TransferHandler.TransferSupport)
      * @since 1.6
      */
-    public final DropLocation getDropLocation() {
-        return dropLocation;
-    }
+    public final DropLocation getDropLocation() {throw new RuntimeException("cf-bug");} //{
+//        return dropLocation;
+//    }
 
     /**
      * Specifies whether a {@code RowSorter} should be created for the
@@ -1835,15 +1835,15 @@
      *  description: Whether or not to turn on sorting by default.
      * @since 1.6
      */
-    public void setAutoCreateRowSorter(boolean autoCreateRowSorter) {
-        boolean oldValue = this.autoCreateRowSorter;
-        this.autoCreateRowSorter = autoCreateRowSorter;
-        if (autoCreateRowSorter) {
-            setRowSorter(new TableRowSorter<TableModel>(getModel()));
-        }
-        firePropertyChange("autoCreateRowSorter", oldValue,
-                           autoCreateRowSorter);
-    }
+    public void setAutoCreateRowSorter(boolean autoCreateRowSorter) {throw new RuntimeException("cf-bug");} //{
+//        boolean oldValue = this.autoCreateRowSorter;
+//        this.autoCreateRowSorter = autoCreateRowSorter;
+//        if (autoCreateRowSorter) {
+//            setRowSorter(new TableRowSorter<TableModel>(getModel()));
+//        }
+//        firePropertyChange("autoCreateRowSorter", oldValue,
+//                           autoCreateRowSorter);
+//    }
 
     /**
      * Returns {@code true} if whenever the model changes, a new
@@ -1854,9 +1854,9 @@
      *         the model changes
      * @since 1.6
      */
-    public boolean getAutoCreateRowSorter() {
-        return autoCreateRowSorter;
-    }
+    public boolean getAutoCreateRowSorter() {throw new RuntimeException("cf-bug");} //{
+//        return autoCreateRowSorter;
+//    }
 
     /**
      * Specifies whether the selection should be updated after sorting.
@@ -1871,12 +1871,12 @@
      *  description: Whether or not to update the selection on sorting
      * @since 1.6
      */
-    public void setUpdateSelectionOnSort(boolean update) {
-        if (updateSelectionOnSort != update) {
-            updateSelectionOnSort = update;
-            firePropertyChange("updateSelectionOnSort", !update, update);
-        }
-    }
+    public void setUpdateSelectionOnSort(boolean update) {throw new RuntimeException("cf-bug");} //{
+//        if (updateSelectionOnSort != update) {
+//            updateSelectionOnSort = update;
+//            firePropertyChange("updateSelectionOnSort", !update, update);
+//        }
+//    }
 
     /**
      * Returns true if the selection should be updated after sorting.
@@ -1884,9 +1884,9 @@
      * @return whether to update the selection on a sort
      * @since 1.6
      */
-    public boolean getUpdateSelectionOnSort() {
-        return updateSelectionOnSort;
-    }
+    public boolean getUpdateSelectionOnSort() {throw new RuntimeException("cf-bug");} //{
+//        return updateSelectionOnSort;
+//    }
 
     /**
      * Sets the <code>RowSorter</code>.  <code>RowSorter</code> is used
@@ -1910,22 +1910,22 @@
      *  description: The table's RowSorter
      * @since 1.6
      */
-    public void setRowSorter(RowSorter<? extends TableModel> sorter) {
-        RowSorter<? extends TableModel> oldRowSorter = null;
-        if (sortManager != null) {
-            oldRowSorter = sortManager.sorter;
-            sortManager.dispose();
-            sortManager = null;
-        }
-        rowModel = null;
-        clearSelectionAndLeadAnchor();
-        if (sorter != null) {
-            sortManager = new SortManager(sorter);
-        }
-        resizeAndRepaint();
-        firePropertyChange("rowSorter", oldRowSorter, sorter);
-        firePropertyChange("sorter", oldRowSorter, sorter);
-    }
+    public void setRowSorter(RowSorter<? extends TableModel> sorter) {throw new RuntimeException("cf-bug");} //{
+//        RowSorter<? extends TableModel> oldRowSorter = null;
+//        if (sortManager != null) {
+//            oldRowSorter = sortManager.sorter;
+//            sortManager.dispose();
+//            sortManager = null;
+//        }
+//        rowModel = null;
+//        clearSelectionAndLeadAnchor();
+//        if (sorter != null) {
+//            sortManager = new SortManager(sorter);
+//        }
+//        resizeAndRepaint();
+//        firePropertyChange("rowSorter", oldRowSorter, sorter);
+//        firePropertyChange("sorter", oldRowSorter, sorter);
+//    }
 
     /**
      * Returns the object responsible for sorting.
@@ -1933,9 +1933,9 @@
      * @return the object responsible for sorting
      * @since 1.6
      */
-    public RowSorter<? extends TableModel> getRowSorter() {
-        return (sortManager != null) ? sortManager.sorter : null;
-    }
+    public RowSorter<? extends TableModel> getRowSorter() {throw new RuntimeException("cf-bug");} //{
+//        return (sortManager != null) ? sortManager.sorter : null;
+//    }
 
 //
 // Selection methods
@@ -1966,11 +1966,11 @@
      *              SINGLE_INTERVAL_SELECTION   ListSelectionModel.SINGLE_INTERVAL_SELECTION
      *              MULTIPLE_INTERVAL_SELECTION ListSelectionModel.MULTIPLE_INTERVAL_SELECTION
      */
-    public void setSelectionMode(int selectionMode) {
-        clearSelection();
-        getSelectionModel().setSelectionMode(selectionMode);
-        getColumnModel().getSelectionModel().setSelectionMode(selectionMode);
-    }
+    public void setSelectionMode(int selectionMode) {throw new RuntimeException("cf-bug");} //{
+//        clearSelection();
+//        getSelectionModel().setSelectionMode(selectionMode);
+//        getColumnModel().getSelectionModel().setSelectionMode(selectionMode);
+//    }
 
     /**
      * Sets whether the rows in this model can be selected.
@@ -1982,14 +1982,14 @@
      *    attribute: visualUpdate true
      *  description: If true, an entire row is selected for each selected cell.
      */
-    public void setRowSelectionAllowed(boolean rowSelectionAllowed) {
-        boolean old = this.rowSelectionAllowed;
-        this.rowSelectionAllowed = rowSelectionAllowed;
-        if (old != rowSelectionAllowed) {
-            repaint();
-        }
-        firePropertyChange("rowSelectionAllowed", old, rowSelectionAllowed);
-    }
+    public void setRowSelectionAllowed(boolean rowSelectionAllowed) {throw new RuntimeException("cf-bug");} //{
+//        boolean old = this.rowSelectionAllowed;
+//        this.rowSelectionAllowed = rowSelectionAllowed;
+//        if (old != rowSelectionAllowed) {
+//            repaint();
+//        }
+//        firePropertyChange("rowSelectionAllowed", old, rowSelectionAllowed);
+//    }
 
     /**
      * Returns true if rows can be selected.
@@ -1997,9 +1997,9 @@
      * @return true if rows can be selected, otherwise false
      * @see #setRowSelectionAllowed
      */
-    public boolean getRowSelectionAllowed() {
-        return rowSelectionAllowed;
-    }
+    public boolean getRowSelectionAllowed() {throw new RuntimeException("cf-bug");} //{
+//        return rowSelectionAllowed;
+//    }
 
     /**
      * Sets whether the columns in this model can be selected.
@@ -2011,14 +2011,14 @@
      *    attribute: visualUpdate true
      *  description: If true, an entire column is selected for each selected cell.
      */
-    public void setColumnSelectionAllowed(boolean columnSelectionAllowed) {
-        boolean old = columnModel.getColumnSelectionAllowed();
-        columnModel.setColumnSelectionAllowed(columnSelectionAllowed);
-        if (old != columnSelectionAllowed) {
-            repaint();
-        }
-        firePropertyChange("columnSelectionAllowed", old, columnSelectionAllowed);
-    }
+    public void setColumnSelectionAllowed(boolean columnSelectionAllowed) {throw new RuntimeException("cf-bug");} //{
+//        boolean old = columnModel.getColumnSelectionAllowed();
+//        columnModel.setColumnSelectionAllowed(columnSelectionAllowed);
+//        if (old != columnSelectionAllowed) {
+//            repaint();
+//        }
+//        firePropertyChange("columnSelectionAllowed", old, columnSelectionAllowed);
+//    }
 
     /**
      * Returns true if columns can be selected.
@@ -2026,9 +2026,9 @@
      * @return true if columns can be selected, otherwise false
      * @see #setColumnSelectionAllowed
      */
-    public boolean getColumnSelectionAllowed() {
-        return columnModel.getColumnSelectionAllowed();
-    }
+    public boolean getColumnSelectionAllowed() {throw new RuntimeException("cf-bug");} //{
+//        return columnModel.getColumnSelectionAllowed();
+//    }
 
     /**
      * Sets whether this table allows both a column selection and a
@@ -2050,13 +2050,13 @@
      *  description: Select a rectangular region of cells rather than
      *               rows or columns.
      */
-    public void setCellSelectionEnabled(boolean cellSelectionEnabled) {
-        setRowSelectionAllowed(cellSelectionEnabled);
-        setColumnSelectionAllowed(cellSelectionEnabled);
-        boolean old = this.cellSelectionEnabled;
-        this.cellSelectionEnabled = cellSelectionEnabled;
-        firePropertyChange("cellSelectionEnabled", old, cellSelectionEnabled);
-    }
+    public void setCellSelectionEnabled(boolean cellSelectionEnabled) {throw new RuntimeException("cf-bug");} //{
+//        setRowSelectionAllowed(cellSelectionEnabled);
+//        setColumnSelectionAllowed(cellSelectionEnabled);
+//        boolean old = this.cellSelectionEnabled;
+//        this.cellSelectionEnabled = cellSelectionEnabled;
+//        firePropertyChange("cellSelectionEnabled", old, cellSelectionEnabled);
+//    }
 
     /**
      * Returns true if both row and column selection models are enabled.
@@ -2067,90 +2067,90 @@
      *
      * @see #setCellSelectionEnabled
      */
-    public boolean getCellSelectionEnabled() {
-        return getRowSelectionAllowed() && getColumnSelectionAllowed();
-    }
+    public boolean getCellSelectionEnabled() {throw new RuntimeException("cf-bug");} //{
+//        return getRowSelectionAllowed() && getColumnSelectionAllowed();
+//    }
 
     /**
      *  Selects all rows, columns, and cells in the table.
      */
-    public void selectAll() {
-        // If I'm currently editing, then I should stop editing
-        if (isEditing()) {
-            removeEditor();
-        }
-        if (getRowCount() > 0 && getColumnCount() > 0) {
-            int oldLead;
-            int oldAnchor;
-            ListSelectionModel selModel;
-
-            selModel = selectionModel;
-            selModel.setValueIsAdjusting(true);
-            oldLead = getAdjustedIndex(selModel.getLeadSelectionIndex(), true);
-            oldAnchor = getAdjustedIndex(selModel.getAnchorSelectionIndex(), true);
-
-            setRowSelectionInterval(0, getRowCount()-1);
-
-            // this is done to restore the anchor and lead
-            SwingUtilities2.setLeadAnchorWithoutSelection(selModel, oldLead, oldAnchor);
-
-            selModel.setValueIsAdjusting(false);
-
-            selModel = columnModel.getSelectionModel();
-            selModel.setValueIsAdjusting(true);
-            oldLead = getAdjustedIndex(selModel.getLeadSelectionIndex(), false);
-            oldAnchor = getAdjustedIndex(selModel.getAnchorSelectionIndex(), false);
-
-            setColumnSelectionInterval(0, getColumnCount()-1);
-
-            // this is done to restore the anchor and lead
-            SwingUtilities2.setLeadAnchorWithoutSelection(selModel, oldLead, oldAnchor);
-
-            selModel.setValueIsAdjusting(false);
-        }
-    }
+    public void selectAll() {throw new RuntimeException("cf-bug");} //{
+//        // If I'm currently editing, then I should stop editing
+//        if (isEditing()) {
+//            removeEditor();
+//        }
+//        if (getRowCount() > 0 && getColumnCount() > 0) {
+//            int oldLead;
+//            int oldAnchor;
+//            ListSelectionModel selModel;
+//
+//            selModel = selectionModel;
+//            selModel.setValueIsAdjusting(true);
+//            oldLead = getAdjustedIndex(selModel.getLeadSelectionIndex(), true);
+//            oldAnchor = getAdjustedIndex(selModel.getAnchorSelectionIndex(), true);
+//
+//            setRowSelectionInterval(0, getRowCount()-1);
+//
+//            // this is done to restore the anchor and lead
+//            SwingUtilities2.setLeadAnchorWithoutSelection(selModel, oldLead, oldAnchor);
+//
+//            selModel.setValueIsAdjusting(false);
+//
+//            selModel = columnModel.getSelectionModel();
+//            selModel.setValueIsAdjusting(true);
+//            oldLead = getAdjustedIndex(selModel.getLeadSelectionIndex(), false);
+//            oldAnchor = getAdjustedIndex(selModel.getAnchorSelectionIndex(), false);
+//
+//            setColumnSelectionInterval(0, getColumnCount()-1);
+//
+//            // this is done to restore the anchor and lead
+//            SwingUtilities2.setLeadAnchorWithoutSelection(selModel, oldLead, oldAnchor);
+//
+//            selModel.setValueIsAdjusting(false);
+//        }
+//    }
 
     /**
      * Deselects all selected columns and rows.
      */
-    public void clearSelection() {
-        selectionModel.clearSelection();
-        columnModel.getSelectionModel().clearSelection();
-    }
-
-    private void clearSelectionAndLeadAnchor() {
-        selectionModel.setValueIsAdjusting(true);
-        columnModel.getSelectionModel().setValueIsAdjusting(true);
-
-        clearSelection();
-
-        selectionModel.setAnchorSelectionIndex(-1);
-        selectionModel.setLeadSelectionIndex(-1);
-        columnModel.getSelectionModel().setAnchorSelectionIndex(-1);
-        columnModel.getSelectionModel().setLeadSelectionIndex(-1);
-
-        selectionModel.setValueIsAdjusting(false);
-        columnModel.getSelectionModel().setValueIsAdjusting(false);
-    }
-
-    private int getAdjustedIndex(int index, boolean row) {
-        int compare = row ? getRowCount() : getColumnCount();
-        return index < compare ? index : -1;
-    }
-
-    private int boundRow(int row) throws IllegalArgumentException {
-        if (row < 0 || row >= getRowCount()) {
-            throw new IllegalArgumentException("Row index out of range");
-        }
-        return row;
-    }
-
-    private int boundColumn(int col) {
-        if (col< 0 || col >= getColumnCount()) {
-            throw new IllegalArgumentException("Column index out of range");
-        }
-        return col;
-    }
+    public void clearSelection() {throw new RuntimeException("cf-bug");} //{
+//        selectionModel.clearSelection();
+//        columnModel.getSelectionModel().clearSelection();
+//    }
+
+    private void clearSelectionAndLeadAnchor() {throw new RuntimeException("cf-bug");} //{
+//        selectionModel.setValueIsAdjusting(true);
+//        columnModel.getSelectionModel().setValueIsAdjusting(true);
+//
+//        clearSelection();
+//
+//        selectionModel.setAnchorSelectionIndex(-1);
+//        selectionModel.setLeadSelectionIndex(-1);
+//        columnModel.getSelectionModel().setAnchorSelectionIndex(-1);
+//        columnModel.getSelectionModel().setLeadSelectionIndex(-1);
+//
+//        selectionModel.setValueIsAdjusting(false);
+//        columnModel.getSelectionModel().setValueIsAdjusting(false);
+//    }
+
+    private int getAdjustedIndex(int index, boolean row) {throw new RuntimeException("cf-bug");} //{
+//        int compare = row ? getRowCount() : getColumnCount();
+//        return index < compare ? index : -1;
+//    }
+
+    private int boundRow(int row) throws IllegalArgumentException {throw new RuntimeException("cf-bug");} //{
+//        if (row < 0 || row >= getRowCount()) {
+//            throw new IllegalArgumentException("Row index out of range");
+//        }
+//        return row;
+//    }
+
+    private int boundColumn(int col) {throw new RuntimeException("cf-bug");} //{
+//        if (col< 0 || col >= getColumnCount()) {
+//            throw new IllegalArgumentException("Column index out of range");
+//        }
+//        return col;
+//    }
 
     /**
      * Selects the rows from <code>index0</code> to <code>index1</code>,
@@ -2162,9 +2162,9 @@
      * @param   index0 one end of the interval
      * @param   index1 the other end of the interval
      */
-    public void setRowSelectionInterval(int index0, int index1) {
-        selectionModel.setSelectionInterval(boundRow(index0), boundRow(index1));
-    }
+    public void setRowSelectionInterval(int index0, int index1) {throw new RuntimeException("cf-bug");} //{
+//        selectionModel.setSelectionInterval(boundRow(index0), boundRow(index1));
+//    }
 
     /**
      * Selects the columns from <code>index0</code> to <code>index1</code>,
@@ -2176,9 +2176,9 @@
      * @param   index0 one end of the interval
      * @param   index1 the other end of the interval
      */
-    public void setColumnSelectionInterval(int index0, int index1) {
-        columnModel.getSelectionModel().setSelectionInterval(boundColumn(index0), boundColumn(index1));
-    }
+    public void setColumnSelectionInterval(int index0, int index1) {throw new RuntimeException("cf-bug");} //{
+//        columnModel.getSelectionModel().setSelectionInterval(boundColumn(index0), boundColumn(index1));
+//    }
 
     /**
      * Adds the rows from <code>index0</code> to <code>index1</code>, inclusive, to
@@ -2189,9 +2189,9 @@
      * @param   index0 one end of the interval
      * @param   index1 the other end of the interval
      */
-    public void addRowSelectionInterval(int index0, int index1) {
-        selectionModel.addSelectionInterval(boundRow(index0), boundRow(index1));
-    }
+    public void addRowSelectionInterval(int index0, int index1) {throw new RuntimeException("cf-bug");} //{
+//        selectionModel.addSelectionInterval(boundRow(index0), boundRow(index1));
+//    }
 
     /**
      * Adds the columns from <code>index0</code> to <code>index1</code>,
@@ -2203,9 +2203,9 @@
      * @param   index0 one end of the interval
      * @param   index1 the other end of the interval
      */
-    public void addColumnSelectionInterval(int index0, int index1) {
-        columnModel.getSelectionModel().addSelectionInterval(boundColumn(index0), boundColumn(index1));
-    }
+    public void addColumnSelectionInterval(int index0, int index1) {throw new RuntimeException("cf-bug");} //{
+//        columnModel.getSelectionModel().addSelectionInterval(boundColumn(index0), boundColumn(index1));
+//    }
 
     /**
      * Deselects the rows from <code>index0</code> to <code>index1</code>, inclusive.
@@ -2216,9 +2216,9 @@
      * @param   index0 one end of the interval
      * @param   index1 the other end of the interval
      */
-    public void removeRowSelectionInterval(int index0, int index1) {
-        selectionModel.removeSelectionInterval(boundRow(index0), boundRow(index1));
-    }
+    public void removeRowSelectionInterval(int index0, int index1) {throw new RuntimeException("cf-bug");} //{
+//        selectionModel.removeSelectionInterval(boundRow(index0), boundRow(index1));
+//    }
 
     /**
      * Deselects the columns from <code>index0</code> to <code>index1</code>, inclusive.
@@ -2229,26 +2229,26 @@
      * @param   index0 one end of the interval
      * @param   index1 the other end of the interval
      */
-    public void removeColumnSelectionInterval(int index0, int index1) {
-        columnModel.getSelectionModel().removeSelectionInterval(boundColumn(index0), boundColumn(index1));
-    }
+    public void removeColumnSelectionInterval(int index0, int index1) {throw new RuntimeException("cf-bug");} //{
+//        columnModel.getSelectionModel().removeSelectionInterval(boundColumn(index0), boundColumn(index1));
+//    }
 
     /**
      * Returns the index of the first selected row, -1 if no row is selected.
      * @return the index of the first selected row
      */
-    public int getSelectedRow() {
-        return selectionModel.getMinSelectionIndex();
-    }
+    public int getSelectedRow() {throw new RuntimeException("cf-bug");} //{
+//        return selectionModel.getMinSelectionIndex();
+//    }
 
     /**
      * Returns the index of the first selected column,
      * -1 if no column is selected.
      * @return the index of the first selected column
      */
-    public int getSelectedColumn() {
-        return columnModel.getSelectionModel().getMinSelectionIndex();
-    }
+    public int getSelectedColumn() {throw new RuntimeException("cf-bug");} //{
+//        return columnModel.getSelectionModel().getMinSelectionIndex();
+//    }
 
     /**
      * Returns the indices of all selected rows.
@@ -2257,25 +2257,25 @@
      *         or an empty array if no row is selected
      * @see #getSelectedRow
      */
-    public int[] getSelectedRows() {
-        int iMin = selectionModel.getMinSelectionIndex();
-        int iMax = selectionModel.getMaxSelectionIndex();
-
-        if ((iMin == -1) || (iMax == -1)) {
-            return new int[0];
-        }
-
-        int[] rvTmp = new int[1+ (iMax - iMin)];
-        int n = 0;
-        for(int i = iMin; i <= iMax; i++) {
-            if (selectionModel.isSelectedIndex(i)) {
-                rvTmp[n++] = i;
-            }
-        }
-        int[] rv = new int[n];
-        System.arraycopy(rvTmp, 0, rv, 0, n);
-        return rv;
-    }
+    public int[] getSelectedRows() {throw new RuntimeException("cf-bug");} //{
+//        int iMin = selectionModel.getMinSelectionIndex();
+//        int iMax = selectionModel.getMaxSelectionIndex();
+//
+//        if ((iMin == -1) || (iMax == -1)) {
+//            return new int[0];
+//        }
+//
+//        int[] rvTmp = new int[1+ (iMax - iMin)];
+//        int n = 0;
+//        for(int i = iMin; i <= iMax; i++) {
+//            if (selectionModel.isSelectedIndex(i)) {
+//                rvTmp[n++] = i;
+//            }
+//        }
+//        int[] rv = new int[n];
+//        System.arraycopy(rvTmp, 0, rv, 0, n);
+//        return rv;
+//    }
 
     /**
      * Returns the indices of all selected columns.
@@ -2284,36 +2284,36 @@
      *         or an empty array if no column is selected
      * @see #getSelectedColumn
      */
-    public int[] getSelectedColumns() {
-        return columnModel.getSelectedColumns();
-    }
+    public int[] getSelectedColumns() {throw new RuntimeException("cf-bug");} //{
+//        return columnModel.getSelectedColumns();
+//    }
 
     /**
      * Returns the number of selected rows.
      *
      * @return the number of selected rows, 0 if no rows are selected
      */
-    public int getSelectedRowCount() {
-        int iMin = selectionModel.getMinSelectionIndex();
-        int iMax = selectionModel.getMaxSelectionIndex();
-        int count = 0;
-
-        for(int i = iMin; i <= iMax; i++) {
-            if (selectionModel.isSelectedIndex(i)) {
-                count++;
-            }
-        }
-        return count;
-    }
+    public int getSelectedRowCount() {throw new RuntimeException("cf-bug");} //{
+//        int iMin = selectionModel.getMinSelectionIndex();
+//        int iMax = selectionModel.getMaxSelectionIndex();
+//        int count = 0;
+//
+//        for(int i = iMin; i <= iMax; i++) {
+//            if (selectionModel.isSelectedIndex(i)) {
+//                count++;
+//            }
+//        }
+//        return count;
+//    }
 
     /**
      * Returns the number of selected columns.
      *
      * @return the number of selected columns, 0 if no columns are selected
      */
-    public int getSelectedColumnCount() {
-        return columnModel.getSelectedColumnCount();
-    }
+    public int getSelectedColumnCount() {throw new RuntimeException("cf-bug");} //{
+//        return columnModel.getSelectedColumnCount();
+//    }
 
     /**
      * Returns true if the specified index is in the valid range of rows,
@@ -2322,9 +2322,9 @@
      * @return true if <code>row</code> is a valid index and the row at
      *              that index is selected (where 0 is the first row)
      */
-    public boolean isRowSelected(int row) {
-        return selectionModel.isSelectedIndex(row);
-    }
+    public boolean isRowSelected(int row) {throw new RuntimeException("cf-bug");} //{
+//        return selectionModel.isSelectedIndex(row);
+//    }
 
     /**
      * Returns true if the specified index is in the valid range of columns,
@@ -2334,9 +2334,9 @@
      * @return true if <code>column</code> is a valid index and the column at
      *              that index is selected (where 0 is the first column)
      */
-    public boolean isColumnSelected(int column) {
-        return columnModel.getSelectionModel().isSelectedIndex(column);
-    }
+    public boolean isColumnSelected(int column) {throw new RuntimeException("cf-bug");} //{
+//        return columnModel.getSelectionModel().isSelectedIndex(column);
+//    }
 
     /**
      * Returns true if the specified indices are in the valid range of rows
@@ -2348,48 +2348,48 @@
      *              and the cell at index <code>(row, column)</code> is selected,
      *              where the first row and first column are at index 0
      */
-    public boolean isCellSelected(int row, int column) {
-        if (!getRowSelectionAllowed() && !getColumnSelectionAllowed()) {
-            return false;
-        }
-        return (!getRowSelectionAllowed() || isRowSelected(row)) &&
-               (!getColumnSelectionAllowed() || isColumnSelected(column));
-    }
+    public boolean isCellSelected(int row, int column) {throw new RuntimeException("cf-bug");} //{
+//        if (!getRowSelectionAllowed() && !getColumnSelectionAllowed()) {
+//            return false;
+//        }
+//        return (!getRowSelectionAllowed() || isRowSelected(row)) &&
+//               (!getColumnSelectionAllowed() || isColumnSelected(column));
+//    }
 
     private void changeSelectionModel(ListSelectionModel sm, int index,
                                       boolean toggle, boolean extend, boolean selected,
-                                      int anchor, boolean anchorSelected) {
-        if (extend) {
-            if (toggle) {
-                if (anchorSelected) {
-                    sm.addSelectionInterval(anchor, index);
-                } else {
-                    sm.removeSelectionInterval(anchor, index);
-                    // this is a Windows-only behavior that we want for file lists
-                    if (Boolean.TRUE == getClientProperty("Table.isFileList")) {
-                        sm.addSelectionInterval(index, index);
-                        sm.setAnchorSelectionIndex(anchor);
-                    }
-                }
-            }
-            else {
-                sm.setSelectionInterval(anchor, index);
-            }
-        }
-        else {
-            if (toggle) {
-                if (selected) {
-                    sm.removeSelectionInterval(index, index);
-                }
-                else {
-                    sm.addSelectionInterval(index, index);
-                }
-            }
-            else {
-                sm.setSelectionInterval(index, index);
-            }
-        }
-    }
+                                      int anchor, boolean anchorSelected) {throw new RuntimeException("cf-bug");} //{
+//        if (extend) {
+//            if (toggle) {
+//                if (anchorSelected) {
+//                    sm.addSelectionInterval(anchor, index);
+//                } else {
+//                    sm.removeSelectionInterval(anchor, index);
+//                    // this is a Windows-only behavior that we want for file lists
+//                    if (Boolean.TRUE == getClientProperty("Table.isFileList")) {
+//                        sm.addSelectionInterval(index, index);
+//                        sm.setAnchorSelectionIndex(anchor);
+//                    }
+//                }
+//            }
+//            else {
+//                sm.setSelectionInterval(anchor, index);
+//            }
+//        }
+//        else {
+//            if (toggle) {
+//                if (selected) {
+//                    sm.removeSelectionInterval(index, index);
+//                }
+//                else {
+//                    sm.addSelectionInterval(index, index);
+//                }
+//            }
+//            else {
+//                sm.setSelectionInterval(index, index);
+//            }
+//        }
+//    }
 
     /**
      * Updates the selection models of the table, depending on the state of the
@@ -2420,54 +2420,54 @@
      *
      * @since 1.3
      */
-    public void changeSelection(int rowIndex, int columnIndex, boolean toggle, boolean extend) {
-        ListSelectionModel rsm = getSelectionModel();
-        ListSelectionModel csm = getColumnModel().getSelectionModel();
-
-        int anchorRow = getAdjustedIndex(rsm.getAnchorSelectionIndex(), true);
-        int anchorCol = getAdjustedIndex(csm.getAnchorSelectionIndex(), false);
-
-        boolean anchorSelected = true;
-
-        if (anchorRow == -1) {
-            if (getRowCount() > 0) {
-                anchorRow = 0;
-            }
-            anchorSelected = false;
-        }
-
-        if (anchorCol == -1) {
-            if (getColumnCount() > 0) {
-                anchorCol = 0;
-            }
-            anchorSelected = false;
-        }
-
-        // Check the selection here rather than in each selection model.
-        // This is significant in cell selection mode if we are supposed
-        // to be toggling the selection. In this case it is better to
-        // ensure that the cell's selection state will indeed be changed.
-        // If this were done in the code for the selection model it
-        // might leave a cell in selection state if the row was
-        // selected but the column was not - as it would toggle them both.
-        boolean selected = isCellSelected(rowIndex, columnIndex);
-        anchorSelected = anchorSelected && isCellSelected(anchorRow, anchorCol);
-
-        changeSelectionModel(csm, columnIndex, toggle, extend, selected,
-                             anchorCol, anchorSelected);
-        changeSelectionModel(rsm, rowIndex, toggle, extend, selected,
-                             anchorRow, anchorSelected);
-
-        // Scroll after changing the selection as blit scrolling is immediate,
-        // so that if we cause the repaint after the scroll we end up painting
-        // everything!
-        if (getAutoscrolls()) {
-            Rectangle cellRect = getCellRect(rowIndex, columnIndex, false);
-            if (cellRect != null) {
-                scrollRectToVisible(cellRect);
-            }
-        }
-    }
+    public void changeSelection(int rowIndex, int columnIndex, boolean toggle, boolean extend) {throw new RuntimeException("cf-bug");} //{
+//        ListSelectionModel rsm = getSelectionModel();
+//        ListSelectionModel csm = getColumnModel().getSelectionModel();
+//
+//        int anchorRow = getAdjustedIndex(rsm.getAnchorSelectionIndex(), true);
+//        int anchorCol = getAdjustedIndex(csm.getAnchorSelectionIndex(), false);
+//
+//        boolean anchorSelected = true;
+//
+//        if (anchorRow == -1) {
+//            if (getRowCount() > 0) {
+//                anchorRow = 0;
+//            }
+//            anchorSelected = false;
+//        }
+//
+//        if (anchorCol == -1) {
+//            if (getColumnCount() > 0) {
+//                anchorCol = 0;
+//            }
+//            anchorSelected = false;
+//        }
+//
+//        // Check the selection here rather than in each selection model.
+//        // This is significant in cell selection mode if we are supposed
+//        // to be toggling the selection. In this case it is better to
+//        // ensure that the cell's selection state will indeed be changed.
+//        // If this were done in the code for the selection model it
+//        // might leave a cell in selection state if the row was
+//        // selected but the column was not - as it would toggle them both.
+//        boolean selected = isCellSelected(rowIndex, columnIndex);
+//        anchorSelected = anchorSelected && isCellSelected(anchorRow, anchorCol);
+//
+//        changeSelectionModel(csm, columnIndex, toggle, extend, selected,
+//                             anchorCol, anchorSelected);
+//        changeSelectionModel(rsm, rowIndex, toggle, extend, selected,
+//                             anchorRow, anchorSelected);
+//
+//        // Scroll after changing the selection as blit scrolling is immediate,
+//        // so that if we cause the repaint after the scroll we end up painting
+//        // everything!
+//        if (getAutoscrolls()) {
+//            Rectangle cellRect = getCellRect(rowIndex, columnIndex, false);
+//            if (cellRect != null) {
+//                scrollRectToVisible(cellRect);
+//            }
+//        }
+//    }
 
     /**
      * Returns the foreground color for selected cells.
@@ -2476,9 +2476,9 @@
      * @see #setSelectionForeground
      * @see #setSelectionBackground
      */
-    public Color getSelectionForeground() {
-        return selectionForeground;
-    }
+    public Color getSelectionForeground() {throw new RuntimeException("cf-bug");} //{
+//        return selectionForeground;
+//    }
 
     /**
      * Sets the foreground color for selected cells.  Cell renderers
@@ -2501,12 +2501,12 @@
      *       bound: true
      * description: A default foreground color for selected cells.
      */
-    public void setSelectionForeground(Color selectionForeground) {
-        Color old = this.selectionForeground;
-        this.selectionForeground = selectionForeground;
-        firePropertyChange("selectionForeground", old, selectionForeground);
-        repaint();
-    }
+    public void setSelectionForeground(Color selectionForeground) {throw new RuntimeException("cf-bug");} //{
+//        Color old = this.selectionForeground;
+//        this.selectionForeground = selectionForeground;
+//        firePropertyChange("selectionForeground", old, selectionForeground);
+//        repaint();
+//    }
 
     /**
      * Returns the background color for selected cells.
@@ -2515,9 +2515,9 @@
      * @see #setSelectionBackground
      * @see #setSelectionForeground
      */
-    public Color getSelectionBackground() {
-        return selectionBackground;
-    }
+    public Color getSelectionBackground() {throw new RuntimeException("cf-bug");} //{
+//        return selectionBackground;
+//    }
 
     /**
      * Sets the background color for selected cells.  Cell renderers
@@ -2539,12 +2539,12 @@
      *       bound: true
      * description: A default background color for selected cells.
      */
-    public void setSelectionBackground(Color selectionBackground) {
-        Color old = this.selectionBackground;
-        this.selectionBackground = selectionBackground;
-        firePropertyChange("selectionBackground", old, selectionBackground);
-        repaint();
-    }
+    public void setSelectionBackground(Color selectionBackground) {throw new RuntimeException("cf-bug");} //{
+//        Color old = this.selectionBackground;
+//        this.selectionBackground = selectionBackground;
+//        firePropertyChange("selectionBackground", old, selectionBackground);
+//        repaint();
+//    }
 
     /**
      * Returns the <code>TableColumn</code> object for the column in the table
@@ -2556,11 +2556,11 @@
      *
      * @param   identifier                      the identifier object
      */
-    public TableColumn getColumn(Object identifier) {
-        TableColumnModel cm = getColumnModel();
-        int columnIndex = cm.getColumnIndex(identifier);
-        return cm.getColumn(columnIndex);
-    }
+    public TableColumn getColumn(Object identifier) {throw new RuntimeException("cf-bug");} //{
+//        TableColumnModel cm = getColumnModel();
+//        int columnIndex = cm.getColumnIndex(identifier);
+//        return cm.getColumn(columnIndex);
+//    }
 
 //
 // Informally implement the TableModel interface.
@@ -2578,10 +2578,10 @@
      *
      * @see #convertColumnIndexToView
      */
-    public int convertColumnIndexToModel(int viewColumnIndex) {
-        return SwingUtilities2.convertColumnIndexToModel(
-                getColumnModel(), viewColumnIndex);
-    }
+    public int convertColumnIndexToModel(int viewColumnIndex) {throw new RuntimeException("cf-bug");} //{
+//        return SwingUtilities2.convertColumnIndexToModel(
+//                getColumnModel(), viewColumnIndex);
+//    }
 
     /**
      * Maps the index of the column in the table model at
@@ -2596,10 +2596,10 @@
      *
      * @see #convertColumnIndexToModel
      */
-    public int convertColumnIndexToView(int modelColumnIndex) {
-        return SwingUtilities2.convertColumnIndexToView(
-                getColumnModel(), modelColumnIndex);
-    }
+    public int convertColumnIndexToView(int modelColumnIndex) {throw new RuntimeException("cf-bug");} //{
+//        return SwingUtilities2.convertColumnIndexToView(
+//                getColumnModel(), modelColumnIndex);
+//    }
 
     /**
      * Maps the index of the row in terms of the
@@ -2614,13 +2614,13 @@
      * @see javax.swing.table.TableRowSorter
      * @since 1.6
      */
-    public int convertRowIndexToView(int modelRowIndex) {
-        RowSorter sorter = getRowSorter();
-        if (sorter != null) {
-            return sorter.convertRowIndexToView(modelRowIndex);
-        }
-        return modelRowIndex;
-    }
+    public int convertRowIndexToView(int modelRowIndex) {throw new RuntimeException("cf-bug");} //{
+//        RowSorter sorter = getRowSorter();
+//        if (sorter != null) {
+//            return sorter.convertRowIndexToView(modelRowIndex);
+//        }
+//        return modelRowIndex;
+//    }
 
     /**
      * Maps the index of the row in terms of the view to the
@@ -2636,13 +2636,13 @@
      * @see #getRowCount
      * @since 1.6
      */
-    public int convertRowIndexToModel(int viewRowIndex) {
-        RowSorter sorter = getRowSorter();
-        if (sorter != null) {
-            return sorter.convertRowIndexToModel(viewRowIndex);
-        }
-        return viewRowIndex;
-    }
+    public int convertRowIndexToModel(int viewRowIndex) {throw new RuntimeException("cf-bug");} //{
+//        RowSorter sorter = getRowSorter();
+//        if (sorter != null) {
+//            return sorter.convertRowIndexToModel(viewRowIndex);
+//        }
+//        return viewRowIndex;
+//    }
 
     /**
      * Returns the number of rows that can be shown in the
@@ -2654,13 +2654,13 @@
      * @return the number of rows shown in the <code>JTable</code>
      * @see #getColumnCount
      */
-    public int getRowCount() {
-        RowSorter sorter = getRowSorter();
-        if (sorter != null) {
-            return sorter.getViewRowCount();
-        }
-        return getModel().getRowCount();
-    }
+    public int getRowCount() {throw new RuntimeException("cf-bug");} //{
+//        RowSorter sorter = getRowSorter();
+//        if (sorter != null) {
+//            return sorter.getViewRowCount();
+//        }
+//        return getModel().getRowCount();
+//    }
 
     /**
      * Returns the number of columns in the column model. Note that this may
@@ -2670,9 +2670,9 @@
      * @see #getRowCount
      * @see #removeColumn
      */
-    public int getColumnCount() {
-        return getColumnModel().getColumnCount();
-    }
+    public int getColumnCount() {throw new RuntimeException("cf-bug");} //{
+//        return getColumnModel().getColumnCount();
+//    }
 
     /**
      * Returns the name of the column appearing in the view at
@@ -2682,9 +2682,9 @@
      * @return the name of the column at position <code>column</code>
                         in the view where the first column is column 0
      */
-    public String getColumnName(int column) {
-        return getModel().getColumnName(convertColumnIndexToModel(column));
-    }
+    public String getColumnName(int column) {throw new RuntimeException("cf-bug");} //{
+//        return getModel().getColumnName(convertColumnIndexToModel(column));
+//    }
 
     /**
      * Returns the type of the column appearing in the view at
@@ -2694,9 +2694,9 @@
      * @return the type of the column at position <code>column</code>
      *          in the view where the first column is column 0
      */
-    public Class<?> getColumnClass(int column) {
-        return getModel().getColumnClass(convertColumnIndexToModel(column));
-    }
+    public Class<?> getColumnClass(int column) {throw new RuntimeException("cf-bug");} //{
+//        return getModel().getColumnClass(convertColumnIndexToModel(column));
+//    }
 
     /**
      * Returns the cell value at <code>row</code> and <code>column</code>.
@@ -2713,10 +2713,10 @@
      * @param   column          the column whose value is to be queried
      * @return  the Object at the specified cell
      */
-    public Object getValueAt(int row, int column) {
-        return getModel().getValueAt(convertRowIndexToModel(row),
-                                     convertColumnIndexToModel(column));
-    }
+    public Object getValueAt(int row, int column) {throw new RuntimeException("cf-bug");} //{
+//        return getModel().getValueAt(convertRowIndexToModel(row),
+//                                     convertColumnIndexToModel(column));
+//    }
 
     /**
      * Sets the value for the cell in the table model at <code>row</code>
@@ -2737,10 +2737,10 @@
      * @param   column          the column of the cell to be changed
      * @see #getValueAt
      */
-    public void setValueAt(Object aValue, int row, int column) {
-        getModel().setValueAt(aValue, convertRowIndexToModel(row),
-                              convertColumnIndexToModel(column));
-    }
+    public void setValueAt(Object aValue, int row, int column) {throw new RuntimeException("cf-bug");} //{
+//        getModel().setValueAt(aValue, convertRowIndexToModel(row),
+//                              convertColumnIndexToModel(column));
+//    }
 
     /**
      * Returns true if the cell at <code>row</code> and <code>column</code>
@@ -2761,10 +2761,10 @@
      * @return  true if the cell is editable
      * @see #setValueAt
      */
-    public boolean isCellEditable(int row, int column) {
-        return getModel().isCellEditable(convertRowIndexToModel(row),
-                                         convertColumnIndexToModel(column));
-    }
+    public boolean isCellEditable(int row, int column) {throw new RuntimeException("cf-bug");} //{
+//        return getModel().isCellEditable(convertRowIndexToModel(row),
+//                                         convertColumnIndexToModel(column));
+//    }
 //
 // Adding and removing columns in the view
 //
@@ -2795,14 +2795,14 @@
      *  @param  aColumn         the <code>TableColumn</code> to be added
      *  @see    #removeColumn
      */
-    public void addColumn(TableColumn aColumn) {
-        if (aColumn.getHeaderValue() == null) {
-            int modelColumn = aColumn.getModelIndex();
-            String columnName = getModel().getColumnName(modelColumn);
-            aColumn.setHeaderValue(columnName);
-        }
-        getColumnModel().addColumn(aColumn);
-    }
+    public void addColumn(TableColumn aColumn) {throw new RuntimeException("cf-bug");} //{
+//        if (aColumn.getHeaderValue() == null) {
+//            int modelColumn = aColumn.getModelIndex();
+//            String columnName = getModel().getColumnName(modelColumn);
+//            aColumn.setHeaderValue(columnName);
+//        }
+//        getColumnModel().addColumn(aColumn);
+//    }
 
     /**
      *  Removes <code>aColumn</code> from this <code>JTable</code>'s
@@ -2813,9 +2813,9 @@
      *  @param  aColumn         the <code>TableColumn</code> to be removed
      *  @see    #addColumn
      */
-    public void removeColumn(TableColumn aColumn) {
-        getColumnModel().removeColumn(aColumn);
-    }
+    public void removeColumn(TableColumn aColumn) {throw new RuntimeException("cf-bug");} //{
+//        getColumnModel().removeColumn(aColumn);
+//    }
 
     /**
      * Moves the column <code>column</code> to the position currently
@@ -2826,9 +2826,9 @@
      * @param   column                  the index of column to be moved
      * @param   targetColumn            the new index of the column
      */
-    public void moveColumn(int column, int targetColumn) {
-        getColumnModel().moveColumn(column, targetColumn);
-    }
+    public void moveColumn(int column, int targetColumn) {throw new RuntimeException("cf-bug");} //{
+//        getColumnModel().moveColumn(column, targetColumn);
+//    }
 
 //
 // Cover methods for various models and helper methods
@@ -2845,13 +2845,13 @@
      *          [0, <code>getColumnCount()</code>-1]
      * @see     #rowAtPoint
      */
-    public int columnAtPoint(Point point) {
-        int x = point.x;
-        if( !getComponentOrientation().isLeftToRight() ) {
-            x = getWidth() - x - 1;
-        }
-        return getColumnModel().getColumnIndexAtX(x);
-    }
+    public int columnAtPoint(Point point) {throw new RuntimeException("cf-bug");} //{
+//        int x = point.x;
+//        if( !getComponentOrientation().isLeftToRight() ) {
+//            x = getWidth() - x - 1;
+//        }
+//        return getColumnModel().getColumnIndexAtX(x);
+//    }
 
     /**
      * Returns the index of the row that <code>point</code> lies in,
@@ -2864,19 +2864,19 @@
      *          [0, <code>getRowCount()</code>-1]
      * @see     #columnAtPoint
      */
-    public int rowAtPoint(Point point) {
-        int y = point.y;
-        int result = (rowModel == null) ?  y/getRowHeight() : rowModel.getIndex(y);
-        if (result < 0) {
-            return -1;
-        }
-        else if (result >= getRowCount()) {
-            return -1;
-        }
-        else {
-            return result;
-        }
-    }
+    public int rowAtPoint(Point point) {throw new RuntimeException("cf-bug");} //{
+//        int y = point.y;
+//        int result = (rowModel == null) ?  y/getRowHeight() : rowModel.getIndex(y);
+//        if (result < 0) {
+//            return -1;
+//        }
+//        else if (result >= getRowCount()) {
+//            return -1;
+//        }
+//        else {
+//            return result;
+//        }
+//    }
 
     /**
      * Returns a rectangle for the cell that lies at the intersection of
@@ -2922,70 +2922,70 @@
      *          <code>row</code>,<code>column</code>
      * @see #getIntercellSpacing
      */
-    public Rectangle getCellRect(int row, int column, boolean includeSpacing) {
-        Rectangle r = new Rectangle();
-        boolean valid = true;
-        if (row < 0) {
-            // y = height = 0;
-            valid = false;
-        }
-        else if (row >= getRowCount()) {
-            r.y = getHeight();
-            valid = false;
-        }
-        else {
-            r.height = getRowHeight(row);
-            r.y = (rowModel == null) ? row * r.height : rowModel.getPosition(row);
-        }
-
-        if (column < 0) {
-            if( !getComponentOrientation().isLeftToRight() ) {
-                r.x = getWidth();
-            }
-            // otherwise, x = width = 0;
-            valid = false;
-        }
-        else if (column >= getColumnCount()) {
-            if( getComponentOrientation().isLeftToRight() ) {
-                r.x = getWidth();
-            }
-            // otherwise, x = width = 0;
-            valid = false;
-        }
-        else {
-            TableColumnModel cm = getColumnModel();
-            if( getComponentOrientation().isLeftToRight() ) {
-                for(int i = 0; i < column; i++) {
-                    r.x += cm.getColumn(i).getWidth();
-                }
-            } else {
-                for(int i = cm.getColumnCount()-1; i > column; i--) {
-                    r.x += cm.getColumn(i).getWidth();
-                }
-            }
-            r.width = cm.getColumn(column).getWidth();
-        }
-
-        if (valid && !includeSpacing) {
-            // Bound the margins by their associated dimensions to prevent
-            // returning bounds with negative dimensions.
-            int rm = Math.min(getRowMargin(), r.height);
-            int cm = Math.min(getColumnModel().getColumnMargin(), r.width);
-            // This is not the same as grow(), it rounds differently.
-            r.setBounds(r.x + cm/2, r.y + rm/2, r.width - cm, r.height - rm);
-        }
-        return r;
-    }
-
-    private int viewIndexForColumn(TableColumn aColumn) {
-        TableColumnModel cm = getColumnModel();
-        for (int column = 0; column < cm.getColumnCount(); column++) {
-            if (cm.getColumn(column) == aColumn) {
-                return column;
-            }
-        }
-        return -1;
-    }
+    public Rectangle getCellRect(int row, int column, boolean includeSpacing) {throw new RuntimeException("cf-bug");} //{
+//        Rectangle r = new Rectangle();
+//        boolean valid = true;
+//        if (row < 0) {
+//            // y = height = 0;
+//            valid = false;
+//        }
+//        else if (row >= getRowCount()) {
+//            r.y = getHeight();
+//            valid = false;
+//        }
+//        else {
+//            r.height = getRowHeight(row);
+//            r.y = (rowModel == null) ? row * r.height : rowModel.getPosition(row);
+//        }
+//
+//        if (column < 0) {
+//            if( !getComponentOrientation().isLeftToRight() ) {
+//                r.x = getWidth();
+//            }
+//            // otherwise, x = width = 0;
+//            valid = false;
+//        }
+//        else if (column >= getColumnCount()) {
+//            if( getComponentOrientation().isLeftToRight() ) {
+//                r.x = getWidth();
+//            }
+//            // otherwise, x = width = 0;
+//            valid = false;
+//        }
+//        else {
+//            TableColumnModel cm = getColumnModel();
+//            if( getComponentOrientation().isLeftToRight() ) {
+//                for(int i = 0; i < column; i++) {
+//                    r.x += cm.getColumn(i).getWidth();
+//                }
+//            } else {
+//                for(int i = cm.getColumnCount()-1; i > column; i--) {
+//                    r.x += cm.getColumn(i).getWidth();
+//                }
+//            }
+//            r.width = cm.getColumn(column).getWidth();
+//        }
+//
+//        if (valid && !includeSpacing) {
+//            // Bound the margins by their associated dimensions to prevent
+//            // returning bounds with negative dimensions.
+//            int rm = Math.min(getRowMargin(), r.height);
+//            int cm = Math.min(getColumnModel().getColumnMargin(), r.width);
+//            // This is not the same as grow(), it rounds differently.
+//            r.setBounds(r.x + cm/2, r.y + rm/2, r.width - cm, r.height - rm);
+//        }
+//        return r;
+//    }
+
+    private int viewIndexForColumn(TableColumn aColumn) {throw new RuntimeException("cf-bug");} //{
+//        TableColumnModel cm = getColumnModel();
+//        for (int column = 0; column < cm.getColumnCount(); column++) {
+//            if (cm.getColumn(column) == aColumn) {
+//                return column;
+//            }
+//        }
+//        return -1;
+//    }
 
     /**
      * Causes this table to lay out its rows and columns.  Overridden so
@@ -3122,53 +3122,53 @@
      * (maximum or minimum).
      *
      */
-    public void doLayout() {
-        TableColumn resizingColumn = getResizingColumn();
-        if (resizingColumn == null) {
-            setWidthsFromPreferredWidths(false);
-        }
-        else {
-            // JTable behaves like a layout manger - but one in which the
-            // user can come along and dictate how big one of the children
-            // (columns) is supposed to be.
-
-            // A column has been resized and JTable may need to distribute
-            // any overall delta to other columns, according to the resize mode.
-            int columnIndex = viewIndexForColumn(resizingColumn);
-            int delta = getWidth() - getColumnModel().getTotalColumnWidth();
-            accommodateDelta(columnIndex, delta);
-            delta = getWidth() - getColumnModel().getTotalColumnWidth();
-
-            // If the delta cannot be completely accomodated, then the
-            // resizing column will have to take any remainder. This means
-            // that the column is not being allowed to take the requested
-            // width. This happens under many circumstances: For example,
-            // AUTO_RESIZE_NEXT_COLUMN specifies that any delta be distributed
-            // to the column after the resizing column. If one were to attempt
-            // to resize the last column of the table, there would be no
-            // columns after it, and hence nowhere to distribute the delta.
-            // It would then be given entirely back to the resizing column,
-            // preventing it from changing size.
-            if (delta != 0) {
-                resizingColumn.setWidth(resizingColumn.getWidth() + delta);
-            }
-
-            // At this point the JTable has to work out what preferred sizes
-            // would have resulted in the layout the user has chosen.
-            // Thereafter, during window resizing etc. it has to work off
-            // the preferred sizes as usual - the idea being that, whatever
-            // the user does, everything stays in synch and things don't jump
-            // around.
-            setWidthsFromPreferredWidths(true);
-        }
-
-        super.doLayout();
-    }
+    public void doLayout() {throw new RuntimeException("cf-bug");} //{
+//        TableColumn resizingColumn = getResizingColumn();
+//        if (resizingColumn == null) {
+//            setWidthsFromPreferredWidths(false);
+//        }
+//        else {
+//            // JTable behaves like a layout manger - but one in which the
+//            // user can come along and dictate how big one of the children
+//            // (columns) is supposed to be.
+//
+//            // A column has been resized and JTable may need to distribute
+//            // any overall delta to other columns, according to the resize mode.
+//            int columnIndex = viewIndexForColumn(resizingColumn);
+//            int delta = getWidth() - getColumnModel().getTotalColumnWidth();
+//            accommodateDelta(columnIndex, delta);
+//            delta = getWidth() - getColumnModel().getTotalColumnWidth();
+//
+//            // If the delta cannot be completely accomodated, then the
+//            // resizing column will have to take any remainder. This means
+//            // that the column is not being allowed to take the requested
+//            // width. This happens under many circumstances: For example,
+//            // AUTO_RESIZE_NEXT_COLUMN specifies that any delta be distributed
+//            // to the column after the resizing column. If one were to attempt
+//            // to resize the last column of the table, there would be no
+//            // columns after it, and hence nowhere to distribute the delta.
+//            // It would then be given entirely back to the resizing column,
+//            // preventing it from changing size.
+//            if (delta != 0) {
+//                resizingColumn.setWidth(resizingColumn.getWidth() + delta);
+//            }
+//
+//            // At this point the JTable has to work out what preferred sizes
+//            // would have resulted in the layout the user has chosen.
+//            // Thereafter, during window resizing etc. it has to work off
+//            // the preferred sizes as usual - the idea being that, whatever
+//            // the user does, everything stays in synch and things don't jump
+//            // around.
+//            setWidthsFromPreferredWidths(true);
+//        }
+//
+//        super.doLayout();
+//    }
 
-    private TableColumn getResizingColumn() {
-        return (tableHeader == null) ? null
-                                     : tableHeader.getResizingColumn();
-    }
+    private TableColumn getResizingColumn() {throw new RuntimeException("cf-bug");} //{
+//        return (tableHeader == null) ? null
+//                                     : tableHeader.getResizingColumn();
+//    }
 
     /**
      * Sizes the table columns to fit the available space.
@@ -3177,13 +3177,13 @@
      * @see #doLayout
      */
     @Deprecated
-    public void sizeColumnsToFit(boolean lastColumnOnly) {
-        int oldAutoResizeMode = autoResizeMode;
-        setAutoResizeMode(lastColumnOnly ? AUTO_RESIZE_LAST_COLUMN
-                                         : AUTO_RESIZE_ALL_COLUMNS);
-        sizeColumnsToFit(-1);
-        setAutoResizeMode(oldAutoResizeMode);
-    }
+    public void sizeColumnsToFit(boolean lastColumnOnly) {throw new RuntimeException("cf-bug");} //{
+//        int oldAutoResizeMode = autoResizeMode;
+//        setAutoResizeMode(lastColumnOnly ? AUTO_RESIZE_LAST_COLUMN
+//                                         : AUTO_RESIZE_ALL_COLUMNS);
+//        sizeColumnsToFit(-1);
+//        setAutoResizeMode(oldAutoResizeMode);
+//    }
 
     /**
      * Obsolete as of Java 2 platform v1.4.  Please use the
@@ -3192,99 +3192,99 @@
      *                          necessary or -1 if there is no such column
      * @see  #doLayout
      */
-    public void sizeColumnsToFit(int resizingColumn) {
-        if (resizingColumn == -1) {
-            setWidthsFromPreferredWidths(false);
-        }
-        else {
-            if (autoResizeMode == AUTO_RESIZE_OFF) {
-                TableColumn aColumn = getColumnModel().getColumn(resizingColumn);
-                aColumn.setPreferredWidth(aColumn.getWidth());
-            }
-            else {
-                int delta = getWidth() - getColumnModel().getTotalColumnWidth();
-                accommodateDelta(resizingColumn, delta);
-                setWidthsFromPreferredWidths(true);
-            }
-        }
-    }
-
-    private void setWidthsFromPreferredWidths(final boolean inverse) {
-        int totalWidth     = getWidth();
-        int totalPreferred = getPreferredSize().width;
-        int target = !inverse ? totalWidth : totalPreferred;
-
-        final TableColumnModel cm = columnModel;
-        Resizable3 r = new Resizable3() {
-            public int  getElementCount()      { return cm.getColumnCount(); }
-            public int  getLowerBoundAt(int i) { return cm.getColumn(i).getMinWidth(); }
-            public int  getUpperBoundAt(int i) { return cm.getColumn(i).getMaxWidth(); }
-            public int  getMidPointAt(int i)  {
-                if (!inverse) {
-                    return cm.getColumn(i).getPreferredWidth();
-                }
-                else {
-                    return cm.getColumn(i).getWidth();
-                }
-            }
-            public void setSizeAt(int s, int i) {
-                if (!inverse) {
-                    cm.getColumn(i).setWidth(s);
-                }
-                else {
-                    cm.getColumn(i).setPreferredWidth(s);
-                }
-            }
-        };
-
-        adjustSizes(target, r, inverse);
-    }
+    public void sizeColumnsToFit(int resizingColumn) {throw new RuntimeException("cf-bug");} //{
+//        if (resizingColumn == -1) {
+//            setWidthsFromPreferredWidths(false);
+//        }
+//        else {
+//            if (autoResizeMode == AUTO_RESIZE_OFF) {
+//                TableColumn aColumn = getColumnModel().getColumn(resizingColumn);
+//                aColumn.setPreferredWidth(aColumn.getWidth());
+//            }
+//            else {
+//                int delta = getWidth() - getColumnModel().getTotalColumnWidth();
+//                accommodateDelta(resizingColumn, delta);
+//                setWidthsFromPreferredWidths(true);
+//            }
+//        }
+//    }
+
+    private void setWidthsFromPreferredWidths(final boolean inverse) {throw new RuntimeException("cf-bug");} //{
+//        int totalWidth     = getWidth();
+//        int totalPreferred = getPreferredSize().width;
+//        int target = !inverse ? totalWidth : totalPreferred;
+//
+//        final TableColumnModel cm = columnModel;
+//        Resizable3 r = new Resizable3() {
+//            public int  getElementCount()      { return cm.getColumnCount(); }
+//            public int  getLowerBoundAt(int i) { return cm.getColumn(i).getMinWidth(); }
+//            public int  getUpperBoundAt(int i) { return cm.getColumn(i).getMaxWidth(); }
+//            public int  getMidPointAt(int i)  {
+//                if (!inverse) {
+//                    return cm.getColumn(i).getPreferredWidth();
+//                }
+//                else {
+//                    return cm.getColumn(i).getWidth();
+//                }
+//            }
+//            public void setSizeAt(int s, int i) {
+//                if (!inverse) {
+//                    cm.getColumn(i).setWidth(s);
+//                }
+//                else {
+//                    cm.getColumn(i).setPreferredWidth(s);
+//                }
+//            }
+//        };
+//
+//        adjustSizes(target, r, inverse);
+//    }
 
 
     // Distribute delta over columns, as indicated by the autoresize mode.
-    private void accommodateDelta(int resizingColumnIndex, int delta) {
-        int columnCount = getColumnCount();
-        int from = resizingColumnIndex;
-        int to;
-
-        // Use the mode to determine how to absorb the changes.
-        switch(autoResizeMode) {
-            case AUTO_RESIZE_NEXT_COLUMN:
-                from = from + 1;
-                to = Math.min(from + 1, columnCount); break;
-            case AUTO_RESIZE_SUBSEQUENT_COLUMNS:
-                from = from + 1;
-                to = columnCount; break;
-            case AUTO_RESIZE_LAST_COLUMN:
-                from = columnCount - 1;
-                to = from + 1; break;
-            case AUTO_RESIZE_ALL_COLUMNS:
-                from = 0;
-                to = columnCount; break;
-            default:
-                return;
-        }
-
-        final int start = from;
-        final int end = to;
-        final TableColumnModel cm = columnModel;
-        Resizable3 r = new Resizable3() {
-            public int  getElementCount()       { return end-start; }
-            public int  getLowerBoundAt(int i)  { return cm.getColumn(i+start).getMinWidth(); }
-            public int  getUpperBoundAt(int i)  { return cm.getColumn(i+start).getMaxWidth(); }
-            public int  getMidPointAt(int i)    { return cm.getColumn(i+start).getWidth(); }
-            public void setSizeAt(int s, int i) {        cm.getColumn(i+start).setWidth(s); }
-        };
-
-        int totalWidth = 0;
-        for(int i = from; i < to; i++) {
-            TableColumn aColumn = columnModel.getColumn(i);
-            int input = aColumn.getWidth();
-            totalWidth = totalWidth + input;
-        }
-
-        adjustSizes(totalWidth + delta, r, false);
-    }
+    private void accommodateDelta(int resizingColumnIndex, int delta) {throw new RuntimeException("cf-bug");} //{
+//        int columnCount = getColumnCount();
+//        int from = resizingColumnIndex;
+//        int to;
+//
+//        // Use the mode to determine how to absorb the changes.
+//        switch(autoResizeMode) {
+//            case AUTO_RESIZE_NEXT_COLUMN:
+//                from = from + 1;
+//                to = Math.min(from + 1, columnCount); break;
+//            case AUTO_RESIZE_SUBSEQUENT_COLUMNS:
+//                from = from + 1;
+//                to = columnCount; break;
+//            case AUTO_RESIZE_LAST_COLUMN:
+//                from = columnCount - 1;
+//                to = from + 1; break;
+//            case AUTO_RESIZE_ALL_COLUMNS:
+//                from = 0;
+//                to = columnCount; break;
+//            default:
+//                return;
+//        }
+//
+//        final int start = from;
+//        final int end = to;
+//        final TableColumnModel cm = columnModel;
+//        Resizable3 r = new Resizable3() {
+//            public int  getElementCount()       { return end-start; }
+//            public int  getLowerBoundAt(int i)  { return cm.getColumn(i+start).getMinWidth(); }
+//            public int  getUpperBoundAt(int i)  { return cm.getColumn(i+start).getMaxWidth(); }
+//            public int  getMidPointAt(int i)    { return cm.getColumn(i+start).getWidth(); }
+//            public void setSizeAt(int s, int i) {        cm.getColumn(i+start).setWidth(s); }
+//        };
+//
+//        int totalWidth = 0;
+//        for(int i = from; i < to; i++) {
+//            TableColumn aColumn = columnModel.getColumn(i);
+//            int input = aColumn.getWidth();
+//            totalWidth = totalWidth + input;
+//        }
+//
+//        adjustSizes(totalWidth + delta, r, false);
+//    }
 
     private interface Resizable2 {
         public int  getElementCount();
@@ -3298,69 +3298,69 @@
     }
 
 
-    private void adjustSizes(long target, final Resizable3 r, boolean inverse) {
-        int N = r.getElementCount();
-        long totalPreferred = 0;
-        for(int i = 0; i < N; i++) {
-            totalPreferred += r.getMidPointAt(i);
-        }
-        Resizable2 s;
-        if ((target < totalPreferred) == !inverse) {
-            s = new Resizable2() {
-                public int  getElementCount()      { return r.getElementCount(); }
-                public int  getLowerBoundAt(int i) { return r.getLowerBoundAt(i); }
-                public int  getUpperBoundAt(int i) { return r.getMidPointAt(i); }
-                public void setSizeAt(int newSize, int i) { r.setSizeAt(newSize, i); }
-
-            };
-        }
-        else {
-            s = new Resizable2() {
-                public int  getElementCount()      { return r.getElementCount(); }
-                public int  getLowerBoundAt(int i) { return r.getMidPointAt(i); }
-                public int  getUpperBoundAt(int i) { return r.getUpperBoundAt(i); }
-                public void setSizeAt(int newSize, int i) { r.setSizeAt(newSize, i); }
-
-            };
-        }
-        adjustSizes(target, s, !inverse);
-    }
-
-    private void adjustSizes(long target, Resizable2 r, boolean limitToRange) {
-        long totalLowerBound = 0;
-        long totalUpperBound = 0;
-        for(int i = 0; i < r.getElementCount(); i++) {
-            totalLowerBound += r.getLowerBoundAt(i);
-            totalUpperBound += r.getUpperBoundAt(i);
-        }
-
-        if (limitToRange) {
-            target = Math.min(Math.max(totalLowerBound, target), totalUpperBound);
-        }
-
-        for(int i = 0; i < r.getElementCount(); i++) {
-            int lowerBound = r.getLowerBoundAt(i);
-            int upperBound = r.getUpperBoundAt(i);
-            // Check for zero. This happens when the distribution of the delta
-            // finishes early due to a series of "fixed" entries at the end.
-            // In this case, lowerBound == upperBound, for all subsequent terms.
-            int newSize;
-            if (totalLowerBound == totalUpperBound) {
-                newSize = lowerBound;
-            }
-            else {
-                double f = (double)(target - totalLowerBound)/(totalUpperBound - totalLowerBound);
-                newSize = (int)Math.round(lowerBound+f*(upperBound - lowerBound));
-                // We'd need to round manually in an all integer version.
-                // size[i] = (int)(((totalUpperBound - target) * lowerBound +
-                //     (target - totalLowerBound) * upperBound)/(totalUpperBound-totalLowerBound));
-            }
-            r.setSizeAt(newSize, i);
-            target -= newSize;
-            totalLowerBound -= lowerBound;
-            totalUpperBound -= upperBound;
-        }
-    }
+    private void adjustSizes(long target, final Resizable3 r, boolean inverse) {throw new RuntimeException("cf-bug");} //{
+//        int N = r.getElementCount();
+//        long totalPreferred = 0;
+//        for(int i = 0; i < N; i++) {
+//            totalPreferred += r.getMidPointAt(i);
+//        }
+//        Resizable2 s;
+//        if ((target < totalPreferred) == !inverse) {
+//            s = new Resizable2() {
+//                public int  getElementCount()      { return r.getElementCount(); }
+//                public int  getLowerBoundAt(int i) { return r.getLowerBoundAt(i); }
+//                public int  getUpperBoundAt(int i) { return r.getMidPointAt(i); }
+//                public void setSizeAt(int newSize, int i) { r.setSizeAt(newSize, i); }
+//
+//            };
+//        }
+//        else {
+//            s = new Resizable2() {
+//                public int  getElementCount()      { return r.getElementCount(); }
+//                public int  getLowerBoundAt(int i) { return r.getMidPointAt(i); }
+//                public int  getUpperBoundAt(int i) { return r.getUpperBoundAt(i); }
+//                public void setSizeAt(int newSize, int i) { r.setSizeAt(newSize, i); }
+//
+//            };
+//        }
+//        adjustSizes(target, s, !inverse);
+//    }
+
+    private void adjustSizes(long target, Resizable2 r, boolean limitToRange) {throw new RuntimeException("cf-bug");} //{
+//        long totalLowerBound = 0;
+//        long totalUpperBound = 0;
+//        for(int i = 0; i < r.getElementCount(); i++) {
+//            totalLowerBound += r.getLowerBoundAt(i);
+//            totalUpperBound += r.getUpperBoundAt(i);
+//        }
+//
+//        if (limitToRange) {
+//            target = Math.min(Math.max(totalLowerBound, target), totalUpperBound);
+//        }
+//
+//        for(int i = 0; i < r.getElementCount(); i++) {
+//            int lowerBound = r.getLowerBoundAt(i);
+//            int upperBound = r.getUpperBoundAt(i);
+//            // Check for zero. This happens when the distribution of the delta
+//            // finishes early due to a series of "fixed" entries at the end.
+//            // In this case, lowerBound == upperBound, for all subsequent terms.
+//            int newSize;
+//            if (totalLowerBound == totalUpperBound) {
+//                newSize = lowerBound;
+//            }
+//            else {
+//                double f = (double)(target - totalLowerBound)/(totalUpperBound - totalLowerBound);
+//                newSize = (int)Math.round(lowerBound+f*(upperBound - lowerBound));
+//                // We'd need to round manually in an all integer version.
+//                // size[i] = (int)(((totalUpperBound - target) * lowerBound +
+//                //     (target - totalLowerBound) * upperBound)/(totalUpperBound-totalLowerBound));
+//            }
+//            r.setSizeAt(newSize, i);
+//            target -= newSize;
+//            totalLowerBound -= lowerBound;
+//            totalUpperBound -= upperBound;
+//        }
+//    }
 
     /**
      * Overrides <code>JComponent</code>'s <code>getToolTipText</code>
@@ -3378,43 +3378,43 @@
      *
      * @see JComponent#getToolTipText
      */
-    public String getToolTipText(MouseEvent event) {
-        String tip = null;
-        Point p = event.getPoint();
-
-        // Locate the renderer under the event location
-        int hitColumnIndex = columnAtPoint(p);
-        int hitRowIndex = rowAtPoint(p);
-
-        if ((hitColumnIndex != -1) && (hitRowIndex != -1)) {
-            TableCellRenderer renderer = getCellRenderer(hitRowIndex, hitColumnIndex);
-            Component component = prepareRenderer(renderer, hitRowIndex, hitColumnIndex);
-
-            // Now have to see if the component is a JComponent before
-            // getting the tip
-            if (component instanceof JComponent) {
-                // Convert the event to the renderer's coordinate system
-                Rectangle cellRect = getCellRect(hitRowIndex, hitColumnIndex, false);
-                p.translate(-cellRect.x, -cellRect.y);
-                MouseEvent newEvent = new MouseEvent(component, event.getID(),
-                                          event.getWhen(), event.getModifiers(),
-                                          p.x, p.y,
-                                          event.getXOnScreen(),
-                                          event.getYOnScreen(),
-                                          event.getClickCount(),
-                                          event.isPopupTrigger(),
-                                          MouseEvent.NOBUTTON);
-
-                tip = ((JComponent)component).getToolTipText(newEvent);
-            }
-        }
-
-        // No tip from the renderer get our own tip
-        if (tip == null)
-            tip = getToolTipText();
-
-        return tip;
-    }
+    public String getToolTipText(MouseEvent event) {throw new RuntimeException("cf-bug");} //{
+//        String tip = null;
+//        Point p = event.getPoint();
+//
+//        // Locate the renderer under the event location
+//        int hitColumnIndex = columnAtPoint(p);
+//        int hitRowIndex = rowAtPoint(p);
+//
+//        if ((hitColumnIndex != -1) && (hitRowIndex != -1)) {
+//            TableCellRenderer renderer = getCellRenderer(hitRowIndex, hitColumnIndex);
+//            Component component = prepareRenderer(renderer, hitRowIndex, hitColumnIndex);
+//
+//            // Now have to see if the component is a JComponent before
+//            // getting the tip
+//            if (component instanceof JComponent) {
+//                // Convert the event to the renderer's coordinate system
+//                Rectangle cellRect = getCellRect(hitRowIndex, hitColumnIndex, false);
+//                p.translate(-cellRect.x, -cellRect.y);
+//                MouseEvent newEvent = new MouseEvent(component, event.getID(),
+//                                          event.getWhen(), event.getModifiers(),
+//                                          p.x, p.y,
+//                                          event.getXOnScreen(),
+//                                          event.getYOnScreen(),
+//                                          event.getClickCount(),
+//                                          event.isPopupTrigger(),
+//                                          MouseEvent.NOBUTTON);
+//
+//                tip = ((JComponent)component).getToolTipText(newEvent);
+//            }
+//        }
+//
+//        // No tip from the renderer get our own tip
+//        if (tip == null)
+//            tip = getToolTipText();
+//
+//        return tip;
+//    }
 
 //
 // Editing Support
@@ -3435,9 +3435,9 @@
      * @see #getSurrendersFocusOnKeystroke
      * @since 1.4
      */
-    public void setSurrendersFocusOnKeystroke(boolean surrendersFocusOnKeystroke) {
-        this.surrendersFocusOnKeystroke = surrendersFocusOnKeystroke;
-    }
+    public void setSurrendersFocusOnKeystroke(boolean surrendersFocusOnKeystroke) {throw new RuntimeException("cf-bug");} //{
+//        this.surrendersFocusOnKeystroke = surrendersFocusOnKeystroke;
+//    }
 
     /**
      * Returns true if the editor should get the focus
@@ -3450,9 +3450,9 @@
      * @see #setSurrendersFocusOnKeystroke
      * @since 1.4
      */
-    public boolean getSurrendersFocusOnKeystroke() {
-        return surrendersFocusOnKeystroke;
-    }
+    public boolean getSurrendersFocusOnKeystroke() {throw new RuntimeException("cf-bug");} //{
+//        return surrendersFocusOnKeystroke;
+//    }
 
     /**
      * Programmatically starts editing the cell at <code>row</code> and
@@ -3466,9 +3466,9 @@
      * @return  false if for any reason the cell cannot be edited,
      *                or if the indices are invalid
      */
-    public boolean editCellAt(int row, int column) {
-        return editCellAt(row, column, null);
-    }
+    public boolean editCellAt(int row, int column) {throw new RuntimeException("cf-bug");} //{
+//        return editCellAt(row, column, null);
+//    }
 
     /**
      * Programmatically starts editing the cell at <code>row</code> and
@@ -3487,47 +3487,47 @@
      * @return  false if for any reason the cell cannot be edited,
      *                or if the indices are invalid
      */
-    public boolean editCellAt(int row, int column, EventObject e){
-        if (cellEditor != null && !cellEditor.stopCellEditing()) {
-            return false;
-        }
-
-        if (row < 0 || row >= getRowCount() ||
-            column < 0 || column >= getColumnCount()) {
-            return false;
-        }
-
-        if (!isCellEditable(row, column))
-            return false;
-
-        if (editorRemover == null) {
-            KeyboardFocusManager fm =
-                KeyboardFocusManager.getCurrentKeyboardFocusManager();
-            editorRemover = new CellEditorRemover(fm);
-            fm.addPropertyChangeListener("permanentFocusOwner", editorRemover);
-        }
-
-        TableCellEditor editor = getCellEditor(row, column);
-        if (editor != null && editor.isCellEditable(e)) {
-            editorComp = prepareEditor(editor, row, column);
-            if (editorComp == null) {
-                removeEditor();
-                return false;
-            }
-            editorComp.setBounds(getCellRect(row, column, false));
-            add(editorComp);
-            editorComp.validate();
-            editorComp.repaint();
-
-            setCellEditor(editor);
-            setEditingRow(row);
-            setEditingColumn(column);
-            editor.addCellEditorListener(this);
-
-            return true;
-        }
-        return false;
-    }
+    public boolean editCellAt(int row, int column, EventObject e){throw new RuntimeException("cf-bug");} //{
+//        if (cellEditor != null && !cellEditor.stopCellEditing()) {
+//            return false;
+//        }
+//
+//        if (row < 0 || row >= getRowCount() ||
+//            column < 0 || column >= getColumnCount()) {
+//            return false;
+//        }
+//
+//        if (!isCellEditable(row, column))
+//            return false;
+//
+//        if (editorRemover == null) {
+//            KeyboardFocusManager fm =
+//                KeyboardFocusManager.getCurrentKeyboardFocusManager();
+//            editorRemover = new CellEditorRemover(fm);
+//            fm.addPropertyChangeListener("permanentFocusOwner", editorRemover);
+//        }
+//
+//        TableCellEditor editor = getCellEditor(row, column);
+//        if (editor != null && editor.isCellEditable(e)) {
+//            editorComp = prepareEditor(editor, row, column);
+//            if (editorComp == null) {
+//                removeEditor();
+//                return false;
+//            }
+//            editorComp.setBounds(getCellRect(row, column, false));
+//            add(editorComp);
+//            editorComp.validate();
+//            editorComp.repaint();
+//
+//            setCellEditor(editor);
+//            setEditingRow(row);
+//            setEditingColumn(column);
+//            editor.addCellEditorListener(this);
+//
+//            return true;
+//        }
+//        return false;
+//    }
 
     /**
      * Returns true if a cell is being edited.
@@ -3536,9 +3536,9 @@
      * @see     #editingColumn
      * @see     #editingRow
      */
-    public boolean isEditing() {
-        return cellEditor != null;
-    }
+    public boolean isEditing() {throw new RuntimeException("cf-bug");} //{
+//        return cellEditor != null;
+//    }
 
     /**
      * Returns the component that is handling the editing session.
@@ -3546,9 +3546,9 @@
      *
      * @return  Component handling editing session
      */
-    public Component getEditorComponent() {
-        return editorComp;
-    }
+    public Component getEditorComponent() {throw new RuntimeException("cf-bug");} //{
+//        return editorComp;
+//    }
 
     /**
      * Returns the index of the column that contains the cell currently
@@ -3558,9 +3558,9 @@
      *          being edited; returns -1 if nothing being edited
      * @see #editingRow
      */
-    public int getEditingColumn() {
-        return editingColumn;
-    }
+    public int getEditingColumn() {throw new RuntimeException("cf-bug");} //{
+//        return editingColumn;
+//    }
 
     /**
      * Returns the index of the row that contains the cell currently
@@ -3570,9 +3570,9 @@
      *          being edited; returns -1 if nothing being edited
      * @see #editingColumn
      */
-    public int getEditingRow() {
-        return editingRow;
-    }
+    public int getEditingRow() {throw new RuntimeException("cf-bug");} //{
+//        return editingRow;
+//    }
 
 //
 // Managing TableUI
@@ -3583,9 +3583,9 @@
      *
      * @return the <code>TableUI</code> object that renders this component
      */
-    public TableUI getUI() {
-        return (TableUI)ui;
-    }
+    public TableUI getUI() {throw new RuntimeException("cf-bug");} //{
+//        return (TableUI)ui;
+//    }
 
     /**
      * Sets the L&amp;F object that renders this component and repaints.
@@ -3598,12 +3598,12 @@
      *    attribute: visualUpdate true
      *  description: The UI object that implements the Component's LookAndFeel.
      */
-    public void setUI(TableUI ui) {
-        if (this.ui != ui) {
-            super.setUI(ui);
-            repaint();
-        }
-    }
+    public void setUI(TableUI ui) {throw new RuntimeException("cf-bug");} //{
+//        if (this.ui != ui) {
+//            super.setUI(ui);
+//            repaint();
+//        }
+//    }
 
     /**
      * Notification from the <code>UIManager</code> that the L&amp;F has changed.
@@ -3612,38 +3612,38 @@
      *
      * @see JComponent#updateUI
      */
-    public void updateUI() {
-        // Update the UIs of the cell renderers, cell editors and header renderers.
-        TableColumnModel cm = getColumnModel();
-        for(int column = 0; column < cm.getColumnCount(); column++) {
-            TableColumn aColumn = cm.getColumn(column);
-            SwingUtilities.updateRendererOrEditorUI(aColumn.getCellRenderer());
-            SwingUtilities.updateRendererOrEditorUI(aColumn.getCellEditor());
-            SwingUtilities.updateRendererOrEditorUI(aColumn.getHeaderRenderer());
-        }
-
-        // Update the UIs of all the default renderers.
-        Enumeration defaultRenderers = defaultRenderersByColumnClass.elements();
-        while (defaultRenderers.hasMoreElements()) {
-            SwingUtilities.updateRendererOrEditorUI(defaultRenderers.nextElement());
-        }
-
-        // Update the UIs of all the default editors.
-        Enumeration defaultEditors = defaultEditorsByColumnClass.elements();
-        while (defaultEditors.hasMoreElements()) {
-            SwingUtilities.updateRendererOrEditorUI(defaultEditors.nextElement());
-        }
-
-        // Update the UI of the table header
-        if (tableHeader != null && tableHeader.getParent() == null) {
-            tableHeader.updateUI();
-        }
-
-        // Update UI applied to parent ScrollPane
-        configureEnclosingScrollPaneUI();
-
-        setUI((TableUI)UIManager.getUI(this));
-    }
+    public void updateUI() {throw new RuntimeException("cf-bug");} //{
+//        // Update the UIs of the cell renderers, cell editors and header renderers.
+//        TableColumnModel cm = getColumnModel();
+//        for(int column = 0; column < cm.getColumnCount(); column++) {
+//            TableColumn aColumn = cm.getColumn(column);
+//            SwingUtilities.updateRendererOrEditorUI(aColumn.getCellRenderer());
+//            SwingUtilities.updateRendererOrEditorUI(aColumn.getCellEditor());
+//            SwingUtilities.updateRendererOrEditorUI(aColumn.getHeaderRenderer());
+//        }
+//
+//        // Update the UIs of all the default renderers.
+//        Enumeration defaultRenderers = defaultRenderersByColumnClass.elements();
+//        while (defaultRenderers.hasMoreElements()) {
+//            SwingUtilities.updateRendererOrEditorUI(defaultRenderers.nextElement());
+//        }
+//
+//        // Update the UIs of all the default editors.
+//        Enumeration defaultEditors = defaultEditorsByColumnClass.elements();
+//        while (defaultEditors.hasMoreElements()) {
+//            SwingUtilities.updateRendererOrEditorUI(defaultEditors.nextElement());
+//        }
+//
+//        // Update the UI of the table header
+//        if (tableHeader != null && tableHeader.getParent() == null) {
+//            tableHeader.updateUI();
+//        }
+//
+//        // Update UI applied to parent ScrollPane
+//        configureEnclosingScrollPaneUI();
+//
+//        setUI((TableUI)UIManager.getUI(this));
+//    }
 
     /**
      * Returns the suffix used to construct the name of the L&amp;F class used to
@@ -3653,9 +3653,9 @@
      * @see JComponent#getUIClassID
      * @see UIDefaults#getUI
      */
-    public String getUIClassID() {
-        return uiClassID;
-    }
+    public String getUIClassID() {throw new RuntimeException("cf-bug");} //{
+//        return uiClassID;
+//    }
 
 
 //
@@ -3673,27 +3673,27 @@
      *  bound: true
      *  description: The model that is the source of the data for this view.
      */
-    public void setModel(TableModel dataModel) {
-        if (dataModel == null) {
-            throw new IllegalArgumentException("Cannot set a null TableModel");
-        }
-        if (this.dataModel != dataModel) {
-            TableModel old = this.dataModel;
-            if (old != null) {
-                old.removeTableModelListener(this);
-            }
-            this.dataModel = dataModel;
-            dataModel.addTableModelListener(this);
-
-            tableChanged(new TableModelEvent(dataModel, TableModelEvent.HEADER_ROW));
-
-            firePropertyChange("model", old, dataModel);
-
-            if (getAutoCreateRowSorter()) {
-                setRowSorter(new TableRowSorter<TableModel>(dataModel));
-            }
-        }
-    }
+    public void setModel(TableModel dataModel) {throw new RuntimeException("cf-bug");} //{
+//        if (dataModel == null) {
+//            throw new IllegalArgumentException("Cannot set a null TableModel");
+//        }
+//        if (this.dataModel != dataModel) {
+//            TableModel old = this.dataModel;
+//            if (old != null) {
+//                old.removeTableModelListener(this);
+//            }
+//            this.dataModel = dataModel;
+//            dataModel.addTableModelListener(this);
+//
+//            tableChanged(new TableModelEvent(dataModel, TableModelEvent.HEADER_ROW));
+//
+//            firePropertyChange("model", old, dataModel);
+//
+//            if (getAutoCreateRowSorter()) {
+//                setRowSorter(new TableRowSorter<TableModel>(dataModel));
+//            }
+//        }
+//    }
 
     /**
      * Returns the <code>TableModel</code> that provides the data displayed by this
@@ -3702,9 +3702,9 @@
      * @return  the <code>TableModel</code> that provides the data displayed by this <code>JTable</code>
      * @see     #setModel
      */
-    public TableModel getModel() {
-        return dataModel;
-    }
+    public TableModel getModel() {throw new RuntimeException("cf-bug");} //{
+//        return dataModel;
+//    }
 
     /**
      * Sets the column model for this table to <code>newModel</code> and registers
@@ -3718,27 +3718,27 @@
      *  bound: true
      *  description: The object governing the way columns appear in the view.
      */
-    public void setColumnModel(TableColumnModel columnModel) {
-        if (columnModel == null) {
-            throw new IllegalArgumentException("Cannot set a null ColumnModel");
-        }
-        TableColumnModel old = this.columnModel;
-        if (columnModel != old) {
-            if (old != null) {
-                old.removeColumnModelListener(this);
-            }
-            this.columnModel = columnModel;
-            columnModel.addColumnModelListener(this);
-
-            // Set the column model of the header as well.
-            if (tableHeader != null) {
-                tableHeader.setColumnModel(columnModel);
-            }
-
-            firePropertyChange("columnModel", old, columnModel);
-            resizeAndRepaint();
-        }
-    }
+    public void setColumnModel(TableColumnModel columnModel) {throw new RuntimeException("cf-bug");} //{
+//        if (columnModel == null) {
+//            throw new IllegalArgumentException("Cannot set a null ColumnModel");
+//        }
+//        TableColumnModel old = this.columnModel;
+//        if (columnModel != old) {
+//            if (old != null) {
+//                old.removeColumnModelListener(this);
+//            }
+//            this.columnModel = columnModel;
+//            columnModel.addColumnModelListener(this);
+//
+//            // Set the column model of the header as well.
+//            if (tableHeader != null) {
+//                tableHeader.setColumnModel(columnModel);
+//            }
+//
+//            firePropertyChange("columnModel", old, columnModel);
+//            resizeAndRepaint();
+//        }
+//    }
 
     /**
      * Returns the <code>TableColumnModel</code> that contains all column information
@@ -3747,9 +3747,9 @@
      * @return  the object that provides the column state of the table
      * @see     #setColumnModel
      */
-    public TableColumnModel getColumnModel() {
-        return columnModel;
-    }
+    public TableColumnModel getColumnModel() {throw new RuntimeException("cf-bug");} //{
+//        return columnModel;
+//    }
 
     /**
      * Sets the row selection model for this table to <code>newModel</code>
@@ -3762,25 +3762,25 @@
      *      bound: true
      *      description: The selection model for rows.
      */
-    public void setSelectionModel(ListSelectionModel newModel) {
-        if (newModel == null) {
-            throw new IllegalArgumentException("Cannot set a null SelectionModel");
-        }
-
-        ListSelectionModel oldModel = selectionModel;
-
-        if (newModel != oldModel) {
-            if (oldModel != null) {
-                oldModel.removeListSelectionListener(this);
-            }
-
-            selectionModel = newModel;
-            newModel.addListSelectionListener(this);
-
-            firePropertyChange("selectionModel", oldModel, newModel);
-            repaint();
-        }
-    }
+    public void setSelectionModel(ListSelectionModel newModel) {throw new RuntimeException("cf-bug");} //{
+//        if (newModel == null) {
+//            throw new IllegalArgumentException("Cannot set a null SelectionModel");
+//        }
+//
+//        ListSelectionModel oldModel = selectionModel;
+//
+//        if (newModel != oldModel) {
+//            if (oldModel != null) {
+//                oldModel.removeListSelectionListener(this);
+//            }
+//
+//            selectionModel = newModel;
+//            newModel.addListSelectionListener(this);
+//
+//            firePropertyChange("selectionModel", oldModel, newModel);
+//            repaint();
+//        }
+//    }
 
     /**
      * Returns the <code>ListSelectionModel</code> that is used to maintain row
@@ -3790,9 +3790,9 @@
      *          if row selection is not allowed
      * @see     #setSelectionModel
      */
-    public ListSelectionModel getSelectionModel() {
-        return selectionModel;
-    }
+    public ListSelectionModel getSelectionModel() {throw new RuntimeException("cf-bug");} //{
+//        return selectionModel;
+//    }
 
 //
 // RowSorterListener
@@ -3806,20 +3806,20 @@
      * @throws NullPointerException if <code>e</code> is <code>null</code>
      * @since 1.6
      */
-    public void sorterChanged(RowSorterEvent e) {
-        if (e.getType() == RowSorterEvent.Type.SORT_ORDER_CHANGED) {
-            JTableHeader header = getTableHeader();
-            if (header != null) {
-                header.repaint();
-            }
-        }
-        else if (e.getType() == RowSorterEvent.Type.SORTED) {
-            sorterChanged = true;
-            if (!ignoreSortChange) {
-                sortedTableChanged(e, null);
-            }
-        }
-    }
+    public void sorterChanged(RowSorterEvent e) {throw new RuntimeException("cf-bug");} //{
+//        if (e.getType() == RowSorterEvent.Type.SORT_ORDER_CHANGED) {
+//            JTableHeader header = getTableHeader();
+//            if (header != null) {
+//                header.repaint();
+//            }
+//        }
+//        else if (e.getType() == RowSorterEvent.Type.SORTED) {
+//            sorterChanged = true;
+//            if (!ignoreSortChange) {
+//                sortedTableChanged(e, null);
+//            }
+//        }
+//    }
 
 
     /**
@@ -3853,40 +3853,40 @@
         /**
          * Disposes any resources used by this SortManager.
          */
-        public void dispose() {
-            if (sorter != null) {
-                sorter.removeRowSorterListener(JTable.this);
-            }
-        }
+        public void dispose() {throw new RuntimeException("cf-bug");} //{
+//            if (sorter != null) {
+//                sorter.removeRowSorterListener(JTable.this);
+//            }
+//        }
 
         /**
          * Sets the height for a row at a specified index.
          */
-        public void setViewRowHeight(int viewIndex, int rowHeight) {
-            if (modelRowSizes == null) {
-                modelRowSizes = new SizeSequence(getModel().getRowCount(),
-                                                 getRowHeight());
-            }
-            modelRowSizes.setSize(convertRowIndexToModel(viewIndex),rowHeight);
-        }
+        public void setViewRowHeight(int viewIndex, int rowHeight) {throw new RuntimeException("cf-bug");} //{
+//            if (modelRowSizes == null) {
+//                modelRowSizes = new SizeSequence(getModel().getRowCount(),
+//                                                 getRowHeight());
+//            }
+//            modelRowSizes.setSize(convertRowIndexToModel(viewIndex),rowHeight);
+//        }
 
         /**
          * Invoked when the underlying model has completely changed.
          */
-        public void allChanged() {
-            modelLeadIndex = -1;
-            modelSelection = null;
-            modelRowSizes = null;
-        }
+        public void allChanged() {throw new RuntimeException("cf-bug");} //{
+//            modelLeadIndex = -1;
+//            modelSelection = null;
+//            modelRowSizes = null;
+//        }
 
         /**
          * Invoked when the selection, on the view, has changed.
          */
-        public void viewSelectionChanged(ListSelectionEvent e) {
-            if (!syncingSelection && modelSelection != null) {
-                modelSelection = null;
-            }
-        }
+        public void viewSelectionChanged(ListSelectionEvent e) {throw new RuntimeException("cf-bug");} //{
+//            if (!syncingSelection && modelSelection != null) {
+//                modelSelection = null;
+//            }
+//        }
 
         /**
          * Invoked when either the table model has changed, or the RowSorter
@@ -3894,78 +3894,78 @@
          * change.
          */
         public void prepareForChange(RowSorterEvent sortEvent,
-                                     ModelChange change) {
-            if (getUpdateSelectionOnSort()) {
-                cacheSelection(sortEvent, change);
-            }
-        }
+                                     ModelChange change) {throw new RuntimeException("cf-bug");} //{
+//            if (getUpdateSelectionOnSort()) {
+//                cacheSelection(sortEvent, change);
+//            }
+//        }
 
         /**
          * Updates the internal cache of the selection based on the change.
          */
         private void cacheSelection(RowSorterEvent sortEvent,
-                                    ModelChange change) {
-            if (sortEvent != null) {
-                // sort order changed. If modelSelection is null and filtering
-                // is enabled we need to cache the selection in terms of the
-                // underlying model, this will allow us to correctly restore
-                // the selection even if rows are filtered out.
-                if (modelSelection == null &&
-                        sorter.getViewRowCount() != getModel().getRowCount()) {
-                    modelSelection = new DefaultListSelectionModel();
-                    ListSelectionModel viewSelection = getSelectionModel();
-                    int min = viewSelection.getMinSelectionIndex();
-                    int max = viewSelection.getMaxSelectionIndex();
-                    int modelIndex;
-                    for (int viewIndex = min; viewIndex <= max; viewIndex++) {
-                        if (viewSelection.isSelectedIndex(viewIndex)) {
-                            modelIndex = convertRowIndexToModel(
-                                    sortEvent, viewIndex);
-                            if (modelIndex != -1) {
-                                modelSelection.addSelectionInterval(
-                                    modelIndex, modelIndex);
-                            }
-                        }
-                    }
-                    modelIndex = convertRowIndexToModel(sortEvent,
-                            viewSelection.getLeadSelectionIndex());
-                    SwingUtilities2.setLeadAnchorWithoutSelection(
-                            modelSelection, modelIndex, modelIndex);
-                } else if (modelSelection == null) {
-                    // Sorting changed, haven't cached selection in terms
-                    // of model and no filtering. Temporarily cache selection.
-                    cacheModelSelection(sortEvent);
-                }
-            } else if (change.allRowsChanged) {
-                // All the rows have changed, chuck any cached selection.
-                modelSelection = null;
-            } else if (modelSelection != null) {
-                // Table changed, reflect changes in cached selection model.
-                switch(change.type) {
-                case TableModelEvent.DELETE:
-                    modelSelection.removeIndexInterval(change.startModelIndex,
-                                                       change.endModelIndex);
-                    break;
-                case TableModelEvent.INSERT:
-                    modelSelection.insertIndexInterval(change.startModelIndex,
-                                                       change.length,
-                                                       true);
-                    break;
-                default:
-                    break;
-                }
-            } else {
-                // table changed, but haven't cached rows, temporarily
-                // cache them.
-                cacheModelSelection(null);
-            }
-        }
-
-        private void cacheModelSelection(RowSorterEvent sortEvent) {
-            lastModelSelection = convertSelectionToModel(sortEvent);
-            modelLeadIndex = convertRowIndexToModel(sortEvent,
-                        selectionModel.getLeadSelectionIndex());
-        }
+                                    ModelChange change) {throw new RuntimeException("cf-bug");} //{
+//            if (sortEvent != null) {
+//                // sort order changed. If modelSelection is null and filtering
+//                // is enabled we need to cache the selection in terms of the
+//                // underlying model, this will allow us to correctly restore
+//                // the selection even if rows are filtered out.
+//                if (modelSelection == null &&
+//                        sorter.getViewRowCount() != getModel().getRowCount()) {
+//                    modelSelection = new DefaultListSelectionModel();
+//                    ListSelectionModel viewSelection = getSelectionModel();
+//                    int min = viewSelection.getMinSelectionIndex();
+//                    int max = viewSelection.getMaxSelectionIndex();
+//                    int modelIndex;
+//                    for (int viewIndex = min; viewIndex <= max; viewIndex++) {
+//                        if (viewSelection.isSelectedIndex(viewIndex)) {
+//                            modelIndex = convertRowIndexToModel(
+//                                    sortEvent, viewIndex);
+//                            if (modelIndex != -1) {
+//                                modelSelection.addSelectionInterval(
+//                                    modelIndex, modelIndex);
+//                            }
+//                        }
+//                    }
+//                    modelIndex = convertRowIndexToModel(sortEvent,
+//                            viewSelection.getLeadSelectionIndex());
+//                    SwingUtilities2.setLeadAnchorWithoutSelection(
+//                            modelSelection, modelIndex, modelIndex);
+//                } else if (modelSelection == null) {
+//                    // Sorting changed, haven't cached selection in terms
+//                    // of model and no filtering. Temporarily cache selection.
+//                    cacheModelSelection(sortEvent);
+//                }
+//            } else if (change.allRowsChanged) {
+//                // All the rows have changed, chuck any cached selection.
+//                modelSelection = null;
+//            } else if (modelSelection != null) {
+//                // Table changed, reflect changes in cached selection model.
+//                switch(change.type) {
+//                case TableModelEvent.DELETE:
+//                    modelSelection.removeIndexInterval(change.startModelIndex,
+//                                                       change.endModelIndex);
+//                    break;
+//                case TableModelEvent.INSERT:
+//                    modelSelection.insertIndexInterval(change.startModelIndex,
+//                                                       change.length,
+//                                                       true);
+//                    break;
+//                default:
+//                    break;
+//                }
+//            } else {
+//                // table changed, but haven't cached rows, temporarily
+//                // cache them.
+//                cacheModelSelection(null);
+//            }
+//        }
+
+        private void cacheModelSelection(RowSorterEvent sortEvent) {throw new RuntimeException("cf-bug");} //{
+//            lastModelSelection = convertSelectionToModel(sortEvent);
+//            modelLeadIndex = convertRowIndexToModel(sortEvent,
+//                        selectionModel.getLeadSelectionIndex());
+//        }
 
         /**
          * Inovked when either the table has changed or the sorter has changed
@@ -3974,82 +3974,82 @@
          */
         public void processChange(RowSorterEvent sortEvent,
                                   ModelChange change,
-                                  boolean sorterChanged) {
-            if (change != null) {
-                if (change.allRowsChanged) {
-                    modelRowSizes = null;
-                    rowModel = null;
-                } else if (modelRowSizes != null) {
-                    if (change.type == TableModelEvent.INSERT) {
-                        modelRowSizes.insertEntries(change.startModelIndex,
-                                                    change.endModelIndex -
-                                                    change.startModelIndex + 1,
-                                                    getRowHeight());
-                    } else if (change.type == TableModelEvent.DELETE) {
-                        modelRowSizes.removeEntries(change.startModelIndex,
-                                                    change.endModelIndex -
-                                                    change.startModelIndex +1 );
-                    }
-                }
-            }
-            if (sorterChanged) {
-                setViewRowHeightsFromModel();
-                restoreSelection(change);
-            }
-        }
+                                  boolean sorterChanged) {throw new RuntimeException("cf-bug");} //{
+//            if (change != null) {
+//                if (change.allRowsChanged) {
+//                    modelRowSizes = null;
+//                    rowModel = null;
+//                } else if (modelRowSizes != null) {
+//                    if (change.type == TableModelEvent.INSERT) {
+//                        modelRowSizes.insertEntries(change.startModelIndex,
+//                                                    change.endModelIndex -
+//                                                    change.startModelIndex + 1,
+//                                                    getRowHeight());
+//                    } else if (change.type == TableModelEvent.DELETE) {
+//                        modelRowSizes.removeEntries(change.startModelIndex,
+//                                                    change.endModelIndex -
+//                                                    change.startModelIndex +1 );
+//                    }
+//                }
+//            }
+//            if (sorterChanged) {
+//                setViewRowHeightsFromModel();
+//                restoreSelection(change);
+//            }
+//        }
 
         /**
          * Resets the variable row heights in terms of the view from
          * that of the variable row heights in terms of the model.
          */
-        private void setViewRowHeightsFromModel() {
-            if (modelRowSizes != null) {
-                rowModel.setSizes(getRowCount(), getRowHeight());
-                for (int viewIndex = getRowCount() - 1; viewIndex >= 0;
-                         viewIndex--) {
-                    int modelIndex = convertRowIndexToModel(viewIndex);
-                    rowModel.setSize(viewIndex,
-                                     modelRowSizes.getSize(modelIndex));
-                }
-            }
-        }
+        private void setViewRowHeightsFromModel() {throw new RuntimeException("cf-bug");} //{
+//            if (modelRowSizes != null) {
+//                rowModel.setSizes(getRowCount(), getRowHeight());
+//                for (int viewIndex = getRowCount() - 1; viewIndex >= 0;
+//                         viewIndex--) {
+//                    int modelIndex = convertRowIndexToModel(viewIndex);
+//                    rowModel.setSize(viewIndex,
+//                                     modelRowSizes.getSize(modelIndex));
+//                }
+//            }
+//        }
 
         /**
          * Restores the selection from that in terms of the model.
          */
-        private void restoreSelection(ModelChange change) {
-            syncingSelection = true;
-            if (lastModelSelection != null) {
-                restoreSortingSelection(lastModelSelection,
-                                        modelLeadIndex, change);
-                lastModelSelection = null;
-            } else if (modelSelection != null) {
-                ListSelectionModel viewSelection = getSelectionModel();
-                viewSelection.setValueIsAdjusting(true);
-                viewSelection.clearSelection();
-                int min = modelSelection.getMinSelectionIndex();
-                int max = modelSelection.getMaxSelectionIndex();
-                int viewIndex;
-                for (int modelIndex = min; modelIndex <= max; modelIndex++) {
-                    if (modelSelection.isSelectedIndex(modelIndex)) {
-                        viewIndex = convertRowIndexToView(modelIndex);
-                        if (viewIndex != -1) {
-                            viewSelection.addSelectionInterval(viewIndex,
-                                                               viewIndex);
-                        }
-                    }
-                }
-                // Restore the lead
-                int viewLeadIndex = modelSelection.getLeadSelectionIndex();
-                if (viewLeadIndex != -1 && !modelSelection.isSelectionEmpty()) {
-                    viewLeadIndex = convertRowIndexToView(viewLeadIndex);
-                }
-                SwingUtilities2.setLeadAnchorWithoutSelection(
-                        viewSelection, viewLeadIndex, viewLeadIndex);
-                viewSelection.setValueIsAdjusting(false);
-            }
-            syncingSelection = false;
-        }
+        private void restoreSelection(ModelChange change) {throw new RuntimeException("cf-bug");} //{
+//            syncingSelection = true;
+//            if (lastModelSelection != null) {
+//                restoreSortingSelection(lastModelSelection,
+//                                        modelLeadIndex, change);
+//                lastModelSelection = null;
+//            } else if (modelSelection != null) {
+//                ListSelectionModel viewSelection = getSelectionModel();
+//                viewSelection.setValueIsAdjusting(true);
+//                viewSelection.clearSelection();
+//                int min = modelSelection.getMinSelectionIndex();
+//                int max = modelSelection.getMaxSelectionIndex();
+//                int viewIndex;
+//                for (int modelIndex = min; modelIndex <= max; modelIndex++) {
+//                    if (modelSelection.isSelectedIndex(modelIndex)) {
+//                        viewIndex = convertRowIndexToView(modelIndex);
+//                        if (viewIndex != -1) {
+//                            viewSelection.addSelectionInterval(viewIndex,
+//                                                               viewIndex);
+//                        }
+//                    }
+//                }
+//                // Restore the lead
+//                int viewLeadIndex = modelSelection.getLeadSelectionIndex();
+//                if (viewLeadIndex != -1 && !modelSelection.isSelectionEmpty()) {
+//                    viewLeadIndex = convertRowIndexToView(viewLeadIndex);
+//                }
+//                SwingUtilities2.setLeadAnchorWithoutSelection(
+//                        viewSelection, viewLeadIndex, viewLeadIndex);
+//                viewSelection.setValueIsAdjusting(false);
+//            }
+//            syncingSelection = false;
+//        }
     }
 
 
@@ -4099,186 +4099,186 @@
      * when <code>tableChanged</code> is invoked and sorting is enabled.
      */
     private void sortedTableChanged(RowSorterEvent sortedEvent,
-                                    TableModelEvent e) {
-        int editingModelIndex = -1;
-        ModelChange change = (e != null) ? new ModelChange(e) : null;
-
-        if ((change == null || !change.allRowsChanged) &&
-                this.editingRow != -1) {
-            editingModelIndex = convertRowIndexToModel(sortedEvent,
-                                                       this.editingRow);
-        }
-
-        sortManager.prepareForChange(sortedEvent, change);
-
-        if (e != null) {
-            if (change.type == TableModelEvent.UPDATE) {
-                repaintSortedRows(change);
-            }
-            notifySorter(change);
-            if (change.type != TableModelEvent.UPDATE) {
-                // If the Sorter is unsorted we will not have received
-                // notification, force treating insert/delete as a change.
-                sorterChanged = true;
-            }
-        }
-        else {
-            sorterChanged = true;
-        }
-
-        sortManager.processChange(sortedEvent, change, sorterChanged);
-
-        if (sorterChanged) {
-            // Update the editing row
-            if (this.editingRow != -1) {
-                int newIndex = (editingModelIndex == -1) ? -1 :
-                        convertRowIndexToView(editingModelIndex,change);
-                restoreSortingEditingRow(newIndex);
-            }
-
-            // And handle the appropriate repainting.
-            if (e == null || change.type != TableModelEvent.UPDATE) {
-                resizeAndRepaint();
-            }
-        }
-
-        // Check if lead/anchor need to be reset.
-        if (change != null && change.allRowsChanged) {
-            clearSelectionAndLeadAnchor();
-            resizeAndRepaint();
-        }
-    }
+                                    TableModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//        int editingModelIndex = -1;
+//        ModelChange change = (e != null) ? new ModelChange(e) : null;
+//
+//        if ((change == null || !change.allRowsChanged) &&
+//                this.editingRow != -1) {
+//            editingModelIndex = convertRowIndexToModel(sortedEvent,
+//                                                       this.editingRow);
+//        }
+//
+//        sortManager.prepareForChange(sortedEvent, change);
+//
+//        if (e != null) {
+//            if (change.type == TableModelEvent.UPDATE) {
+//                repaintSortedRows(change);
+//            }
+//            notifySorter(change);
+//            if (change.type != TableModelEvent.UPDATE) {
+//                // If the Sorter is unsorted we will not have received
+//                // notification, force treating insert/delete as a change.
+//                sorterChanged = true;
+//            }
+//        }
+//        else {
+//            sorterChanged = true;
+//        }
+//
+//        sortManager.processChange(sortedEvent, change, sorterChanged);
+//
+//        if (sorterChanged) {
+//            // Update the editing row
+//            if (this.editingRow != -1) {
+//                int newIndex = (editingModelIndex == -1) ? -1 :
+//                        convertRowIndexToView(editingModelIndex,change);
+//                restoreSortingEditingRow(newIndex);
+//            }
+//
+//            // And handle the appropriate repainting.
+//            if (e == null || change.type != TableModelEvent.UPDATE) {
+//                resizeAndRepaint();
+//            }
+//        }
+//
+//        // Check if lead/anchor need to be reset.
+//        if (change != null && change.allRowsChanged) {
+//            clearSelectionAndLeadAnchor();
+//            resizeAndRepaint();
+//        }
+//    }
 
     /**
      * Repaints the sort of sorted rows in response to a TableModelEvent.
      */
-    private void repaintSortedRows(ModelChange change) {
-        if (change.startModelIndex > change.endModelIndex ||
-                change.startModelIndex + 10 < change.endModelIndex) {
-            // Too much has changed, punt
-            repaint();
-            return;
-        }
-        int eventColumn = change.event.getColumn();
-        int columnViewIndex = eventColumn;
-        if (columnViewIndex == TableModelEvent.ALL_COLUMNS) {
-            columnViewIndex = 0;
-        }
-        else {
-            columnViewIndex = convertColumnIndexToView(columnViewIndex);
-            if (columnViewIndex == -1) {
-                return;
-            }
-        }
-        int modelIndex = change.startModelIndex;
-        while (modelIndex <= change.endModelIndex) {
-            int viewIndex = convertRowIndexToView(modelIndex++);
-            if (viewIndex != -1) {
-                Rectangle dirty = getCellRect(viewIndex, columnViewIndex,
-                                              false);
-                int x = dirty.x;
-                int w = dirty.width;
-                if (eventColumn == TableModelEvent.ALL_COLUMNS) {
-                    x = 0;
-                    w = getWidth();
-                }
-                repaint(x, dirty.y, w, dirty.height);
-            }
-        }
-    }
+    private void repaintSortedRows(ModelChange change) {throw new RuntimeException("cf-bug");} //{
+//        if (change.startModelIndex > change.endModelIndex ||
+//                change.startModelIndex + 10 < change.endModelIndex) {
+//            // Too much has changed, punt
+//            repaint();
+//            return;
+//        }
+//        int eventColumn = change.event.getColumn();
+//        int columnViewIndex = eventColumn;
+//        if (columnViewIndex == TableModelEvent.ALL_COLUMNS) {
+//            columnViewIndex = 0;
+//        }
+//        else {
+//            columnViewIndex = convertColumnIndexToView(columnViewIndex);
+//            if (columnViewIndex == -1) {
+//                return;
+//            }
+//        }
+//        int modelIndex = change.startModelIndex;
+//        while (modelIndex <= change.endModelIndex) {
+//            int viewIndex = convertRowIndexToView(modelIndex++);
+//            if (viewIndex != -1) {
+//                Rectangle dirty = getCellRect(viewIndex, columnViewIndex,
+//                                              false);
+//                int x = dirty.x;
+//                int w = dirty.width;
+//                if (eventColumn == TableModelEvent.ALL_COLUMNS) {
+//                    x = 0;
+//                    w = getWidth();
+//                }
+//                repaint(x, dirty.y, w, dirty.height);
+//            }
+//        }
+//    }
 
     /**
      * Restores the selection after a model event/sort order changes.
      * All coordinates are in terms of the model.
      */
     private void restoreSortingSelection(int[] selection, int lead,
-            ModelChange change) {
-        // Convert the selection from model to view
-        for (int i = selection.length - 1; i >= 0; i--) {
-            selection[i] = convertRowIndexToView(selection[i], change);
-        }
-        lead = convertRowIndexToView(lead, change);
-
-        // Check for the common case of no change in selection for 1 row
-        if (selection.length == 0 ||
-            (selection.length == 1 && selection[0] == getSelectedRow())) {
-            return;
-        }
-
-        // And apply the new selection
-        selectionModel.setValueIsAdjusting(true);
-        selectionModel.clearSelection();
-        for (int i = selection.length - 1; i >= 0; i--) {
-            if (selection[i] != -1) {
-                selectionModel.addSelectionInterval(selection[i],
-                                                    selection[i]);
-            }
-        }
-        SwingUtilities2.setLeadAnchorWithoutSelection(
-                selectionModel, lead, lead);
-        selectionModel.setValueIsAdjusting(false);
-    }
+            ModelChange change) {throw new RuntimeException("cf-bug");} //{
+//        // Convert the selection from model to view
+//        for (int i = selection.length - 1; i >= 0; i--) {
+//            selection[i] = convertRowIndexToView(selection[i], change);
+//        }
+//        lead = convertRowIndexToView(lead, change);
+//
+//        // Check for the common case of no change in selection for 1 row
+//        if (selection.length == 0 ||
+//            (selection.length == 1 && selection[0] == getSelectedRow())) {
+//            return;
+//        }
+//
+//        // And apply the new selection
+//        selectionModel.setValueIsAdjusting(true);
+//        selectionModel.clearSelection();
+//        for (int i = selection.length - 1; i >= 0; i--) {
+//            if (selection[i] != -1) {
+//                selectionModel.addSelectionInterval(selection[i],
+//                                                    selection[i]);
+//            }
+//        }
+//        SwingUtilities2.setLeadAnchorWithoutSelection(
+//                selectionModel, lead, lead);
+//        selectionModel.setValueIsAdjusting(false);
+//    }
 
     /**
      * Restores the editing row after a model event/sort order change.
      *
      * @param editingRow new index of the editingRow, in terms of the view
      */
-    private void restoreSortingEditingRow(int editingRow) {
-        if (editingRow == -1) {
-            // Editing row no longer being shown, cancel editing
-            TableCellEditor editor = getCellEditor();
-            if (editor != null) {
-                // First try and cancel
-                editor.cancelCellEditing();
-                if (getCellEditor() != null) {
-                    // CellEditor didn't cede control, forcefully
-                    // remove it
-                    removeEditor();
-                }
-            }
-        }
-        else {
-            // Repositioning handled in BasicTableUI
-            this.editingRow = editingRow;
-            repaint();
-        }
-    }
+    private void restoreSortingEditingRow(int editingRow) {throw new RuntimeException("cf-bug");} //{
+//        if (editingRow == -1) {
+//            // Editing row no longer being shown, cancel editing
+//            TableCellEditor editor = getCellEditor();
+//            if (editor != null) {
+//                // First try and cancel
+//                editor.cancelCellEditing();
+//                if (getCellEditor() != null) {
+//                    // CellEditor didn't cede control, forcefully
+//                    // remove it
+//                    removeEditor();
+//                }
+//            }
+//        }
+//        else {
+//            // Repositioning handled in BasicTableUI
+//            this.editingRow = editingRow;
+//            repaint();
+//        }
+//    }
 
     /**
      * Notifies the sorter of a change in the underlying model.
      */
-    private void notifySorter(ModelChange change) {
-        try {
-            ignoreSortChange = true;
-            sorterChanged = false;
-            switch(change.type) {
-            case TableModelEvent.UPDATE:
-                if (change.event.getLastRow() == Integer.MAX_VALUE) {
-                    sortManager.sorter.allRowsChanged();
-                } else if (change.event.getColumn() ==
-                           TableModelEvent.ALL_COLUMNS) {
-                    sortManager.sorter.rowsUpdated(change.startModelIndex,
-                                       change.endModelIndex);
-                } else {
-                    sortManager.sorter.rowsUpdated(change.startModelIndex,
-                                       change.endModelIndex,
-                                       change.event.getColumn());
-                }
-                break;
-            case TableModelEvent.INSERT:
-                sortManager.sorter.rowsInserted(change.startModelIndex,
-                                    change.endModelIndex);
-                break;
-            case TableModelEvent.DELETE:
-                sortManager.sorter.rowsDeleted(change.startModelIndex,
-                                   change.endModelIndex);
-                break;
-            }
-        } finally {
-            ignoreSortChange = false;
-        }
-    }
+    private void notifySorter(ModelChange change) {throw new RuntimeException("cf-bug");} //{
+//        try {
+//            ignoreSortChange = true;
+//            sorterChanged = false;
+//            switch(change.type) {
+//            case TableModelEvent.UPDATE:
+//                if (change.event.getLastRow() == Integer.MAX_VALUE) {
+//                    sortManager.sorter.allRowsChanged();
+//                } else if (change.event.getColumn() ==
+//                           TableModelEvent.ALL_COLUMNS) {
+//                    sortManager.sorter.rowsUpdated(change.startModelIndex,
+//                                       change.endModelIndex);
+//                } else {
+//                    sortManager.sorter.rowsUpdated(change.startModelIndex,
+//                                       change.endModelIndex,
+//                                       change.event.getColumn());
+//                }
+//                break;
+//            case TableModelEvent.INSERT:
+//                sortManager.sorter.rowsInserted(change.startModelIndex,
+//                                    change.endModelIndex);
+//                break;
+//            case TableModelEvent.DELETE:
+//                sortManager.sorter.rowsDeleted(change.startModelIndex,
+//                                   change.endModelIndex);
+//                break;
+//            }
+//        } finally {
+//            ignoreSortChange = false;
+//        }
+//    }
 
     /**
      * Converts a model index to view index.  This is called when the
@@ -4287,65 +4287,65 @@
      * @param change describes the TableModelEvent that initiated the change;
      *        will be null if called as the result of a sort
      */
-    private int convertRowIndexToView(int modelIndex, ModelChange change) {
-        if (modelIndex < 0) {
-            return -1;
-        }
-        if (change != null && modelIndex >= change.startModelIndex) {
-            if (change.type == TableModelEvent.INSERT) {
-                if (modelIndex + change.length >= change.modelRowCount) {
-                    return -1;
-                }
-                return sortManager.sorter.convertRowIndexToView(
-                        modelIndex + change.length);
-            }
-            else if (change.type == TableModelEvent.DELETE) {
-                if (modelIndex <= change.endModelIndex) {
-                    // deleted
-                    return -1;
-                }
-                else {
-                    if (modelIndex - change.length >= change.modelRowCount) {
-                        return -1;
-                    }
-                    return sortManager.sorter.convertRowIndexToView(
-                            modelIndex - change.length);
-                }
-            }
-            // else, updated
-        }
-        if (modelIndex >= getModel().getRowCount()) {
-            return -1;
-        }
-        return sortManager.sorter.convertRowIndexToView(modelIndex);
-    }
+    private int convertRowIndexToView(int modelIndex, ModelChange change) {throw new RuntimeException("cf-bug");} //{
+//        if (modelIndex < 0) {
+//            return -1;
+//        }
+//        if (change != null && modelIndex >= change.startModelIndex) {
+//            if (change.type == TableModelEvent.INSERT) {
+//                if (modelIndex + change.length >= change.modelRowCount) {
+//                    return -1;
+//                }
+//                return sortManager.sorter.convertRowIndexToView(
+//                        modelIndex + change.length);
+//            }
+//            else if (change.type == TableModelEvent.DELETE) {
+//                if (modelIndex <= change.endModelIndex) {
+//                    // deleted
+//                    return -1;
+//                }
+//                else {
+//                    if (modelIndex - change.length >= change.modelRowCount) {
+//                        return -1;
+//                    }
+//                    return sortManager.sorter.convertRowIndexToView(
+//                            modelIndex - change.length);
+//                }
+//            }
+//            // else, updated
+//        }
+//        if (modelIndex >= getModel().getRowCount()) {
+//            return -1;
+//        }
+//        return sortManager.sorter.convertRowIndexToView(modelIndex);
+//    }
 
     /**
      * Converts the selection to model coordinates.  This is used when
      * the model changes or the sorter changes.
      */
-    private int[] convertSelectionToModel(RowSorterEvent e) {
-        int[] selection = getSelectedRows();
-        for (int i = selection.length - 1; i >= 0; i--) {
-            selection[i] = convertRowIndexToModel(e, selection[i]);
-        }
-        return selection;
-    }
-
-    private int convertRowIndexToModel(RowSorterEvent e, int viewIndex) {
-        if (e != null) {
-            if (e.getPreviousRowCount() == 0) {
-                return viewIndex;
-            }
-            // range checking handled by RowSorterEvent
-            return e.convertPreviousRowIndexToModel(viewIndex);
-        }
-        // Make sure the viewIndex is valid
-        if (viewIndex < 0 || viewIndex >= getRowCount()) {
-            return -1;
-        }
-        return convertRowIndexToModel(viewIndex);
-    }
+    private int[] convertSelectionToModel(RowSorterEvent e) {throw new RuntimeException("cf-bug");} //{
+//        int[] selection = getSelectedRows();
+//        for (int i = selection.length - 1; i >= 0; i--) {
+//            selection[i] = convertRowIndexToModel(e, selection[i]);
+//        }
+//        return selection;
+//    }
+
+    private int convertRowIndexToModel(RowSorterEvent e, int viewIndex) {throw new RuntimeException("cf-bug");} //{
+//        if (e != null) {
+//            if (e.getPreviousRowCount() == 0) {
+//                return viewIndex;
+//            }
+//            // range checking handled by RowSorterEvent
+//            return e.convertPreviousRowIndexToModel(viewIndex);
+//        }
+//        // Make sure the viewIndex is valid
+//        if (viewIndex < 0 || viewIndex >= getRowCount()) {
+//            return -1;
+//        }
+//        return convertRowIndexToModel(viewIndex);
+//    }
 
 //
 // Implementing TableModelListener interface
@@ -4364,89 +4364,89 @@
      * <p>
      * Note that as of 1.3, this method clears the selection, if any.
      */
-    public void tableChanged(TableModelEvent e) {
-        if (e == null || e.getFirstRow() == TableModelEvent.HEADER_ROW) {
-            // The whole thing changed
-            clearSelectionAndLeadAnchor();
-
-            rowModel = null;
-
-            if (sortManager != null) {
-                try {
-                    ignoreSortChange = true;
-                    sortManager.sorter.modelStructureChanged();
-                } finally {
-                    ignoreSortChange = false;
-                }
-                sortManager.allChanged();
-            }
-
-            if (getAutoCreateColumnsFromModel()) {
-                // This will effect invalidation of the JTable and JTableHeader.
-                createDefaultColumnsFromModel();
-                return;
-            }
-
-            resizeAndRepaint();
-            return;
-        }
-
-        if (sortManager != null) {
-            sortedTableChanged(null, e);
-            return;
-        }
-
-        // The totalRowHeight calculated below will be incorrect if
-        // there are variable height rows. Repaint the visible region,
-        // but don't return as a revalidate may be necessary as well.
-        if (rowModel != null) {
-            repaint();
-        }
-
-        if (e.getType() == TableModelEvent.INSERT) {
-            tableRowsInserted(e);
-            return;
-        }
-
-        if (e.getType() == TableModelEvent.DELETE) {
-            tableRowsDeleted(e);
-            return;
-        }
-
-        int modelColumn = e.getColumn();
-        int start = e.getFirstRow();
-        int end = e.getLastRow();
-
-        Rectangle dirtyRegion;
-        if (modelColumn == TableModelEvent.ALL_COLUMNS) {
-            // 1 or more rows changed
-            dirtyRegion = new Rectangle(0, start * getRowHeight(),
-                                        getColumnModel().getTotalColumnWidth(), 0);
-        }
-        else {
-            // A cell or column of cells has changed.
-            // Unlike the rest of the methods in the JTable, the TableModelEvent
-            // uses the coordinate system of the model instead of the view.
-            // This is the only place in the JTable where this "reverse mapping"
-            // is used.
-            int column = convertColumnIndexToView(modelColumn);
-            dirtyRegion = getCellRect(start, column, false);
-        }
-
-        // Now adjust the height of the dirty region according to the value of "end".
-        // Check for Integer.MAX_VALUE as this will cause an overflow.
-        if (end != Integer.MAX_VALUE) {
-            dirtyRegion.height = (end-start+1)*getRowHeight();
-            repaint(dirtyRegion.x, dirtyRegion.y, dirtyRegion.width, dirtyRegion.height);
-        }
-        // In fact, if the end is Integer.MAX_VALUE we need to revalidate anyway
-        // because the scrollbar may need repainting.
-        else {
-            clearSelectionAndLeadAnchor();
-            resizeAndRepaint();
-            rowModel = null;
-        }
-    }
+    public void tableChanged(TableModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//        if (e == null || e.getFirstRow() == TableModelEvent.HEADER_ROW) {
+//            // The whole thing changed
+//            clearSelectionAndLeadAnchor();
+//
+//            rowModel = null;
+//
+//            if (sortManager != null) {
+//                try {
+//                    ignoreSortChange = true;
+//                    sortManager.sorter.modelStructureChanged();
+//                } finally {
+//                    ignoreSortChange = false;
+//                }
+//                sortManager.allChanged();
+//            }
+//
+//            if (getAutoCreateColumnsFromModel()) {
+//                // This will effect invalidation of the JTable and JTableHeader.
+//                createDefaultColumnsFromModel();
+//                return;
+//            }
+//
+//            resizeAndRepaint();
+//            return;
+//        }
+//
+//        if (sortManager != null) {
+//            sortedTableChanged(null, e);
+//            return;
+//        }
+//
+//        // The totalRowHeight calculated below will be incorrect if
+//        // there are variable height rows. Repaint the visible region,
+//        // but don't return as a revalidate may be necessary as well.
+//        if (rowModel != null) {
+//            repaint();
+//        }
+//
+//        if (e.getType() == TableModelEvent.INSERT) {
+//            tableRowsInserted(e);
+//            return;
+//        }
+//
+//        if (e.getType() == TableModelEvent.DELETE) {
+//            tableRowsDeleted(e);
+//            return;
+//        }
+//
+//        int modelColumn = e.getColumn();
+//        int start = e.getFirstRow();
+//        int end = e.getLastRow();
+//
+//        Rectangle dirtyRegion;
+//        if (modelColumn == TableModelEvent.ALL_COLUMNS) {
+//            // 1 or more rows changed
+//            dirtyRegion = new Rectangle(0, start * getRowHeight(),
+//                                        getColumnModel().getTotalColumnWidth(), 0);
+//        }
+//        else {
+//            // A cell or column of cells has changed.
+//            // Unlike the rest of the methods in the JTable, the TableModelEvent
+//            // uses the coordinate system of the model instead of the view.
+//            // This is the only place in the JTable where this "reverse mapping"
+//            // is used.
+//            int column = convertColumnIndexToView(modelColumn);
+//            dirtyRegion = getCellRect(start, column, false);
+//        }
+//
+//        // Now adjust the height of the dirty region according to the value of "end".
+//        // Check for Integer.MAX_VALUE as this will cause an overflow.
+//        if (end != Integer.MAX_VALUE) {
+//            dirtyRegion.height = (end-start+1)*getRowHeight();
+//            repaint(dirtyRegion.x, dirtyRegion.y, dirtyRegion.width, dirtyRegion.height);
+//        }
+//        // In fact, if the end is Integer.MAX_VALUE we need to revalidate anyway
+//        // because the scrollbar may need repainting.
+//        else {
+//            clearSelectionAndLeadAnchor();
+//            resizeAndRepaint();
+//            rowModel = null;
+//        }
+//    }
 
     /*
      * Invoked when rows have been inserted into the table.
@@ -4456,34 +4456,34 @@
      *
      * @param e the TableModelEvent encapsulating the insertion
      */
-    private void tableRowsInserted(TableModelEvent e) {
-        int start = e.getFirstRow();
-        int end = e.getLastRow();
-        if (start < 0) {
-            start = 0;
-        }
-        if (end < 0) {
-            end = getRowCount()-1;
-        }
-
-        // Adjust the selection to account for the new rows.
-        int length = end - start + 1;
-        selectionModel.insertIndexInterval(start, length, true);
-
-        // If we have variable height rows, adjust the row model.
-        if (rowModel != null) {
-            rowModel.insertEntries(start, length, getRowHeight());
-        }
-        int rh = getRowHeight() ;
-        Rectangle drawRect = new Rectangle(0, start * rh,
-                                        getColumnModel().getTotalColumnWidth(),
-                                           (getRowCount()-start) * rh);
-
-        revalidate();
-        // PENDING(milne) revalidate calls repaint() if parent is a ScrollPane
-        // repaint still required in the unusual case where there is no ScrollPane
-        repaint(drawRect);
-    }
+    private void tableRowsInserted(TableModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//        int start = e.getFirstRow();
+//        int end = e.getLastRow();
+//        if (start < 0) {
+//            start = 0;
+//        }
+//        if (end < 0) {
+//            end = getRowCount()-1;
+//        }
+//
+//        // Adjust the selection to account for the new rows.
+//        int length = end - start + 1;
+//        selectionModel.insertIndexInterval(start, length, true);
+//
+//        // If we have variable height rows, adjust the row model.
+//        if (rowModel != null) {
+//            rowModel.insertEntries(start, length, getRowHeight());
+//        }
+//        int rh = getRowHeight() ;
+//        Rectangle drawRect = new Rectangle(0, start * rh,
+//                                        getColumnModel().getTotalColumnWidth(),
+//                                           (getRowCount()-start) * rh);
+//
+//        revalidate();
+//        // PENDING(milne) revalidate calls repaint() if parent is a ScrollPane
+//        // repaint still required in the unusual case where there is no ScrollPane
+//        repaint(drawRect);
+//    }
 
     /*
      * Invoked when rows have been removed from the table.
@@ -4493,36 +4493,36 @@
      *
      * @param e the TableModelEvent encapsulating the deletion
      */
-    private void tableRowsDeleted(TableModelEvent e) {
-        int start = e.getFirstRow();
-        int end = e.getLastRow();
-        if (start < 0) {
-            start = 0;
-        }
-        if (end < 0) {
-            end = getRowCount()-1;
-        }
-
-        int deletedCount = end - start + 1;
-        int previousRowCount = getRowCount() + deletedCount;
-        // Adjust the selection to account for the new rows
-        selectionModel.removeIndexInterval(start, end);
-
-        // If we have variable height rows, adjust the row model.
-        if (rowModel != null) {
-            rowModel.removeEntries(start, deletedCount);
-        }
-
-        int rh = getRowHeight();
-        Rectangle drawRect = new Rectangle(0, start * rh,
-                                        getColumnModel().getTotalColumnWidth(),
-                                        (previousRowCount - start) * rh);
-
-        revalidate();
-        // PENDING(milne) revalidate calls repaint() if parent is a ScrollPane
-        // repaint still required in the unusual case where there is no ScrollPane
-        repaint(drawRect);
-    }
+    private void tableRowsDeleted(TableModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//        int start = e.getFirstRow();
+//        int end = e.getLastRow();
+//        if (start < 0) {
+//            start = 0;
+//        }
+//        if (end < 0) {
+//            end = getRowCount()-1;
+//        }
+//
+//        int deletedCount = end - start + 1;
+//        int previousRowCount = getRowCount() + deletedCount;
+//        // Adjust the selection to account for the new rows
+//        selectionModel.removeIndexInterval(start, end);
+//
+//        // If we have variable height rows, adjust the row model.
+//        if (rowModel != null) {
+//            rowModel.removeEntries(start, deletedCount);
+//        }
+//
+//        int rh = getRowHeight();
+//        Rectangle drawRect = new Rectangle(0, start * rh,
+//                                        getColumnModel().getTotalColumnWidth(),
+//                                        (previousRowCount - start) * rh);
+//
+//        revalidate();
+//        // PENDING(milne) revalidate calls repaint() if parent is a ScrollPane
+//        // repaint still required in the unusual case where there is no ScrollPane
+//        repaint(drawRect);
+//    }
 
 //
 // Implementing TableColumnModelListener interface
@@ -4536,13 +4536,13 @@
      *
      * @see TableColumnModelListener
      */
-    public void columnAdded(TableColumnModelEvent e) {
-        // If I'm currently editing, then I should stop editing
-        if (isEditing()) {
-            removeEditor();
-        }
-        resizeAndRepaint();
-    }
+    public void columnAdded(TableColumnModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//        // If I'm currently editing, then I should stop editing
+//        if (isEditing()) {
+//            removeEditor();
+//        }
+//        resizeAndRepaint();
+//    }
 
     /**
      * Invoked when a column is removed from the table column model.
@@ -4552,13 +4552,13 @@
      *
      * @see TableColumnModelListener
      */
-    public void columnRemoved(TableColumnModelEvent e) {
-        // If I'm currently editing, then I should stop editing
-        if (isEditing()) {
-            removeEditor();
-        }
-        resizeAndRepaint();
-    }
+    public void columnRemoved(TableColumnModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//        // If I'm currently editing, then I should stop editing
+//        if (isEditing()) {
+//            removeEditor();
+//        }
+//        resizeAndRepaint();
+//    }
 
     /**
      * Invoked when a column is repositioned. If a cell is being
@@ -4570,12 +4570,12 @@
      * @param e   the event received
      * @see TableColumnModelListener
      */
-    public void columnMoved(TableColumnModelEvent e) {
-        if (isEditing() && !getCellEditor().stopCellEditing()) {
-            getCellEditor().cancelCellEditing();
-        }
-        repaint();
-    }
+    public void columnMoved(TableColumnModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//        if (isEditing() && !getCellEditor().stopCellEditing()) {
+//            getCellEditor().cancelCellEditing();
+//        }
+//        repaint();
+//    }
 
     /**
      * Invoked when a column is moved due to a margin change.
@@ -4588,22 +4588,22 @@
      * @param  e    the event received
      * @see TableColumnModelListener
      */
-    public void columnMarginChanged(ChangeEvent e) {
-        if (isEditing() && !getCellEditor().stopCellEditing()) {
-            getCellEditor().cancelCellEditing();
-        }
-        TableColumn resizingColumn = getResizingColumn();
-        // Need to do this here, before the parent's
-        // layout manager calls getPreferredSize().
-        if (resizingColumn != null && autoResizeMode == AUTO_RESIZE_OFF) {
-            resizingColumn.setPreferredWidth(resizingColumn.getWidth());
-        }
-        resizeAndRepaint();
-    }
-
-    private int limit(int i, int a, int b) {
-        return Math.min(b, Math.max(i, a));
-    }
+    public void columnMarginChanged(ChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//        if (isEditing() && !getCellEditor().stopCellEditing()) {
+//            getCellEditor().cancelCellEditing();
+//        }
+//        TableColumn resizingColumn = getResizingColumn();
+//        // Need to do this here, before the parent's
+//        // layout manager calls getPreferredSize().
+//        if (resizingColumn != null && autoResizeMode == AUTO_RESIZE_OFF) {
+//            resizingColumn.setPreferredWidth(resizingColumn.getWidth());
+//        }
+//        resizeAndRepaint();
+//    }
+
+    private int limit(int i, int a, int b) {throw new RuntimeException("cf-bug");} //{
+//        return Math.min(b, Math.max(i, a));
+//    }
 
     /**
      * Invoked when the selection model of the <code>TableColumnModel</code>
@@ -4615,52 +4615,52 @@
      * @param  e  the event received
      * @see TableColumnModelListener
      */
-    public void columnSelectionChanged(ListSelectionEvent e) {
-        boolean isAdjusting = e.getValueIsAdjusting();
-        if (columnSelectionAdjusting && !isAdjusting) {
-            // The assumption is that when the model is no longer adjusting
-            // we will have already gotten all the changes, and therefore
-            // don't need to do an additional paint.
-            columnSelectionAdjusting = false;
-            return;
-        }
-        columnSelectionAdjusting = isAdjusting;
-        // The getCellRect() call will fail unless there is at least one row.
-        if (getRowCount() <= 0 || getColumnCount() <= 0) {
-            return;
-        }
-        int firstIndex = limit(e.getFirstIndex(), 0, getColumnCount()-1);
-        int lastIndex = limit(e.getLastIndex(), 0, getColumnCount()-1);
-        int minRow = 0;
-        int maxRow = getRowCount() - 1;
-        if (getRowSelectionAllowed()) {
-            minRow = selectionModel.getMinSelectionIndex();
-            maxRow = selectionModel.getMaxSelectionIndex();
-            int leadRow = getAdjustedIndex(selectionModel.getLeadSelectionIndex(), true);
-
-            if (minRow == -1 || maxRow == -1) {
-                if (leadRow == -1) {
-                    // nothing to repaint, return
-                    return;
-                }
-
-                // only thing to repaint is the lead
-                minRow = maxRow = leadRow;
-            } else {
-                // We need to consider more than just the range between
-                // the min and max selected index. The lead row, which could
-                // be outside this range, should be considered also.
-                if (leadRow != -1) {
-                    minRow = Math.min(minRow, leadRow);
-                    maxRow = Math.max(maxRow, leadRow);
-                }
-            }
-        }
-        Rectangle firstColumnRect = getCellRect(minRow, firstIndex, false);
-        Rectangle lastColumnRect = getCellRect(maxRow, lastIndex, false);
-        Rectangle dirtyRegion = firstColumnRect.union(lastColumnRect);
-        repaint(dirtyRegion);
-    }
+    public void columnSelectionChanged(ListSelectionEvent e) {throw new RuntimeException("cf-bug");} //{
+//        boolean isAdjusting = e.getValueIsAdjusting();
+//        if (columnSelectionAdjusting && !isAdjusting) {
+//            // The assumption is that when the model is no longer adjusting
+//            // we will have already gotten all the changes, and therefore
+//            // don't need to do an additional paint.
+//            columnSelectionAdjusting = false;
+//            return;
+//        }
+//        columnSelectionAdjusting = isAdjusting;
+//        // The getCellRect() call will fail unless there is at least one row.
+//        if (getRowCount() <= 0 || getColumnCount() <= 0) {
+//            return;
+//        }
+//        int firstIndex = limit(e.getFirstIndex(), 0, getColumnCount()-1);
+//        int lastIndex = limit(e.getLastIndex(), 0, getColumnCount()-1);
+//        int minRow = 0;
+//        int maxRow = getRowCount() - 1;
+//        if (getRowSelectionAllowed()) {
+//            minRow = selectionModel.getMinSelectionIndex();
+//            maxRow = selectionModel.getMaxSelectionIndex();
+//            int leadRow = getAdjustedIndex(selectionModel.getLeadSelectionIndex(), true);
+//
+//            if (minRow == -1 || maxRow == -1) {
+//                if (leadRow == -1) {
+//                    // nothing to repaint, return
+//                    return;
+//                }
+//
+//                // only thing to repaint is the lead
+//                minRow = maxRow = leadRow;
+//            } else {
+//                // We need to consider more than just the range between
+//                // the min and max selected index. The lead row, which could
+//                // be outside this range, should be considered also.
+//                if (leadRow != -1) {
+//                    minRow = Math.min(minRow, leadRow);
+//                    maxRow = Math.max(maxRow, leadRow);
+//                }
+//            }
+//        }
+//        Rectangle firstColumnRect = getCellRect(minRow, firstIndex, false);
+//        Rectangle lastColumnRect = getCellRect(maxRow, lastIndex, false);
+//        Rectangle dirtyRegion = firstColumnRect.union(lastColumnRect);
+//        repaint(dirtyRegion);
+//    }
 
 //
 // Implementing ListSelectionListener interface
@@ -4676,30 +4676,30 @@
      * @param e   the event received
      * @see ListSelectionListener
      */
-    public void valueChanged(ListSelectionEvent e) {
-        if (sortManager != null) {
-            sortManager.viewSelectionChanged(e);
-        }
-        boolean isAdjusting = e.getValueIsAdjusting();
-        if (rowSelectionAdjusting && !isAdjusting) {
-            // The assumption is that when the model is no longer adjusting
-            // we will have already gotten all the changes, and therefore
-            // don't need to do an additional paint.
-            rowSelectionAdjusting = false;
-            return;
-        }
-        rowSelectionAdjusting = isAdjusting;
-        // The getCellRect() calls will fail unless there is at least one column.
-        if (getRowCount() <= 0 || getColumnCount() <= 0) {
-            return;
-        }
-        int firstIndex = limit(e.getFirstIndex(), 0, getRowCount()-1);
-        int lastIndex = limit(e.getLastIndex(), 0, getRowCount()-1);
-        Rectangle firstRowRect = getCellRect(firstIndex, 0, false);
-        Rectangle lastRowRect = getCellRect(lastIndex, getColumnCount()-1, false);
-        Rectangle dirtyRegion = firstRowRect.union(lastRowRect);
-        repaint(dirtyRegion);
-    }
+    public void valueChanged(ListSelectionEvent e) {throw new RuntimeException("cf-bug");} //{
+//        if (sortManager != null) {
+//            sortManager.viewSelectionChanged(e);
+//        }
+//        boolean isAdjusting = e.getValueIsAdjusting();
+//        if (rowSelectionAdjusting && !isAdjusting) {
+//            // The assumption is that when the model is no longer adjusting
+//            // we will have already gotten all the changes, and therefore
+//            // don't need to do an additional paint.
+//            rowSelectionAdjusting = false;
+//            return;
+//        }
+//        rowSelectionAdjusting = isAdjusting;
+//        // The getCellRect() calls will fail unless there is at least one column.
+//        if (getRowCount() <= 0 || getColumnCount() <= 0) {
+//            return;
+//        }
+//        int firstIndex = limit(e.getFirstIndex(), 0, getRowCount()-1);
+//        int lastIndex = limit(e.getLastIndex(), 0, getRowCount()-1);
+//        Rectangle firstRowRect = getCellRect(firstIndex, 0, false);
+//        Rectangle lastRowRect = getCellRect(lastIndex, getColumnCount()-1, false);
+//        Rectangle dirtyRegion = firstRowRect.union(lastRowRect);
+//        repaint(dirtyRegion);
+//    }
 
 //
 // Implementing the CellEditorListener interface
@@ -4715,15 +4715,15 @@
      * @param  e  the event received
      * @see CellEditorListener
      */
-    public void editingStopped(ChangeEvent e) {
-        // Take in the new value
-        TableCellEditor editor = getCellEditor();
-        if (editor != null) {
-            Object value = editor.getCellEditorValue();
-            setValueAt(value, editingRow, editingColumn);
-            removeEditor();
-        }
-    }
+    public void editingStopped(ChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//        // Take in the new value
+//        TableCellEditor editor = getCellEditor();
+//        if (editor != null) {
+//            Object value = editor.getCellEditorValue();
+//            setValueAt(value, editingRow, editingColumn);
+//            removeEditor();
+//        }
+//    }
 
     /**
      * Invoked when editing is canceled. The editor object is discarded
@@ -4735,9 +4735,9 @@
      * @param  e  the event received
      * @see CellEditorListener
      */
-    public void editingCanceled(ChangeEvent e) {
-        removeEditor();
-    }
+    public void editingCanceled(ChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//        removeEditor();
+//    }
 
 //
 // Implementing the Scrollable interface
@@ -4752,9 +4752,9 @@
      * @beaninfo
      * description: The preferred size of the viewport.
      */
-    public void setPreferredScrollableViewportSize(Dimension size) {
-        preferredViewportSize = size;
-    }
+    public void setPreferredScrollableViewportSize(Dimension size) {throw new RuntimeException("cf-bug");} //{
+//        preferredViewportSize = size;
+//    }
 
     /**
      * Returns the preferred size of the viewport for this table.
@@ -4763,9 +4763,9 @@
      *         which displays this table
      * @see Scrollable#getPreferredScrollableViewportSize
      */
-    public Dimension getPreferredScrollableViewportSize() {
-        return preferredViewportSize;
-    }
+    public Dimension getPreferredScrollableViewportSize() {throw new RuntimeException("cf-bug");} //{
+//        return preferredViewportSize;
+//    }
 
     /**
      * Returns the scroll increment (in pixels) that completely exposes one new
@@ -4783,91 +4783,91 @@
      */
     public int getScrollableUnitIncrement(Rectangle visibleRect,
                                           int orientation,
-                                          int direction) {
-        int leadingRow;
-        int leadingCol;
-        Rectangle leadingCellRect;
-
-        int leadingVisibleEdge;
-        int leadingCellEdge;
-        int leadingCellSize;
-
-        leadingRow = getLeadingRow(visibleRect);
-        leadingCol = getLeadingCol(visibleRect);
-        if (orientation == SwingConstants.VERTICAL && leadingRow < 0) {
-            // Couldn't find leading row - return some default value
-            return getRowHeight();
-        }
-        else if (orientation == SwingConstants.HORIZONTAL && leadingCol < 0) {
-            // Couldn't find leading col - return some default value
-            return 100;
-        }
-
-        // Note that it's possible for one of leadingCol or leadingRow to be
-        // -1, depending on the orientation.  This is okay, as getCellRect()
-        // still provides enough information to calculate the unit increment.
-        leadingCellRect = getCellRect(leadingRow, leadingCol, true);
-        leadingVisibleEdge = leadingEdge(visibleRect, orientation);
-        leadingCellEdge = leadingEdge(leadingCellRect, orientation);
-
-        if (orientation == SwingConstants.VERTICAL) {
-            leadingCellSize = leadingCellRect.height;
-
-        }
-        else {
-            leadingCellSize = leadingCellRect.width;
-        }
-
-        // 4 cases:
-        // #1: Leading cell fully visible, reveal next cell
-        // #2: Leading cell fully visible, hide leading cell
-        // #3: Leading cell partially visible, hide rest of leading cell
-        // #4: Leading cell partially visible, reveal rest of leading cell
-
-        if (leadingVisibleEdge == leadingCellEdge) { // Leading cell is fully
-                                                     // visible
-            // Case #1: Reveal previous cell
-            if (direction < 0) {
-                int retVal = 0;
-
-                if (orientation == SwingConstants.VERTICAL) {
-                    // Loop past any zero-height rows
-                    while (--leadingRow >= 0) {
-                        retVal = getRowHeight(leadingRow);
-                        if (retVal != 0) {
-                            break;
-                        }
-                    }
-                }
-                else { // HORIZONTAL
-                    // Loop past any zero-width cols
-                    while (--leadingCol >= 0) {
-                        retVal = getCellRect(leadingRow, leadingCol, true).width;
-                        if (retVal != 0) {
-                            break;
-                        }
-                    }
-                }
-                return retVal;
-            }
-            else { // Case #2: hide leading cell
-                return leadingCellSize;
-            }
-        }
-        else { // Leading cell is partially hidden
-            // Compute visible, hidden portions
-            int hiddenAmt = Math.abs(leadingVisibleEdge - leadingCellEdge);
-            int visibleAmt = leadingCellSize - hiddenAmt;
-
-            if (direction > 0) {
-                // Case #3: hide showing portion of leading cell
-                return visibleAmt;
-            }
-            else { // Case #4: reveal hidden portion of leading cell
-                return hiddenAmt;
-            }
-        }
-    }
+                                          int direction) {throw new RuntimeException("cf-bug");} //{
+//        int leadingRow;
+//        int leadingCol;
+//        Rectangle leadingCellRect;
+//
+//        int leadingVisibleEdge;
+//        int leadingCellEdge;
+//        int leadingCellSize;
+//
+//        leadingRow = getLeadingRow(visibleRect);
+//        leadingCol = getLeadingCol(visibleRect);
+//        if (orientation == SwingConstants.VERTICAL && leadingRow < 0) {
+//            // Couldn't find leading row - return some default value
+//            return getRowHeight();
+//        }
+//        else if (orientation == SwingConstants.HORIZONTAL && leadingCol < 0) {
+//            // Couldn't find leading col - return some default value
+//            return 100;
+//        }
+//
+//        // Note that it's possible for one of leadingCol or leadingRow to be
+//        // -1, depending on the orientation.  This is okay, as getCellRect()
+//        // still provides enough information to calculate the unit increment.
+//        leadingCellRect = getCellRect(leadingRow, leadingCol, true);
+//        leadingVisibleEdge = leadingEdge(visibleRect, orientation);
+//        leadingCellEdge = leadingEdge(leadingCellRect, orientation);
+//
+//        if (orientation == SwingConstants.VERTICAL) {
+//            leadingCellSize = leadingCellRect.height;
+//
+//        }
+//        else {
+//            leadingCellSize = leadingCellRect.width;
+//        }
+//
+//        // 4 cases:
+//        // #1: Leading cell fully visible, reveal next cell
+//        // #2: Leading cell fully visible, hide leading cell
+//        // #3: Leading cell partially visible, hide rest of leading cell
+//        // #4: Leading cell partially visible, reveal rest of leading cell
+//
+//        if (leadingVisibleEdge == leadingCellEdge) { // Leading cell is fully
+//                                                     // visible
+//            // Case #1: Reveal previous cell
+//            if (direction < 0) {
+//                int retVal = 0;
+//
+//                if (orientation == SwingConstants.VERTICAL) {
+//                    // Loop past any zero-height rows
+//                    while (--leadingRow >= 0) {
+//                        retVal = getRowHeight(leadingRow);
+//                        if (retVal != 0) {
+//                            break;
+//                        }
+//                    }
+//                }
+//                else { // HORIZONTAL
+//                    // Loop past any zero-width cols
+//                    while (--leadingCol >= 0) {
+//                        retVal = getCellRect(leadingRow, leadingCol, true).width;
+//                        if (retVal != 0) {
+//                            break;
+//                        }
+//                    }
+//                }
+//                return retVal;
+//            }
+//            else { // Case #2: hide leading cell
+//                return leadingCellSize;
+//            }
+//        }
+//        else { // Leading cell is partially hidden
+//            // Compute visible, hidden portions
+//            int hiddenAmt = Math.abs(leadingVisibleEdge - leadingCellEdge);
+//            int visibleAmt = leadingCellSize - hiddenAmt;
+//
+//            if (direction > 0) {
+//                // Case #3: hide showing portion of leading cell
+//                return visibleAmt;
+//            }
+//            else { // Case #4: reveal hidden portion of leading cell
+//                return hiddenAmt;
+//            }
+//        }
+//    }
 
     /**
      * Returns <code>visibleRect.height</code> or
@@ -4883,39 +4883,39 @@
      * @see Scrollable#getScrollableBlockIncrement
      */
     public int getScrollableBlockIncrement(Rectangle visibleRect,
-            int orientation, int direction) {
-
-        if (getRowCount() == 0) {
-            // Short-circuit empty table model
-            if (SwingConstants.VERTICAL == orientation) {
-                int rh = getRowHeight();
-                return (rh > 0) ? Math.max(rh, (visibleRect.height / rh) * rh) :
-                                  visibleRect.height;
-            }
-            else {
-                return visibleRect.width;
-            }
-        }
-        // Shortcut for vertical scrolling of a table w/ uniform row height
-        if (null == rowModel && SwingConstants.VERTICAL == orientation) {
-            int row = rowAtPoint(visibleRect.getLocation());
-            assert row != -1;
-            int col = columnAtPoint(visibleRect.getLocation());
-            Rectangle cellRect = getCellRect(row, col, true);
-
-            if (cellRect.y == visibleRect.y) {
-                int rh = getRowHeight();
-                assert rh > 0;
-                return Math.max(rh, (visibleRect.height / rh) * rh);
-            }
-        }
-        if (direction < 0) {
-            return getPreviousBlockIncrement(visibleRect, orientation);
-        }
-        else {
-            return getNextBlockIncrement(visibleRect, orientation);
-        }
-    }
+            int orientation, int direction) {throw new RuntimeException("cf-bug");} //{
+//
+//        if (getRowCount() == 0) {
+//            // Short-circuit empty table model
+//            if (SwingConstants.VERTICAL == orientation) {
+//                int rh = getRowHeight();
+//                return (rh > 0) ? Math.max(rh, (visibleRect.height / rh) * rh) :
+//                                  visibleRect.height;
+//            }
+//            else {
+//                return visibleRect.width;
+//            }
+//        }
+//        // Shortcut for vertical scrolling of a table w/ uniform row height
+//        if (null == rowModel && SwingConstants.VERTICAL == orientation) {
+//            int row = rowAtPoint(visibleRect.getLocation());
+//            assert row != -1;
+//            int col = columnAtPoint(visibleRect.getLocation());
+//            Rectangle cellRect = getCellRect(row, col, true);
+//
+//            if (cellRect.y == visibleRect.y) {
+//                int rh = getRowHeight();
+//                assert rh > 0;
+//                return Math.max(rh, (visibleRect.height / rh) * rh);
+//            }
+//        }
+//        if (direction < 0) {
+//            return getPreviousBlockIncrement(visibleRect, orientation);
+//        }
+//        else {
+//            return getNextBlockIncrement(visibleRect, orientation);
+//        }
+//    }
 
     /**
      * Called to get the block increment for upward scrolling in cases of
@@ -4923,89 +4923,89 @@
      * variable row heights.
      */
     private int getPreviousBlockIncrement(Rectangle visibleRect,
-                                          int orientation) {
-        // Measure back from visible leading edge
-        // If we hit the cell on its leading edge, it becomes the leading cell.
-        // Else, use following cell
-
-        int row;
-        int col;
-
-        int   newEdge;
-        Point newCellLoc;
-
-        int visibleLeadingEdge = leadingEdge(visibleRect, orientation);
-        boolean leftToRight = getComponentOrientation().isLeftToRight();
-        int newLeadingEdge;
-
-        // Roughly determine the new leading edge by measuring back from the
-        // leading visible edge by the size of the visible rect, and find the
-        // cell there.
-        if (orientation == SwingConstants.VERTICAL) {
-            newEdge = visibleLeadingEdge - visibleRect.height;
-            int x = visibleRect.x + (leftToRight ? 0 : visibleRect.width);
-            newCellLoc = new Point(x, newEdge);
-        }
-        else if (leftToRight) {
-            newEdge = visibleLeadingEdge - visibleRect.width;
-            newCellLoc = new Point(newEdge, visibleRect.y);
-        }
-        else { // Horizontal, right-to-left
-            newEdge = visibleLeadingEdge + visibleRect.width;
-            newCellLoc = new Point(newEdge - 1, visibleRect.y);
-        }
-        row = rowAtPoint(newCellLoc);
-        col = columnAtPoint(newCellLoc);
-
-        // If we're measuring past the beginning of the table, we get an invalid
-        // cell.  Just go to the beginning of the table in this case.
-        if (orientation == SwingConstants.VERTICAL & row < 0) {
-            newLeadingEdge = 0;
-        }
-        else if (orientation == SwingConstants.HORIZONTAL & col < 0) {
-            if (leftToRight) {
-                newLeadingEdge = 0;
-            }
-            else {
-                newLeadingEdge = getWidth();
-            }
-        }
-        else {
-            // Refine our measurement
-            Rectangle newCellRect = getCellRect(row, col, true);
-            int newCellLeadingEdge = leadingEdge(newCellRect, orientation);
-            int newCellTrailingEdge = trailingEdge(newCellRect, orientation);
-
-            // Usually, we hit in the middle of newCell, and want to scroll to
-            // the beginning of the cell after newCell.  But there are a
-            // couple corner cases where we want to scroll to the beginning of
-            // newCell itself.  These cases are:
-            // 1) newCell is so large that it ends at or extends into the
-            //    visibleRect (newCell is the leading cell, or is adjacent to
-            //    the leading cell)
-            // 2) newEdge happens to fall right on the beginning of a cell
-
-            // Case 1
-            if ((orientation == SwingConstants.VERTICAL || leftToRight) &&
-                (newCellTrailingEdge >= visibleLeadingEdge)) {
-                newLeadingEdge = newCellLeadingEdge;
-            }
-            else if (orientation == SwingConstants.HORIZONTAL &&
-                     !leftToRight &&
-                     newCellTrailingEdge <= visibleLeadingEdge) {
-                newLeadingEdge = newCellLeadingEdge;
-            }
-            // Case 2:
-            else if (newEdge == newCellLeadingEdge) {
-                newLeadingEdge = newCellLeadingEdge;
-            }
-            // Common case: scroll to cell after newCell
-            else {
-                newLeadingEdge = newCellTrailingEdge;
-            }
-        }
-        return Math.abs(visibleLeadingEdge - newLeadingEdge);
-    }
+                                          int orientation) {throw new RuntimeException("cf-bug");} //{
+//        // Measure back from visible leading edge
+//        // If we hit the cell on its leading edge, it becomes the leading cell.
+//        // Else, use following cell
+//
+//        int row;
+//        int col;
+//
+//        int   newEdge;
+//        Point newCellLoc;
+//
+//        int visibleLeadingEdge = leadingEdge(visibleRect, orientation);
+//        boolean leftToRight = getComponentOrientation().isLeftToRight();
+//        int newLeadingEdge;
+//
+//        // Roughly determine the new leading edge by measuring back from the
+//        // leading visible edge by the size of the visible rect, and find the
+//        // cell there.
+//        if (orientation == SwingConstants.VERTICAL) {
+//            newEdge = visibleLeadingEdge - visibleRect.height;
+//            int x = visibleRect.x + (leftToRight ? 0 : visibleRect.width);
+//            newCellLoc = new Point(x, newEdge);
+//        }
+//        else if (leftToRight) {
+//            newEdge = visibleLeadingEdge - visibleRect.width;
+//            newCellLoc = new Point(newEdge, visibleRect.y);
+//        }
+//        else { // Horizontal, right-to-left
+//            newEdge = visibleLeadingEdge + visibleRect.width;
+//            newCellLoc = new Point(newEdge - 1, visibleRect.y);
+//        }
+//        row = rowAtPoint(newCellLoc);
+//        col = columnAtPoint(newCellLoc);
+//
+//        // If we're measuring past the beginning of the table, we get an invalid
+//        // cell.  Just go to the beginning of the table in this case.
+//        if (orientation == SwingConstants.VERTICAL & row < 0) {
+//            newLeadingEdge = 0;
+//        }
+//        else if (orientation == SwingConstants.HORIZONTAL & col < 0) {
+//            if (leftToRight) {
+//                newLeadingEdge = 0;
+//            }
+//            else {
+//                newLeadingEdge = getWidth();
+//            }
+//        }
+//        else {
+//            // Refine our measurement
+//            Rectangle newCellRect = getCellRect(row, col, true);
+//            int newCellLeadingEdge = leadingEdge(newCellRect, orientation);
+//            int newCellTrailingEdge = trailingEdge(newCellRect, orientation);
+//
+//            // Usually, we hit in the middle of newCell, and want to scroll to
+//            // the beginning of the cell after newCell.  But there are a
+//            // couple corner cases where we want to scroll to the beginning of
+//            // newCell itself.  These cases are:
+//            // 1) newCell is so large that it ends at or extends into the
+//            //    visibleRect (newCell is the leading cell, or is adjacent to
+//            //    the leading cell)
+//            // 2) newEdge happens to fall right on the beginning of a cell
+//
+//            // Case 1
+//            if ((orientation == SwingConstants.VERTICAL || leftToRight) &&
+//                (newCellTrailingEdge >= visibleLeadingEdge)) {
+//                newLeadingEdge = newCellLeadingEdge;
+//            }
+//            else if (orientation == SwingConstants.HORIZONTAL &&
+//                     !leftToRight &&
+//                     newCellTrailingEdge <= visibleLeadingEdge) {
+//                newLeadingEdge = newCellLeadingEdge;
+//            }
+//            // Case 2:
+//            else if (newEdge == newCellLeadingEdge) {
+//                newLeadingEdge = newCellLeadingEdge;
+//            }
+//            // Common case: scroll to cell after newCell
+//            else {
+//                newLeadingEdge = newCellTrailingEdge;
+//            }
+//        }
+//        return Math.abs(visibleLeadingEdge - newLeadingEdge);
+//    }
 
     /**
      * Called to get the block increment for downward scrolling in cases of
@@ -5013,169 +5013,169 @@
      * variable row heights.
      */
     private int getNextBlockIncrement(Rectangle visibleRect,
-                                      int orientation) {
-        // Find the cell at the trailing edge.  Return the distance to put
-        // that cell at the leading edge.
-        int trailingRow = getTrailingRow(visibleRect);
-        int trailingCol = getTrailingCol(visibleRect);
-
-        Rectangle cellRect;
-        boolean cellFillsVis;
-
-        int cellLeadingEdge;
-        int cellTrailingEdge;
-        int newLeadingEdge;
-        int visibleLeadingEdge = leadingEdge(visibleRect, orientation);
-
-        // If we couldn't find trailing cell, just return the size of the
-        // visibleRect.  Note that, for instance, we don't need the
-        // trailingCol to proceed if we're scrolling vertically, because
-        // cellRect will still fill in the required dimensions.  This would
-        // happen if we're scrolling vertically, and the table is not wide
-        // enough to fill the visibleRect.
-        if (orientation == SwingConstants.VERTICAL && trailingRow < 0) {
-            return visibleRect.height;
-        }
-        else if (orientation == SwingConstants.HORIZONTAL && trailingCol < 0) {
-            return visibleRect.width;
-        }
-        cellRect = getCellRect(trailingRow, trailingCol, true);
-        cellLeadingEdge = leadingEdge(cellRect, orientation);
-        cellTrailingEdge = trailingEdge(cellRect, orientation);
-
-        if (orientation == SwingConstants.VERTICAL ||
-            getComponentOrientation().isLeftToRight()) {
-            cellFillsVis = cellLeadingEdge <= visibleLeadingEdge;
-        }
-        else { // Horizontal, right-to-left
-            cellFillsVis = cellLeadingEdge >= visibleLeadingEdge;
-        }
-
-        if (cellFillsVis) {
-            // The visibleRect contains a single large cell.  Scroll to the end
-            // of this cell, so the following cell is the first cell.
-            newLeadingEdge = cellTrailingEdge;
-        }
-        else if (cellTrailingEdge == trailingEdge(visibleRect, orientation)) {
-            // The trailing cell happens to end right at the end of the
-            // visibleRect.  Again, scroll to the beginning of the next cell.
-            newLeadingEdge = cellTrailingEdge;
-        }
-        else {
-            // Common case: the trailing cell is partially visible, and isn't
-            // big enough to take up the entire visibleRect.  Scroll so it
-            // becomes the leading cell.
-            newLeadingEdge = cellLeadingEdge;
-        }
-        return Math.abs(newLeadingEdge - visibleLeadingEdge);
-    }
+                                      int orientation) {throw new RuntimeException("cf-bug");} //{
+//        // Find the cell at the trailing edge.  Return the distance to put
+//        // that cell at the leading edge.
+//        int trailingRow = getTrailingRow(visibleRect);
+//        int trailingCol = getTrailingCol(visibleRect);
+//
+//        Rectangle cellRect;
+//        boolean cellFillsVis;
+//
+//        int cellLeadingEdge;
+//        int cellTrailingEdge;
+//        int newLeadingEdge;
+//        int visibleLeadingEdge = leadingEdge(visibleRect, orientation);
+//
+//        // If we couldn't find trailing cell, just return the size of the
+//        // visibleRect.  Note that, for instance, we don't need the
+//        // trailingCol to proceed if we're scrolling vertically, because
+//        // cellRect will still fill in the required dimensions.  This would
+//        // happen if we're scrolling vertically, and the table is not wide
+//        // enough to fill the visibleRect.
+//        if (orientation == SwingConstants.VERTICAL && trailingRow < 0) {
+//            return visibleRect.height;
+//        }
+//        else if (orientation == SwingConstants.HORIZONTAL && trailingCol < 0) {
+//            return visibleRect.width;
+//        }
+//        cellRect = getCellRect(trailingRow, trailingCol, true);
+//        cellLeadingEdge = leadingEdge(cellRect, orientation);
+//        cellTrailingEdge = trailingEdge(cellRect, orientation);
+//
+//        if (orientation == SwingConstants.VERTICAL ||
+//            getComponentOrientation().isLeftToRight()) {
+//            cellFillsVis = cellLeadingEdge <= visibleLeadingEdge;
+//        }
+//        else { // Horizontal, right-to-left
+//            cellFillsVis = cellLeadingEdge >= visibleLeadingEdge;
+//        }
+//
+//        if (cellFillsVis) {
+//            // The visibleRect contains a single large cell.  Scroll to the end
+//            // of this cell, so the following cell is the first cell.
+//            newLeadingEdge = cellTrailingEdge;
+//        }
+//        else if (cellTrailingEdge == trailingEdge(visibleRect, orientation)) {
+//            // The trailing cell happens to end right at the end of the
+//            // visibleRect.  Again, scroll to the beginning of the next cell.
+//            newLeadingEdge = cellTrailingEdge;
+//        }
+//        else {
+//            // Common case: the trailing cell is partially visible, and isn't
+//            // big enough to take up the entire visibleRect.  Scroll so it
+//            // becomes the leading cell.
+//            newLeadingEdge = cellLeadingEdge;
+//        }
+//        return Math.abs(newLeadingEdge - visibleLeadingEdge);
+//    }
 
     /*
      * Return the row at the top of the visibleRect
      *
      * May return -1
      */
-    private int getLeadingRow(Rectangle visibleRect) {
-        Point leadingPoint;
-
-        if (getComponentOrientation().isLeftToRight()) {
-            leadingPoint = new Point(visibleRect.x, visibleRect.y);
-        }
-        else {
-            leadingPoint = new Point(visibleRect.x + visibleRect.width - 1,
-                                     visibleRect.y);
-        }
-        return rowAtPoint(leadingPoint);
-    }
+    private int getLeadingRow(Rectangle visibleRect) {throw new RuntimeException("cf-bug");} //{
+//        Point leadingPoint;
+//
+//        if (getComponentOrientation().isLeftToRight()) {
+//            leadingPoint = new Point(visibleRect.x, visibleRect.y);
+//        }
+//        else {
+//            leadingPoint = new Point(visibleRect.x + visibleRect.width - 1,
+//                                     visibleRect.y);
+//        }
+//        return rowAtPoint(leadingPoint);
+//    }
 
     /*
      * Return the column at the leading edge of the visibleRect.
      *
      * May return -1
      */
-    private int getLeadingCol(Rectangle visibleRect) {
-        Point leadingPoint;
-
-        if (getComponentOrientation().isLeftToRight()) {
-            leadingPoint = new Point(visibleRect.x, visibleRect.y);
-        }
-        else {
-            leadingPoint = new Point(visibleRect.x + visibleRect.width - 1,
-                                     visibleRect.y);
-        }
-        return columnAtPoint(leadingPoint);
-    }
+    private int getLeadingCol(Rectangle visibleRect) {throw new RuntimeException("cf-bug");} //{
+//        Point leadingPoint;
+//
+//        if (getComponentOrientation().isLeftToRight()) {
+//            leadingPoint = new Point(visibleRect.x, visibleRect.y);
+//        }
+//        else {
+//            leadingPoint = new Point(visibleRect.x + visibleRect.width - 1,
+//                                     visibleRect.y);
+//        }
+//        return columnAtPoint(leadingPoint);
+//    }
 
     /*
      * Return the row at the bottom of the visibleRect.
      *
      * May return -1
      */
-    private int getTrailingRow(Rectangle visibleRect) {
-        Point trailingPoint;
-
-        if (getComponentOrientation().isLeftToRight()) {
-            trailingPoint = new Point(visibleRect.x,
-                                      visibleRect.y + visibleRect.height - 1);
-        }
-        else {
-            trailingPoint = new Point(visibleRect.x + visibleRect.width - 1,
-                                      visibleRect.y + visibleRect.height - 1);
-        }
-        return rowAtPoint(trailingPoint);
-    }
+    private int getTrailingRow(Rectangle visibleRect) {throw new RuntimeException("cf-bug");} //{
+//        Point trailingPoint;
+//
+//        if (getComponentOrientation().isLeftToRight()) {
+//            trailingPoint = new Point(visibleRect.x,
+//                                      visibleRect.y + visibleRect.height - 1);
+//        }
+//        else {
+//            trailingPoint = new Point(visibleRect.x + visibleRect.width - 1,
+//                                      visibleRect.y + visibleRect.height - 1);
+//        }
+//        return rowAtPoint(trailingPoint);
+//    }
 
     /*
      * Return the column at the trailing edge of the visibleRect.
      *
      * May return -1
      */
-    private int getTrailingCol(Rectangle visibleRect) {
-        Point trailingPoint;
-
-        if (getComponentOrientation().isLeftToRight()) {
-            trailingPoint = new Point(visibleRect.x + visibleRect.width - 1,
-                                      visibleRect.y);
-        }
-        else {
-            trailingPoint = new Point(visibleRect.x, visibleRect.y);
-        }
-        return columnAtPoint(trailingPoint);
-    }
+    private int getTrailingCol(Rectangle visibleRect) {throw new RuntimeException("cf-bug");} //{
+//        Point trailingPoint;
+//
+//        if (getComponentOrientation().isLeftToRight()) {
+//            trailingPoint = new Point(visibleRect.x + visibleRect.width - 1,
+//                                      visibleRect.y);
+//        }
+//        else {
+//            trailingPoint = new Point(visibleRect.x, visibleRect.y);
+//        }
+//        return columnAtPoint(trailingPoint);
+//    }
 
     /*
      * Returns the leading edge ("beginning") of the given Rectangle.
      * For VERTICAL, this is the top, for left-to-right, the left side, and for
      * right-to-left, the right side.
      */
-    private int leadingEdge(Rectangle rect, int orientation) {
-        if (orientation == SwingConstants.VERTICAL) {
-            return rect.y;
-        }
-        else if (getComponentOrientation().isLeftToRight()) {
-            return rect.x;
-        }
-        else { // Horizontal, right-to-left
-            return rect.x + rect.width;
-        }
-    }
+    private int leadingEdge(Rectangle rect, int orientation) {throw new RuntimeException("cf-bug");} //{
+//        if (orientation == SwingConstants.VERTICAL) {
+//            return rect.y;
+//        }
+//        else if (getComponentOrientation().isLeftToRight()) {
+//            return rect.x;
+//        }
+//        else { // Horizontal, right-to-left
+//            return rect.x + rect.width;
+//        }
+//    }
 
     /*
      * Returns the trailing edge ("end") of the given Rectangle.
      * For VERTICAL, this is the bottom, for left-to-right, the right side, and
      * for right-to-left, the left side.
      */
-    private int trailingEdge(Rectangle rect, int orientation) {
-        if (orientation == SwingConstants.VERTICAL) {
-            return rect.y + rect.height;
-        }
-        else if (getComponentOrientation().isLeftToRight()) {
-            return rect.x + rect.width;
-        }
-        else { // Horizontal, right-to-left
-            return rect.x;
-        }
-    }
+    private int trailingEdge(Rectangle rect, int orientation) {throw new RuntimeException("cf-bug");} //{
+//        if (orientation == SwingConstants.VERTICAL) {
+//            return rect.y + rect.height;
+//        }
+//        else if (getComponentOrientation().isLeftToRight()) {
+//            return rect.x + rect.width;
+//        }
+//        else { // Horizontal, right-to-left
+//            return rect.x;
+//        }
+//    }
 
     /**
      * Returns false if <code>autoResizeMode</code> is set to
@@ -5187,9 +5187,9 @@
      *   to <code>AUTO_RESIZE_OFF</code>, otherwise returns true
      * @see Scrollable#getScrollableTracksViewportWidth
      */
-    public boolean getScrollableTracksViewportWidth() {
-        return !(autoResizeMode == AUTO_RESIZE_OFF);
-    }
+    public boolean getScrollableTracksViewportWidth() {throw new RuntimeException("cf-bug");} //{
+//        return !(autoResizeMode == AUTO_RESIZE_OFF);
+//    }
 
     /**
      * Returns {@code false} to indicate that the height of the viewport does
@@ -5204,12 +5204,12 @@
      * @see #setFillsViewportHeight
      * @see #getFillsViewportHeight
      */
-    public boolean getScrollableTracksViewportHeight() {
-        Container parent = SwingUtilities.getUnwrappedParent(this);
-        return getFillsViewportHeight()
-               && parent instanceof JViewport
-               && parent.getHeight() > getPreferredSize().height;
-    }
+    public boolean getScrollableTracksViewportHeight() {throw new RuntimeException("cf-bug");} //{
+//        Container parent = SwingUtilities.getUnwrappedParent(this);
+//        return getFillsViewportHeight()
+//               && parent instanceof JViewport
+//               && parent.getHeight() > getPreferredSize().height;
+//    }
 
     /**
      * Sets whether or not this table is always made large enough
@@ -5230,12 +5230,12 @@
      *      description: Whether or not this table is always made large enough
      *                   to fill the height of an enclosing viewport
      */
-    public void setFillsViewportHeight(boolean fillsViewportHeight) {
-        boolean old = this.fillsViewportHeight;
-        this.fillsViewportHeight = fillsViewportHeight;
-        resizeAndRepaint();
-        firePropertyChange("fillsViewportHeight", old, fillsViewportHeight);
-    }
+    public void setFillsViewportHeight(boolean fillsViewportHeight) {throw new RuntimeException("cf-bug");} //{
+//        boolean old = this.fillsViewportHeight;
+//        this.fillsViewportHeight = fillsViewportHeight;
+//        resizeAndRepaint();
+//        firePropertyChange("fillsViewportHeight", old, fillsViewportHeight);
+//    }
 
     /**
      * Returns whether or not this table is always made large enough
@@ -5246,64 +5246,64 @@
      * @see #setFillsViewportHeight
      * @since 1.6
      */
-    public boolean getFillsViewportHeight() {
-        return fillsViewportHeight;
-    }
+    public boolean getFillsViewportHeight() {throw new RuntimeException("cf-bug");} //{
+//        return fillsViewportHeight;
+//    }
 
 //
 // Protected Methods
 //
 
     protected boolean processKeyBinding(KeyStroke ks, KeyEvent e,
-                                        int condition, boolean pressed) {
-        boolean retValue = super.processKeyBinding(ks, e, condition, pressed);
-
-        // Start editing when a key is typed. UI classes can disable this behavior
-        // by setting the client property JTable.autoStartsEdit to Boolean.FALSE.
-        if (!retValue && condition == WHEN_ANCESTOR_OF_FOCUSED_COMPONENT &&
-            isFocusOwner() &&
-            !Boolean.FALSE.equals(getClientProperty("JTable.autoStartsEdit"))) {
-            // We do not have a binding for the event.
-            Component editorComponent = getEditorComponent();
-            if (editorComponent == null) {
-                // Only attempt to install the editor on a KEY_PRESSED,
-                if (e == null || e.getID() != KeyEvent.KEY_PRESSED) {
-                    return false;
-                }
-                // Don't start when just a modifier is pressed
-                int code = e.getKeyCode();
-                if (code == KeyEvent.VK_SHIFT || code == KeyEvent.VK_CONTROL ||
-                    code == KeyEvent.VK_ALT) {
-                    return false;
-                }
-                // Try to install the editor
-                int leadRow = getSelectionModel().getLeadSelectionIndex();
-                int leadColumn = getColumnModel().getSelectionModel().
-                                   getLeadSelectionIndex();
-                if (leadRow != -1 && leadColumn != -1 && !isEditing()) {
-                    if (!editCellAt(leadRow, leadColumn, e)) {
-                        return false;
-                    }
-                }
-                editorComponent = getEditorComponent();
-                if (editorComponent == null) {
-                    return false;
-                }
-            }
-            // If the editorComponent is a JComponent, pass the event to it.
-            if (editorComponent instanceof JComponent) {
-                retValue = ((JComponent)editorComponent).processKeyBinding
-                                        (ks, e, WHEN_FOCUSED, pressed);
-                // If we have started an editor as a result of the user
-                // pressing a key and the surrendersFocusOnKeystroke property
-                // is true, give the focus to the new editor.
-                if (getSurrendersFocusOnKeystroke()) {
-                    editorComponent.requestFocus();
-                }
-            }
-        }
-        return retValue;
-    }
+                                        int condition, boolean pressed) {throw new RuntimeException("cf-bug");} //{
+//        boolean retValue = super.processKeyBinding(ks, e, condition, pressed);
+//
+//        // Start editing when a key is typed. UI classes can disable this behavior
+//        // by setting the client property JTable.autoStartsEdit to Boolean.FALSE.
+//        if (!retValue && condition == WHEN_ANCESTOR_OF_FOCUSED_COMPONENT &&
+//            isFocusOwner() &&
+//            !Boolean.FALSE.equals(getClientProperty("JTable.autoStartsEdit"))) {
+//            // We do not have a binding for the event.
+//            Component editorComponent = getEditorComponent();
+//            if (editorComponent == null) {
+//                // Only attempt to install the editor on a KEY_PRESSED,
+//                if (e == null || e.getID() != KeyEvent.KEY_PRESSED) {
+//                    return false;
+//                }
+//                // Don't start when just a modifier is pressed
+//                int code = e.getKeyCode();
+//                if (code == KeyEvent.VK_SHIFT || code == KeyEvent.VK_CONTROL ||
+//                    code == KeyEvent.VK_ALT) {
+//                    return false;
+//                }
+//                // Try to install the editor
+//                int leadRow = getSelectionModel().getLeadSelectionIndex();
+//                int leadColumn = getColumnModel().getSelectionModel().
+//                                   getLeadSelectionIndex();
+//                if (leadRow != -1 && leadColumn != -1 && !isEditing()) {
+//                    if (!editCellAt(leadRow, leadColumn, e)) {
+//                        return false;
+//                    }
+//                }
+//                editorComponent = getEditorComponent();
+//                if (editorComponent == null) {
+//                    return false;
+//                }
+//            }
+//            // If the editorComponent is a JComponent, pass the event to it.
+//            if (editorComponent instanceof JComponent) {
+//                retValue = ((JComponent)editorComponent).processKeyBinding
+//                                        (ks, e, WHEN_FOCUSED, pressed);
+//                // If we have started an editor as a result of the user
+//                // pressing a key and the surrendersFocusOnKeystroke property
+//                // is true, give the focus to the new editor.
+//                if (getSurrendersFocusOnKeystroke()) {
+//                    editorComponent.requestFocus();
+//                }
+//            }
+//        }
+//        return retValue;
+//    }
 
     /**
      * Creates default cell renderers for objects, numbers, doubles, dates,
@@ -5311,29 +5311,29 @@
      * @see javax.swing.table.DefaultTableCellRenderer
      *
      */
-    protected void createDefaultRenderers() {
-        defaultRenderersByColumnClass = new UIDefaults(8, 0.75f);
-
-        // Objects
-        defaultRenderersByColumnClass.put(Object.class, (UIDefaults.LazyValue) t -> new DefaultTableCellRenderer.UIResource());
-
-        // Numbers
-        defaultRenderersByColumnClass.put(Number.class, (UIDefaults.LazyValue) t -> new NumberRenderer());
-
-        // Doubles and Floats
-        defaultRenderersByColumnClass.put(Float.class, (UIDefaults.LazyValue) t -> new DoubleRenderer());
-        defaultRenderersByColumnClass.put(Double.class, (UIDefaults.LazyValue) t -> new DoubleRenderer());
-
-        // Dates
-        defaultRenderersByColumnClass.put(Date.class, (UIDefaults.LazyValue) t -> new DateRenderer());
-
-        // Icons and ImageIcons
-        defaultRenderersByColumnClass.put(Icon.class, (UIDefaults.LazyValue) t -> new IconRenderer());
-        defaultRenderersByColumnClass.put(ImageIcon.class, (UIDefaults.LazyValue) t -> new IconRenderer());
-
-        // Booleans
-        defaultRenderersByColumnClass.put(Boolean.class, (UIDefaults.LazyValue) t -> new BooleanRenderer());
-    }
+    protected void createDefaultRenderers() {throw new RuntimeException("cf-bug");} //{
+//        defaultRenderersByColumnClass = new UIDefaults(8, 0.75f);
+//
+//        // Objects
+//        defaultRenderersByColumnClass.put(Object.class, (UIDefaults.LazyValue) t -> new DefaultTableCellRenderer.UIResource());
+//
+//        // Numbers
+//        defaultRenderersByColumnClass.put(Number.class, (UIDefaults.LazyValue) t -> new NumberRenderer());
+//
+//        // Doubles and Floats
+//        defaultRenderersByColumnClass.put(Float.class, (UIDefaults.LazyValue) t -> new DoubleRenderer());
+//        defaultRenderersByColumnClass.put(Double.class, (UIDefaults.LazyValue) t -> new DoubleRenderer());
+//
+//        // Dates
+//        defaultRenderersByColumnClass.put(Date.class, (UIDefaults.LazyValue) t -> new DateRenderer());
+//
+//        // Icons and ImageIcons
+//        defaultRenderersByColumnClass.put(Icon.class, (UIDefaults.LazyValue) t -> new IconRenderer());
+//        defaultRenderersByColumnClass.put(ImageIcon.class, (UIDefaults.LazyValue) t -> new IconRenderer());
+//
+//        // Booleans
+//        defaultRenderersByColumnClass.put(Boolean.class, (UIDefaults.LazyValue) t -> new BooleanRenderer());
+//    }
 
     /**
      * Default Renderers
@@ -5349,24 +5349,24 @@
         NumberFormat formatter;
         public DoubleRenderer() { super(); }
 
-        public void setValue(Object value) {
-            if (formatter == null) {
-                formatter = NumberFormat.getInstance();
-            }
-            setText((value == null) ? "" : formatter.format(value));
-        }
+        public void setValue(Object value) {throw new RuntimeException("cf-bug");} //{
+//            if (formatter == null) {
+//                formatter = NumberFormat.getInstance();
+//            }
+//            setText((value == null) ? "" : formatter.format(value));
+//        }
     }
 
     static class DateRenderer extends DefaultTableCellRenderer.UIResource {
         DateFormat formatter;
         public DateRenderer() { super(); }
 
-        public void setValue(Object value) {
-            if (formatter==null) {
-                formatter = DateFormat.getDateInstance();
-            }
-            setText((value == null) ? "" : formatter.format(value));
-        }
+        public void setValue(Object value) {throw new RuntimeException("cf-bug");} //{
+//            if (formatter==null) {
+//                formatter = DateFormat.getDateInstance();
+//            }
+//            setText((value == null) ? "" : formatter.format(value));
+//        }
     }
 
     static class IconRenderer extends DefaultTableCellRenderer.UIResource {
@@ -5374,7 +5374,7 @@
             super();
             setHorizontalAlignment(JLabel.CENTER);
         }
-        public void setValue(Object value) { setIcon((value instanceof Icon) ? (Icon)value : null); }
+        public void setValue(Object value) {throw new RuntimeException("cf-bug");} //{ setIcon((value instanceof Icon) ? (Icon)value : null); }
     }
 
 
@@ -5389,43 +5389,43 @@
         }
 
         public Component getTableCellRendererComponent(JTable table, Object value,
-                                                       boolean isSelected, boolean hasFocus, int row, int column) {
-            if (isSelected) {
-                setForeground(table.getSelectionForeground());
-                super.setBackground(table.getSelectionBackground());
-            }
-            else {
-                setForeground(table.getForeground());
-                setBackground(table.getBackground());
-            }
-            setSelected((value != null && ((Boolean)value).booleanValue()));
-
-            if (hasFocus) {
-                setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
-            } else {
-                setBorder(noFocusBorder);
-            }
-
-            return this;
-        }
+                                                       boolean isSelected, boolean hasFocus, int row, int column) {throw new RuntimeException("cf-bug");} //{
+//            if (isSelected) {
+//                setForeground(table.getSelectionForeground());
+//                super.setBackground(table.getSelectionBackground());
+//            }
+//            else {
+//                setForeground(table.getForeground());
+//                setBackground(table.getBackground());
+//            }
+//            setSelected((value != null && ((Boolean)value).booleanValue()));
+//
+//            if (hasFocus) {
+//                setBorder(UIManager.getBorder("Table.focusCellHighlightBorder"));
+//            } else {
+//                setBorder(noFocusBorder);
+//            }
+//
+//            return this;
+//        }
     }
 
     /**
      * Creates default cell editors for objects, numbers, and boolean values.
      * @see DefaultCellEditor
      */
-    protected void createDefaultEditors() {
-        defaultEditorsByColumnClass = new UIDefaults(3, 0.75f);
-
-        // Objects
-        defaultEditorsByColumnClass.put(Object.class, (UIDefaults.LazyValue) t -> new GenericEditor());
-
-        // Numbers
-        defaultEditorsByColumnClass.put(Number.class, (UIDefaults.LazyValue) t -> new NumberEditor());
-
-        // Booleans
-        defaultEditorsByColumnClass.put(Boolean.class, (UIDefaults.LazyValue) t -> new BooleanEditor());
-    }
+    protected void createDefaultEditors() {throw new RuntimeException("cf-bug");} //{
+//        defaultEditorsByColumnClass = new UIDefaults(3, 0.75f);
+//
+//        // Objects
+//        defaultEditorsByColumnClass.put(Object.class, (UIDefaults.LazyValue) t -> new GenericEditor());
+//
+//        // Numbers
+//        defaultEditorsByColumnClass.put(Number.class, (UIDefaults.LazyValue) t -> new NumberEditor());
+//
+//        // Booleans
+//        defaultEditorsByColumnClass.put(Boolean.class, (UIDefaults.LazyValue) t -> new BooleanEditor());
+//    }
 
     /**
      * Default Editors
@@ -5441,59 +5441,59 @@
             getComponent().setName("Table.editor");
         }
 
-        public boolean stopCellEditing() {
-            String s = (String)super.getCellEditorValue();
-            // Here we are dealing with the case where a user
-            // has deleted the string value in a cell, possibly
-            // after a failed validation. Return null, so that
-            // they have the option to replace the value with
-            // null or use escape to restore the original.
-            // For Strings, return "" for backward compatibility.
-            try {
-                if ("".equals(s)) {
-                    if (constructor.getDeclaringClass() == String.class) {
-                        value = s;
-                    }
-                    return super.stopCellEditing();
-                }
-
-                SwingUtilities2.checkAccess(constructor.getModifiers());
-                value = constructor.newInstance(new Object[]{s});
-            }
-            catch (Exception e) {
-                ((JComponent)getComponent()).setBorder(new LineBorder(Color.red));
-                return false;
-            }
-            return super.stopCellEditing();
-        }
+        public boolean stopCellEditing() {throw new RuntimeException("cf-bug");} //{
+//            String s = (String)super.getCellEditorValue();
+//            // Here we are dealing with the case where a user
+//            // has deleted the string value in a cell, possibly
+//            // after a failed validation. Return null, so that
+//            // they have the option to replace the value with
+//            // null or use escape to restore the original.
+//            // For Strings, return "" for backward compatibility.
+//            try {
+//                if ("".equals(s)) {
+//                    if (constructor.getDeclaringClass() == String.class) {
+//                        value = s;
+//                    }
+//                    return super.stopCellEditing();
+//                }
+//
+//                SwingUtilities2.checkAccess(constructor.getModifiers());
+//                value = constructor.newInstance(new Object[]{s});
+//            }
+//            catch (Exception e) {
+//                ((JComponent)getComponent()).setBorder(new LineBorder(Color.red));
+//                return false;
+//            }
+//            return super.stopCellEditing();
+//        }
 
         public Component getTableCellEditorComponent(JTable table, Object value,
                                                  boolean isSelected,
-                                                 int row, int column) {
-            this.value = null;
-            ((JComponent)getComponent()).setBorder(new LineBorder(Color.black));
-            try {
-                Class<?> type = table.getColumnClass(column);
-                // Since our obligation is to produce a value which is
-                // assignable for the required type it is OK to use the
-                // String constructor for columns which are declared
-                // to contain Objects. A String is an Object.
-                if (type == Object.class) {
-                    type = String.class;
-                }
-                ReflectUtil.checkPackageAccess(type);
-                SwingUtilities2.checkAccess(type.getModifiers());
-                constructor = type.getConstructor(argTypes);
-            }
-            catch (Exception e) {
-                return null;
-            }
-            return super.getTableCellEditorComponent(table, value, isSelected, row, column);
-        }
-
-        public Object getCellEditorValue() {
-            return value;
-        }
+                                                 int row, int column) {throw new RuntimeException("cf-bug");} //{
+//            this.value = null;
+//            ((JComponent)getComponent()).setBorder(new LineBorder(Color.black));
+//            try {
+//                Class<?> type = table.getColumnClass(column);
+//                // Since our obligation is to produce a value which is
+//                // assignable for the required type it is OK to use the
+//                // String constructor for columns which are declared
+//                // to contain Objects. A String is an Object.
+//                if (type == Object.class) {
+//                    type = String.class;
+//                }
+//                ReflectUtil.checkPackageAccess(type);
+//                SwingUtilities2.checkAccess(type.getModifiers());
+//                constructor = type.getConstructor(argTypes);
+//            }
+//            catch (Exception e) {
+//                return null;
+//            }
+//            return super.getTableCellEditorComponent(table, value, isSelected, row, column);
+//        }
+
+        public Object getCellEditorValue() {throw new RuntimeException("cf-bug");} //{
+//            return value;
+//        }
     }
 
     static class NumberEditor extends GenericEditor {
@@ -5514,32 +5514,32 @@
     /**
      * Initializes table properties to their default values.
      */
-    protected void initializeLocalVars() {
-        updateSelectionOnSort = true;
-        setOpaque(true);
-        createDefaultRenderers();
-        createDefaultEditors();
-
-        setTableHeader(createDefaultTableHeader());
-
-        setShowGrid(true);
-        setAutoResizeMode(AUTO_RESIZE_SUBSEQUENT_COLUMNS);
-        setRowHeight(16);
-        isRowHeightSet = false;
-        setRowMargin(1);
-        setRowSelectionAllowed(true);
-        setCellEditor(null);
-        setEditingColumn(-1);
-        setEditingRow(-1);
-        setSurrendersFocusOnKeystroke(false);
-        setPreferredScrollableViewportSize(new Dimension(450, 400));
-
-        // I'm registered to do tool tips so we can draw tips for the renderers
-        ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
-        toolTipManager.registerComponent(this);
-
-        setAutoscrolls(true);
-    }
+    protected void initializeLocalVars() {throw new RuntimeException("cf-bug");} //{
+//        updateSelectionOnSort = true;
+//        setOpaque(true);
+//        createDefaultRenderers();
+//        createDefaultEditors();
+//
+//        setTableHeader(createDefaultTableHeader());
+//
+//        setShowGrid(true);
+//        setAutoResizeMode(AUTO_RESIZE_SUBSEQUENT_COLUMNS);
+//        setRowHeight(16);
+//        isRowHeightSet = false;
+//        setRowMargin(1);
+//        setRowSelectionAllowed(true);
+//        setCellEditor(null);
+//        setEditingColumn(-1);
+//        setEditingRow(-1);
+//        setSurrendersFocusOnKeystroke(false);
+//        setPreferredScrollableViewportSize(new Dimension(450, 400));
+//
+//        // I'm registered to do tool tips so we can draw tips for the renderers
+//        ToolTipManager toolTipManager = ToolTipManager.sharedInstance();
+//        toolTipManager.registerComponent(this);
+//
+//        setAutoscrolls(true);
+//    }
 
     /**
      * Returns the default table model object, which is
@@ -5549,9 +5549,9 @@
      * @return the default table model object
      * @see javax.swing.table.DefaultTableModel
      */
-    protected TableModel createDefaultDataModel() {
-        return new DefaultTableModel();
-    }
+    protected TableModel createDefaultDataModel() {throw new RuntimeException("cf-bug");} //{
+//        return new DefaultTableModel();
+//    }
 
     /**
      * Returns the default column model object, which is
@@ -5561,9 +5561,9 @@
      * @return the default column model object
      * @see javax.swing.table.DefaultTableColumnModel
      */
-    protected TableColumnModel createDefaultColumnModel() {
-        return new DefaultTableColumnModel();
-    }
+    protected TableColumnModel createDefaultColumnModel() {throw new RuntimeException("cf-bug");} //{
+//        return new DefaultTableColumnModel();
+//    }
 
     /**
      * Returns the default selection model object, which is
@@ -5573,9 +5573,9 @@
      * @return the default selection model object
      * @see javax.swing.DefaultListSelectionModel
      */
-    protected ListSelectionModel createDefaultSelectionModel() {
-        return new DefaultListSelectionModel();
-    }
+    protected ListSelectionModel createDefaultSelectionModel() {throw new RuntimeException("cf-bug");} //{
+//        return new DefaultListSelectionModel();
+//    }
 
     /**
      * Returns the default table header object, which is
@@ -5585,17 +5585,17 @@
      * @return the default table header object
      * @see javax.swing.table.JTableHeader
      */
-    protected JTableHeader createDefaultTableHeader() {
-        return new JTableHeader(columnModel);
-    }
+    protected JTableHeader createDefaultTableHeader() {throw new RuntimeException("cf-bug");} //{
+//        return new JTableHeader(columnModel);
+//    }
 
     /**
      * Equivalent to <code>revalidate</code> followed by <code>repaint</code>.
      */
-    protected void resizeAndRepaint() {
-        revalidate();
-        repaint();
-    }
+    protected void resizeAndRepaint() {throw new RuntimeException("cf-bug");} //{
+//        revalidate();
+//        repaint();
+//    }
 
     /**
      * Returns the active cell editor, which is {@code null} if the table
@@ -5606,9 +5606,9 @@
      * @see #cellEditor
      * @see #getCellEditor(int, int)
      */
-    public TableCellEditor getCellEditor() {
-        return cellEditor;
-    }
+    public TableCellEditor getCellEditor() {throw new RuntimeException("cf-bug");} //{
+//        return cellEditor;
+//    }
 
     /**
      * Sets the active cell editor.
@@ -5619,11 +5619,11 @@
      *  bound: true
      *  description: The table's active cell editor.
      */
-    public void setCellEditor(TableCellEditor anEditor) {
-        TableCellEditor oldEditor = cellEditor;
-        cellEditor = anEditor;
-        firePropertyChange("tableCellEditor", oldEditor, anEditor);
-    }
+    public void setCellEditor(TableCellEditor anEditor) {throw new RuntimeException("cf-bug");} //{
+//        TableCellEditor oldEditor = cellEditor;
+//        cellEditor = anEditor;
+//        firePropertyChange("tableCellEditor", oldEditor, anEditor);
+//    }
 
     /**
      * Sets the <code>editingColumn</code> variable.
@@ -5631,9 +5631,9 @@
      *
      * @see #editingColumn
      */
-    public void setEditingColumn(int aColumn) {
-        editingColumn = aColumn;
-    }
+    public void setEditingColumn(int aColumn) {throw new RuntimeException("cf-bug");} //{
+//        editingColumn = aColumn;
+//    }
 
     /**
      * Sets the <code>editingRow</code> variable.
@@ -5641,9 +5641,9 @@
      *
      * @see #editingRow
      */
-    public void setEditingRow(int aRow) {
-        editingRow = aRow;
-    }
+    public void setEditingRow(int aRow) {throw new RuntimeException("cf-bug");} //{
+//        editingRow = aRow;
+//    }
 
     /**
      * Returns an appropriate renderer for the cell specified by this row and
@@ -5667,14 +5667,14 @@
      * @see javax.swing.table.TableColumn#setCellRenderer
      * @see #setDefaultRenderer
      */
-    public TableCellRenderer getCellRenderer(int row, int column) {
-        TableColumn tableColumn = getColumnModel().getColumn(column);
-        TableCellRenderer renderer = tableColumn.getCellRenderer();
-        if (renderer == null) {
-            renderer = getDefaultRenderer(getColumnClass(column));
-        }
-        return renderer;
-    }
+    public TableCellRenderer getCellRenderer(int row, int column) {throw new RuntimeException("cf-bug");} //{
+//        TableColumn tableColumn = getColumnModel().getColumn(column);
+//        TableCellRenderer renderer = tableColumn.getCellRenderer();
+//        if (renderer == null) {
+//            renderer = getDefaultRenderer(getColumnClass(column));
+//        }
+//        return renderer;
+//    }
 
     /**
      * Prepares the renderer by querying the data model for the
@@ -5702,28 +5702,28 @@
      *                  where 0 is the first column
      * @return          the <code>Component</code> under the event location
      */
-    public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {
-        Object value = getValueAt(row, column);
-
-        boolean isSelected = false;
-        boolean hasFocus = false;
-
-        // Only indicate the selection and focused cell if not printing
-        if (!isPaintingForPrint()) {
-            isSelected = isCellSelected(row, column);
-
-            boolean rowIsLead =
-                (selectionModel.getLeadSelectionIndex() == row);
-            boolean colIsLead =
-                (columnModel.getSelectionModel().getLeadSelectionIndex() == column);
-
-            hasFocus = (rowIsLead && colIsLead) && isFocusOwner();
-        }
-
-        return renderer.getTableCellRendererComponent(this, value,
-                                                      isSelected, hasFocus,
-                                                      row, column);
-    }
+    public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {throw new RuntimeException("cf-bug");} //{
+//        Object value = getValueAt(row, column);
+//
+//        boolean isSelected = false;
+//        boolean hasFocus = false;
+//
+//        // Only indicate the selection and focused cell if not printing
+//        if (!isPaintingForPrint()) {
+//            isSelected = isCellSelected(row, column);
+//
+//            boolean rowIsLead =
+//                (selectionModel.getLeadSelectionIndex() == row);
+//            boolean colIsLead =
+//                (columnModel.getSelectionModel().getLeadSelectionIndex() == column);
+//
+//            hasFocus = (rowIsLead && colIsLead) && isFocusOwner();
+//        }
+//
+//        return renderer.getTableCellRendererComponent(this, value,
+//                                                      isSelected, hasFocus,
+//                                                      row, column);
+//    }
 
     /**
      * Returns an appropriate editor for the cell specified by
@@ -5746,14 +5746,14 @@
      *                  this type of cell
      * @see DefaultCellEditor
      */
-    public TableCellEditor getCellEditor(int row, int column) {
-        TableColumn tableColumn = getColumnModel().getColumn(column);
-        TableCellEditor editor = tableColumn.getCellEditor();
-        if (editor == null) {
-            editor = getDefaultEditor(getColumnClass(column));
-        }
-        return editor;
-    }
+    public TableCellEditor getCellEditor(int row, int column) {throw new RuntimeException("cf-bug");} //{
+//        TableColumn tableColumn = getColumnModel().getColumn(column);
+//        TableCellEditor editor = tableColumn.getCellEditor();
+//        if (editor == null) {
+//            editor = getDefaultEditor(getColumnClass(column));
+//        }
+//        return editor;
+//    }
 
 
     /**
@@ -5772,53 +5772,53 @@
      *                where 0 is the first column
      * @return the <code>Component</code> being edited
      */
-    public Component prepareEditor(TableCellEditor editor, int row, int column) {
-        Object value = getValueAt(row, column);
-        boolean isSelected = isCellSelected(row, column);
-        Component comp = editor.getTableCellEditorComponent(this, value, isSelected,
-                                                  row, column);
-        if (comp instanceof JComponent) {
-            JComponent jComp = (JComponent)comp;
-            if (jComp.getNextFocusableComponent() == null) {
-                jComp.setNextFocusableComponent(this);
-            }
-        }
-        return comp;
-    }
+    public Component prepareEditor(TableCellEditor editor, int row, int column) {throw new RuntimeException("cf-bug");} //{
+//        Object value = getValueAt(row, column);
+//        boolean isSelected = isCellSelected(row, column);
+//        Component comp = editor.getTableCellEditorComponent(this, value, isSelected,
+//                                                  row, column);
+//        if (comp instanceof JComponent) {
+//            JComponent jComp = (JComponent)comp;
+//            if (jComp.getNextFocusableComponent() == null) {
+//                jComp.setNextFocusableComponent(this);
+//            }
+//        }
+//        return comp;
+//    }
 
     /**
      * Discards the editor object and frees the real estate it used for
      * cell rendering.
      */
-    public void removeEditor() {
-        KeyboardFocusManager.getCurrentKeyboardFocusManager().
-            removePropertyChangeListener("permanentFocusOwner", editorRemover);
-        editorRemover = null;
-
-        TableCellEditor editor = getCellEditor();
-        if(editor != null) {
-            editor.removeCellEditorListener(this);
-            if (editorComp != null) {
-                Component focusOwner =
-                        KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
-                boolean isFocusOwnerInTheTable = focusOwner != null?
-                        SwingUtilities.isDescendingFrom(focusOwner, this):false;
-                remove(editorComp);
-                if(isFocusOwnerInTheTable) {
-                    requestFocusInWindow();
-                }
-            }
-
-            Rectangle cellRect = getCellRect(editingRow, editingColumn, false);
-
-            setCellEditor(null);
-            setEditingColumn(-1);
-            setEditingRow(-1);
-            editorComp = null;
-
-            repaint(cellRect);
-        }
-    }
+    public void removeEditor() {throw new RuntimeException("cf-bug");} //{
+//        KeyboardFocusManager.getCurrentKeyboardFocusManager().
+//            removePropertyChangeListener("permanentFocusOwner", editorRemover);
+//        editorRemover = null;
+//
+//        TableCellEditor editor = getCellEditor();
+//        if(editor != null) {
+//            editor.removeCellEditorListener(this);
+//            if (editorComp != null) {
+//                Component focusOwner =
+//                        KeyboardFocusManager.getCurrentKeyboardFocusManager().getFocusOwner();
+//                boolean isFocusOwnerInTheTable = focusOwner != null?
+//                        SwingUtilities.isDescendingFrom(focusOwner, this):false;
+//                remove(editorComp);
+//                if(isFocusOwnerInTheTable) {
+//                    requestFocusInWindow();
+//                }
+//            }
+//
+//            Rectangle cellRect = getCellRect(editingRow, editingColumn, false);
+//
+//            setCellEditor(null);
+//            setEditingColumn(-1);
+//            setEditingRow(-1);
+//            editorComp = null;
+//
+//            repaint(cellRect);
+//        }
+//    }
 
 //
 // Serialization
@@ -5828,46 +5828,46 @@
      * See readObject() and writeObject() in JComponent for more
      * information about serialization in Swing.
      */
-    private void writeObject(ObjectOutputStream s) throws IOException {
-        s.defaultWriteObject();
-        if (getUIClassID().equals(uiClassID)) {
-            byte count = JComponent.getWriteObjCounter(this);
-            JComponent.setWriteObjCounter(this, --count);
-            if (count == 0 && ui != null) {
-                ui.installUI(this);
-            }
-        }
-    }
+    private void writeObject(ObjectOutputStream s) throws IOException {throw new RuntimeException("cf-bug");} //{
+//        s.defaultWriteObject();
+//        if (getUIClassID().equals(uiClassID)) {
+//            byte count = JComponent.getWriteObjCounter(this);
+//            JComponent.setWriteObjCounter(this, --count);
+//            if (count == 0 && ui != null) {
+//                ui.installUI(this);
+//            }
+//        }
+//    }
 
     private void readObject(ObjectInputStream s)
         throws IOException, ClassNotFoundException
-    {
-        s.defaultReadObject();
-        if ((ui != null) && (getUIClassID().equals(uiClassID))) {
-            ui.installUI(this);
-        }
-        createDefaultRenderers();
-        createDefaultEditors();
-
-        // If ToolTipText != null, then the tooltip has already been
-        // registered by JComponent.readObject() and we don't want
-        // to re-register here
-        if (getToolTipText() == null) {
-            ToolTipManager.sharedInstance().registerComponent(this);
-         }
-    }
+    {throw new RuntimeException("cf-bug");} //{
+//        s.defaultReadObject();
+//        if ((ui != null) && (getUIClassID().equals(uiClassID))) {
+//            ui.installUI(this);
+//        }
+//        createDefaultRenderers();
+//        createDefaultEditors();
+//
+//        // If ToolTipText != null, then the tooltip has already been
+//        // registered by JComponent.readObject() and we don't want
+//        // to re-register here
+//        if (getToolTipText() == null) {
+//            ToolTipManager.sharedInstance().registerComponent(this);
+//         }
+//    }
 
     /* Called from the JComponent's EnableSerializationFocusListener to
      * do any Swing-specific pre-serialization configuration.
      */
-    void compWriteObjectNotify() {
-        super.compWriteObjectNotify();
-        // If ToolTipText != null, then the tooltip has already been
-        // unregistered by JComponent.compWriteObjectNotify()
-        if (getToolTipText() == null) {
-            ToolTipManager.sharedInstance().unregisterComponent(this);
-        }
-    }
+    void compWriteObjectNotify() {throw new RuntimeException("cf-bug");} //{
+//        super.compWriteObjectNotify();
+//        // If ToolTipText != null, then the tooltip has already been
+//        // unregistered by JComponent.compWriteObjectNotify()
+//        if (getToolTipText() == null) {
+//            ToolTipManager.sharedInstance().unregisterComponent(this);
+//        }
+//    }
 
     /**
      * Returns a string representation of this table. This method
@@ -5878,57 +5878,57 @@
      *
      * @return  a string representation of this table
      */
-    protected String paramString() {
-        String gridColorString = (gridColor != null ?
-                                  gridColor.toString() : "");
-        String showHorizontalLinesString = (showHorizontalLines ?
-                                            "true" : "false");
-        String showVerticalLinesString = (showVerticalLines ?
-                                          "true" : "false");
-        String autoResizeModeString;
-        if (autoResizeMode == AUTO_RESIZE_OFF) {
-            autoResizeModeString = "AUTO_RESIZE_OFF";
-        } else if (autoResizeMode == AUTO_RESIZE_NEXT_COLUMN) {
-            autoResizeModeString = "AUTO_RESIZE_NEXT_COLUMN";
-        } else if (autoResizeMode == AUTO_RESIZE_SUBSEQUENT_COLUMNS) {
-            autoResizeModeString = "AUTO_RESIZE_SUBSEQUENT_COLUMNS";
-        } else if (autoResizeMode == AUTO_RESIZE_LAST_COLUMN) {
-            autoResizeModeString = "AUTO_RESIZE_LAST_COLUMN";
-        } else if (autoResizeMode == AUTO_RESIZE_ALL_COLUMNS)  {
-            autoResizeModeString = "AUTO_RESIZE_ALL_COLUMNS";
-        } else autoResizeModeString = "";
-        String autoCreateColumnsFromModelString = (autoCreateColumnsFromModel ?
-                                                   "true" : "false");
-        String preferredViewportSizeString = (preferredViewportSize != null ?
-                                              preferredViewportSize.toString()
-                                              : "");
-        String rowSelectionAllowedString = (rowSelectionAllowed ?
-                                            "true" : "false");
-        String cellSelectionEnabledString = (cellSelectionEnabled ?
-                                            "true" : "false");
-        String selectionForegroundString = (selectionForeground != null ?
-                                            selectionForeground.toString() :
-                                            "");
-        String selectionBackgroundString = (selectionBackground != null ?
-                                            selectionBackground.toString() :
-                                            "");
-
-        return super.paramString() +
-        ",autoCreateColumnsFromModel=" + autoCreateColumnsFromModelString +
-        ",autoResizeMode=" + autoResizeModeString +
-        ",cellSelectionEnabled=" + cellSelectionEnabledString +
-        ",editingColumn=" + editingColumn +
-        ",editingRow=" + editingRow +
-        ",gridColor=" + gridColorString +
-        ",preferredViewportSize=" + preferredViewportSizeString +
-        ",rowHeight=" + rowHeight +
-        ",rowMargin=" + rowMargin +
-        ",rowSelectionAllowed=" + rowSelectionAllowedString +
-        ",selectionBackground=" + selectionBackgroundString +
-        ",selectionForeground=" + selectionForegroundString +
-        ",showHorizontalLines=" + showHorizontalLinesString +
-        ",showVerticalLines=" + showVerticalLinesString;
-    }
+    protected String paramString() {throw new RuntimeException("cf-bug");} //{
+//        String gridColorString = (gridColor != null ?
+//                                  gridColor.toString() : "");
+//        String showHorizontalLinesString = (showHorizontalLines ?
+//                                            "true" : "false");
+//        String showVerticalLinesString = (showVerticalLines ?
+//                                          "true" : "false");
+//        String autoResizeModeString;
+//        if (autoResizeMode == AUTO_RESIZE_OFF) {
+//            autoResizeModeString = "AUTO_RESIZE_OFF";
+//        } else if (autoResizeMode == AUTO_RESIZE_NEXT_COLUMN) {
+//            autoResizeModeString = "AUTO_RESIZE_NEXT_COLUMN";
+//        } else if (autoResizeMode == AUTO_RESIZE_SUBSEQUENT_COLUMNS) {
+//            autoResizeModeString = "AUTO_RESIZE_SUBSEQUENT_COLUMNS";
+//        } else if (autoResizeMode == AUTO_RESIZE_LAST_COLUMN) {
+//            autoResizeModeString = "AUTO_RESIZE_LAST_COLUMN";
+//        } else if (autoResizeMode == AUTO_RESIZE_ALL_COLUMNS)  {
+//            autoResizeModeString = "AUTO_RESIZE_ALL_COLUMNS";
+//        } else autoResizeModeString = "";
+//        String autoCreateColumnsFromModelString = (autoCreateColumnsFromModel ?
+//                                                   "true" : "false");
+//        String preferredViewportSizeString = (preferredViewportSize != null ?
+//                                              preferredViewportSize.toString()
+//                                              : "");
+//        String rowSelectionAllowedString = (rowSelectionAllowed ?
+//                                            "true" : "false");
+//        String cellSelectionEnabledString = (cellSelectionEnabled ?
+//                                            "true" : "false");
+//        String selectionForegroundString = (selectionForeground != null ?
+//                                            selectionForeground.toString() :
+//                                            "");
+//        String selectionBackgroundString = (selectionBackground != null ?
+//                                            selectionBackground.toString() :
+//                                            "");
+//
+//        return super.paramString() +
+//        ",autoCreateColumnsFromModel=" + autoCreateColumnsFromModelString +
+//        ",autoResizeMode=" + autoResizeModeString +
+//        ",cellSelectionEnabled=" + cellSelectionEnabledString +
+//        ",editingColumn=" + editingColumn +
+//        ",editingRow=" + editingRow +
+//        ",gridColor=" + gridColorString +
+//        ",preferredViewportSize=" + preferredViewportSizeString +
+//        ",rowHeight=" + rowHeight +
+//        ",rowMargin=" + rowMargin +
+//        ",rowSelectionAllowed=" + rowSelectionAllowedString +
+//        ",selectionBackground=" + selectionBackgroundString +
+//        ",selectionForeground=" + selectionForegroundString +
+//        ",showHorizontalLines=" + showHorizontalLinesString +
+//        ",showVerticalLines=" + showVerticalLinesString;
+//    }
 
     // This class tracks changes in the keyboard focus state. It is used
     // when the JTable is editing to determine when to cancel the edit.
@@ -5941,28 +5941,28 @@
             this.focusManager = fm;
         }
 
-        public void propertyChange(PropertyChangeEvent ev) {
-            if (!isEditing() || getClientProperty("terminateEditOnFocusLost") != Boolean.TRUE) {
-                return;
-            }
-
-            Component c = focusManager.getPermanentFocusOwner();
-            while (c != null) {
-                if (c == JTable.this) {
-                    // focus remains inside the table
-                    return;
-                } else if ((c instanceof Window) ||
-                           (c instanceof Applet && c.getParent() == null)) {
-                    if (c == SwingUtilities.getRoot(JTable.this)) {
-                        if (!getCellEditor().stopCellEditing()) {
-                            getCellEditor().cancelCellEditing();
-                        }
-                    }
-                    break;
-                }
-                c = c.getParent();
-            }
-        }
+        public void propertyChange(PropertyChangeEvent ev) {throw new RuntimeException("cf-bug");} //{
+//            if (!isEditing() || getClientProperty("terminateEditOnFocusLost") != Boolean.TRUE) {
+//                return;
+//            }
+//
+//            Component c = focusManager.getPermanentFocusOwner();
+//            while (c != null) {
+//                if (c == JTable.this) {
+//                    // focus remains inside the table
+//                    return;
+//                } else if ((c instanceof Window) ||
+//                           (c instanceof Applet && c.getParent() == null)) {
+//                    if (c == SwingUtilities.getRoot(JTable.this)) {
+//                        if (!getCellEditor().stopCellEditing()) {
+//                            getCellEditor().cancelCellEditing();
+//                        }
+//                    }
+//                    break;
+//                }
+//                c = c.getParent();
+//            }
+//        }
     }
 
 /////////////////
@@ -5989,10 +5989,10 @@
      *
      * @since 1.5
      */
-    public boolean print() throws PrinterException {
-
-        return print(PrintMode.FIT_WIDTH);
-    }
+    public boolean print() throws PrinterException {throw new RuntimeException("cf-bug");} //{
+//
+//        return print(PrintMode.FIT_WIDTH);
+//    }
 
     /**
      * A convenience method that displays a printing dialog, and then prints
@@ -6015,10 +6015,10 @@
      *
      * @since 1.5
      */
-    public boolean print(PrintMode printMode) throws PrinterException {
-
-        return print(printMode, null, null);
-    }
+    public boolean print(PrintMode printMode) throws PrinterException {throw new RuntimeException("cf-bug");} //{
+//
+//        return print(printMode, null, null);
+//    }
 
     /**
      * A convenience method that displays a printing dialog, and then prints
@@ -6049,12 +6049,12 @@
      */
     public boolean print(PrintMode printMode,
                          MessageFormat headerFormat,
-                         MessageFormat footerFormat) throws PrinterException {
-
-        boolean showDialogs = !GraphicsEnvironment.isHeadless();
-        return print(printMode, headerFormat, footerFormat,
-                     showDialogs, null, showDialogs);
-    }
+                         MessageFormat footerFormat) throws PrinterException {throw new RuntimeException("cf-bug");} //{
+//
+//        boolean showDialogs = !GraphicsEnvironment.isHeadless();
+//        return print(printMode, headerFormat, footerFormat,
+//                     showDialogs, null, showDialogs);
+//    }
 
     /**
      * Prints this table, as specified by the fully featured
@@ -6095,16 +6095,16 @@
                          boolean showPrintDialog,
                          PrintRequestAttributeSet attr,
                          boolean interactive) throws PrinterException,
-                                                     HeadlessException {
-
-        return print(printMode,
-                     headerFormat,
-                     footerFormat,
-                     showPrintDialog,
-                     attr,
-                     interactive,
-                     null);
-    }
+                                                     HeadlessException {throw new RuntimeException("cf-bug");} //{
+//
+//        return print(printMode,
+//                     headerFormat,
+//                     footerFormat,
+//                     showPrintDialog,
+//                     attr,
+//                     interactive,
+//                     null);
+//    }
 
     /**
      * Prints this <code>JTable</code>. Takes steps that the majority of
@@ -6191,136 +6191,136 @@
                          PrintRequestAttributeSet attr,
                          boolean interactive,
                          PrintService service) throws PrinterException,
-                                                      HeadlessException {
-
-        // complain early if an invalid parameter is specified for headless mode
-        boolean isHeadless = GraphicsEnvironment.isHeadless();
-        if (isHeadless) {
-            if (showPrintDialog) {
-                throw new HeadlessException("Can't show print dialog.");
-            }
-
-            if (interactive) {
-                throw new HeadlessException("Can't run interactively.");
-            }
-        }
-
-        // Get a PrinterJob.
-        // Do this before anything with side-effects since it may throw a
-        // security exception - in which case we don't want to do anything else.
-        final PrinterJob job = PrinterJob.getPrinterJob();
-
-        if (isEditing()) {
-            // try to stop cell editing, and failing that, cancel it
-            if (!getCellEditor().stopCellEditing()) {
-                getCellEditor().cancelCellEditing();
-            }
-        }
-
-        if (attr == null) {
-            attr = new HashPrintRequestAttributeSet();
-        }
-
-        final PrintingStatus printingStatus;
-
-         // fetch the Printable
-        Printable printable =
-             getPrintable(printMode, headerFormat, footerFormat);
-
-        if (interactive) {
-            // wrap the Printable so that we can print on another thread
-            printable = new ThreadSafePrintable(printable);
-            printingStatus = PrintingStatus.createPrintingStatus(this, job);
-            printable = printingStatus.createNotificationPrintable(printable);
-        } else {
-            // to please compiler
-            printingStatus = null;
-        }
-
-        // set the printable on the PrinterJob
-        job.setPrintable(printable);
-
-        // if specified, set the PrintService on the PrinterJob
-        if (service != null) {
-            job.setPrintService(service);
-        }
-
-        // if requested, show the print dialog
-        if (showPrintDialog && !job.printDialog(attr)) {
-            // the user cancelled the print dialog
-            return false;
-        }
-
-        // if not interactive, just print on this thread (no dialog)
-        if (!interactive) {
-            // do the printing
-            job.print(attr);
-
-            // we're done
-            return true;
-        }
-
-        // make sure this is clear since we'll check it after
-        printError = null;
-
-        // to synchronize on
-        final Object lock = new Object();
-
-        // copied so we can access from the inner class
-        final PrintRequestAttributeSet copyAttr = attr;
-
-        // this runnable will be used to do the printing
-        // (and save any throwables) on another thread
-        Runnable runnable = new Runnable() {
-            public void run() {
-                try {
-                    // do the printing
-                    job.print(copyAttr);
-                } catch (Throwable t) {
-                    // save any Throwable to be rethrown
-                    synchronized(lock) {
-                        printError = t;
-                    }
-                } finally {
-                    // we're finished - hide the dialog
-                    printingStatus.dispose();
-                }
-            }
-        };
-
-        // start printing on another thread
-        Thread th = new Thread(runnable);
-        th.start();
-
-        printingStatus.showModal(true);
-
-        // look for any error that the printing may have generated
-        Throwable pe;
-        synchronized(lock) {
-            pe = printError;
-            printError = null;
-        }
-
-        // check the type of error and handle it
-        if (pe != null) {
-            // a subclass of PrinterException meaning the job was aborted,
-            // in this case, by the user
-            if (pe instanceof PrinterAbortException) {
-                return false;
-            } else if (pe instanceof PrinterException) {
-                throw (PrinterException)pe;
-            } else if (pe instanceof RuntimeException) {
-                throw (RuntimeException)pe;
-            } else if (pe instanceof Error) {
-                throw (Error)pe;
-            }
-
-            // can not happen
-            throw new AssertionError(pe);
-        }
-
-        return true;
-    }
+                                                      HeadlessException {throw new RuntimeException("cf-bug");} //{
+//
+//        // complain early if an invalid parameter is specified for headless mode
+//        boolean isHeadless = GraphicsEnvironment.isHeadless();
+//        if (isHeadless) {
+//            if (showPrintDialog) {
+//                throw new HeadlessException("Can't show print dialog.");
+//            }
+//
+//            if (interactive) {
+//                throw new HeadlessException("Can't run interactively.");
+//            }
+//        }
+//
+//        // Get a PrinterJob.
+//        // Do this before anything with side-effects since it may throw a
+//        // security exception - in which case we don't want to do anything else.
+//        final PrinterJob job = PrinterJob.getPrinterJob();
+//
+//        if (isEditing()) {
+//            // try to stop cell editing, and failing that, cancel it
+//            if (!getCellEditor().stopCellEditing()) {
+//                getCellEditor().cancelCellEditing();
+//            }
+//        }
+//
+//        if (attr == null) {
+//            attr = new HashPrintRequestAttributeSet();
+//        }
+//
+//        final PrintingStatus printingStatus;
+//
+//         // fetch the Printable
+//        Printable printable =
+//             getPrintable(printMode, headerFormat, footerFormat);
+//
+//        if (interactive) {
+//            // wrap the Printable so that we can print on another thread
+//            printable = new ThreadSafePrintable(printable);
+//            printingStatus = PrintingStatus.createPrintingStatus(this, job);
+//            printable = printingStatus.createNotificationPrintable(printable);
+//        } else {
+//            // to please compiler
+//            printingStatus = null;
+//        }
+//
+//        // set the printable on the PrinterJob
+//        job.setPrintable(printable);
+//
+//        // if specified, set the PrintService on the PrinterJob
+//        if (service != null) {
+//            job.setPrintService(service);
+//        }
+//
+//        // if requested, show the print dialog
+//        if (showPrintDialog && !job.printDialog(attr)) {
+//            // the user cancelled the print dialog
+//            return false;
+//        }
+//
+//        // if not interactive, just print on this thread (no dialog)
+//        if (!interactive) {
+//            // do the printing
+//            job.print(attr);
+//
+//            // we're done
+//            return true;
+//        }
+//
+//        // make sure this is clear since we'll check it after
+//        printError = null;
+//
+//        // to synchronize on
+//        final Object lock = new Object();
+//
+//        // copied so we can access from the inner class
+//        final PrintRequestAttributeSet copyAttr = attr;
+//
+//        // this runnable will be used to do the printing
+//        // (and save any throwables) on another thread
+//        Runnable runnable = new Runnable() {
+//            public void run() {
+//                try {
+//                    // do the printing
+//                    job.print(copyAttr);
+//                } catch (Throwable t) {
+//                    // save any Throwable to be rethrown
+//                    synchronized(lock) {
+//                        printError = t;
+//                    }
+//                } finally {
+//                    // we're finished - hide the dialog
+//                    printingStatus.dispose();
+//                }
+//            }
+//        };
+//
+//        // start printing on another thread
+//        Thread th = new Thread(runnable);
+//        th.start();
+//
+//        printingStatus.showModal(true);
+//
+//        // look for any error that the printing may have generated
+//        Throwable pe;
+//        synchronized(lock) {
+//            pe = printError;
+//            printError = null;
+//        }
+//
+//        // check the type of error and handle it
+//        if (pe != null) {
+//            // a subclass of PrinterException meaning the job was aborted,
+//            // in this case, by the user
+//            if (pe instanceof PrinterAbortException) {
+//                return false;
+//            } else if (pe instanceof PrinterException) {
+//                throw (PrinterException)pe;
+//            } else if (pe instanceof RuntimeException) {
+//                throw (RuntimeException)pe;
+//            } else if (pe instanceof Error) {
+//                throw (Error)pe;
+//            }
+//
+//            // can not happen
+//            throw new AssertionError(pe);
+//        }
+//
+//        return true;
+//    }
 
     /**
      * Return a <code>Printable</code> for use in printing this JTable.
@@ -6425,10 +6425,10 @@
      */
     public Printable getPrintable(PrintMode printMode,
                                   MessageFormat headerFormat,
-                                  MessageFormat footerFormat) {
-
-        return new TablePrintable(this, printMode, headerFormat, footerFormat);
-    }
+                                  MessageFormat footerFormat) {throw new RuntimeException("cf-bug");} //{
+//
+//        return new TablePrintable(this, printMode, headerFormat, footerFormat);
+//    }
 
 
     /**
@@ -6476,58 +6476,58 @@
          */
         public int print(final Graphics graphics,
                          final PageFormat pageFormat,
-                         final int pageIndex) throws PrinterException {
-
-            // We'll use this Runnable
-            Runnable runnable = new Runnable() {
-                public synchronized void run() {
-                    try {
-                        // call into the delegate and save the return value
-                        retVal = printDelegate.print(graphics, pageFormat, pageIndex);
-                    } catch (Throwable throwable) {
-                        // save any Throwable to be rethrown
-                        retThrowable = throwable;
-                    } finally {
-                        // notify the caller that we're done
-                        notifyAll();
-                    }
-                }
-            };
-
-            synchronized(runnable) {
-                // make sure these are initialized
-                retVal = -1;
-                retThrowable = null;
-
-                // call into the EDT
-                SwingUtilities.invokeLater(runnable);
-
-                // wait for the runnable to finish
-                while (retVal == -1 && retThrowable == null) {
-                    try {
-                        runnable.wait();
-                    } catch (InterruptedException ie) {
-                        // short process, safe to ignore interrupts
-                    }
-                }
-
-                // if the delegate threw a throwable, rethrow it here
-                if (retThrowable != null) {
-                    if (retThrowable instanceof PrinterException) {
-                        throw (PrinterException)retThrowable;
-                    } else if (retThrowable instanceof RuntimeException) {
-                        throw (RuntimeException)retThrowable;
-                    } else if (retThrowable instanceof Error) {
-                        throw (Error)retThrowable;
-                    }
-
-                    // can not happen
-                    throw new AssertionError(retThrowable);
-                }
-
-                return retVal;
-            }
-        }
+                         final int pageIndex) throws PrinterException {throw new RuntimeException("cf-bug");} //{
+//
+//            // We'll use this Runnable
+//            Runnable runnable = new Runnable() {
+//                public synchronized void run() {
+//                    try {
+//                        // call into the delegate and save the return value
+//                        retVal = printDelegate.print(graphics, pageFormat, pageIndex);
+//                    } catch (Throwable throwable) {
+//                        // save any Throwable to be rethrown
+//                        retThrowable = throwable;
+//                    } finally {
+//                        // notify the caller that we're done
+//                        notifyAll();
+//                    }
+//                }
+//            };
+//
+//            synchronized(runnable) {
+//                // make sure these are initialized
+//                retVal = -1;
+//                retThrowable = null;
+//
+//                // call into the EDT
+//                SwingUtilities.invokeLater(runnable);
+//
+//                // wait for the runnable to finish
+//                while (retVal == -1 && retThrowable == null) {
+//                    try {
+//                        runnable.wait();
+//                    } catch (InterruptedException ie) {
+//                        // short process, safe to ignore interrupts
+//                    }
+//                }
+//
+//                // if the delegate threw a throwable, rethrow it here
+//                if (retThrowable != null) {
+//                    if (retThrowable instanceof PrinterException) {
+//                        throw (PrinterException)retThrowable;
+//                    } else if (retThrowable instanceof RuntimeException) {
+//                        throw (RuntimeException)retThrowable;
+//                    } else if (retThrowable instanceof Error) {
+//                        throw (Error)retThrowable;
+//                    }
+//
+//                    // can not happen
+//                    throw new AssertionError(retThrowable);
+//                }
+//
+//                return retVal;
+//            }
+//        }
     }
 
 
@@ -6544,12 +6544,12 @@
      * @return an AccessibleJTable that serves as the
      *         AccessibleContext of this JTable
      */
-    public AccessibleContext getAccessibleContext() {
-        if (accessibleContext == null) {
-            accessibleContext = new AccessibleJTable();
-        }
-        return accessibleContext;
-    }
+    public AccessibleContext getAccessibleContext() {throw new RuntimeException("cf-bug");} //{
+//        if (accessibleContext == null) {
+//            accessibleContext = new AccessibleJTable();
+//        }
+//        return accessibleContext;
+//    }
 
     //
     // *** should also implement AccessibleSelection?
@@ -6604,77 +6604,77 @@
          * be able to re-place listeners on those in order to pass on
          * information to the Accessibility PropertyChange mechanism
          */
-        public void propertyChange(PropertyChangeEvent e) {
-            String name = e.getPropertyName();
-            Object oldValue = e.getOldValue();
-            Object newValue = e.getNewValue();
-
-                // re-set tableModel listeners
-            if (name.compareTo("model") == 0) {
-
-                if (oldValue != null && oldValue instanceof TableModel) {
-                    ((TableModel) oldValue).removeTableModelListener(this);
-                }
-                if (newValue != null && newValue instanceof TableModel) {
-                    ((TableModel) newValue).addTableModelListener(this);
-                }
-
-                // re-set selectionModel listeners
-            } else if (name.compareTo("selectionModel") == 0) {
-
-                Object source = e.getSource();
-                if (source == JTable.this) {    // row selection model
-
-                    if (oldValue != null &&
-                        oldValue instanceof ListSelectionModel) {
-                        ((ListSelectionModel) oldValue).removeListSelectionListener(this);
-                    }
-                    if (newValue != null &&
-                        newValue instanceof ListSelectionModel) {
-                        ((ListSelectionModel) newValue).addListSelectionListener(this);
-                    }
-
-                } else if (source == JTable.this.getColumnModel()) {
-
-                    if (oldValue != null &&
-                        oldValue instanceof ListSelectionModel) {
-                        ((ListSelectionModel) oldValue).removeListSelectionListener(this);
-                    }
-                    if (newValue != null &&
-                        newValue instanceof ListSelectionModel) {
-                        ((ListSelectionModel) newValue).addListSelectionListener(this);
-                    }
-
-                } else {
-                  //        System.out.println("!!! Bug in source of selectionModel propertyChangeEvent");
-                }
-
-                // re-set columnModel listeners
-                // and column's selection property listener as well
-            } else if (name.compareTo("columnModel") == 0) {
-
-                if (oldValue != null && oldValue instanceof TableColumnModel) {
-                    TableColumnModel tcm = (TableColumnModel) oldValue;
-                    tcm.removeColumnModelListener(this);
-                    tcm.getSelectionModel().removeListSelectionListener(this);
-                }
-                if (newValue != null && newValue instanceof TableColumnModel) {
-                    TableColumnModel tcm = (TableColumnModel) newValue;
-                    tcm.addColumnModelListener(this);
-                    tcm.getSelectionModel().addListSelectionListener(this);
-                }
-
-                // re-se cellEditor listeners
-            } else if (name.compareTo("tableCellEditor") == 0) {
-
-                if (oldValue != null && oldValue instanceof TableCellEditor) {
-                    ((TableCellEditor) oldValue).removeCellEditorListener(this);
-                }
-                if (newValue != null && newValue instanceof TableCellEditor) {
-                    ((TableCellEditor) newValue).addCellEditorListener(this);
-                }
-            }
-        }
+        public void propertyChange(PropertyChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//            String name = e.getPropertyName();
+//            Object oldValue = e.getOldValue();
+//            Object newValue = e.getNewValue();
+//
+//                // re-set tableModel listeners
+//            if (name.compareTo("model") == 0) {
+//
+//                if (oldValue != null && oldValue instanceof TableModel) {
+//                    ((TableModel) oldValue).removeTableModelListener(this);
+//                }
+//                if (newValue != null && newValue instanceof TableModel) {
+//                    ((TableModel) newValue).addTableModelListener(this);
+//                }
+//
+//                // re-set selectionModel listeners
+//            } else if (name.compareTo("selectionModel") == 0) {
+//
+//                Object source = e.getSource();
+//                if (source == JTable.this) {    // row selection model
+//
+//                    if (oldValue != null &&
+//                        oldValue instanceof ListSelectionModel) {
+//                        ((ListSelectionModel) oldValue).removeListSelectionListener(this);
+//                    }
+//                    if (newValue != null &&
+//                        newValue instanceof ListSelectionModel) {
+//                        ((ListSelectionModel) newValue).addListSelectionListener(this);
+//                    }
+//
+//                } else if (source == JTable.this.getColumnModel()) {
+//
+//                    if (oldValue != null &&
+//                        oldValue instanceof ListSelectionModel) {
+//                        ((ListSelectionModel) oldValue).removeListSelectionListener(this);
+//                    }
+//                    if (newValue != null &&
+//                        newValue instanceof ListSelectionModel) {
+//                        ((ListSelectionModel) newValue).addListSelectionListener(this);
+//                    }
+//
+//                } else {
+//                  //        System.out.println("!!! Bug in source of selectionModel propertyChangeEvent");
+//                }
+//
+//                // re-set columnModel listeners
+//                // and column's selection property listener as well
+//            } else if (name.compareTo("columnModel") == 0) {
+//
+//                if (oldValue != null && oldValue instanceof TableColumnModel) {
+//                    TableColumnModel tcm = (TableColumnModel) oldValue;
+//                    tcm.removeColumnModelListener(this);
+//                    tcm.getSelectionModel().removeListSelectionListener(this);
+//                }
+//                if (newValue != null && newValue instanceof TableColumnModel) {
+//                    TableColumnModel tcm = (TableColumnModel) newValue;
+//                    tcm.addColumnModelListener(this);
+//                    tcm.getSelectionModel().addListSelectionListener(this);
+//                }
+//
+//                // re-se cellEditor listeners
+//            } else if (name.compareTo("tableCellEditor") == 0) {
+//
+//                if (oldValue != null && oldValue instanceof TableCellEditor) {
+//                    ((TableCellEditor) oldValue).removeCellEditorListener(this);
+//                }
+//                if (newValue != null && newValue instanceof TableCellEditor) {
+//                    ((TableCellEditor) newValue).addCellEditorListener(this);
+//                }
+//            }
+//        }
 
 
     // Listeners to echo changes to the AccessiblePropertyChange mechanism
@@ -6701,193 +6701,193 @@
                 this.lastColumn = lastColumn;
             }
 
-            public int getType() {
-                return type;
-            }
-
-            public int getFirstRow() {
-                return firstRow;
-            }
-
-            public int getLastRow() {
-                return lastRow;
-            }
-
-            public int getFirstColumn() {
-                return firstColumn;
-            }
-
-            public int getLastColumn() {
-                return lastColumn;
-            }
+            public int getType() {throw new RuntimeException("cf-bug");} //{
+//                return type;
+//            }
+
+            public int getFirstRow() {throw new RuntimeException("cf-bug");} //{
+//                return firstRow;
+//            }
+
+            public int getLastRow() {throw new RuntimeException("cf-bug");} //{
+//                return lastRow;
+//            }
+
+            public int getFirstColumn() {throw new RuntimeException("cf-bug");} //{
+//                return firstColumn;
+//            }
+
+            public int getLastColumn() {throw new RuntimeException("cf-bug");} //{
+//                return lastColumn;
+//            }
         }
 
         /**
          * Track changes to the table contents
          */
-        public void tableChanged(TableModelEvent e) {
-           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                              null, null);
-           if (e != null) {
-               int firstColumn = e.getColumn();
-               int lastColumn = e.getColumn();
-               if (firstColumn == TableModelEvent.ALL_COLUMNS) {
-                   firstColumn = 0;
-                   lastColumn = getColumnCount() - 1;
-               }
-
-               // Fire a property change event indicating the table model
-               // has changed.
-               AccessibleJTableModelChange change =
-                   new AccessibleJTableModelChange(e.getType(),
-                                                   e.getFirstRow(),
-                                                   e.getLastRow(),
-                                                   firstColumn,
-                                                   lastColumn);
-               firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
-                                  null, change);
-            }
-        }
+        public void tableChanged(TableModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                              null, null);
+//           if (e != null) {
+//               int firstColumn = e.getColumn();
+//               int lastColumn = e.getColumn();
+//               if (firstColumn == TableModelEvent.ALL_COLUMNS) {
+//                   firstColumn = 0;
+//                   lastColumn = getColumnCount() - 1;
+//               }
+//
+//               // Fire a property change event indicating the table model
+//               // has changed.
+//               AccessibleJTableModelChange change =
+//                   new AccessibleJTableModelChange(e.getType(),
+//                                                   e.getFirstRow(),
+//                                                   e.getLastRow(),
+//                                                   firstColumn,
+//                                                   lastColumn);
+//               firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
+//                                  null, change);
+//            }
+//        }
 
         /**
          * Track changes to the table contents (row insertions)
          */
-        public void tableRowsInserted(TableModelEvent e) {
-           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                              null, null);
-
-           // Fire a property change event indicating the table model
-           // has changed.
-           int firstColumn = e.getColumn();
-           int lastColumn = e.getColumn();
-           if (firstColumn == TableModelEvent.ALL_COLUMNS) {
-               firstColumn = 0;
-               lastColumn = getColumnCount() - 1;
-           }
-           AccessibleJTableModelChange change =
-               new AccessibleJTableModelChange(e.getType(),
-                                               e.getFirstRow(),
-                                               e.getLastRow(),
-                                               firstColumn,
-                                               lastColumn);
-           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
-                              null, change);
-        }
+        public void tableRowsInserted(TableModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                              null, null);
+//
+//           // Fire a property change event indicating the table model
+//           // has changed.
+//           int firstColumn = e.getColumn();
+//           int lastColumn = e.getColumn();
+//           if (firstColumn == TableModelEvent.ALL_COLUMNS) {
+//               firstColumn = 0;
+//               lastColumn = getColumnCount() - 1;
+//           }
+//           AccessibleJTableModelChange change =
+//               new AccessibleJTableModelChange(e.getType(),
+//                                               e.getFirstRow(),
+//                                               e.getLastRow(),
+//                                               firstColumn,
+//                                               lastColumn);
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
+//                              null, change);
+//        }
 
         /**
          * Track changes to the table contents (row deletions)
          */
-        public void tableRowsDeleted(TableModelEvent e) {
-           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                              null, null);
-
-           // Fire a property change event indicating the table model
-           // has changed.
-           int firstColumn = e.getColumn();
-           int lastColumn = e.getColumn();
-           if (firstColumn == TableModelEvent.ALL_COLUMNS) {
-               firstColumn = 0;
-               lastColumn = getColumnCount() - 1;
-           }
-           AccessibleJTableModelChange change =
-               new AccessibleJTableModelChange(e.getType(),
-                                               e.getFirstRow(),
-                                               e.getLastRow(),
-                                               firstColumn,
-                                               lastColumn);
-           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
-                              null, change);
-        }
+        public void tableRowsDeleted(TableModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                              null, null);
+//
+//           // Fire a property change event indicating the table model
+//           // has changed.
+//           int firstColumn = e.getColumn();
+//           int lastColumn = e.getColumn();
+//           if (firstColumn == TableModelEvent.ALL_COLUMNS) {
+//               firstColumn = 0;
+//               lastColumn = getColumnCount() - 1;
+//           }
+//           AccessibleJTableModelChange change =
+//               new AccessibleJTableModelChange(e.getType(),
+//                                               e.getFirstRow(),
+//                                               e.getLastRow(),
+//                                               firstColumn,
+//                                               lastColumn);
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
+//                              null, change);
+//        }
 
         /**
          * Track changes to the table contents (column insertions)
          */
-        public void columnAdded(TableColumnModelEvent e) {
-           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                              null, null);
-
-           // Fire a property change event indicating the table model
-           // has changed.
-           int type = AccessibleTableModelChange.INSERT;
-           AccessibleJTableModelChange change =
-               new AccessibleJTableModelChange(type,
-                                               0,
-                                               0,
-                                               e.getFromIndex(),
-                                               e.getToIndex());
-           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
-                              null, change);
-        }
+        public void columnAdded(TableColumnModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                              null, null);
+//
+//           // Fire a property change event indicating the table model
+//           // has changed.
+//           int type = AccessibleTableModelChange.INSERT;
+//           AccessibleJTableModelChange change =
+//               new AccessibleJTableModelChange(type,
+//                                               0,
+//                                               0,
+//                                               e.getFromIndex(),
+//                                               e.getToIndex());
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
+//                              null, change);
+//        }
 
         /**
          * Track changes to the table contents (column deletions)
          */
-        public void columnRemoved(TableColumnModelEvent e) {
-           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                              null, null);
-           // Fire a property change event indicating the table model
-           // has changed.
-           int type = AccessibleTableModelChange.DELETE;
-           AccessibleJTableModelChange change =
-               new AccessibleJTableModelChange(type,
-                                               0,
-                                               0,
-                                               e.getFromIndex(),
-                                               e.getToIndex());
-           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
-                              null, change);
-        }
+        public void columnRemoved(TableColumnModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                              null, null);
+//           // Fire a property change event indicating the table model
+//           // has changed.
+//           int type = AccessibleTableModelChange.DELETE;
+//           AccessibleJTableModelChange change =
+//               new AccessibleJTableModelChange(type,
+//                                               0,
+//                                               0,
+//                                               e.getFromIndex(),
+//                                               e.getToIndex());
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
+//                              null, change);
+//        }
 
         /**
          * Track changes of a column repositioning.
          *
          * @see TableColumnModelListener
          */
-        public void columnMoved(TableColumnModelEvent e) {
-           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                              null, null);
-
-           // Fire property change events indicating the table model
-           // has changed.
-           int type = AccessibleTableModelChange.DELETE;
-           AccessibleJTableModelChange change =
-               new AccessibleJTableModelChange(type,
-                                               0,
-                                               0,
-                                               e.getFromIndex(),
-                                               e.getFromIndex());
-           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
-                              null, change);
-
-           int type2 = AccessibleTableModelChange.INSERT;
-           AccessibleJTableModelChange change2 =
-               new AccessibleJTableModelChange(type2,
-                                               0,
-                                               0,
-                                               e.getToIndex(),
-                                               e.getToIndex());
-           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
-                              null, change2);
-        }
+        public void columnMoved(TableColumnModelEvent e) {throw new RuntimeException("cf-bug");} //{
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                              null, null);
+//
+//           // Fire property change events indicating the table model
+//           // has changed.
+//           int type = AccessibleTableModelChange.DELETE;
+//           AccessibleJTableModelChange change =
+//               new AccessibleJTableModelChange(type,
+//                                               0,
+//                                               0,
+//                                               e.getFromIndex(),
+//                                               e.getFromIndex());
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
+//                              null, change);
+//
+//           int type2 = AccessibleTableModelChange.INSERT;
+//           AccessibleJTableModelChange change2 =
+//               new AccessibleJTableModelChange(type2,
+//                                               0,
+//                                               0,
+//                                               e.getToIndex(),
+//                                               e.getToIndex());
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_MODEL_CHANGED,
+//                              null, change2);
+//        }
 
         /**
          * Track changes of a column moving due to margin changes.
          *
          * @see TableColumnModelListener
          */
-        public void columnMarginChanged(ChangeEvent e) {
-           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                              null, null);
-        }
+        public void columnMarginChanged(ChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                              null, null);
+//        }
 
         /**
          * Track that the selection model of the TableColumnModel changed.
          *
          * @see TableColumnModelListener
          */
-        public void columnSelectionChanged(ListSelectionEvent e) {
-            // we should now re-place our TableColumn listener
-        }
+        public void columnSelectionChanged(ListSelectionEvent e) {throw new RuntimeException("cf-bug");} //{
+//            // we should now re-place our TableColumn listener
+//        }
 
         /**
          * Track changes to a cell's contents.
@@ -6897,12 +6897,12 @@
          *
          * @see CellEditorListener
          */
-        public void editingStopped(ChangeEvent e) {
-           // it'd be great if we could figure out which cell, and pass that
-           // somehow as a parameter
-           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
-                              null, null);
-        }
+        public void editingStopped(ChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//           // it'd be great if we could figure out which cell, and pass that
+//           // somehow as a parameter
+//           firePropertyChange(AccessibleContext.ACCESSIBLE_VISIBLE_DATA_PROPERTY,
+//                              null, null);
+//        }
 
         /**
          * Invoked when editing is canceled. The editor object is discarded
@@ -6910,33 +6910,33 @@
          *
          * @see CellEditorListener
          */
-        public void editingCanceled(ChangeEvent e) {
-            // nothing to report, 'cause nothing changed
-        }
+        public void editingCanceled(ChangeEvent e) {throw new RuntimeException("cf-bug");} //{
+//            // nothing to report, 'cause nothing changed
+//        }
 
         /**
          * Track changes to table cell selections
          */
-        public void valueChanged(ListSelectionEvent e) {
-            firePropertyChange(AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,
-                               Boolean.valueOf(false), Boolean.valueOf(true));
-
-            // Using lead selection index to cover both cases: node selected and node
-            // is focused but not selected (Ctrl+up/down)
-            int focusedRow = JTable.this.getSelectionModel().getLeadSelectionIndex();
-            int focusedCol = JTable.this.getColumnModel().getSelectionModel().
-                                                            getLeadSelectionIndex();
-
-            if (focusedRow != previousFocusedRow ||
-                focusedCol != previousFocusedCol) {
-                Accessible oldA = getAccessibleAt(previousFocusedRow, previousFocusedCol);
-                Accessible newA = getAccessibleAt(focusedRow, focusedCol);
-                firePropertyChange(AccessibleContext.ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY,
-                                    oldA, newA);
-                previousFocusedRow = focusedRow;
-                previousFocusedCol = focusedCol;
-            }
-        }
+        public void valueChanged(ListSelectionEvent e) {throw new RuntimeException("cf-bug");} //{
+//            firePropertyChange(AccessibleContext.ACCESSIBLE_SELECTION_PROPERTY,
+//                               Boolean.valueOf(false), Boolean.valueOf(true));
+//
+//            // Using lead selection index to cover both cases: node selected and node
+//            // is focused but not selected (Ctrl+up/down)
+//            int focusedRow = JTable.this.getSelectionModel().getLeadSelectionIndex();
+//            int focusedCol = JTable.this.getColumnModel().getSelectionModel().
+//                                                            getLeadSelectionIndex();
+//
+//            if (focusedRow != previousFocusedRow ||
+//                focusedCol != previousFocusedCol) {
+//                Accessible oldA = getAccessibleAt(previousFocusedRow, previousFocusedCol);
+//                Accessible newA = getAccessibleAt(focusedRow, focusedCol);
+//                firePropertyChange(AccessibleContext.ACCESSIBLE_ACTIVE_DESCENDANT_PROPERTY,
+//                                    oldA, newA);
+//                previousFocusedRow = focusedRow;
+//                previousFocusedCol = focusedCol;
+//            }
+//        }
 
 
 
@@ -6951,9 +6951,9 @@
          *
          * @return this object
          */
-        public AccessibleSelection getAccessibleSelection() {
-            return this;
-        }
+        public AccessibleSelection getAccessibleSelection() {throw new RuntimeException("cf-bug");} //{
+//            return this;
+//        }
 
         /**
          * Gets the role of this object.
@@ -6962,9 +6962,9 @@
          * object
          * @see AccessibleRole
          */
-        public AccessibleRole getAccessibleRole() {
-            return AccessibleRole.TABLE;
-        }
+        public AccessibleRole getAccessibleRole() {throw new RuntimeException("cf-bug");} //{
+//            return AccessibleRole.TABLE;
+//        }
 
         /**
          * Returns the <code>Accessible</code> child, if one exists,
@@ -6976,25 +6976,25 @@
          * @return the <code>Accessible</code>, if it exists,
          *    at the specified location; else <code>null</code>
          */
-        public Accessible getAccessibleAt(Point p) {
-            int column = columnAtPoint(p);
-            int row = rowAtPoint(p);
-
-            if ((column != -1) && (row != -1)) {
-                TableColumn aColumn = getColumnModel().getColumn(column);
-                TableCellRenderer renderer = aColumn.getCellRenderer();
-                if (renderer == null) {
-                    Class<?> columnClass = getColumnClass(column);
-                    renderer = getDefaultRenderer(columnClass);
-                }
-                Component component = renderer.getTableCellRendererComponent(
-                                  JTable.this, null, false, false,
-                                  row, column);
-                return new AccessibleJTableCell(JTable.this, row, column,
-                      getAccessibleIndexAt(row, column));
-            }
-            return null;
-        }
+        public Accessible getAccessibleAt(Point p) {throw new RuntimeException("cf-bug");} //{
+//            int column = columnAtPoint(p);
+//            int row = rowAtPoint(p);
+//
+//            if ((column != -1) && (row != -1)) {
+//                TableColumn aColumn = getColumnModel().getColumn(column);
+//                TableCellRenderer renderer = aColumn.getCellRenderer();
+//                if (renderer == null) {
+//                    Class<?> columnClass = getColumnClass(column);
+//                    renderer = getDefaultRenderer(columnClass);
+//                }
+//                Component component = renderer.getTableCellRendererComponent(
+//                                  JTable.this, null, false, false,
+//                                  row, column);
+//                return new AccessibleJTableCell(JTable.this, row, column,
+//                      getAccessibleIndexAt(row, column));
+//            }
+//            return null;
+//        }
 
         /**
          * Returns the number of accessible children in the object.  If all
@@ -7003,9 +7003,9 @@
          *
          * @return the number of accessible children in the object
          */
-        public int getAccessibleChildrenCount() {
-            return (JTable.this.getColumnCount() * JTable.this.getRowCount());
-        }
+        public int getAccessibleChildrenCount() {throw new RuntimeException("cf-bug");} //{
+//            return (JTable.this.getColumnCount() * JTable.this.getRowCount());
+//        }
 
         /**
          * Returns the nth <code>Accessible</code> child of the object.
@@ -7013,28 +7013,28 @@
          * @param i zero-based index of child
          * @return the nth Accessible child of the object
          */
-        public Accessible getAccessibleChild(int i) {
-            if (i < 0 || i >= getAccessibleChildrenCount()) {
-                return null;
-            } else {
-                // children increase across, and then down, for tables
-                // (arbitrary decision)
-                int column = getAccessibleColumnAtIndex(i);
-                int row = getAccessibleRowAtIndex(i);
-
-                TableColumn aColumn = getColumnModel().getColumn(column);
-                TableCellRenderer renderer = aColumn.getCellRenderer();
-                if (renderer == null) {
-                    Class<?> columnClass = getColumnClass(column);
-                    renderer = getDefaultRenderer(columnClass);
-                }
-                Component component = renderer.getTableCellRendererComponent(
-                                  JTable.this, null, false, false,
-                                  row, column);
-                return new AccessibleJTableCell(JTable.this, row, column,
-                      getAccessibleIndexAt(row, column));
-            }
-        }
+        public Accessible getAccessibleChild(int i) {throw new RuntimeException("cf-bug");} //{
+//            if (i < 0 || i >= getAccessibleChildrenCount()) {
+//                return null;
+//            } else {
+//                // children increase across, and then down, for tables
+//                // (arbitrary decision)
+//                int column = getAccessibleColumnAtIndex(i);
+//                int row = getAccessibleRowAtIndex(i);
+//
+//                TableColumn aColumn = getColumnModel().getColumn(column);
+//                TableCellRenderer renderer = aColumn.getCellRenderer();
+//                if (renderer == null) {
+//                    Class<?> columnClass = getColumnClass(column);
+//                    renderer = getDefaultRenderer(columnClass);
+//                }
+//                Component component = renderer.getTableCellRendererComponent(
+//                                  JTable.this, null, false, false,
+//                                  row, column);
+//                return new AccessibleJTableCell(JTable.this, row, column,
+//                      getAccessibleIndexAt(row, column));
+//            }
+//        }
 
     // AccessibleSelection support
 
@@ -7045,34 +7045,34 @@
          *
          * @return the number of items currently selected
          */
-        public int getAccessibleSelectionCount() {
-            int rowsSel = JTable.this.getSelectedRowCount();
-            int colsSel = JTable.this.getSelectedColumnCount();
-
-            if (JTable.this.cellSelectionEnabled) { // a contiguous block
-                return rowsSel * colsSel;
-
-            } else {
-                // a column swath and a row swath, with a shared block
-                if (JTable.this.getRowSelectionAllowed() &&
-                    JTable.this.getColumnSelectionAllowed()) {
-                    return rowsSel * JTable.this.getColumnCount() +
-                           colsSel * JTable.this.getRowCount() -
-                           rowsSel * colsSel;
-
-                // just one or more rows in selection
-                } else if (JTable.this.getRowSelectionAllowed()) {
-                    return rowsSel * JTable.this.getColumnCount();
-
-                // just one or more rows in selection
-                } else if (JTable.this.getColumnSelectionAllowed()) {
-                    return colsSel * JTable.this.getRowCount();
-
-                } else {
-                    return 0;    // JTable doesn't allow selections
-                }
-            }
-        }
+        public int getAccessibleSelectionCount() {throw new RuntimeException("cf-bug");} //{
+//            int rowsSel = JTable.this.getSelectedRowCount();
+//            int colsSel = JTable.this.getSelectedColumnCount();
+//
+//            if (JTable.this.cellSelectionEnabled) { // a contiguous block
+//                return rowsSel * colsSel;
+//
+//            } else {
+//                // a column swath and a row swath, with a shared block
+//                if (JTable.this.getRowSelectionAllowed() &&
+//                    JTable.this.getColumnSelectionAllowed()) {
+//                    return rowsSel * JTable.this.getColumnCount() +
+//                           colsSel * JTable.this.getRowCount() -
+//                           rowsSel * colsSel;
+//
+//                // just one or more rows in selection
+//                } else if (JTable.this.getRowSelectionAllowed()) {
+//                    return rowsSel * JTable.this.getColumnCount();
+//
+//                // just one or more rows in selection
+//                } else if (JTable.this.getColumnSelectionAllowed()) {
+//                    return colsSel * JTable.this.getRowCount();
+//
+//                } else {
+//                    return 0;    // JTable doesn't allow selections
+//                }
+//            }
+//        }
 
         /**
          * Returns an <code>Accessible</code> representing the
@@ -7087,123 +7087,123 @@
          * @return the i-th selected child
          * @see #getAccessibleSelectionCount
          */
-        public Accessible getAccessibleSelection(int i) {
-            if (i < 0 || i > getAccessibleSelectionCount()) {
-                return null;
-            }
-
-            int rowsSel = JTable.this.getSelectedRowCount();
-            int colsSel = JTable.this.getSelectedColumnCount();
-            int rowIndicies[] = getSelectedRows();
-            int colIndicies[] = getSelectedColumns();
-            int ttlCols = JTable.this.getColumnCount();
-            int ttlRows = JTable.this.getRowCount();
-            int r;
-            int c;
-
-            if (JTable.this.cellSelectionEnabled) { // a contiguous block
-                r = rowIndicies[i / colsSel];
-                c = colIndicies[i % colsSel];
-                return getAccessibleChild((r * ttlCols) + c);
-            } else {
-
-                // a column swath and a row swath, with a shared block
-                if (JTable.this.getRowSelectionAllowed() &&
-                    JTable.this.getColumnSelectionAllowed()) {
-
-                    // Situation:
-                    //   We have a table, like the 6x3 table below,
-                    //   wherein three colums and one row selected
-                    //   (selected cells marked with "*", unselected "0"):
-                    //
-                    //            0 * 0 * * 0
-                    //            * * * * * *
-                    //            0 * 0 * * 0
-                    //
-
-                    // State machine below walks through the array of
-                    // selected rows in two states: in a selected row,
-                    // and not in one; continuing until we are in a row
-                    // in which the ith selection exists.  Then we return
-                    // the appropriate cell.  In the state machine, we
-                    // always do rows above the "current" selected row first,
-                    // then the cells in the selected row.  If we're done
-                    // with the state machine before finding the requested
-                    // selected child, we handle the rows below the last
-                    // selected row at the end.
-                    //
-                    int curIndex = i;
-                    final int IN_ROW = 0;
-                    final int NOT_IN_ROW = 1;
-                    int state = (rowIndicies[0] == 0 ? IN_ROW : NOT_IN_ROW);
-                    int j = 0;
-                    int prevRow = -1;
-                    while (j < rowIndicies.length) {
-                        switch (state) {
-
-                        case IN_ROW:   // on individual row full of selections
-                            if (curIndex < ttlCols) { // it's here!
-                                c = curIndex % ttlCols;
-                                r = rowIndicies[j];
-                                return getAccessibleChild((r * ttlCols) + c);
-                            } else {                               // not here
-                                curIndex -= ttlCols;
-                            }
-                            // is the next row in table selected or not?
-                            if (j + 1 == rowIndicies.length ||
-                                rowIndicies[j] != rowIndicies[j+1] - 1) {
-                                state = NOT_IN_ROW;
-                                prevRow = rowIndicies[j];
-                            }
-                            j++;  // we didn't return earlier, so go to next row
-                            break;
-
-                        case NOT_IN_ROW:  // sparse bunch of rows of selections
-                            if (curIndex <
-                                (colsSel * (rowIndicies[j] -
-                                (prevRow == -1 ? 0 : (prevRow + 1))))) {
-
-                                // it's here!
-                                c = colIndicies[curIndex % colsSel];
-                                r = (j > 0 ? rowIndicies[j-1] + 1 : 0)
-                                    + curIndex / colsSel;
-                                return getAccessibleChild((r * ttlCols) + c);
-                            } else {                               // not here
-                                curIndex -= colsSel * (rowIndicies[j] -
-                                (prevRow == -1 ? 0 : (prevRow + 1)));
-                            }
-                            state = IN_ROW;
-                            break;
-                        }
-                    }
-                    // we got here, so we didn't find it yet; find it in
-                    // the last sparse bunch of rows
-                    if (curIndex <
-                        (colsSel * (ttlRows -
-                        (prevRow == -1 ? 0 : (prevRow + 1))))) { // it's here!
-                        c = colIndicies[curIndex % colsSel];
-                        r = rowIndicies[j-1] + curIndex / colsSel + 1;
-                        return getAccessibleChild((r * ttlCols) + c);
-                    } else {                               // not here
-                        // we shouldn't get to this spot in the code!
-//                      System.out.println("Bug in AccessibleJTable.getAccessibleSelection()");
-                    }
-
-                // one or more rows selected
-                } else if (JTable.this.getRowSelectionAllowed()) {
-                    c = i % ttlCols;
-                    r = rowIndicies[i / ttlCols];
-                    return getAccessibleChild((r * ttlCols) + c);
-
-                // one or more columns selected
-                } else if (JTable.this.getColumnSelectionAllowed()) {
-                    c = colIndicies[i % colsSel];
-                    r = i / colsSel;
-                    return getAccessibleChild((r * ttlCols) + c);
-                }
-            }
-            return null;
-        }
+        public Accessible getAccessibleSelection(int i) {throw new RuntimeException("cf-bug");} //{
+//            if (i < 0 || i > getAccessibleSelectionCount()) {
+//                return null;
+//            }
+//
+//            int rowsSel = JTable.this.getSelectedRowCount();
+//            int colsSel = JTable.this.getSelectedColumnCount();
+//            int rowIndicies[] = getSelectedRows();
+//            int colIndicies[] = getSelectedColumns();
+//            int ttlCols = JTable.this.getColumnCount();
+//            int ttlRows = JTable.this.getRowCount();
+//            int r;
+//            int c;
+//
+//            if (JTable.this.cellSelectionEnabled) { // a contiguous block
+//                r = rowIndicies[i / colsSel];
+//                c = colIndicies[i % colsSel];
+//                return getAccessibleChild((r * ttlCols) + c);
+//            } else {
+//
+//                // a column swath and a row swath, with a shared block
+//                if (JTable.this.getRowSelectionAllowed() &&
+//                    JTable.this.getColumnSelectionAllowed()) {
+//
+//                    // Situation:
+//                    //   We have a table, like the 6x3 table below,
+//                    //   wherein three colums and one row selected
+//                    //   (selected cells marked with "*", unselected "0"):
+//                    //
+//                    //            0 * 0 * * 0
+//                    //            * * * * * *
+//                    //            0 * 0 * * 0
+//                    //
+//
+//                    // State machine below walks through the array of
+//                    // selected rows in two states: in a selected row,
+//                    // and not in one; continuing until we are in a row
+//                    // in which the ith selection exists.  Then we return
+//                    // the appropriate cell.  In the state machine, we
+//                    // always do rows above the "current" selected row first,
+//                    // then the cells in the selected row.  If we're done
+//                    // with the state machine before finding the requested
+//                    // selected child, we handle the rows below the last
+//                    // selected row at the end.
+//                    //
+//                    int curIndex = i;
+//                    final int IN_ROW = 0;
+//                    final int NOT_IN_ROW = 1;
+//                    int state = (rowIndicies[0] == 0 ? IN_ROW : NOT_IN_ROW);
+//                    int j = 0;
+//                    int prevRow = -1;
+//                    while (j < rowIndicies.length) {
+//                        switch (state) {
+//
+//                        case IN_ROW:   // on individual row full of selections
+//                            if (curIndex < ttlCols) { // it's here!
+//                                c = curIndex % ttlCols;
+//                                r = rowIndicies[j];
+//                                return getAccessibleChild((r * ttlCols) + c);
+//                            } else {                               // not here
+//                                curIndex -= ttlCols;
+//                            }
+//                            // is the next row in table selected or not?
+//                            if (j + 1 == rowIndicies.length ||
+//                                rowIndicies[j] != rowIndicies[j+1] - 1) {
+//                                state = NOT_IN_ROW;
+//                                prevRow = rowIndicies[j];
+//                            }
+//                            j++;  // we didn't return earlier, so go to next row
+//                            break;
+//
+//                        case NOT_IN_ROW:  // sparse bunch of rows of selections
+//                            if (curIndex <
+//                                (colsSel * (rowIndicies[j] -
+//                                (prevRow == -1 ? 0 : (prevRow + 1))))) {
+//
+//                                // it's here!
+//                                c = colIndicies[curIndex % colsSel];
+//                                r = (j > 0 ? rowIndicies[j-1] + 1 : 0)
+//                                    + curIndex / colsSel;
+//                                return getAccessibleChild((r * ttlCols) + c);
+//                            } else {                               // not here
+//                                curIndex -= colsSel * (rowIndicies[j] -
+//                                (prevRow == -1 ? 0 : (prevRow + 1)));
+//                            }
+//                            state = IN_ROW;
+//                            break;
+//                        }
+//                    }
+//                    // we got here, so we didn't find it yet; find it in
+//                    // the last sparse bunch of rows
+//                    if (curIndex <
+//                        (colsSel * (ttlRows -
+//                        (prevRow == -1 ? 0 : (prevRow + 1))))) { // it's here!
+//                        c = colIndicies[curIndex % colsSel];
+//                        r = rowIndicies[j-1] + curIndex / colsSel + 1;
+//                        return getAccessibleChild((r * ttlCols) + c);
+//                    } else {                               // not here
+//                        // we shouldn't get to this spot in the code!
+////                      System.out.println("Bug in AccessibleJTable.getAccessibleSelection()");
+//                    }
+//
+//                // one or more rows selected
+//                } else if (JTable.this.getRowSelectionAllowed()) {
+//                    c = i % ttlCols;
+//                    r = rowIndicies[i / ttlCols];
+//                    return getAccessibleChild((r * ttlCols) + c);
+//
+//                // one or more columns selected
+//                } else if (JTable.this.getColumnSelectionAllowed()) {
+//                    c = colIndicies[i % colsSel];
+//                    r = i / colsSel;
+//                    return getAccessibleChild((r * ttlCols) + c);
+//                }
+//            }
+//            return null;
+//        }
 
         /**
          * Determines if the current child of this object is selected.
@@ -7213,11 +7213,11 @@
          * @return true if the current child of this object is selected
          * @see AccessibleContext#getAccessibleChild
          */
-        public boolean isAccessibleChildSelected(int i) {
-            int column = getAccessibleColumnAtIndex(i);
-            int row = getAccessibleRowAtIndex(i);
-            return JTable.this.isCellSelected(row, column);
-        }
+        public boolean isAccessibleChildSelected(int i) {throw new RuntimeException("cf-bug");} //{
+//            int column = getAccessibleColumnAtIndex(i);
+//            int row = getAccessibleRowAtIndex(i);
+//            return JTable.this.isCellSelected(row, column);
+//        }
 
         /**
          * Adds the specified <code>Accessible</code> child of the
@@ -7233,12 +7233,12 @@
          * @param i the zero-based index of the child
          * @see AccessibleContext#getAccessibleChild
          */
-        public void addAccessibleSelection(int i) {
-            // TIGER - 4495286
-            int column = getAccessibleColumnAtIndex(i);
-            int row = getAccessibleRowAtIndex(i);
-            JTable.this.changeSelection(row, column, true, false);
-        }
+        public void addAccessibleSelection(int i) {throw new RuntimeException("cf-bug");} //{
+//            // TIGER - 4495286
+//            int column = getAccessibleColumnAtIndex(i);
+//            int row = getAccessibleRowAtIndex(i);
+//            JTable.this.changeSelection(row, column, true, false);
+//        }
 
         /**
          * Removes the specified child of the object from the object's
@@ -7251,33 +7251,33 @@
          * @param i the zero-based index of the child
          * @see AccessibleContext#getAccessibleChild
          */
-        public void removeAccessibleSelection(int i) {
-            if (JTable.this.cellSelectionEnabled) {
-                int column = getAccessibleColumnAtIndex(i);
-                int row = getAccessibleRowAtIndex(i);
-                JTable.this.removeRowSelectionInterval(row, row);
-                JTable.this.removeColumnSelectionInterval(column, column);
-            }
-        }
+        public void removeAccessibleSelection(int i) {throw new RuntimeException("cf-bug");} //{
+//            if (JTable.this.cellSelectionEnabled) {
+//                int column = getAccessibleColumnAtIndex(i);
+//                int row = getAccessibleRowAtIndex(i);
+//                JTable.this.removeRowSelectionInterval(row, row);
+//                JTable.this.removeColumnSelectionInterval(column, column);
+//            }
+//        }
 
         /**
          * Clears the selection in the object, so that no children in the
          * object are selected.
          */
-        public void clearAccessibleSelection() {
-            JTable.this.clearSelection();
-        }
+        public void clearAccessibleSelection() {throw new RuntimeException("cf-bug");} //{
+//            JTable.this.clearSelection();
+//        }
 
         /**
          * Causes every child of the object to be selected, but only
          * if the <code>JTable</code> supports multiple selections,
          * and if individual cell selection is enabled.
          */
-        public void selectAllAccessibleSelection() {
-            if (JTable.this.cellSelectionEnabled) {
-                JTable.this.selectAll();
-            }
-        }
+        public void selectAllAccessibleSelection() {throw new RuntimeException("cf-bug");} //{
+//            if (JTable.this.cellSelectionEnabled) {
+//                JTable.this.selectAll();
+//            }
+//        }
 
         // begin AccessibleExtendedTable implementation -------------
 
@@ -7289,9 +7289,9 @@
          * otherwise -1.
          * @since 1.4
          */
-        public int getAccessibleRow(int index) {
-            return getAccessibleRowAtIndex(index);
-        }
+        public int getAccessibleRow(int index) {throw new RuntimeException("cf-bug");} //{
+//            return getAccessibleRowAtIndex(index);
+//        }
 
         /**
          * Returns the column number of an index in the table.
@@ -7301,9 +7301,9 @@
          * otherwise -1.
          * @since 1.4
          */
-        public int getAccessibleColumn(int index) {
-            return getAccessibleColumnAtIndex(index);
-        }
+        public int getAccessibleColumn(int index) {throw new RuntimeException("cf-bug");} //{
+//            return getAccessibleColumnAtIndex(index);
+//        }
 
         /**
          * Returns the index at a row and column in the table.
@@ -7314,9 +7314,9 @@
          * otherwise -1.
          * @since 1.4
          */
-        public int getAccessibleIndex(int r, int c) {
-            return getAccessibleIndexAt(r, c);
-        }
+        public int getAccessibleIndex(int r, int c) {throw new RuntimeException("cf-bug");} //{
+//            return getAccessibleIndexAt(r, c);
+//        }
 
         // end of AccessibleExtendedTable implementation ------------
 
@@ -7337,9 +7337,9 @@
          * @return this object
          * @since 1.3
          */
-        public AccessibleTable getAccessibleTable() {
-            return this;
-        }
+        public AccessibleTable getAccessibleTable() {throw new RuntimeException("cf-bug");} //{
+//            return this;
+//        }
 
         /**
          * Returns the caption for the table.
@@ -7347,9 +7347,9 @@
          * @return the caption for the table
          * @since 1.3
          */
-        public Accessible getAccessibleCaption() {
-            return this.caption;
-        }
+        public Accessible getAccessibleCaption() {throw new RuntimeException("cf-bug");} //{
+//            return this.caption;
+//        }
 
         /**
          * Sets the caption for the table.
@@ -7357,12 +7357,12 @@
          * @param a the caption for the table
          * @since 1.3
          */
-        public void setAccessibleCaption(Accessible a) {
-            Accessible oldCaption = caption;
-            this.caption = a;
-            firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_CAPTION_CHANGED,
-                               oldCaption, this.caption);
-        }
+        public void setAccessibleCaption(Accessible a) {throw new RuntimeException("cf-bug");} //{
+//            Accessible oldCaption = caption;
+//            this.caption = a;
+//            firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_CAPTION_CHANGED,
+//                               oldCaption, this.caption);
+//        }
 
         /**
          * Returns the summary description of the table.
@@ -7370,9 +7370,9 @@
          * @return the summary description of the table
          * @since 1.3
          */
-        public Accessible getAccessibleSummary() {
-            return this.summary;
-        }
+        public Accessible getAccessibleSummary() {throw new RuntimeException("cf-bug");} //{
+//            return this.summary;
+//        }
 
         /**
          * Sets the summary description of the table.
@@ -7380,30 +7380,30 @@
          * @param a the summary description of the table
          * @since 1.3
          */
-        public void setAccessibleSummary(Accessible a) {
-            Accessible oldSummary = summary;
-            this.summary = a;
-            firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_SUMMARY_CHANGED,
-                               oldSummary, this.summary);
-        }
+        public void setAccessibleSummary(Accessible a) {throw new RuntimeException("cf-bug");} //{
+//            Accessible oldSummary = summary;
+//            this.summary = a;
+//            firePropertyChange(AccessibleContext.ACCESSIBLE_TABLE_SUMMARY_CHANGED,
+//                               oldSummary, this.summary);
+//        }
 
         /*
          * Returns the total number of rows in this table.
          *
          * @return the total number of rows in this table
          */
-        public int getAccessibleRowCount() {
-            return JTable.this.getRowCount();
-        }
+        public int getAccessibleRowCount() {throw new RuntimeException("cf-bug");} //{
+//            return JTable.this.getRowCount();
+//        }
 
         /*
          * Returns the total number of columns in the table.
          *
          * @return the total number of columns in the table
          */
-        public int getAccessibleColumnCount() {
-            return JTable.this.getColumnCount();
-        }
+        public int getAccessibleColumnCount() {throw new RuntimeException("cf-bug");} //{
+//            return JTable.this.getColumnCount();
+//        }
 
         /*
          * Returns the <code>Accessible</code> at a specified row
@@ -7414,9 +7414,9 @@
          * @return the <code>Accessible</code> at the specified row and column
          * in the table
          */
-        public Accessible getAccessibleAt(int r, int c) {
-            return getAccessibleChild((r * getAccessibleColumnCount()) + c);
-        }
+        public Accessible getAccessibleAt(int r, int c) {throw new RuntimeException("cf-bug");} //{
+//            return getAccessibleChild((r * getAccessibleColumnCount()) + c);
+//        }
 
         /**
          * Returns the number of rows occupied by the <code>Accessible</code>
@@ -7426,9 +7426,9 @@
          *     at a specified row and column in the table
          * @since 1.3
          */
-        public int getAccessibleRowExtentAt(int r, int c) {
-            return 1;
-        }
+        public int getAccessibleRowExtentAt(int r, int c) {throw new RuntimeException("cf-bug");} //{
+//            return 1;
+//        }
 
         /**
          * Returns the number of columns occupied by the
@@ -7438,9 +7438,9 @@
          *     at a specified row and column in the table
          * @since 1.3
          */
-        public int getAccessibleColumnExtentAt(int r, int c) {
-            return 1;
-        }
+        public int getAccessibleColumnExtentAt(int r, int c) {throw new RuntimeException("cf-bug");} //{
+//            return 1;
+//        }
 
         /**
          * Returns the row headers as an <code>AccessibleTable</code>.
@@ -7449,10 +7449,10 @@
          * headers
          * @since 1.3
          */
-        public AccessibleTable getAccessibleRowHeader() {
-            // row headers are not supported
-            return null;
-        }
+        public AccessibleTable getAccessibleRowHeader() {throw new RuntimeException("cf-bug");} //{
+//            // row headers are not supported
+//            return null;
+//        }
 
         /**
          * Sets the row headers as an <code>AccessibleTable</code>.
@@ -7461,9 +7461,9 @@
          *  headers
          * @since 1.3
          */
-        public void setAccessibleRowHeader(AccessibleTable a) {
-            // row headers are not supported
-        }
+        public void setAccessibleRowHeader(AccessibleTable a) {throw new RuntimeException("cf-bug");} //{
+//            // row headers are not supported
+//        }
 
         /**
          * Returns the column headers as an <code>AccessibleTable</code>.
@@ -7473,10 +7473,10 @@
          *          <code>null</code>
          * @since 1.3
          */
-        public AccessibleTable getAccessibleColumnHeader() {
-            JTableHeader header = JTable.this.getTableHeader();
-            return header == null ? null : new AccessibleTableHeader(header);
-        }
+        public AccessibleTable getAccessibleColumnHeader() {throw new RuntimeException("cf-bug");} //{
+//            JTableHeader header = JTable.this.getTableHeader();
+//            return header == null ? null : new AccessibleTableHeader(header);
+//        }
 
         /*
          * Private class representing a table column header
@@ -7495,7 +7495,7 @@
              *
              * @return the caption for the table
              */
-            public Accessible getAccessibleCaption() { return null; }
+            public Accessible getAccessibleCaption() {throw new RuntimeException("cf-bug");} //{ return null; }
 
 
             /**
@@ -7510,7 +7510,7 @@
              *
              * @return the summary description of the table
              */
-            public Accessible getAccessibleSummary() { return null; }
+            public Accessible getAccessibleSummary() {throw new RuntimeException("cf-bug");} //{ return null; }
 
             /**
              * Sets the summary description of the table
@@ -7524,16 +7524,16 @@
              *
              * @return the number of rows in the table
              */
-            public int getAccessibleRowCount() { return 1; }
+            public int getAccessibleRowCount() {throw new RuntimeException("cf-bug");} //{ return 1; }
 
             /**
              * Returns the number of columns in the table.
              *
              * @return the number of columns in the table
              */
-            public int getAccessibleColumnCount() {
-                return headerModel.getColumnCount();
-            }
+            public int getAccessibleColumnCount() {throw new RuntimeException("cf-bug");} //{
+//                return headerModel.getColumnCount();
+//            }
 
             /**
              * Returns the Accessible at a specified row and column
@@ -7543,24 +7543,24 @@
              * @param column zero-based column of the table
              * @return the Accessible at the specified row and column
              */
-            public Accessible getAccessibleAt(int row, int column) {
-
-
-                // TIGER - 4715503
-                TableColumn aColumn = headerModel.getColumn(column);
-                TableCellRenderer renderer = aColumn.getHeaderRenderer();
-                if (renderer == null) {
-                    renderer = header.getDefaultRenderer();
-                }
-                Component component = renderer.getTableCellRendererComponent(
-                                  header.getTable(),
-                                  aColumn.getHeaderValue(), false, false,
-                                  -1, column);
-
-                return new AccessibleJTableHeaderCell(row, column,
-                                                      JTable.this.getTableHeader(),
-                                                      component);
-            }
+            public Accessible getAccessibleAt(int row, int column) {throw new RuntimeException("cf-bug");} //{
+//
+//
+//                // TIGER - 4715503
+//                TableColumn aColumn = headerModel.getColumn(column);
+//                TableCellRenderer renderer = aColumn.getHeaderRenderer();
+//                if (renderer == null) {
+//                    renderer = header.getDefaultRenderer();
+//                }
+//                Component component = renderer.getTableCellRendererComponent(
+//                                  header.getTable(),
+//                                  aColumn.getHeaderValue(), false, false,
+//                                  -1, column);
+//
+//                return new AccessibleJTableHeaderCell(row, column,
+//                                                      JTable.this.getTableHeader(),
+//                                                      component);
+//            }
 
             /**
              * Returns the number of rows occupied by the Accessible at
@@ -7569,7 +7569,7 @@
              * @return the number of rows occupied by the Accessible at a
              * given specified (row, column)
              */
-            public int getAccessibleRowExtentAt(int r, int c) { return 1; }
+            public int getAccessibleRowExtentAt(int r, int c) {throw new RuntimeException("cf-bug");} //{ return 1; }
 
             /**
              * Returns the number of columns occupied by the Accessible at
@@ -7586,7 +7586,7 @@
              * @return an AccessibleTable representing the row
              * headers
              */
-            public AccessibleTable getAccessibleRowHeader() { return null; }
+            public AccessibleTable getAccessibleRowHeader() {throw new RuntimeException("cf-bug");} //{ return null; }
 
             /**
              * Sets the row headers.
@@ -7602,7 +7602,7 @@
              * @return an AccessibleTable representing the column
              * headers
              */
-            public AccessibleTable getAccessibleColumnHeader() { return null; }
+            public AccessibleTable getAccessibleColumnHeader() {throw new RuntimeException("cf-bug");} //{ return null; }
 
             /**
              * Sets the column headers.
@@ -7620,7 +7620,7 @@
              * @return the description of the row
              * @since 1.3
              */
-            public Accessible getAccessibleRowDescription(int r) { return null; }
+            public Accessible getAccessibleRowDescription(int r) {throw new RuntimeException("cf-bug");} //{ return null; }
 
             /**
              * Sets the description text of the specified row of the table.
@@ -7638,7 +7638,7 @@
              * @return the text description of the column
              * @since 1.3
              */
-            public Accessible getAccessibleColumnDescription(int c) { return null; }
+            public Accessible getAccessibleColumnDescription(int c) {throw new RuntimeException("cf-bug");} //{ return null; }
 
             /**
              * Sets the description text of the specified column in the table.
@@ -7660,7 +7660,7 @@
              * false
              * @since 1.3
              */
-            public boolean isAccessibleSelected(int r, int c) { return false; }
+            public boolean isAccessibleSelected(int r, int c) {throw new RuntimeException("cf-bug");} //{ return false; }
 
             /**
              * Returns a boolean value indicating whether the specified row
@@ -7671,7 +7671,7 @@
              * Otherwise, false.
              * @since 1.3
              */
-            public boolean isAccessibleRowSelected(int r) { return false; }
+            public boolean isAccessibleRowSelected(int r) {throw new RuntimeException("cf-bug");} //{ return false; }
 
             /**
              * Returns a boolean value indicating whether the specified column
@@ -7682,7 +7682,7 @@
              * Otherwise, false.
              * @since 1.3
              */
-            public boolean isAccessibleColumnSelected(int c) { return false; }
+            public boolean isAccessibleColumnSelected(int c) {throw new RuntimeException("cf-bug");} //{ return false; }
 
             /**
              * Returns the selected rows in a table.
@@ -7691,7 +7691,7 @@
              * zero-based row of the table
              * @since 1.3
              */
-            public int [] getSelectedAccessibleRows() { return new int[0]; }
+            public int [] getSelectedAccessibleRows() {throw new RuntimeException("cf-bug");} //{ return new int[0]; }
 
             /**
              * Returns the selected columns in a table.
@@ -7700,7 +7700,7 @@
              * zero-based column of the table
              * @since 1.3
              */
-            public int [] getSelectedAccessibleColumns() { return new int[0]; }
+            public int [] getSelectedAccessibleColumns() {throw new RuntimeException("cf-bug");} //{ return new int[0]; }
         }
 
 
@@ -7722,16 +7722,16 @@
          * @return the description of the row
          * @since 1.3
          */
-        public Accessible getAccessibleRowDescription(int r) {
-            if (r < 0 || r >= getAccessibleRowCount()) {
-                throw new IllegalArgumentException(Integer.toString(r));
-            }
-            if (rowDescription == null) {
-                return null;
-            } else {
-                return rowDescription[r];
-            }
-        }
+        public Accessible getAccessibleRowDescription(int r) {throw new RuntimeException("cf-bug");} //{
+//            if (r < 0 || r >= getAccessibleRowCount()) {
+//                throw new IllegalArgumentException(Integer.toString(r));
+//            }
+//            if (rowDescription == null) {
+//                return null;
+//            } else {
+//                return rowDescription[r];
+//            }
+//        }
 
         /**
          * Sets the description text of the specified row of the table.
@@ -7740,16 +7740,16 @@
          * @param a the description of the row
          * @since 1.3
          */
-        public void setAccessibleRowDescription(int r, Accessible a) {
-            if (r < 0 || r >= getAccessibleRowCount()) {
-                throw new IllegalArgumentException(Integer.toString(r));
-            }
-            if (rowDescription == null) {
-                int numRows = getAccessibleRowCount();
-                rowDescription = new Accessible[numRows];
-            }
-            rowDescription[r] = a;
-        }
+        public void setAccessibleRowDescription(int r, Accessible a) {throw new RuntimeException("cf-bug");} //{
+//            if (r < 0 || r >= getAccessibleRowCount()) {
+//                throw new IllegalArgumentException(Integer.toString(r));
+//            }
+//            if (rowDescription == null) {
+//                int numRows = getAccessibleRowCount();
+//                rowDescription = new Accessible[numRows];
+//            }
+//            rowDescription[r] = a;
+//        }
 
         /**
          * Returns the description of the specified column in the table.
@@ -7758,16 +7758,16 @@
          * @return the description of the column
          * @since 1.3
          */
-        public Accessible getAccessibleColumnDescription(int c) {
-            if (c < 0 || c >= getAccessibleColumnCount()) {
-                throw new IllegalArgumentException(Integer.toString(c));
-            }
-            if (columnDescription == null) {
-                return null;
-            } else {
-                return columnDescription[c];
-            }
-        }
+        public Accessible getAccessibleColumnDescription(int c) {throw new RuntimeException("cf-bug");} //{
+//            if (c < 0 || c >= getAccessibleColumnCount()) {
+//                throw new IllegalArgumentException(Integer.toString(c));
+//            }
+//            if (columnDescription == null) {
+//                return null;
+//            } else {
+//                return columnDescription[c];
+//            }
+//        }
 
         /**
          * Sets the description text of the specified column of the table.
@@ -7776,16 +7776,16 @@
          * @param a the description of the column
          * @since 1.3
          */
-        public void setAccessibleColumnDescription(int c, Accessible a) {
-            if (c < 0 || c >= getAccessibleColumnCount()) {
-                throw new IllegalArgumentException(Integer.toString(c));
-            }
-            if (columnDescription == null) {
-                int numColumns = getAccessibleColumnCount();
-                columnDescription = new Accessible[numColumns];
-            }
-            columnDescription[c] = a;
-        }
+        public void setAccessibleColumnDescription(int c, Accessible a) {throw new RuntimeException("cf-bug");} //{
+//            if (c < 0 || c >= getAccessibleColumnCount()) {
+//                throw new IllegalArgumentException(Integer.toString(c));
+//            }
+//            if (columnDescription == null) {
+//                int numColumns = getAccessibleColumnCount();
+//                columnDescription = new Accessible[numColumns];
+//            }
+//            columnDescription[c] = a;
+//        }
 
         /**
          * Returns a boolean value indicating whether the accessible at a
@@ -7797,9 +7797,9 @@
          *     is selected; otherwise, the boolean value false
          * @since 1.3
          */
-        public boolean isAccessibleSelected(int r, int c) {
-            return JTable.this.isCellSelected(r, c);
-        }
+        public boolean isAccessibleSelected(int r, int c) {throw new RuntimeException("cf-bug");} //{
+//            return JTable.this.isCellSelected(r, c);
+//        }
 
         /**
          * Returns a boolean value indicating whether the specified row
@@ -7810,9 +7810,9 @@
          *     otherwise, false
          * @since 1.3
          */
-        public boolean isAccessibleRowSelected(int r) {
-            return JTable.this.isRowSelected(r);
-        }
+        public boolean isAccessibleRowSelected(int r) {throw new RuntimeException("cf-bug");} //{
+//            return JTable.this.isRowSelected(r);
+//        }
 
         /**
          * Returns a boolean value indicating whether the specified column
@@ -7823,9 +7823,9 @@
          *     otherwise, false
          * @since 1.3
          */
-        public boolean isAccessibleColumnSelected(int c) {
-            return JTable.this.isColumnSelected(c);
-        }
+        public boolean isAccessibleColumnSelected(int c) {throw new RuntimeException("cf-bug");} //{
+//            return JTable.this.isColumnSelected(c);
+//        }
 
         /**
          * Returns the selected rows in a table.
@@ -7834,9 +7834,9 @@
          *     zero-based row of the table
          * @since 1.3
          */
-        public int [] getSelectedAccessibleRows() {
-            return JTable.this.getSelectedRows();
-        }
+        public int [] getSelectedAccessibleRows() {throw new RuntimeException("cf-bug");} //{
+//            return JTable.this.getSelectedRows();
+//        }
 
         /**
          * Returns the selected columns in a table.
@@ -7845,9 +7845,9 @@
          *     zero-based column of the table
          * @since 1.3
          */
-        public int [] getSelectedAccessibleColumns() {
-            return JTable.this.getSelectedColumns();
-        }
+        public int [] getSelectedAccessibleColumns() {throw new RuntimeException("cf-bug");} //{
+//            return JTable.this.getSelectedColumns();
+//        }
 
         /**
          * Returns the row at a given index into the table.
@@ -7856,14 +7856,14 @@
          * @return the row at a given index
          * @since 1.3
          */
-        public int getAccessibleRowAtIndex(int i) {
-            int columnCount = getAccessibleColumnCount();
-            if (columnCount == 0) {
-                return -1;
-            } else {
-                return (i / columnCount);
-            }
-        }
+        public int getAccessibleRowAtIndex(int i) {throw new RuntimeException("cf-bug");} //{
+//            int columnCount = getAccessibleColumnCount();
+//            if (columnCount == 0) {
+//                return -1;
+//            } else {
+//                return (i / columnCount);
+//            }
+//        }
 
         /**
          * Returns the column at a given index into the table.
@@ -7872,14 +7872,14 @@
          * @return the column at a given index
          * @since 1.3
          */
-        public int getAccessibleColumnAtIndex(int i) {
-            int columnCount = getAccessibleColumnCount();
-            if (columnCount == 0) {
-                return -1;
-            } else {
-                return (i % columnCount);
-            }
-        }
+        public int getAccessibleColumnAtIndex(int i) {throw new RuntimeException("cf-bug");} //{
+//            int columnCount = getAccessibleColumnCount();
+//            if (columnCount == 0) {
+//                return -1;
+//            } else {
+//                return (i % columnCount);
+//            }
+//        }
 
         /**
          * Returns the index at a given (row, column) in the table.
@@ -7889,9 +7889,9 @@
          * @return the index into the table
          * @since 1.3
          */
-        public int getAccessibleIndexAt(int r, int c) {
-            return ((r * getAccessibleColumnCount()) + c);
-        }
+        public int getAccessibleIndexAt(int r, int c) {throw new RuntimeException("cf-bug");} //{
+//            return ((r * getAccessibleColumnCount()) + c);
+//        }
 
         // end of AccessibleTable implementation --------------------
 
@@ -7927,9 +7927,9 @@
              *
              * @return this object
              */
-            public AccessibleContext getAccessibleContext() {
-                return this;
-            }
+            public AccessibleContext getAccessibleContext() {throw new RuntimeException("cf-bug");} //{
+//                return this;
+//            }
 
             /**
              * Gets the AccessibleContext for the table cell renderer.
@@ -7939,22 +7939,22 @@
              * otherwise, returns <code>null</code>.
              * @since 1.6
              */
-            protected AccessibleContext getCurrentAccessibleContext() {
-                TableColumn aColumn = getColumnModel().getColumn(column);
-                TableCellRenderer renderer = aColumn.getCellRenderer();
-                if (renderer == null) {
-                    Class<?> columnClass = getColumnClass(column);
-                    renderer = getDefaultRenderer(columnClass);
-                }
-                Component component = renderer.getTableCellRendererComponent(
-                                  JTable.this, getValueAt(row, column),
-                                  false, false, row, column);
-                if (component instanceof Accessible) {
-                    return component.getAccessibleContext();
-                } else {
-                    return null;
-                }
-            }
+            protected AccessibleContext getCurrentAccessibleContext() {throw new RuntimeException("cf-bug");} //{
+//                TableColumn aColumn = getColumnModel().getColumn(column);
+//                TableCellRenderer renderer = aColumn.getCellRenderer();
+//                if (renderer == null) {
+//                    Class<?> columnClass = getColumnClass(column);
+//                    renderer = getDefaultRenderer(columnClass);
+//                }
+//                Component component = renderer.getTableCellRendererComponent(
+//                                  JTable.this, getValueAt(row, column),
+//                                  false, false, row, column);
+//                if (component instanceof Accessible) {
+//                    return component.getAccessibleContext();
+//                } else {
+//                    return null;
+//                }
+//            }
 
             /**
              * Gets the table cell renderer component.
@@ -7963,17 +7963,17 @@
              * otherwise, returns <code>null</code>.
              * @since 1.6
              */
-            protected Component getCurrentComponent() {
-                TableColumn aColumn = getColumnModel().getColumn(column);
-                TableCellRenderer renderer = aColumn.getCellRenderer();
-                if (renderer == null) {
-                    Class<?> columnClass = getColumnClass(column);
-                    renderer = getDefaultRenderer(columnClass);
-                }
-                return renderer.getTableCellRendererComponent(
-                                  JTable.this, null, false, false,
-                                  row, column);
-            }
+            protected Component getCurrentComponent() {throw new RuntimeException("cf-bug");} //{
+//                TableColumn aColumn = getColumnModel().getColumn(column);
+//                TableCellRenderer renderer = aColumn.getCellRenderer();
+//                if (renderer == null) {
+//                    Class<?> columnClass = getColumnClass(column);
+//                    renderer = getDefaultRenderer(columnClass);
+//                }
+//                return renderer.getTableCellRendererComponent(
+//                                  JTable.this, null, false, false,
+//                                  row, column);
+//            }
 
         // AccessibleContext methods
 
@@ -7983,36 +7983,36 @@
              * @return the localized name of the object; <code>null</code>
              *     if this object does not have a name
              */
-            public String getAccessibleName() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    String name = ac.getAccessibleName();
-                    if ((name != null) && (name != "")) {
-                        // return the cell renderer's AccessibleName
-                        return name;
-                    }
-                }
-                if ((accessibleName != null) && (accessibleName != "")) {
-                    return accessibleName;
-                } else {
-                    // fall back to the client property
-                    return (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);
-                }
-            }
+            public String getAccessibleName() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    String name = ac.getAccessibleName();
+//                    if ((name != null) && (name != "")) {
+//                        // return the cell renderer's AccessibleName
+//                        return name;
+//                    }
+//                }
+//                if ((accessibleName != null) && (accessibleName != "")) {
+//                    return accessibleName;
+//                } else {
+//                    // fall back to the client property
+//                    return (String)getClientProperty(AccessibleContext.ACCESSIBLE_NAME_PROPERTY);
+//                }
+//            }
 
             /**
              * Sets the localized accessible name of this object.
              *
              * @param s the new localized name of the object
              */
-            public void setAccessibleName(String s) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    ac.setAccessibleName(s);
-                } else {
-                    super.setAccessibleName(s);
-                }
-            }
+            public void setAccessibleName(String s) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    ac.setAccessibleName(s);
+//                } else {
+//                    super.setAccessibleName(s);
+//                }
+//            }
 
             //
             // *** should check toolTip text for desc. (needs MouseEvent)
@@ -8024,28 +8024,28 @@
              *     <code>null</code> if this object does not have
              *     a description
              */
-            public String getAccessibleDescription() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    return ac.getAccessibleDescription();
-                } else {
-                    return super.getAccessibleDescription();
-                }
-            }
+            public String getAccessibleDescription() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    return ac.getAccessibleDescription();
+//                } else {
+//                    return super.getAccessibleDescription();
+//                }
+//            }
 
             /**
              * Sets the accessible description of this object.
              *
              * @param s the new localized description of the object
              */
-            public void setAccessibleDescription(String s) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    ac.setAccessibleDescription(s);
-                } else {
-                    super.setAccessibleDescription(s);
-                }
-            }
+            public void setAccessibleDescription(String s) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    ac.setAccessibleDescription(s);
+//                } else {
+//                    super.setAccessibleDescription(s);
+//                }
+//            }
 
             /**
              * Gets the role of this object.
@@ -8054,14 +8054,14 @@
              *      describing the role of the object
              * @see AccessibleRole
              */
-            public AccessibleRole getAccessibleRole() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    return ac.getAccessibleRole();
-                } else {
-                    return AccessibleRole.UNKNOWN;
-                }
-            }
+            public AccessibleRole getAccessibleRole() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    return ac.getAccessibleRole();
+//                } else {
+//                    return AccessibleRole.UNKNOWN;
+//                }
+//            }
 
             /**
              * Gets the state set of this object.
@@ -8070,36 +8070,36 @@
              *     containing the current state set of the object
              * @see AccessibleState
              */
-            public AccessibleStateSet getAccessibleStateSet() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                AccessibleStateSet as = null;
-
-                if (ac != null) {
-                    as = ac.getAccessibleStateSet();
-                }
-                if (as == null) {
-                    as = new AccessibleStateSet();
-                }
-                Rectangle rjt = JTable.this.getVisibleRect();
-                Rectangle rcell = JTable.this.getCellRect(row, column, false);
-                if (rjt.intersects(rcell)) {
-                    as.add(AccessibleState.SHOWING);
-                } else {
-                    if (as.contains(AccessibleState.SHOWING)) {
-                         as.remove(AccessibleState.SHOWING);
-                    }
-                }
-                if (parent.isCellSelected(row, column)) {
-                    as.add(AccessibleState.SELECTED);
-                } else if (as.contains(AccessibleState.SELECTED)) {
-                    as.remove(AccessibleState.SELECTED);
-                }
-                if ((row == getSelectedRow()) && (column == getSelectedColumn())) {
-                    as.add(AccessibleState.ACTIVE);
-                }
-                as.add(AccessibleState.TRANSIENT);
-                return as;
-            }
+            public AccessibleStateSet getAccessibleStateSet() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                AccessibleStateSet as = null;
+//
+//                if (ac != null) {
+//                    as = ac.getAccessibleStateSet();
+//                }
+//                if (as == null) {
+//                    as = new AccessibleStateSet();
+//                }
+//                Rectangle rjt = JTable.this.getVisibleRect();
+//                Rectangle rcell = JTable.this.getCellRect(row, column, false);
+//                if (rjt.intersects(rcell)) {
+//                    as.add(AccessibleState.SHOWING);
+//                } else {
+//                    if (as.contains(AccessibleState.SHOWING)) {
+//                         as.remove(AccessibleState.SHOWING);
+//                    }
+//                }
+//                if (parent.isCellSelected(row, column)) {
+//                    as.add(AccessibleState.SELECTED);
+//                } else if (as.contains(AccessibleState.SELECTED)) {
+//                    as.remove(AccessibleState.SELECTED);
+//                }
+//                if ((row == getSelectedRow()) && (column == getSelectedColumn())) {
+//                    as.add(AccessibleState.ACTIVE);
+//                }
+//                as.add(AccessibleState.TRANSIENT);
+//                return as;
+//            }
 
             /**
              * Gets the <code>Accessible</code> parent of this object.
@@ -8108,9 +8108,9 @@
              *     <code>null</code> if this object does not
              *     have an <code>Accessible</code> parent
              */
-            public Accessible getAccessibleParent() {
-                return parent;
-            }
+            public Accessible getAccessibleParent() {throw new RuntimeException("cf-bug");} //{
+//                return parent;
+//            }
 
             /**
              * Gets the index of this object in its accessible parent.
@@ -8119,23 +8119,23 @@
              *     object does not have an accessible parent
              * @see #getAccessibleParent
              */
-            public int getAccessibleIndexInParent() {
-                return index;
-            }
+            public int getAccessibleIndexInParent() {throw new RuntimeException("cf-bug");} //{
+//                return index;
+//            }
 
             /**
              * Returns the number of accessible children in the object.
              *
              * @return the number of accessible children in the object
              */
-            public int getAccessibleChildrenCount() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    return ac.getAccessibleChildrenCount();
-                } else {
-                    return 0;
-                }
-            }
+            public int getAccessibleChildrenCount() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    return ac.getAccessibleChildrenCount();
+//                } else {
+//                    return 0;
+//                }
+//            }
 
             /**
              * Returns the specified <code>Accessible</code> child of the
@@ -8144,16 +8144,16 @@
              * @param i zero-based index of child
              * @return the <code>Accessible</code> child of the object
              */
-            public Accessible getAccessibleChild(int i) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    Accessible accessibleChild = ac.getAccessibleChild(i);
-                    ac.setAccessibleParent(this);
-                    return accessibleChild;
-                } else {
-                    return null;
-                }
-            }
+            public Accessible getAccessibleChild(int i) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    Accessible accessibleChild = ac.getAccessibleChild(i);
+//                    ac.setAccessibleParent(this);
+//                    return accessibleChild;
+//                } else {
+//                    return null;
+//                }
+//            }
 
             /**
              * Gets the locale of the component. If the component
@@ -8169,14 +8169,14 @@
              *    containing parent
              * @see #setLocale
              */
-            public Locale getLocale() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    return ac.getLocale();
-                } else {
-                    return null;
-                }
-            }
+            public Locale getLocale() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    return ac.getLocale();
+//                } else {
+//                    return null;
+//                }
+//            }
 
             /**
              * Adds a <code>PropertyChangeListener</code> to the listener list.
@@ -8185,14 +8185,14 @@
              * @param l  the <code>PropertyChangeListener</code>
              *     to be added
              */
-            public void addPropertyChangeListener(PropertyChangeListener l) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    ac.addPropertyChangeListener(l);
-                } else {
-                    super.addPropertyChangeListener(l);
-                }
-            }
+            public void addPropertyChangeListener(PropertyChangeListener l) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    ac.addPropertyChangeListener(l);
+//                } else {
+//                    super.addPropertyChangeListener(l);
+//                }
+//            }
 
             /**
              * Removes a <code>PropertyChangeListener</code> from the
@@ -8202,14 +8202,14 @@
              * @param l  the <code>PropertyChangeListener</code>
              *    to be removed
              */
-            public void removePropertyChangeListener(PropertyChangeListener l) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    ac.removePropertyChangeListener(l);
-                } else {
-                    super.removePropertyChangeListener(l);
-                }
-            }
+            public void removePropertyChangeListener(PropertyChangeListener l) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    ac.removePropertyChangeListener(l);
+//                } else {
+//                    super.removePropertyChangeListener(l);
+//                }
+//            }
 
             /**
              * Gets the <code>AccessibleAction</code> associated with this
@@ -8217,9 +8217,9 @@
              *
              * @return the <code>AccessibleAction</code>, or <code>null</code>
              */
-            public AccessibleAction getAccessibleAction() {
-                return getCurrentAccessibleContext().getAccessibleAction();
-            }
+            public AccessibleAction getAccessibleAction() {throw new RuntimeException("cf-bug");} //{
+//                return getCurrentAccessibleContext().getAccessibleAction();
+//            }
 
             /**
              * Gets the <code>AccessibleComponent</code> associated with
@@ -8228,9 +8228,9 @@
              * @return the <code>AccessibleComponent</code>, or
              *    <code>null</code>
              */
-            public AccessibleComponent getAccessibleComponent() {
-                return this; // to override getBounds()
-            }
+            public AccessibleComponent getAccessibleComponent() {throw new RuntimeException("cf-bug");} //{
+//                return this; // to override getBounds()
+//            }
 
             /**
              * Gets the <code>AccessibleSelection</code> associated with
@@ -8239,9 +8239,9 @@
              * @return the <code>AccessibleSelection</code>, or
              *    <code>null</code>
              */
-            public AccessibleSelection getAccessibleSelection() {
-                return getCurrentAccessibleContext().getAccessibleSelection();
-            }
+            public AccessibleSelection getAccessibleSelection() {throw new RuntimeException("cf-bug");} //{
+//                return getCurrentAccessibleContext().getAccessibleSelection();
+//            }
 
             /**
              * Gets the <code>AccessibleText</code> associated with this
@@ -8249,9 +8249,9 @@
              *
              * @return the <code>AccessibleText</code>, or <code>null</code>
              */
-            public AccessibleText getAccessibleText() {
-                return getCurrentAccessibleContext().getAccessibleText();
-            }
+            public AccessibleText getAccessibleText() {throw new RuntimeException("cf-bug");} //{
+//                return getCurrentAccessibleContext().getAccessibleText();
+//            }
 
             /**
              * Gets the <code>AccessibleValue</code> associated with
@@ -8259,9 +8259,9 @@
              *
              * @return the <code>AccessibleValue</code>, or <code>null</code>
              */
-            public AccessibleValue getAccessibleValue() {
-                return getCurrentAccessibleContext().getAccessibleValue();
-            }
+            public AccessibleValue getAccessibleValue() {throw new RuntimeException("cf-bug");} //{
+//                return getCurrentAccessibleContext().getAccessibleValue();
+//            }
 
 
         // AccessibleComponent methods
@@ -8272,36 +8272,36 @@
              * @return the background color, if supported, of the object;
              *     otherwise, <code>null</code>
              */
-            public Color getBackground() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getBackground();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.getBackground();
-                    } else {
-                        return null;
-                    }
-                }
-            }
+            public Color getBackground() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getBackground();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.getBackground();
+//                    } else {
+//                        return null;
+//                    }
+//                }
+//            }
 
             /**
              * Sets the background color of this object.
              *
              * @param c the new <code>Color</code> for the background
              */
-            public void setBackground(Color c) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setBackground(c);
-                } else {
-                    Component cp = getCurrentComponent();
-                    if (cp != null) {
-                        cp.setBackground(c);
-                    }
-                }
-            }
+            public void setBackground(Color c) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setBackground(c);
+//                } else {
+//                    Component cp = getCurrentComponent();
+//                    if (cp != null) {
+//                        cp.setBackground(c);
+//                    }
+//                }
+//            }
 
             /**
              * Gets the foreground color of this object.
@@ -8309,36 +8309,36 @@
              * @return the foreground color, if supported, of the object;
              *     otherwise, <code>null</code>
              */
-            public Color getForeground() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getForeground();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.getForeground();
-                    } else {
-                        return null;
-                    }
-                }
-            }
+            public Color getForeground() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getForeground();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.getForeground();
+//                    } else {
+//                        return null;
+//                    }
+//                }
+//            }
 
             /**
              * Sets the foreground color of this object.
              *
              * @param c the new <code>Color</code> for the foreground
              */
-            public void setForeground(Color c) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setForeground(c);
-                } else {
-                    Component cp = getCurrentComponent();
-                    if (cp != null) {
-                        cp.setForeground(c);
-                    }
-                }
-            }
+            public void setForeground(Color c) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setForeground(c);
+//                } else {
+//                    Component cp = getCurrentComponent();
+//                    if (cp != null) {
+//                        cp.setForeground(c);
+//                    }
+//                }
+//            }
 
             /**
              * Gets the <code>Cursor</code> of this object.
@@ -8346,41 +8346,41 @@
              * @return the <code>Cursor</code>, if supported,
              *    of the object; otherwise, <code>null</code>
              */
-            public Cursor getCursor() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getCursor();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.getCursor();
-                    } else {
-                        Accessible ap = getAccessibleParent();
-                        if (ap instanceof AccessibleComponent) {
-                            return ((AccessibleComponent) ap).getCursor();
-                        } else {
-                            return null;
-                        }
-                    }
-                }
-            }
+            public Cursor getCursor() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getCursor();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.getCursor();
+//                    } else {
+//                        Accessible ap = getAccessibleParent();
+//                        if (ap instanceof AccessibleComponent) {
+//                            return ((AccessibleComponent) ap).getCursor();
+//                        } else {
+//                            return null;
+//                        }
+//                    }
+//                }
+//            }
 
             /**
              * Sets the <code>Cursor</code> of this object.
              *
              * @param c the new <code>Cursor</code> for the object
              */
-            public void setCursor(Cursor c) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setCursor(c);
-                } else {
-                    Component cp = getCurrentComponent();
-                    if (cp != null) {
-                        cp.setCursor(c);
-                    }
-                }
-            }
+            public void setCursor(Cursor c) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setCursor(c);
+//                } else {
+//                    Component cp = getCurrentComponent();
+//                    if (cp != null) {
+//                        cp.setCursor(c);
+//                    }
+//                }
+//            }
 
             /**
              * Gets the <code>Font</code> of this object.
@@ -8388,36 +8388,36 @@
              * @return the <code>Font</code>,if supported,
              *   for the object; otherwise, <code>null</code>
              */
-            public Font getFont() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getFont();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.getFont();
-                    } else {
-                        return null;
-                    }
-                }
-            }
+            public Font getFont() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getFont();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.getFont();
+//                    } else {
+//                        return null;
+//                    }
+//                }
+//            }
 
             /**
              * Sets the <code>Font</code> of this object.
              *
              * @param f the new <code>Font</code> for the object
              */
-            public void setFont(Font f) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setFont(f);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.setFont(f);
-                    }
-                }
-            }
+            public void setFont(Font f) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setFont(f);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.setFont(f);
+//                    }
+//                }
+//            }
 
             /**
              * Gets the <code>FontMetrics</code> of this object.
@@ -8427,55 +8427,55 @@
              *    otherwise <code>null</code>
              * @see #getFont
              */
-            public FontMetrics getFontMetrics(Font f) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getFontMetrics(f);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.getFontMetrics(f);
-                    } else {
-                        return null;
-                    }
-                }
-            }
+            public FontMetrics getFontMetrics(Font f) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getFontMetrics(f);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.getFontMetrics(f);
+//                    } else {
+//                        return null;
+//                    }
+//                }
+//            }
 
             /**
              * Determines if the object is enabled.
              *
              * @return true if object is enabled; otherwise, false
              */
-            public boolean isEnabled() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).isEnabled();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.isEnabled();
-                    } else {
-                        return false;
-                    }
-                }
-            }
+            public boolean isEnabled() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).isEnabled();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.isEnabled();
+//                    } else {
+//                        return false;
+//                    }
+//                }
+//            }
 
             /**
              * Sets the enabled state of the object.
              *
              * @param b if true, enables this object; otherwise, disables it
              */
-            public void setEnabled(boolean b) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setEnabled(b);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.setEnabled(b);
-                    }
-                }
-            }
+            public void setEnabled(boolean b) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setEnabled(b);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.setEnabled(b);
+//                    }
+//                }
+//            }
 
             /**
              * Determines if this object is visible.  Note: this means that the
@@ -8486,36 +8486,36 @@
              *
              * @return true if object is visible; otherwise, false
              */
-            public boolean isVisible() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).isVisible();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.isVisible();
-                    } else {
-                        return false;
-                    }
-                }
-            }
+            public boolean isVisible() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).isVisible();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.isVisible();
+//                    } else {
+//                        return false;
+//                    }
+//                }
+//            }
 
             /**
              * Sets the visible state of the object.
              *
              * @param b if true, shows this object; otherwise, hides it
              */
-            public void setVisible(boolean b) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setVisible(b);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.setVisible(b);
-                    }
-                }
-            }
+            public void setVisible(boolean b) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setVisible(b);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.setVisible(b);
+//                    }
+//                }
+//            }
 
             /**
              * Determines if the object is showing.  This is determined
@@ -8526,26 +8526,26 @@
              *
              * @return true if the object is showing; otherwise, false
              */
-            public boolean isShowing() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    if (ac.getAccessibleParent() != null) {
-                        return ((AccessibleComponent) ac).isShowing();
-                    } else {
-                        // Fixes 4529616 - AccessibleJTableCell.isShowing()
-                        // returns false when the cell on the screen
-                        // if no parent
-                        return isVisible();
-                    }
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.isShowing();
-                    } else {
-                        return false;
-                    }
-                }
-            }
+            public boolean isShowing() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    if (ac.getAccessibleParent() != null) {
+//                        return ((AccessibleComponent) ac).isShowing();
+//                    } else {
+//                        // Fixes 4529616 - AccessibleJTableCell.isShowing()
+//                        // returns false when the cell on the screen
+//                        // if no parent
+//                        return isVisible();
+//                    }
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.isShowing();
+//                    } else {
+//                        return false;
+//                    }
+//                }
+//            }
 
             /**
              * Checks whether the specified point is within this
@@ -8558,21 +8558,21 @@
              * @return true if object contains <code>Point</code>;
              *    otherwise false
              */
-            public boolean contains(Point p) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    Rectangle r = ((AccessibleComponent) ac).getBounds();
-                    return r.contains(p);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        Rectangle r = c.getBounds();
-                        return r.contains(p);
-                    } else {
-                        return getBounds().contains(p);
-                    }
-                }
-            }
+            public boolean contains(Point p) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    Rectangle r = ((AccessibleComponent) ac).getBounds();
+//                    return r.contains(p);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        Rectangle r = c.getBounds();
+//                        return r.contains(p);
+//                    } else {
+//                        return getBounds().contains(p);
+//                    }
+//                }
+//            }
 
             /**
              * Returns the location of the object on the screen.
@@ -8580,16 +8580,16 @@
              * @return location of object on screen -- can be
              *    <code>null</code> if this object is not on the screen
              */
-            public Point getLocationOnScreen() {
-                if (parent != null && parent.isShowing()) {
-                    Point parentLocation = parent.getLocationOnScreen();
-                    Point componentLocation = getLocation();
-                    componentLocation.translate(parentLocation.x, parentLocation.y);
-                    return componentLocation;
-                } else {
-                    return null;
-                }
-            }
+            public Point getLocationOnScreen() {throw new RuntimeException("cf-bug");} //{
+//                if (parent != null && parent.isShowing()) {
+//                    Point parentLocation = parent.getLocationOnScreen();
+//                    Point componentLocation = getLocation();
+//                    componentLocation.translate(parentLocation.x, parentLocation.y);
+//                    return componentLocation;
+//                } else {
+//                    return null;
+//                }
+//            }
 
             /**
              * Gets the location of the object relative to the parent
@@ -8601,15 +8601,15 @@
              *    coordinate space of the screen; <code>null</code> if
              *    this object or its parent are not on the screen
              */
-            public Point getLocation() {
-                if (parent != null) {
-                    Rectangle r = parent.getCellRect(row, column, false);
-                    if (r != null) {
-                        return r.getLocation();
-                    }
-                }
-                return null;
-            }
+            public Point getLocation() {throw new RuntimeException("cf-bug");} //{
+//                if (parent != null) {
+//                    Rectangle r = parent.getCellRect(row, column, false);
+//                    if (r != null) {
+//                        return r.getLocation();
+//                    }
+//                }
+//                return null;
+//            }
 
             /**
              * Sets the location of the object relative to the parent.
@@ -8620,106 +8620,106 @@
 //              }
             }
 
-            public Rectangle getBounds() {
-                if (parent != null) {
-                    return parent.getCellRect(row, column, false);
-                } else {
-                    return null;
-                }
-            }
-
-            public void setBounds(Rectangle r) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setBounds(r);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.setBounds(r);
-                    }
-                }
-            }
-
-            public Dimension getSize() {
-                if (parent != null) {
-                    Rectangle r = parent.getCellRect(row, column, false);
-                    if (r != null) {
-                        return r.getSize();
-                    }
-                }
-                return null;
-            }
-
-            public void setSize (Dimension d) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setSize(d);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.setSize(d);
-                    }
-                }
-            }
-
-            public Accessible getAccessibleAt(Point p) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getAccessibleAt(p);
-                } else {
-                    return null;
-                }
-            }
-
-            public boolean isFocusTraversable() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).isFocusTraversable();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.isFocusTraversable();
-                    } else {
-                        return false;
-                    }
-                }
-            }
-
-            public void requestFocus() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).requestFocus();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.requestFocus();
-                    }
-                }
-            }
-
-            public void addFocusListener(FocusListener l) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).addFocusListener(l);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.addFocusListener(l);
-                    }
-                }
-            }
-
-            public void removeFocusListener(FocusListener l) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).removeFocusListener(l);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.removeFocusListener(l);
-                    }
-                }
-            }
+            public Rectangle getBounds() {throw new RuntimeException("cf-bug");} //{
+//                if (parent != null) {
+//                    return parent.getCellRect(row, column, false);
+//                } else {
+//                    return null;
+//                }
+//            }
+
+            public void setBounds(Rectangle r) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setBounds(r);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.setBounds(r);
+//                    }
+//                }
+//            }
+
+            public Dimension getSize() {throw new RuntimeException("cf-bug");} //{
+//                if (parent != null) {
+//                    Rectangle r = parent.getCellRect(row, column, false);
+//                    if (r != null) {
+//                        return r.getSize();
+//                    }
+//                }
+//                return null;
+//            }
+
+            public void setSize (Dimension d) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setSize(d);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.setSize(d);
+//                    }
+//                }
+//            }
+
+            public Accessible getAccessibleAt(Point p) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getAccessibleAt(p);
+//                } else {
+//                    return null;
+//                }
+//            }
+
+            public boolean isFocusTraversable() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).isFocusTraversable();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.isFocusTraversable();
+//                    } else {
+//                        return false;
+//                    }
+//                }
+//            }
+
+            public void requestFocus() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).requestFocus();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.requestFocus();
+//                    }
+//                }
+//            }
+
+            public void addFocusListener(FocusListener l) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).addFocusListener(l);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.addFocusListener(l);
+//                    }
+//                }
+//            }
+
+            public void removeFocusListener(FocusListener l) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).removeFocusListener(l);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.removeFocusListener(l);
+//                    }
+//                }
+//            }
 
         } // inner class AccessibleJTableCell
 
@@ -8762,24 +8762,24 @@
              *
              * @return this object
              */
-            public AccessibleContext getAccessibleContext() {
-                return this;
-            }
+            public AccessibleContext getAccessibleContext() {throw new RuntimeException("cf-bug");} //{
+//                return this;
+//            }
 
             /*
              * Returns the AccessibleContext for the header cell
              * renderer.
              */
-            private AccessibleContext getCurrentAccessibleContext() {
-                return rendererComponent.getAccessibleContext();
-            }
+            private AccessibleContext getCurrentAccessibleContext() {throw new RuntimeException("cf-bug");} //{
+//                return rendererComponent.getAccessibleContext();
+//            }
 
             /*
              * Returns the component that renders the header cell.
              */
-            private Component getCurrentComponent() {
-                return rendererComponent;
-            }
+            private Component getCurrentComponent() {throw new RuntimeException("cf-bug");} //{
+//                return rendererComponent;
+//            }
 
             // AccessibleContext methods ==========
 
@@ -8789,34 +8789,34 @@
              * @return the localized name of the object; <code>null</code>
              *     if this object does not have a name
              */
-            public String getAccessibleName() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    String name = ac.getAccessibleName();
-                    if ((name != null) && (name != "")) {
-                        return ac.getAccessibleName();
-                    }
-                }
-                if ((accessibleName != null) && (accessibleName != "")) {
-                    return accessibleName;
-                } else {
-                    return null;
-                }
-            }
+            public String getAccessibleName() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    String name = ac.getAccessibleName();
+//                    if ((name != null) && (name != "")) {
+//                        return ac.getAccessibleName();
+//                    }
+//                }
+//                if ((accessibleName != null) && (accessibleName != "")) {
+//                    return accessibleName;
+//                } else {
+//                    return null;
+//                }
+//            }
 
             /**
              * Sets the localized accessible name of this object.
              *
              * @param s the new localized name of the object
              */
-            public void setAccessibleName(String s) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    ac.setAccessibleName(s);
-                } else {
-                    super.setAccessibleName(s);
-                }
-            }
+            public void setAccessibleName(String s) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    ac.setAccessibleName(s);
+//                } else {
+//                    super.setAccessibleName(s);
+//                }
+//            }
 
             /**
              * Gets the accessible description of this object.
@@ -8825,28 +8825,28 @@
              *     <code>null</code> if this object does not have
              *     a description
              */
-            public String getAccessibleDescription() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    return ac.getAccessibleDescription();
-                } else {
-                    return super.getAccessibleDescription();
-                }
-            }
+            public String getAccessibleDescription() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    return ac.getAccessibleDescription();
+//                } else {
+//                    return super.getAccessibleDescription();
+//                }
+//            }
 
             /**
              * Sets the accessible description of this object.
              *
              * @param s the new localized description of the object
              */
-            public void setAccessibleDescription(String s) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    ac.setAccessibleDescription(s);
-                } else {
-                    super.setAccessibleDescription(s);
-                }
-            }
+            public void setAccessibleDescription(String s) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    ac.setAccessibleDescription(s);
+//                } else {
+//                    super.setAccessibleDescription(s);
+//                }
+//            }
 
             /**
              * Gets the role of this object.
@@ -8855,14 +8855,14 @@
              *      describing the role of the object
              * @see AccessibleRole
              */
-            public AccessibleRole getAccessibleRole() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    return ac.getAccessibleRole();
-                } else {
-                    return AccessibleRole.UNKNOWN;
-                }
-            }
+            public AccessibleRole getAccessibleRole() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    return ac.getAccessibleRole();
+//                } else {
+//                    return AccessibleRole.UNKNOWN;
+//                }
+//            }
 
             /**
              * Gets the state set of this object.
@@ -8871,36 +8871,36 @@
              *     containing the current state set of the object
              * @see AccessibleState
              */
-            public AccessibleStateSet getAccessibleStateSet() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                AccessibleStateSet as = null;
-
-                if (ac != null) {
-                    as = ac.getAccessibleStateSet();
-                }
-                if (as == null) {
-                    as = new AccessibleStateSet();
-                }
-                Rectangle rjt = JTable.this.getVisibleRect();
-                Rectangle rcell = JTable.this.getCellRect(row, column, false);
-                if (rjt.intersects(rcell)) {
-                    as.add(AccessibleState.SHOWING);
-                } else {
-                    if (as.contains(AccessibleState.SHOWING)) {
-                         as.remove(AccessibleState.SHOWING);
-                    }
-                }
-                if (JTable.this.isCellSelected(row, column)) {
-                    as.add(AccessibleState.SELECTED);
-                } else if (as.contains(AccessibleState.SELECTED)) {
-                    as.remove(AccessibleState.SELECTED);
-                }
-                if ((row == getSelectedRow()) && (column == getSelectedColumn())) {
-                    as.add(AccessibleState.ACTIVE);
-                }
-                as.add(AccessibleState.TRANSIENT);
-                return as;
-            }
+            public AccessibleStateSet getAccessibleStateSet() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                AccessibleStateSet as = null;
+//
+//                if (ac != null) {
+//                    as = ac.getAccessibleStateSet();
+//                }
+//                if (as == null) {
+//                    as = new AccessibleStateSet();
+//                }
+//                Rectangle rjt = JTable.this.getVisibleRect();
+//                Rectangle rcell = JTable.this.getCellRect(row, column, false);
+//                if (rjt.intersects(rcell)) {
+//                    as.add(AccessibleState.SHOWING);
+//                } else {
+//                    if (as.contains(AccessibleState.SHOWING)) {
+//                         as.remove(AccessibleState.SHOWING);
+//                    }
+//                }
+//                if (JTable.this.isCellSelected(row, column)) {
+//                    as.add(AccessibleState.SELECTED);
+//                } else if (as.contains(AccessibleState.SELECTED)) {
+//                    as.remove(AccessibleState.SELECTED);
+//                }
+//                if ((row == getSelectedRow()) && (column == getSelectedColumn())) {
+//                    as.add(AccessibleState.ACTIVE);
+//                }
+//                as.add(AccessibleState.TRANSIENT);
+//                return as;
+//            }
 
             /**
              * Gets the <code>Accessible</code> parent of this object.
@@ -8909,9 +8909,9 @@
              *     <code>null</code> if this object does not
              *     have an <code>Accessible</code> parent
              */
-            public Accessible getAccessibleParent() {
-                return parent;
-            }
+            public Accessible getAccessibleParent() {throw new RuntimeException("cf-bug");} //{
+//                return parent;
+//            }
 
             /**
              * Gets the index of this object in its accessible parent.
@@ -8920,23 +8920,23 @@
              *     object does not have an accessible parent
              * @see #getAccessibleParent
              */
-            public int getAccessibleIndexInParent() {
-                return column;
-            }
+            public int getAccessibleIndexInParent() {throw new RuntimeException("cf-bug");} //{
+//                return column;
+//            }
 
             /**
              * Returns the number of accessible children in the object.
              *
              * @return the number of accessible children in the object
              */
-            public int getAccessibleChildrenCount() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    return ac.getAccessibleChildrenCount();
-                } else {
-                    return 0;
-                }
-            }
+            public int getAccessibleChildrenCount() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    return ac.getAccessibleChildrenCount();
+//                } else {
+//                    return 0;
+//                }
+//            }
 
             /**
              * Returns the specified <code>Accessible</code> child of the
@@ -8945,16 +8945,16 @@
              * @param i zero-based index of child
              * @return the <code>Accessible</code> child of the object
              */
-            public Accessible getAccessibleChild(int i) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    Accessible accessibleChild = ac.getAccessibleChild(i);
-                    ac.setAccessibleParent(this);
-                    return accessibleChild;
-                } else {
-                    return null;
-                }
-            }
+            public Accessible getAccessibleChild(int i) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    Accessible accessibleChild = ac.getAccessibleChild(i);
+//                    ac.setAccessibleParent(this);
+//                    return accessibleChild;
+//                } else {
+//                    return null;
+//                }
+//            }
 
             /**
              * Gets the locale of the component. If the component
@@ -8970,14 +8970,14 @@
              *    containing parent
              * @see #setLocale
              */
-            public Locale getLocale() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    return ac.getLocale();
-                } else {
-                    return null;
-                }
-            }
+            public Locale getLocale() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    return ac.getLocale();
+//                } else {
+//                    return null;
+//                }
+//            }
 
             /**
              * Adds a <code>PropertyChangeListener</code> to the listener list.
@@ -8986,14 +8986,14 @@
              * @param l  the <code>PropertyChangeListener</code>
              *     to be added
              */
-            public void addPropertyChangeListener(PropertyChangeListener l) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    ac.addPropertyChangeListener(l);
-                } else {
-                    super.addPropertyChangeListener(l);
-                }
-            }
+            public void addPropertyChangeListener(PropertyChangeListener l) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    ac.addPropertyChangeListener(l);
+//                } else {
+//                    super.addPropertyChangeListener(l);
+//                }
+//            }
 
             /**
              * Removes a <code>PropertyChangeListener</code> from the
@@ -9003,14 +9003,14 @@
              * @param l  the <code>PropertyChangeListener</code>
              *    to be removed
              */
-            public void removePropertyChangeListener(PropertyChangeListener l) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac != null) {
-                    ac.removePropertyChangeListener(l);
-                } else {
-                    super.removePropertyChangeListener(l);
-                }
-            }
+            public void removePropertyChangeListener(PropertyChangeListener l) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac != null) {
+//                    ac.removePropertyChangeListener(l);
+//                } else {
+//                    super.removePropertyChangeListener(l);
+//                }
+//            }
 
             /**
              * Gets the <code>AccessibleAction</code> associated with this
@@ -9018,9 +9018,9 @@
              *
              * @return the <code>AccessibleAction</code>, or <code>null</code>
              */
-            public AccessibleAction getAccessibleAction() {
-                return getCurrentAccessibleContext().getAccessibleAction();
-            }
+            public AccessibleAction getAccessibleAction() {throw new RuntimeException("cf-bug");} //{
+//                return getCurrentAccessibleContext().getAccessibleAction();
+//            }
 
             /**
              * Gets the <code>AccessibleComponent</code> associated with
@@ -9029,9 +9029,9 @@
              * @return the <code>AccessibleComponent</code>, or
              *    <code>null</code>
              */
-            public AccessibleComponent getAccessibleComponent() {
-                return this; // to override getBounds()
-            }
+            public AccessibleComponent getAccessibleComponent() {throw new RuntimeException("cf-bug");} //{
+//                return this; // to override getBounds()
+//            }
 
             /**
              * Gets the <code>AccessibleSelection</code> associated with
@@ -9040,9 +9040,9 @@
              * @return the <code>AccessibleSelection</code>, or
              *    <code>null</code>
              */
-            public AccessibleSelection getAccessibleSelection() {
-                return getCurrentAccessibleContext().getAccessibleSelection();
-            }
+            public AccessibleSelection getAccessibleSelection() {throw new RuntimeException("cf-bug");} //{
+//                return getCurrentAccessibleContext().getAccessibleSelection();
+//            }
 
             /**
              * Gets the <code>AccessibleText</code> associated with this
@@ -9050,9 +9050,9 @@
              *
              * @return the <code>AccessibleText</code>, or <code>null</code>
              */
-            public AccessibleText getAccessibleText() {
-                return getCurrentAccessibleContext().getAccessibleText();
-            }
+            public AccessibleText getAccessibleText() {throw new RuntimeException("cf-bug");} //{
+//                return getCurrentAccessibleContext().getAccessibleText();
+//            }
 
             /**
              * Gets the <code>AccessibleValue</code> associated with
@@ -9060,9 +9060,9 @@
              *
              * @return the <code>AccessibleValue</code>, or <code>null</code>
              */
-            public AccessibleValue getAccessibleValue() {
-                return getCurrentAccessibleContext().getAccessibleValue();
-            }
+            public AccessibleValue getAccessibleValue() {throw new RuntimeException("cf-bug");} //{
+//                return getCurrentAccessibleContext().getAccessibleValue();
+//            }
 
 
             // AccessibleComponent methods ==========
@@ -9073,36 +9073,36 @@
              * @return the background color, if supported, of the object;
              *     otherwise, <code>null</code>
              */
-            public Color getBackground() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getBackground();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.getBackground();
-                    } else {
-                        return null;
-                    }
-                }
-            }
+            public Color getBackground() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getBackground();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.getBackground();
+//                    } else {
+//                        return null;
+//                    }
+//                }
+//            }
 
             /**
              * Sets the background color of this object.
              *
              * @param c the new <code>Color</code> for the background
              */
-            public void setBackground(Color c) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setBackground(c);
-                } else {
-                    Component cp = getCurrentComponent();
-                    if (cp != null) {
-                        cp.setBackground(c);
-                    }
-                }
-            }
+            public void setBackground(Color c) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setBackground(c);
+//                } else {
+//                    Component cp = getCurrentComponent();
+//                    if (cp != null) {
+//                        cp.setBackground(c);
+//                    }
+//                }
+//            }
 
             /**
              * Gets the foreground color of this object.
@@ -9110,36 +9110,36 @@
              * @return the foreground color, if supported, of the object;
              *     otherwise, <code>null</code>
              */
-            public Color getForeground() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getForeground();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.getForeground();
-                    } else {
-                        return null;
-                    }
-                }
-            }
+            public Color getForeground() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getForeground();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.getForeground();
+//                    } else {
+//                        return null;
+//                    }
+//                }
+//            }
 
             /**
              * Sets the foreground color of this object.
              *
              * @param c the new <code>Color</code> for the foreground
              */
-            public void setForeground(Color c) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setForeground(c);
-                } else {
-                    Component cp = getCurrentComponent();
-                    if (cp != null) {
-                        cp.setForeground(c);
-                    }
-                }
-            }
+            public void setForeground(Color c) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setForeground(c);
+//                } else {
+//                    Component cp = getCurrentComponent();
+//                    if (cp != null) {
+//                        cp.setForeground(c);
+//                    }
+//                }
+//            }
 
             /**
              * Gets the <code>Cursor</code> of this object.
@@ -9147,41 +9147,41 @@
              * @return the <code>Cursor</code>, if supported,
              *    of the object; otherwise, <code>null</code>
              */
-            public Cursor getCursor() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getCursor();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.getCursor();
-                    } else {
-                        Accessible ap = getAccessibleParent();
-                        if (ap instanceof AccessibleComponent) {
-                            return ((AccessibleComponent) ap).getCursor();
-                        } else {
-                            return null;
-                        }
-                    }
-                }
-            }
+            public Cursor getCursor() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getCursor();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.getCursor();
+//                    } else {
+//                        Accessible ap = getAccessibleParent();
+//                        if (ap instanceof AccessibleComponent) {
+//                            return ((AccessibleComponent) ap).getCursor();
+//                        } else {
+//                            return null;
+//                        }
+//                    }
+//                }
+//            }
 
             /**
              * Sets the <code>Cursor</code> of this object.
              *
              * @param c the new <code>Cursor</code> for the object
              */
-            public void setCursor(Cursor c) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setCursor(c);
-                } else {
-                    Component cp = getCurrentComponent();
-                    if (cp != null) {
-                        cp.setCursor(c);
-                    }
-                }
-            }
+            public void setCursor(Cursor c) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setCursor(c);
+//                } else {
+//                    Component cp = getCurrentComponent();
+//                    if (cp != null) {
+//                        cp.setCursor(c);
+//                    }
+//                }
+//            }
 
             /**
              * Gets the <code>Font</code> of this object.
@@ -9189,36 +9189,36 @@
              * @return the <code>Font</code>,if supported,
              *   for the object; otherwise, <code>null</code>
              */
-            public Font getFont() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getFont();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.getFont();
-                    } else {
-                        return null;
-                    }
-                }
-            }
+            public Font getFont() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getFont();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.getFont();
+//                    } else {
+//                        return null;
+//                    }
+//                }
+//            }
 
             /**
              * Sets the <code>Font</code> of this object.
              *
              * @param f the new <code>Font</code> for the object
              */
-            public void setFont(Font f) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setFont(f);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.setFont(f);
-                    }
-                }
-            }
+            public void setFont(Font f) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setFont(f);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.setFont(f);
+//                    }
+//                }
+//            }
 
             /**
              * Gets the <code>FontMetrics</code> of this object.
@@ -9228,55 +9228,55 @@
              *    otherwise <code>null</code>
              * @see #getFont
              */
-            public FontMetrics getFontMetrics(Font f) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getFontMetrics(f);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.getFontMetrics(f);
-                    } else {
-                        return null;
-                    }
-                }
-            }
+            public FontMetrics getFontMetrics(Font f) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getFontMetrics(f);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.getFontMetrics(f);
+//                    } else {
+//                        return null;
+//                    }
+//                }
+//            }
 
             /**
              * Determines if the object is enabled.
              *
              * @return true if object is enabled; otherwise, false
              */
-            public boolean isEnabled() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).isEnabled();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.isEnabled();
-                    } else {
-                        return false;
-                    }
-                }
-            }
+            public boolean isEnabled() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).isEnabled();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.isEnabled();
+//                    } else {
+//                        return false;
+//                    }
+//                }
+//            }
 
             /**
              * Sets the enabled state of the object.
              *
              * @param b if true, enables this object; otherwise, disables it
              */
-            public void setEnabled(boolean b) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setEnabled(b);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.setEnabled(b);
-                    }
-                }
-            }
+            public void setEnabled(boolean b) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setEnabled(b);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.setEnabled(b);
+//                    }
+//                }
+//            }
 
             /**
              * Determines if this object is visible.  Note: this means that the
@@ -9287,36 +9287,36 @@
              *
              * @return true if object is visible; otherwise, false
              */
-            public boolean isVisible() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).isVisible();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.isVisible();
-                    } else {
-                        return false;
-                    }
-                }
-            }
+            public boolean isVisible() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).isVisible();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.isVisible();
+//                    } else {
+//                        return false;
+//                    }
+//                }
+//            }
 
             /**
              * Sets the visible state of the object.
              *
              * @param b if true, shows this object; otherwise, hides it
              */
-            public void setVisible(boolean b) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setVisible(b);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.setVisible(b);
-                    }
-                }
-            }
+            public void setVisible(boolean b) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setVisible(b);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.setVisible(b);
+//                    }
+//                }
+//            }
 
             /**
              * Determines if the object is showing.  This is determined
@@ -9327,26 +9327,26 @@
              *
              * @return true if the object is showing; otherwise, false
              */
-            public boolean isShowing() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    if (ac.getAccessibleParent() != null) {
-                        return ((AccessibleComponent) ac).isShowing();
-                    } else {
-                        // Fixes 4529616 - AccessibleJTableCell.isShowing()
-                        // returns false when the cell on the screen
-                        // if no parent
-                        return isVisible();
-                    }
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.isShowing();
-                    } else {
-                        return false;
-                    }
-                }
-            }
+            public boolean isShowing() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    if (ac.getAccessibleParent() != null) {
+//                        return ((AccessibleComponent) ac).isShowing();
+//                    } else {
+//                        // Fixes 4529616 - AccessibleJTableCell.isShowing()
+//                        // returns false when the cell on the screen
+//                        // if no parent
+//                        return isVisible();
+//                    }
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.isShowing();
+//                    } else {
+//                        return false;
+//                    }
+//                }
+//            }
 
             /**
              * Checks whether the specified point is within this
@@ -9359,21 +9359,21 @@
              * @return true if object contains <code>Point</code>;
              *    otherwise false
              */
-            public boolean contains(Point p) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    Rectangle r = ((AccessibleComponent) ac).getBounds();
-                    return r.contains(p);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        Rectangle r = c.getBounds();
-                        return r.contains(p);
-                    } else {
-                        return getBounds().contains(p);
-                    }
-                }
-            }
+            public boolean contains(Point p) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    Rectangle r = ((AccessibleComponent) ac).getBounds();
+//                    return r.contains(p);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        Rectangle r = c.getBounds();
+//                        return r.contains(p);
+//                    } else {
+//                        return getBounds().contains(p);
+//                    }
+//                }
+//            }
 
             /**
              * Returns the location of the object on the screen.
@@ -9381,16 +9381,16 @@
              * @return location of object on screen -- can be
              *    <code>null</code> if this object is not on the screen
              */
-            public Point getLocationOnScreen() {
-                if (parent != null && parent.isShowing()) {
-                    Point parentLocation = parent.getLocationOnScreen();
-                    Point componentLocation = getLocation();
-                    componentLocation.translate(parentLocation.x, parentLocation.y);
-                    return componentLocation;
-                } else {
-                    return null;
-                }
-            }
+            public Point getLocationOnScreen() {throw new RuntimeException("cf-bug");} //{
+//                if (parent != null && parent.isShowing()) {
+//                    Point parentLocation = parent.getLocationOnScreen();
+//                    Point componentLocation = getLocation();
+//                    componentLocation.translate(parentLocation.x, parentLocation.y);
+//                    return componentLocation;
+//                } else {
+//                    return null;
+//                }
+//            }
 
             /**
              * Gets the location of the object relative to the parent
@@ -9402,15 +9402,15 @@
              *    coordinate space of the screen; <code>null</code> if
              *    this object or its parent are not on the screen
              */
-            public Point getLocation() {
-                if (parent != null) {
-                    Rectangle r = parent.getHeaderRect(column);
-                    if (r != null) {
-                        return r.getLocation();
-                    }
-                }
-                return null;
-            }
+            public Point getLocation() {throw new RuntimeException("cf-bug");} //{
+//                if (parent != null) {
+//                    Rectangle r = parent.getHeaderRect(column);
+//                    if (r != null) {
+//                        return r.getLocation();
+//                    }
+//                }
+//                return null;
+//            }
 
             /**
              * Sets the location of the object relative to the parent.
@@ -9429,13 +9429,13 @@
              * this object is not on the screen.
              * @see #contains
              */
-            public Rectangle getBounds() {
-                if (parent != null) {
-                    return parent.getHeaderRect(column);
-                } else {
-                    return null;
-                }
-            }
+            public Rectangle getBounds() {throw new RuntimeException("cf-bug");} //{
+//                if (parent != null) {
+//                    return parent.getHeaderRect(column);
+//                } else {
+//                    return null;
+//                }
+//            }
 
             /**
              * Sets the bounds of this object in the form of a Rectangle object.
@@ -9445,17 +9445,17 @@
              * @param r rectangle indicating this component's bounds
              * @see #getBounds
              */
-            public void setBounds(Rectangle r) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setBounds(r);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.setBounds(r);
-                    }
-                }
-            }
+            public void setBounds(Rectangle r) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setBounds(r);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.setBounds(r);
+//                    }
+//                }
+//            }
 
             /**
              * Returns the size of this object in the form of a Dimension object.
@@ -9467,15 +9467,15 @@
              * null if this object is not on the screen
              * @see #setSize
              */
-            public Dimension getSize() {
-                if (parent != null) {
-                    Rectangle r = parent.getHeaderRect(column);
-                    if (r != null) {
-                        return r.getSize();
-                    }
-                }
-                return null;
-            }
+            public Dimension getSize() {throw new RuntimeException("cf-bug");} //{
+//                if (parent != null) {
+//                    Rectangle r = parent.getHeaderRect(column);
+//                    if (r != null) {
+//                        return r.getSize();
+//                    }
+//                }
+//                return null;
+//            }
 
             /**
              * Resizes this object so that it has width and height.
@@ -9483,17 +9483,17 @@
              * @param d The dimension specifying the new size of the object.
              * @see #getSize
              */
-            public void setSize (Dimension d) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).setSize(d);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.setSize(d);
-                    }
-                }
-            }
+            public void setSize (Dimension d) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).setSize(d);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.setSize(d);
+//                    }
+//                }
+//            }
 
             /**
              * Returns the Accessible child, if one exists, contained at the local
@@ -9503,14 +9503,14 @@
              * @return the Accessible, if it exists, at the specified location;
              * otherwise null
              */
-            public Accessible getAccessibleAt(Point p) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).getAccessibleAt(p);
-                } else {
-                    return null;
-                }
-            }
+            public Accessible getAccessibleAt(Point p) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).getAccessibleAt(p);
+//                } else {
+//                    return null;
+//                }
+//            }
 
             /**
              * Returns whether this object can accept focus or not.   Objects that
@@ -9523,19 +9523,19 @@
              * @see AccessibleState#FOCUSED
              * @see AccessibleStateSet
              */
-            public boolean isFocusTraversable() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    return ((AccessibleComponent) ac).isFocusTraversable();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        return c.isFocusTraversable();
-                    } else {
-                        return false;
-                    }
-                }
-            }
+            public boolean isFocusTraversable() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    return ((AccessibleComponent) ac).isFocusTraversable();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        return c.isFocusTraversable();
+//                    } else {
+//                        return false;
+//                    }
+//                }
+//            }
 
             /**
              * Requests focus for this object.  If this object cannot accept focus,
@@ -9543,17 +9543,17 @@
              * focus.
              * @see #isFocusTraversable
              */
-            public void requestFocus() {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).requestFocus();
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.requestFocus();
-                    }
-                }
-            }
+            public void requestFocus() {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).requestFocus();
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.requestFocus();
+//                    }
+//                }
+//            }
 
             /**
              * Adds the specified focus listener to receive focus events from this
@@ -9562,17 +9562,17 @@
              * @param l the focus listener
              * @see #removeFocusListener
              */
-            public void addFocusListener(FocusListener l) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).addFocusListener(l);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.addFocusListener(l);
-                    }
-                }
-            }
+            public void addFocusListener(FocusListener l) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).addFocusListener(l);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.addFocusListener(l);
+//                    }
+//                }
+//            }
 
             /**
              * Removes the specified focus listener so it no longer receives focus
@@ -9581,17 +9581,17 @@
              * @param l the focus listener
              * @see #addFocusListener
              */
-            public void removeFocusListener(FocusListener l) {
-                AccessibleContext ac = getCurrentAccessibleContext();
-                if (ac instanceof AccessibleComponent) {
-                    ((AccessibleComponent) ac).removeFocusListener(l);
-                } else {
-                    Component c = getCurrentComponent();
-                    if (c != null) {
-                        c.removeFocusListener(l);
-                    }
-                }
-            }
+            public void removeFocusListener(FocusListener l) {throw new RuntimeException("cf-bug");} //{
+//                AccessibleContext ac = getCurrentAccessibleContext();
+//                if (ac instanceof AccessibleComponent) {
+//                    ((AccessibleComponent) ac).removeFocusListener(l);
+//                } else {
+//                    Component c = getCurrentComponent();
+//                    if (c != null) {
+//                        c.removeFocusListener(l);
+//                    }
+//                }
+//            }
 
         } // inner class AccessibleJTableHeaderCell
 
